This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-10-19T13:46:49.096Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
- Code comments have been removed.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
script/
  rolling-release-scripts/
    package.json
src/
  main-process/
    application-menu.js
    atom-application.js
    atom-protocol-handler.js
    atom-window.js
    context-menu.js
    file-recovery-service.js
    main.js
    parse-command-line.js
    start.js
    win-shell.js
  application-delegate.js
  atom-environment.js
  atom-paths.js
  babel.config.js
  babel.js
  buffered-node-process.js
  buffered-process.js
  clipboard.js
  coffee-script.js
  color.js
  command-installer.js
  command-registry.js
  comment-utils.js
  compile-cache.js
  config-file.js
  config-schema.js
  config.js
  context-menu-manager.js
  core-uri-handlers.js
  cursor.js
  decoration-manager.js
  decoration.js
  default-directory-provider.js
  default-directory-searcher.js
  delegated-listener.js
  deprecated-syntax-selectors.js
  deserializer-manager.js
  dock.js
  electron-shims.js
  file-system-blob-store.js
  first-mate-helpers.js
  get-app-details.js
  get-window-load-settings.js
  git-repository-provider.js
  git-repository.js
  grammar-registry.js
  gutter-container.js
  gutter.js
  history-manager.js
  initialize-application-window.js
  initialize-test-window.js
  ipc-helpers.js
  item-registry.js
  keymap-extensions.js
  layer-decoration.js
  less-compile-cache.js
  menu-helpers.js
  menu-manager.js
  menu-sort-helpers.js
  model.js
  module-cache.js
  module-utils.js
  native-compile-cache.js
  native-watcher-registry.js
  notification-manager.js
  notification.js
  null-grammar.js
  package-manager.js
  package-transpilation-registry.js
  package.js
  pane-axis-element.js
  pane-axis.js
  pane-container-element.js
  pane-container.js
  pane-element.js
  pane-resize-handle-element.js
  pane.js
  panel-container-element.js
  panel-container.js
  panel.js
  path-watcher.js
  project.js
  protocol-handler-installer.js
  rb-tree.js
  register-default-commands.js
  reopen-project-list-view.js
  reopen-project-menu-manager.js
  replace-handler.js
  ripgrep-directory-searcher.js
  scan-handler.js
  scope-descriptor.js
  scope-resolver.js
  selection.js
  selectors.js
  startup-time.js
  state-store.js
  storage-folder.js
  style-manager.js
  styles-element.js
  syntax-scope-map.js
  task-bootstrap.js
  task.js
  text-editor-component.js
  text-editor-element.js
  text-editor-registry.js
  text-editor.js
  text-mate-language-mode.js
  text-utils.js
  theme-manager.js
  theme-package.js
  title-bar.js
  token-iterator.js
  token.js
  tokenized-line.js
  tooltip-manager.js
  tooltip.js
  tree-indenter.js
  tree-sitter-grammar.js
  tree-sitter-language-mode.js
  typescript.js
  ui.js
  update-process-env.js
  uri-handler-registry.js
  view-registry.js
  wasm-tree-sitter-grammar.js
  wasm-tree-sitter-language-mode.js
  web-tree-sitter.js
  window-event-handler.js
  window.js
  workspace-center.js
  workspace-element.js
  workspace.js
package.json

================================================================
Repository Files
================================================================

================
File: script/rolling-release-scripts/package.json
================
{
  "name": "rolling-release-scripts",
  "description": "Contains possible modules needed for these scripts",
  "dependencies": {
    "publish-release": "^1.6.1"
  }
}

================
File: src/main-process/application-menu.js
================
const { app, Menu } = require('electron');
const _ = require('underscore-plus');
const MenuHelpers = require('../menu-helpers');
module.exports = class ApplicationMenu {
  constructor(version) {
    this.version = version;
    this.windowTemplates = new WeakMap();
    this.setActiveTemplate(this.getDefaultTemplate());
  }
  update(window, template, keystrokesByCommand) {
    this.translateTemplate(template, keystrokesByCommand);
    this.substituteVersion(template);
    this.windowTemplates.set(window, template);
    if (window === this.lastFocusedWindow)
      return this.setActiveTemplate(template);
  }
  setActiveTemplate(template) {
    if (!_.isEqual(template, this.activeTemplate)) {
      this.activeTemplate = template;
      this.menu = Menu.buildFromTemplate(_.deepClone(template));
      Menu.setApplicationMenu(this.menu);
    }
    return;
  }
  addWindow(window) {
    if (this.lastFocusedWindow == null) this.lastFocusedWindow = window;
    const focusHandler = () => {
      this.lastFocusedWindow = window;
      const template = this.windowTemplates.get(window);
      if (template) this.setActiveTemplate(template);
    };
    window.on('focus', focusHandler);
    window.once('closed', () => {
      if (window === this.lastFocusedWindow) this.lastFocusedWindow = null;
      this.windowTemplates.delete(window);
      window.removeListener('focus', focusHandler);
    });
    this.enableWindowSpecificItems(true);
  }
  flattenMenuItems(menu) {
    const object = menu.items || {};
    let items = [];
    for (let index in object) {
      const item = object[index];
      items.push(item);
      if (item.submenu)
        items = items.concat(this.flattenMenuItems(item.submenu));
    }
    return items;
  }
  flattenMenuTemplate(template) {
    let items = [];
    for (let item of template) {
      items.push(item);
      if (item.submenu)
        items = items.concat(this.flattenMenuTemplate(item.submenu));
    }
    return items;
  }
  enableWindowSpecificItems(enable) {
    for (let item of this.flattenMenuItems(this.menu)) {
      if (item.metadata && item.metadata.windowSpecific) item.enabled = enable;
    }
  }
  substituteVersion(template) {
    let item = this.flattenMenuTemplate(template).find(
      ({ label }) => label === 'VERSION'
    );
    if (item) item.label = `Version ${this.version}`;
  }
  getDefaultTemplate() {
    return [
      {
        label: 'Pulsar',
        id: 'Pulsar',
        submenu: [
          {
            label: 'Reload',
            id: 'Reload',
            accelerator: 'Command+R',
            click: () => {
              const window = this.focusedWindow();
              if (window) window.reload();
            }
          },
          {
            label: 'Close Window',
            id: 'Close Window',
            accelerator: 'Command+Shift+W',
            click: () => {
              const window = this.focusedWindow();
              if (window) window.close();
            }
          },
          {
            label: 'Toggle Dev Tools',
            id: 'Toggle Dev Tools',
            accelerator: 'Command+Alt+I',
            click: () => {
              const window = this.focusedWindow();
              if (window) window.toggleDevTools();
            }
          },
          {
            label: 'Quit',
            id: 'Quit',
            accelerator: 'Command+Q',
            click: () => app.quit()
          }
        ]
      }
    ];
  }
  focusedWindow() {
    return global.atomApplication
      .getAllWindows()
      .find(window => window.isFocused());
  }
  translateTemplate(template, keystrokesByCommand) {
    template.forEach(item => {
      if (item.metadata == null) item.metadata = {};
      if (item.command) {
        const keystrokes = keystrokesByCommand[item.command];
        if (keystrokes && keystrokes.length > 0) {
          const keystroke = keystrokes[0];
          if (keystroke.includes(' ')) {
            item.label += ` [${_.humanizeKeystroke(keystroke)}]`;
          } else {
            item.accelerator = MenuHelpers.acceleratorForKeystroke(keystroke);
          }
        }
        item.click = () =>
          global.atomApplication.sendCommand(item.command, item.commandDetail);
        if (!/^application:/.test(item.command)) {
          item.metadata.windowSpecific = true;
        }
      }
      if (item.submenu)
        this.translateTemplate(item.submenu, keystrokesByCommand);
    });
    return template;
  }
};

================
File: src/main-process/atom-application.js
================
const AtomWindow = require('./atom-window');
const ApplicationMenu = require('./application-menu');
const AtomProtocolHandler = require('./atom-protocol-handler');
const StorageFolder = require('../storage-folder');
const Config = require('../config');
const ConfigFile = require('../config-file');
const FileRecoveryService = require('./file-recovery-service');
const StartupTime = require('../startup-time');
const ipcHelpers = require('../ipc-helpers');
const { getConfigFilePath } = require('../get-app-details.js');
const {
  BrowserWindow,
  Menu,
  app,
  clipboard,
  dialog,
  ipcMain,
  shell,
  screen,
  nativeTheme
} = require('electron');
const { CompositeDisposable, Disposable } = require('event-kit');
const crypto = require('crypto');
const fs = require('fs-plus');
const path = require('path');
const os = require('os');
const net = require('net');
const url = require('url');
const { promisify } = require('util');
const { EventEmitter } = require('events');
const _ = require('underscore-plus');
let FindParentDir = null;
let Resolve = null;
const ConfigSchema = require('../config-schema');
const LocationSuffixRegExp = /(:\d+)(:\d+)?$/;
const APPLICATION_STATE_VERSION = '1';
const getSocketSecretPath = applicationVersion => {
  const { username } = os.userInfo();
  const atomHome = path.resolve(process.env.ATOM_HOME);
  return path.join(atomHome, `.pulsar-socket-secret-${username}-${applicationVersion}`);
};
const getSocketPath = socketSecret => {
  if (!socketSecret) {
    return null;
  }
  const socketName = crypto
    .createHmac('sha256', socketSecret)
    .update('socketName')
    .digest('hex')
    .substr(0, 12);
  if (process.platform === 'win32') {
    return `\\\\.\\pipe\\pulsar-${socketName}-sock`;
  } else {
    return path.join(os.tmpdir(), `pulsar-${socketName}.sock`);
  }
};
const getExistingSocketSecret = applicationVersion => {
  const socketSecretPath = getSocketSecretPath(applicationVersion);
  if (!fs.existsSync(socketSecretPath)) {
    return null;
  }
  return fs.readFileSync(socketSecretPath, 'utf8');
};
const getRandomBytes = promisify(crypto.randomBytes);
const writeFile = promisify(fs.writeFile);
const createSocketSecret = async applicationVersion => {
  const socketSecret = (await getRandomBytes(16)).toString('hex');
  await writeFile(getSocketSecretPath(applicationVersion), socketSecret, {
    encoding: 'utf8',
    mode: 0o600
  });
  return socketSecret;
};
const encryptOptions = (options, secret) => {
  const message = JSON.stringify(options);
  const initVector = crypto.randomBytes(16);
  const cipher = crypto.createCipheriv('aes-256-gcm', secret, initVector);
  let content = cipher.update(message, 'utf8', 'hex');
  content += cipher.final('hex');
  const authTag = cipher.getAuthTag().toString('hex');
  return JSON.stringify({
    authTag,
    content,
    initVector: initVector.toString('hex')
  });
};
const decryptOptions = (optionsMessage, secret) => {
  const { authTag, content, initVector } = JSON.parse(optionsMessage);
  const decipher = crypto.createDecipheriv(
    'aes-256-gcm',
    secret,
    Buffer.from(initVector, 'hex')
  );
  decipher.setAuthTag(Buffer.from(authTag, 'hex'));
  let message = decipher.update(content, 'hex', 'utf8');
  message += decipher.final('utf8');
  return JSON.parse(message);
};
ipcMain.handle('isDefaultProtocolClient', (_, { protocol, path, args }) => {
  return app.isDefaultProtocolClient(protocol, path, args);
});
ipcMain.handle('setAsDefaultProtocolClient', (_, { protocol, path, args }) => {
  return app.setAsDefaultProtocolClient(protocol, path, args);
});
module.exports = class AtomApplication extends EventEmitter {
  static open(options) {
    StartupTime.addMarker('main-process:atom-application:open');
    const socketSecret = getExistingSocketSecret(options.version);
    const socketPath = getSocketPath(socketSecret);
    const createApplication =
      options.createApplication ||
      (async () => {
        const app = new AtomApplication(options);
        await app.initialize(options);
        return app;
      });
    if (
      !socketPath ||
      options.test ||
      (process.platform !== 'win32' && !fs.existsSync(socketPath))
    ) {
      return createApplication(options);
    }
    if (options.benchmark || options.benchmarkTest) {
      console.log('The benchmarking feature has been removed.');
    }
    return new Promise(resolve => {
      const client = net.connect({ path: socketPath }, () => {
        client.write(encryptOptions(options, socketSecret), () => {
          client.end();
          app.quit();
          resolve(null);
        });
      });
      client.on('error', () => resolve(createApplication(options)));
    });
  }
  exit(status) {
    app.exit(status);
  }
  constructor(options) {
    StartupTime.addMarker('main-process:atom-application:constructor:start');
    super();
    this.quitting = false;
    this.quittingForUpdate = false;
    this.getAllWindows = this.getAllWindows.bind(this);
    this.getLastFocusedWindow = this.getLastFocusedWindow.bind(this);
    this.resourcePath = options.resourcePath;
    this.devResourcePath = options.devResourcePath;
    this.version = options.version;
    this.devMode = options.devMode;
    this.safeMode = options.safeMode;
    this.logFile = options.logFile;
    this.userDataDir = options.userDataDir;
    this._killProcess = options.killProcess || process.kill.bind(process);
    this.waitSessionsByWindow = new Map();
    this.windowStack = new WindowStack();
    this.initializeAtomHome(process.env.ATOM_HOME);
    let configFilePath = getConfigFilePath({ returnPlaceholder: true });
    this.configFile = ConfigFile.at(configFilePath);
    this.config = new Config({
      saveCallback: settings => {
        if (!this.quitting) {
          return this.configFile.update(settings);
        }
      }
    });
    this.config.setSchema(null, {
      type: 'object',
      properties: _.clone(ConfigSchema)
    });
    this.fileRecoveryService = new FileRecoveryService(
      path.join(process.env.ATOM_HOME, 'recovery')
    );
    this.storageFolder = new StorageFolder(process.env.ATOM_HOME);
    this.disposable = new CompositeDisposable();
    this.handleEvents();
    StartupTime.addMarker('main-process:atom-application:constructor:end');
  }
  async initialize(options) {
    StartupTime.addMarker('main-process:atom-application:initialize:start');
    global.atomApplication = this;
    this.applicationMenu = new ApplicationMenu(
      this.version
    );
    this.atomProtocolHandler = new AtomProtocolHandler(
      this.resourcePath,
      this.safeMode
    );
    let socketServerPromise;
    if (options.test) {
      socketServerPromise = Promise.resolve();
    } else {
      socketServerPromise = this.listenForArgumentsFromNewProcess();
    }
    await socketServerPromise;
    this.setupDockMenu();
    const result = await this.launch(options);
    StartupTime.addMarker('main-process:atom-application:initialize:end');
    return result;
  }
  async destroy() {
    const windowsClosePromises = this.getAllWindows().map(window => {
      window.close();
      return window.closedPromise;
    });
    await Promise.all(windowsClosePromises);
    this.disposable.dispose();
  }
  async launch(options) {
    if (!this.configFilePromise) {
      this.configFilePromise = this.configFile.watch().then(disposable => {
        this.disposable.add(disposable);
        this.config.onDidChange('core.titleBar', () => this.promptForRestart());
        this.config.onDidChange('core.colorProfile', () =>
          this.promptForRestart()
        );
        this.config.onDidChange('core.allowWindowTransparency', () =>
          this.promptForRestart()
        );
      });
      await this.configFilePromise;
    }
    let optionsForWindowsToOpen = [];
    let shouldReopenPreviousWindows = false;
    if (options.test || options.benchmark || options.benchmarkTest) {
      optionsForWindowsToOpen.push(options);
    } else if (options.newWindow) {
      shouldReopenPreviousWindows = false;
    } else if (
      (options.pathsToOpen && options.pathsToOpen.length > 0) ||
      (options.urlsToOpen && options.urlsToOpen.length > 0)
    ) {
      optionsForWindowsToOpen.push(options);
      shouldReopenPreviousWindows =
        this.config.get('core.restorePreviousWindowsOnStart') === 'always';
    } else {
      shouldReopenPreviousWindows =
        this.config.get('core.restorePreviousWindowsOnStart') !== 'no';
    }
    if (shouldReopenPreviousWindows) {
      optionsForWindowsToOpen = [
        ...(await this.loadPreviousWindowOptions()),
        ...optionsForWindowsToOpen
      ];
    }
    if (optionsForWindowsToOpen.length === 0) {
      optionsForWindowsToOpen.push(options);
    }
    const windows = [];
    for (const options of optionsForWindowsToOpen) {
      windows.push(await this.openWithOptions(options));
    }
    return windows;
  }
  openWithOptions(options) {
    const {
      pathsToOpen,
      executedFrom,
      foldersToOpen,
      urlsToOpen,
      benchmark,
      benchmarkTest,
      test,
      pidToKillWhenClosed,
      devMode,
      safeMode,
      newWindow,
      logFile,
      profileStartup,
      timeout,
      clearWindowState,
      addToLastWindow,
      preserveFocus,
      env
    } = options;
    if (!preserveFocus) {
      app.focus();
    }
    if (test) {
      return this.runTests({
        headless: true,
        devMode,
        resourcePath: this.resourcePath,
        executedFrom,
        pathsToOpen,
        logFile,
        timeout,
        env
      });
    } else if (benchmark || benchmarkTest) {
      console.log("The benchmarking feature has been removed.");
      if (this.getAllWindows().length === 0) {
        console.log("Quitting.");
        app.quit();
      };
    } else if (
      (pathsToOpen && pathsToOpen.length > 0) ||
      (foldersToOpen && foldersToOpen.length > 0)
    ) {
      return this.openPaths({
        pathsToOpen,
        foldersToOpen,
        executedFrom,
        pidToKillWhenClosed,
        newWindow,
        devMode,
        safeMode,
        profileStartup,
        clearWindowState,
        addToLastWindow,
        env
      });
    } else if (urlsToOpen && urlsToOpen.length > 0) {
      return Promise.all(
        urlsToOpen.map(urlToOpen =>
          this.openUrl({ urlToOpen, devMode, safeMode, env })
        )
      );
    } else {
      return this.openPath({
        pathToOpen: null,
        pidToKillWhenClosed,
        newWindow,
        devMode,
        safeMode,
        profileStartup,
        clearWindowState,
        addToLastWindow,
        env
      });
    }
  }
  createWindow(settings) {
    return new AtomWindow(this, this.fileRecoveryService, settings);
  }
  removeWindow(window) {
    this.windowStack.removeWindow(window);
    if (this.getAllWindows().length === 0 && process.platform !== 'darwin') {
      app.quit();
      return;
    }
    if (!window.isSpec) this.saveCurrentWindowOptions(true);
  }
  addWindow(window) {
    this.windowStack.addWindow(window);
    if (this.applicationMenu)
      this.applicationMenu.addWindow(window.browserWindow);
    if (!window.isSpec) {
      const focusHandler = () => this.windowStack.touch(window);
      const blurHandler = () => this.saveCurrentWindowOptions(false);
      window.browserWindow.on('focus', focusHandler);
      window.browserWindow.on('blur', blurHandler);
      window.browserWindow.once('closed', () => {
        this.windowStack.removeWindow(window);
        window.browserWindow.removeListener('focus', focusHandler);
        window.browserWindow.removeListener('blur', blurHandler);
      });
      window.browserWindow.webContents.once('did-finish-load', blurHandler);
      this.saveCurrentWindowOptions(false);
    }
  }
  getAllWindows() {
    return this.windowStack.all().slice();
  }
  getLastFocusedWindow(predicate) {
    return this.windowStack.getLastFocusedWindow(predicate);
  }
  async listenForArgumentsFromNewProcess() {
    this.socketSecretPromise = createSocketSecret(this.version);
    this.socketSecret = await this.socketSecretPromise;
    this.socketPath = getSocketPath(this.socketSecret);
    await this.deleteSocketFile();
    const server = net.createServer(connection => {
      let data = '';
      connection.on('data', chunk => {
        data += chunk;
      });
      connection.on('end', () => {
        try {
          const options = decryptOptions(data, this.socketSecret);
          this.openWithOptions(options);
        } catch (e) {
        }
      });
    });
    return new Promise(resolve => {
      server.listen(this.socketPath, resolve);
      server.on('error', error =>
        console.error('Application server failed', error)
      );
    });
  }
  async deleteSocketFile() {
    if (process.platform === 'win32') return;
    if (!this.socketSecretPromise) {
      return;
    }
    await this.socketSecretPromise;
    if (fs.existsSync(this.socketPath)) {
      try {
        fs.unlinkSync(this.socketPath);
      } catch (error) {
        if (error.code !== 'ENOENT') throw error;
      }
    }
  }
  async deleteSocketSecretFile() {
    if (!this.socketSecretPromise) {
      return;
    }
    await this.socketSecretPromise;
    const socketSecretPath = getSocketSecretPath(this.version);
    if (fs.existsSync(socketSecretPath)) {
      try {
        fs.unlinkSync(socketSecretPath);
      } catch (error) {
        if (error.code !== 'ENOENT') throw error;
      }
    }
  }
  handleEvents() {
    const createOpenSettings = ({ event, sameWindow }) => {
      const targetWindow = event
        ? this.atomWindowForEvent(event)
        : this.focusedWindow();
      return {
        devMode: targetWindow ? targetWindow.devMode : false,
        safeMode: targetWindow ? targetWindow.safeMode : false,
        window: sameWindow && targetWindow ? targetWindow : null
      };
    };
    this.on('application:quit', () => app.quit());
    this.on('application:new-window', () =>
      this.openPath(createOpenSettings({}))
    );
    this.on('application:new-file', () =>
      (this.focusedWindow() || this).openPath()
    );
    this.on('application:open-dev', () =>
      this.promptForPathToOpen('all', { devMode: true })
    );
    this.on('application:open-safe', () =>
      this.promptForPathToOpen('all', { safeMode: true })
    );
    this.on('application:inspect', ({ x, y, atomWindow }) => {
      if (!atomWindow) atomWindow = this.focusedWindow();
      if (atomWindow) atomWindow.browserWindow.inspectElement(x, y);
    });
    this.on('application:open-documentation', () =>
      shell.openExternal('https://pulsar-edit.dev/docs/')
    );
    this.on('application:open-discussions', () =>
      shell.openExternal('https://github.com/orgs/pulsar-edit/discussions')
    );
    this.on('application:open-faq', () =>
      shell.openExternal('https://pulsar-edit.dev/docs/launch-manual/sections/faq/')
    );
    this.on('application:open-terms-of-use', () =>
      shell.openExternal('https://atom.io/terms')
    );
    this.on('application:report-issue', () =>
      shell.openExternal(
        'https://github.com/pulsar-edit/pulsar/issues/new/choose'
      )
    );
    this.on('application:search-issues', () =>
      shell.openExternal('https://github.com/pulsar-edit/pulsar/issues?q=is%3Aissue+is%3Aopen+sort%3Aupdated-desc')
    );
    if (process.platform === 'darwin') {
      this.on('application:reopen-project', ({ paths }) => {
        const focusedWindow = this.focusedWindow();
        if (focusedWindow) {
          const { safeMode, devMode } = focusedWindow;
          this.openPaths({ pathsToOpen: paths, safeMode, devMode });
          return;
        }
        this.openPaths({ pathsToOpen: paths });
      });
      this.on('application:open', () => {
        const win = this.focusedWindow();
        if(win) {
          win.sendCommand('application:open')
        } else {
          this.promptForPathToOpen(
            'all',
            createOpenSettings({ sameWindow: true })
          );
        }
      });
      this.on('application:open-file', () => {
        const win = this.focusedWindow();
        if(win) {
          win.sendCommand('application:open-file')
        } else {
          this.promptForPathToOpen(
            'file',
            createOpenSettings({ sameWindow: true })
          );
        }
      });
      this.on('application:open-folder', () => {
        const win = this.focusedWindow();
        if(win) {
          win.sendCommand('application:open-folder')
        } else {
          this.promptForPathToOpen(
            'folder',
            createOpenSettings({ sameWindow: true })
          );
        }
      });
      this.on('application:bring-all-windows-to-front', () =>
        Menu.sendActionToFirstResponder('arrangeInFront:')
      );
      this.on('application:hide', () =>
        Menu.sendActionToFirstResponder('hide:')
      );
      this.on('application:hide-other-applications', () =>
        Menu.sendActionToFirstResponder('hideOtherApplications:')
      );
      this.on('application:minimize', () =>
        Menu.sendActionToFirstResponder('performMiniaturize:')
      );
      this.on('application:unhide-all-applications', () =>
        Menu.sendActionToFirstResponder('unhideAllApplications:')
      );
      this.on('application:zoom', () =>
        Menu.sendActionToFirstResponder('zoom:')
      );
    } else {
      this.on('application:minimize', () => {
        const window = this.focusedWindow();
        if (window) window.minimize();
      });
      this.on('application:zoom', function() {
        const window = this.focusedWindow();
        if (window) window.maximize();
      });
    }
    this.openPathOnEvent('application:about', 'atom://about');
    this.openPathOnEvent('application:show-settings', 'atom://config');
    this.openPathOnEvent('application:open-your-config', 'atom://.pulsar/config');
    this.openPathOnEvent(
      'application:open-your-init-script',
      'atom://.pulsar/init-script'
    );
    this.openPathOnEvent('application:open-your-keymap', 'atom://.pulsar/keymap');
    this.openPathOnEvent(
      'application:open-your-snippets',
      'atom://.pulsar/snippets'
    );
    this.openPathOnEvent(
      'application:open-your-stylesheet',
      'atom://.pulsar/stylesheet'
    );
    this.openPathOnEvent(
      'application:open-license',
      path.join(process.resourcesPath, 'LICENSE.md')
    );
    this.configFile.onDidChange(settings => {
      for (let window of this.getAllWindows()) {
        window.didChangeUserSettings(settings);
      }
      this.config.resetUserSettings(settings);
    });
    this.configFile.onDidError(message => {
      const window = this.focusedWindow() || this.getLastFocusedWindow();
      if (window) {
        window.didFailToReadUserSettings(message);
      } else {
        console.error(message);
      }
    });
    this.disposable.add(
      ipcHelpers.on(app, 'before-quit', async event => {
        let resolveBeforeQuitPromise;
        this.lastBeforeQuitPromise = new Promise(resolve => {
          resolveBeforeQuitPromise = resolve;
        });
        if (!this.quitting) {
          this.quitting = true;
          event.preventDefault();
          const windowUnloadPromises = this.getAllWindows().map(
            async window => {
              const unloaded = await window.prepareToUnload();
              if (unloaded) {
                window.close();
                await window.closedPromise;
              }
              return unloaded;
            }
          );
          const windowUnloadedResults = await Promise.all(windowUnloadPromises);
          if (windowUnloadedResults.every(Boolean)) {
            app.quit();
          } else {
            this.quitting = false;
          }
        }
        resolveBeforeQuitPromise();
      })
    );
    this.disposable.add(
      ipcHelpers.on(app, 'will-quit', () => {
        this.killAllProcesses();
        return Promise.all([
          this.deleteSocketFile(),
          this.deleteSocketSecretFile()
        ]);
      })
    );
    this.disposable.add(
      ipcHelpers.on(app, 'window-all-closed', () => {
        if (this.applicationMenu != null) {
          this.applicationMenu.enableWindowSpecificItems(false);
        }
        if (process.platform !== 'darwin') {
          app.quit();
        }
      })
    );
    this.disposable.add(
      ipcHelpers.on(app, 'open-file', (event, pathToOpen) => {
        event.preventDefault();
        this.openPath({ pathToOpen });
      })
    );
    this.disposable.add(
      ipcHelpers.on(app, 'open-url', (event, urlToOpen) => {
        event.preventDefault();
        this.openUrl({
          urlToOpen,
          devMode: this.devMode,
          safeMode: this.safeMode
        });
      })
    );
    this.disposable.add(
      ipcHelpers.on(app, 'activate', (event, hasVisibleWindows) => {
        if (hasVisibleWindows) return;
        if (event) event.preventDefault();
        this.emit('application:new-window');
      })
    );
    this.disposable.add(
      ipcHelpers.on(ipcMain, 'restart-application', () => {
        this.restart();
      })
    );
    this.disposable.add(
      ipcHelpers.on(ipcMain, 'resolve-proxy', async (event, requestId, url) => {
        const proxy = await event.sender.session.resolveProxy(url);
        if (!event.sender.isDestroyed())
          event.sender.send('did-resolve-proxy', requestId, proxy);
      })
    );
    this.disposable.add(
      ipcHelpers.on(ipcMain, 'did-change-history-manager', event => {
        for (let atomWindow of this.getAllWindows()) {
          const { webContents } = atomWindow.browserWindow;
          if (webContents !== event.sender)
            webContents.send('did-change-history-manager');
        }
      })
    );
    this.disposable.add(
      ipcHelpers.on(ipcMain, 'setWindowTheme', (event, options) => {
        if (options && typeof options === 'string') {
          nativeTheme.themeSource = options;
        }
      })
    );
    this.disposable.add(
      ipcHelpers.on(ipcMain, 'open', (event, options) => {
        if (options) {
          if (typeof options.pathsToOpen === 'string') {
            options.pathsToOpen = [options.pathsToOpen];
          }
          if (options.here) {
            options.window = this.atomWindowForEvent(event);
          }
          if (options.pathsToOpen && options.pathsToOpen.length > 0) {
            this.openPaths(options);
          } else {
            this.addWindow(this.createWindow(options));
          }
        } else {
          this.promptForPathToOpen('all', {});
        }
      })
    );
    this.disposable.add(
      ipcHelpers.on(ipcMain, 'open-chosen-any', (event, defaultPath) => {
        this.promptForPathToOpen(
          'all',
          createOpenSettings({ event, sameWindow: true }),
          defaultPath
        );
      })
    );
    this.disposable.add(
      ipcHelpers.on(ipcMain, 'open-chosen-file', (event, defaultPath) => {
        this.promptForPathToOpen(
          'file',
          createOpenSettings({ event, sameWindow: true }),
          defaultPath
        );
      })
    );
    this.disposable.add(
      ipcHelpers.on(ipcMain, 'open-chosen-folder', (event, defaultPath) => {
        this.promptForPathToOpen(
          'folder',
          createOpenSettings({ event }),
          defaultPath
        );
      })
    );
    this.disposable.add(
      ipcHelpers.on(
        ipcMain,
        'update-application-menu',
        (event, template, menu) => {
          const window = BrowserWindow.fromWebContents(event.sender);
          if (this.applicationMenu)
            this.applicationMenu.update(window, template, menu);
        }
      )
    );
    this.disposable.add(
      ipcHelpers.on(
        ipcMain,
        'run-package-specs',
        (event, packageSpecPath, options = {}) => {
          this.runTests(
            Object.assign(
              {
                resourcePath: this.devResourcePath,
                pathsToOpen: [packageSpecPath],
                headless: false
              },
              options
            )
          );
        }
      )
    );
    this.disposable.add(
      ipcHelpers.on(ipcMain, 'run-benchmarks', (event, benchmarksPath) => {
        console.log("The benchmarking feature has been removed.");
      })
    );
    this.disposable.add(
      ipcHelpers.on(ipcMain, 'command', (event, command) => {
        this.emit(command);
      })
    );
    this.disposable.add(
      ipcHelpers.on(ipcMain, 'window-command', (event, command, ...args) => {
        const window = BrowserWindow.fromWebContents(event.sender);
        return window && window.emit(command, ...args);
      })
    );
    this.disposable.add(
      ipcHelpers.respondTo(
        'window-method',
        (browserWindow, method, ...args) => {
          const window = this.atomWindowForBrowserWindow(browserWindow);
          if (window) window[method](...args);
        }
      )
    );
    this.disposable.add(
      ipcHelpers.on(ipcMain, 'pick-folder', (event, responseChannel) => {
        this.promptForPath('folder', paths =>
          event.sender.send(responseChannel, paths)
        );
      })
    );
    this.disposable.add(
      ipcHelpers.respondTo('set-window-size', (window, width, height) => {
        window.setSize(width, height);
      })
    );
    this.disposable.add(
      ipcHelpers.respondTo('set-window-position', (window, x, y) => {
        window.setPosition(x, y);
      })
    );
    this.disposable.add(
      ipcHelpers.respondTo(
        'set-user-settings',
        (window, settings, filePath) => {
          if (!this.quitting) {
            return ConfigFile.at(filePath || this.configFilePath).update(
              JSON.parse(settings)
            );
          }
        }
      )
    );
    this.disposable.add(
      ipcHelpers.respondTo('center-window', window => window.center())
    );
    this.disposable.add(
      ipcHelpers.respondTo('focus-window', window => window.focus())
    );
    this.disposable.add(
      ipcHelpers.respondTo('show-window', window => window.show())
    );
    this.disposable.add(
      ipcHelpers.respondTo('hide-window', window => window.hide())
    );
    this.disposable.add(
      ipcHelpers.respondTo(
        'get-temporary-window-state',
        window => window.temporaryState
      )
    );
    this.disposable.add(
      ipcHelpers.respondTo('set-temporary-window-state', (win, state) => {
        win.temporaryState = state;
      })
    );
    this.disposable.add(
      ipcHelpers.on(
        ipcMain,
        'write-text-to-selection-clipboard',
        (event, text) => clipboard.writeText(text, 'selection')
      )
    );
    this.disposable.add(
      ipcHelpers.on(ipcMain, 'write-to-stdout', (event, output) =>
        process.stdout.write(output)
      )
    );
    this.disposable.add(
      ipcHelpers.on(ipcMain, 'write-to-stderr', (event, output) =>
        process.stderr.write(output)
      )
    );
    this.disposable.add(
      ipcHelpers.on(ipcMain, 'add-recent-document', (event, filename) =>
        app.addRecentDocument(filename)
      )
    );
    this.disposable.add(
      ipcHelpers.on(
        ipcMain,
        'execute-javascript-in-dev-tools',
        (event, code) =>
          event.sender.devToolsWebContents &&
          event.sender.devToolsWebContents.executeJavaScript(code)
      )
    );
    this.disposable.add(
      ipcHelpers.respondTo('will-save-path', (window, path) =>
        this.fileRecoveryService.willSavePath(window, path)
      )
    );
    this.disposable.add(
      ipcHelpers.respondTo('did-save-path', (window, path) =>
        this.fileRecoveryService.didSavePath(window, path)
      )
    );
    this.disposable.add(this.disableZoomOnDisplayChange());
  }
  setupDockMenu() {
    if (process.platform === 'darwin') {
      return app.dock.setMenu(
        Menu.buildFromTemplate([
          {
            label: 'New Window',
            click: () => this.emit('application:new-window')
          }
        ])
      );
    }
  }
  initializeAtomHome(configDirPath) {
    if (!fs.existsSync(configDirPath)) {
      const templateConfigDirPath = fs.resolve(this.resourcePath, 'dot-atom');
      fs.copySync(templateConfigDirPath, configDirPath);
    }
  }
  sendCommand(command, ...args) {
    if (!this.emit(command, ...args)) {
      const focusedWindow = this.focusedWindow();
      if (focusedWindow) {
        return focusedWindow.sendCommand(command, ...args);
      } else {
        return this.sendCommandToFirstResponder(command);
      }
    }
  }
  sendCommandToWindow(command, atomWindow, ...args) {
    if (!this.emit(command, ...args)) {
      if (atomWindow) {
        return atomWindow.sendCommand(command, ...args);
      } else {
        return this.sendCommandToFirstResponder(command);
      }
    }
  }
  sendCommandToFirstResponder(command) {
    if (process.platform !== 'darwin') return false;
    switch (command) {
      case 'core:undo':
        Menu.sendActionToFirstResponder('undo:');
        break;
      case 'core:redo':
        Menu.sendActionToFirstResponder('redo:');
        break;
      case 'core:copy':
        Menu.sendActionToFirstResponder('copy:');
        break;
      case 'core:cut':
        Menu.sendActionToFirstResponder('cut:');
        break;
      case 'core:paste':
        Menu.sendActionToFirstResponder('paste:');
        break;
      case 'core:select-all':
        Menu.sendActionToFirstResponder('selectAll:');
        break;
      default:
        return false;
    }
    return true;
  }
  openPathOnEvent(eventName, pathToOpen) {
    this.on(eventName, () => {
      const window = this.focusedWindow();
      if (window) {
        return window.openPath(pathToOpen);
      } else {
        return this.openPath({ pathToOpen });
      }
    });
  }
  windowForLocations(locationsToOpen, devMode, safeMode) {
    return this.getLastFocusedWindow(
      window =>
        !window.isSpec &&
        window.devMode === devMode &&
        window.safeMode === safeMode &&
        window.containsLocations(locationsToOpen)
    );
  }
  atomWindowForEvent({ sender }) {
    return this.atomWindowForBrowserWindow(
      BrowserWindow.fromWebContents(sender)
    );
  }
  atomWindowForBrowserWindow(browserWindow) {
    return this.getAllWindows().find(
      atomWindow => atomWindow.browserWindow === browserWindow
    );
  }
  focusedWindow() {
    return this.getAllWindows().find(window => window.isFocused());
  }
  getWindowOffsetForCurrentPlatform() {
    const offsetByPlatform = {
      darwin: 22,
      win32: 26
    };
    return offsetByPlatform[process.platform] || 0;
  }
  getDimensionsForNewWindow() {
    const window = this.focusedWindow() || this.getLastFocusedWindow();
    if (!window || window.isMaximized()) return;
    const dimensions = window.getDimensions();
    if (dimensions) {
      const offset = this.getWindowOffsetForCurrentPlatform();
      dimensions.x += offset;
      dimensions.y += offset;
      return dimensions;
    }
  }
  openPath({
    pathToOpen,
    pidToKillWhenClosed,
    newWindow,
    devMode,
    safeMode,
    profileStartup,
    window,
    clearWindowState,
    addToLastWindow,
    env
  } = {}) {
    return this.openPaths({
      pathsToOpen: [pathToOpen],
      pidToKillWhenClosed,
      newWindow,
      devMode,
      safeMode,
      profileStartup,
      window,
      clearWindowState,
      addToLastWindow,
      env
    });
  }
  async openPaths({
    pathsToOpen,
    foldersToOpen,
    executedFrom,
    pidToKillWhenClosed,
    newWindow,
    devMode,
    safeMode,
    windowDimensions,
    profileStartup,
    window,
    clearWindowState,
    addToLastWindow,
    env
  } = {}) {
    if (!env) env = process.env;
    if (!pathsToOpen) pathsToOpen = [];
    if (!foldersToOpen) foldersToOpen = [];
    devMode = Boolean(devMode);
    safeMode = Boolean(safeMode);
    clearWindowState = Boolean(clearWindowState);
    const locationsToOpen = await Promise.all(
      pathsToOpen.map(pathToOpen =>
        this.parsePathToOpen(pathToOpen, executedFrom, {
          hasWaitSession: pidToKillWhenClosed != null
        })
      )
    );
    for (const folderToOpen of foldersToOpen) {
      locationsToOpen.push({
        pathToOpen: folderToOpen,
        initialLine: null,
        initialColumn: null,
        exists: true,
        isDirectory: true,
        hasWaitSession: pidToKillWhenClosed != null
      });
    }
    if (locationsToOpen.length === 0) {
      return;
    }
    const hasNonEmptyPath = locationsToOpen.some(
      location => location.pathToOpen
    );
    const createNewWindow = newWindow || !hasNonEmptyPath;
    let existingWindow;
    if (!createNewWindow) {
      existingWindow = window;
      if (!existingWindow && hasNonEmptyPath) {
        existingWindow = this.windowForLocations(
          locationsToOpen,
          devMode,
          safeMode
        );
      }
      if (!existingWindow && addToLastWindow) {
        existingWindow = this.getLastFocusedWindow(win => {
          return (
            !win.isSpec && win.devMode === devMode && win.safeMode === safeMode
          );
        });
      }
      if (!existingWindow) {
        existingWindow = this.getLastFocusedWindow(
          win => !win.isSpec && !win.hasProjectPaths()
        );
      }
      if (!existingWindow) {
        const noDirectories = locationsToOpen.every(
          location => !location.isDirectory
        );
        if (noDirectories) {
          existingWindow = this.getLastFocusedWindow(win => {
            return (
              !win.isSpec &&
              win.devMode === devMode &&
              win.safeMode === safeMode
            );
          });
        }
      }
    }
    let openedWindow;
    if (existingWindow) {
      openedWindow = existingWindow;
      StartupTime.addMarker('main-process:atom-application:open-in-existing');
      openedWindow.openLocations(locationsToOpen);
      if (openedWindow.isMinimized()) {
        openedWindow.restore();
      } else {
        openedWindow.focus();
      }
      openedWindow.replaceEnvironment(env);
    } else {
      let resourcePath, windowInitializationScript;
      if (devMode) {
        try {
          windowInitializationScript = require.resolve(
            path.join(
              this.devResourcePath,
              'src',
              'initialize-application-window'
            )
          );
          resourcePath = this.devResourcePath;
        } catch (error) {}
      }
      if (!windowInitializationScript) {
        windowInitializationScript = require.resolve(
          '../initialize-application-window'
        );
      }
      if (!resourcePath) resourcePath = this.resourcePath;
      if (!windowDimensions)
        windowDimensions = this.getDimensionsForNewWindow();
      StartupTime.addMarker('main-process:atom-application:create-window');
      openedWindow = this.createWindow({
        locationsToOpen,
        windowInitializationScript,
        resourcePath,
        devMode,
        safeMode,
        windowDimensions,
        profileStartup,
        clearWindowState,
        env
      });
      this.addWindow(openedWindow);
      openedWindow.focus();
    }
    if (pidToKillWhenClosed != null) {
      if (!this.waitSessionsByWindow.has(openedWindow)) {
        this.waitSessionsByWindow.set(openedWindow, []);
      }
      this.waitSessionsByWindow.get(openedWindow).push({
        pid: pidToKillWhenClosed,
        remainingPaths: new Set(
          locationsToOpen.map(location => location.pathToOpen).filter(Boolean)
        )
      });
    }
    openedWindow.browserWindow.once('closed', () =>
      this.killProcessesForWindow(openedWindow)
    );
    return openedWindow;
  }
  killAllProcesses() {
    for (let window of this.waitSessionsByWindow.keys()) {
      this.killProcessesForWindow(window);
    }
  }
  killProcessesForWindow(window) {
    const sessions = this.waitSessionsByWindow.get(window);
    if (!sessions) return;
    for (const session of sessions) {
      this.killProcess(session.pid);
    }
    this.waitSessionsByWindow.delete(window);
  }
  windowDidClosePathWithWaitSession(window, initialPath) {
    const waitSessions = this.waitSessionsByWindow.get(window);
    if (!waitSessions) return;
    for (let i = waitSessions.length - 1; i >= 0; i--) {
      const session = waitSessions[i];
      session.remainingPaths.delete(initialPath);
      if (session.remainingPaths.size === 0) {
        this.killProcess(session.pid);
        waitSessions.splice(i, 1);
      }
    }
  }
  killProcess(pid) {
    try {
      const parsedPid = parseInt(pid);
      if (isFinite(parsedPid)) this._killProcess(parsedPid);
    } catch (error) {
      if (error.code !== 'ESRCH') {
        console.log(
          `Killing process ${pid} failed: ${
            error.code != null ? error.code : error.message
          }`
        );
      }
    }
  }
  async saveCurrentWindowOptions(allowEmpty = false) {
    if (this.quitting) return;
    const windows = this.getAllWindows();
    const hasASpecWindow = windows.some(window => window.isSpec);
    if (windows.length === 1 && hasASpecWindow) return;
    const state = {
      version: APPLICATION_STATE_VERSION,
      windows: windows
        .filter(window => !window.isSpec)
        .map(window => ({ projectRoots: window.projectRoots }))
    };
    state.windows.reverse();
    if (state.windows.length > 0 || allowEmpty) {
      await this.storageFolder.store('application.json', state);
      this.emit('application:did-save-state');
    }
  }
  async loadPreviousWindowOptions() {
    const state = await this.storageFolder.load('application.json');
    if (!state) {
      return [];
    }
    if (state.version === APPLICATION_STATE_VERSION) {
      return state.windows.map(each => ({
        foldersToOpen: each.projectRoots,
        devMode: this.devMode,
        safeMode: this.safeMode,
        newWindow: true
      }));
    } else if (state.version === undefined) {
      return Promise.all(
        state.map(async windowState => {
          const classifiedPaths = await Promise.all(
            windowState.initialPaths.map(
              initialPath =>
                new Promise(resolve => {
                  fs.isDirectory(initialPath, isDir =>
                    resolve({ initialPath, isDir })
                  );
                })
            )
          );
          return {
            foldersToOpen: classifiedPaths
              .filter(({ isDir }) => isDir)
              .map(({ initialPath }) => initialPath),
            devMode: this.devMode,
            safeMode: this.safeMode,
            newWindow: true
          };
        })
      );
    } else {
      return [];
    }
  }
  openUrl({ urlToOpen, devMode, safeMode, env }) {
    const parsedUrl = url.parse(urlToOpen, true);
    if (parsedUrl.protocol !== 'atom:') return;
    const pack = this.findPackageWithName(parsedUrl.host, devMode);
    if (pack && pack.urlMain) {
      return this.openPackageUrlMain(
        parsedUrl.host,
        pack.urlMain,
        urlToOpen,
        devMode,
        safeMode,
        env
      );
    } else {
      return this.openPackageUriHandler(
        urlToOpen,
        parsedUrl,
        devMode,
        safeMode,
        env
      );
    }
  }
  openPackageUriHandler(url, parsedUrl, devMode, safeMode, env) {
    let bestWindow;
    if (parsedUrl.host === 'core') {
      const predicate = require('../core-uri-handlers').windowPredicate(
        parsedUrl
      );
      bestWindow = this.getLastFocusedWindow(
        win => !win.isSpecWindow() && predicate(win)
      );
    }
    if (!bestWindow)
      bestWindow = this.getLastFocusedWindow(win => !win.isSpecWindow());
    if (bestWindow) {
      bestWindow.sendURIMessage(url);
      bestWindow.focus();
      return bestWindow;
    } else {
      let windowInitializationScript;
      let { resourcePath } = this;
      if (devMode) {
        try {
          windowInitializationScript = require.resolve(
            path.join(
              this.devResourcePath,
              'src',
              'initialize-application-window'
            )
          );
          resourcePath = this.devResourcePath;
        } catch (error) {}
      }
      if (!windowInitializationScript) {
        windowInitializationScript = require.resolve(
          '../initialize-application-window'
        );
      }
      const windowDimensions = this.getDimensionsForNewWindow();
      const window = this.createWindow({
        resourcePath,
        windowInitializationScript,
        devMode,
        safeMode,
        windowDimensions,
        env
      });
      this.addWindow(window);
      window.on('window:loaded', () => window.sendURIMessage(url));
      return window;
    }
  }
  findPackageWithName(packageName, devMode) {
    return this.getPackageManager(devMode)
      .getAvailablePackageMetadata()
      .find(({ name }) => name === packageName);
  }
  openPackageUrlMain(
    packageName,
    packageUrlMain,
    urlToOpen,
    devMode,
    safeMode,
    env
  ) {
    const packagePath = this.getPackageManager(devMode).resolvePackagePath(
      packageName
    );
    const windowInitializationScript = path.resolve(
      packagePath,
      packageUrlMain
    );
    const windowDimensions = this.getDimensionsForNewWindow();
    const window = this.createWindow({
      windowInitializationScript,
      resourcePath: this.resourcePath,
      devMode,
      safeMode,
      urlToOpen,
      windowDimensions,
      env
    });
    this.addWindow(window);
    return window;
  }
  getPackageManager(devMode) {
    if (this.packages == null) {
      const PackageManager = require('../package-manager');
      this.packages = new PackageManager({});
      this.packages.initialize({
        configDirPath: process.env.ATOM_HOME,
        devMode,
        resourcePath: this.resourcePath
      });
    }
    return this.packages;
  }
  runTests({
    headless,
    resourcePath,
    executedFrom,
    pathsToOpen,
    logFile,
    safeMode,
    timeout,
    env
  }) {
    let windowInitializationScript;
    if (resourcePath !== this.resourcePath && !fs.existsSync(resourcePath)) {
      ({ resourcePath } = this);
    }
    const timeoutInSeconds = Number.parseFloat(timeout);
    if (!Number.isNaN(timeoutInSeconds)) {
      const timeoutHandler = function() {
        console.log(
          `The test suite has timed out because it has been running for more than ${timeoutInSeconds} seconds.`
        );
        return process.exit(124);
      };
      setTimeout(timeoutHandler, timeoutInSeconds * 1000);
    }
    try {
      windowInitializationScript = require.resolve(
        path.resolve(this.devResourcePath, 'src', 'initialize-test-window')
      );
    } catch (error) {
      windowInitializationScript = require.resolve(
        path.resolve(__dirname, '..', '..', 'src', 'initialize-test-window')
      );
    }
    const testPaths = [];
    if (pathsToOpen != null) {
      for (let pathToOpen of pathsToOpen) {
        testPaths.push(path.resolve(executedFrom, fs.normalize(pathToOpen)));
      }
    }
    if (testPaths.length === 0) {
      process.stderr.write('Error: Specify at least one test path\n\n');
      process.exit(1);
    }
    const legacyTestRunnerPath = this.resolveLegacyTestRunnerPath();
    const testRunnerPath = this.resolveTestRunnerPath(testPaths[0]);
    const devMode = true;
    const isSpec = true;
    if (safeMode == null) {
      safeMode = false;
    }
    const window = this.createWindow({
      windowInitializationScript,
      resourcePath,
      headless,
      isSpec,
      devMode,
      testRunnerPath,
      legacyTestRunnerPath,
      testPaths,
      logFile,
      safeMode,
      env
    });
    this.addWindow(window);
    if (env) window.replaceEnvironment(env);
    return window;
  }
  resolveTestRunnerPath(testPath) {
    let packageRoot;
    if (FindParentDir == null) {
      FindParentDir = require('find-parent-dir');
    }
    if ((packageRoot = FindParentDir.sync(testPath, 'package.json'))) {
      const packageMetadata = require(path.join(packageRoot, 'package.json'));
      if (packageMetadata.atomTestRunner) {
        let testRunnerPath;
        if (Resolve == null) {
          Resolve = require('resolve');
        }
        if (
          (testRunnerPath = Resolve.sync(packageMetadata.atomTestRunner, {
            basedir: packageRoot,
            extensions: Object.keys(require.extensions)
          }))
        ) {
          return testRunnerPath;
        } else {
          process.stderr.write(
            `Error: Could not resolve test runner path '${
              packageMetadata.atomTestRunner
            }'`
          );
          process.exit(1);
        }
      }
    }
    return this.resolveLegacyTestRunnerPath();
  }
  resolveLegacyTestRunnerPath() {
    try {
      return require.resolve(
        path.resolve(this.devResourcePath, 'spec', 'jasmine-test-runner.js')
      );
    } catch (error) {
      return require.resolve(
        path.resolve(__dirname, '..', '..', 'spec', 'jasmine-test-runner.js')
      );
    }
  }
  async parsePathToOpen(pathToOpen, executedFrom, extra) {
    const result = Object.assign(
      {
        pathToOpen,
        initialColumn: null,
        initialLine: null,
        exists: false,
        isDirectory: false,
        isFile: false
      },
      extra
    );
    if (!pathToOpen) {
      return result;
    }
    result.pathToOpen = result.pathToOpen.replace(/[:\s]+$/, '');
    const match = result.pathToOpen.match(LocationSuffixRegExp);
    if (match != null) {
      result.pathToOpen = result.pathToOpen.slice(0, -match[0].length);
      if (match[1]) {
        result.initialLine = Math.max(0, parseInt(match[1].slice(1), 10) - 1);
      }
      if (match[2]) {
        result.initialColumn = Math.max(0, parseInt(match[2].slice(1), 10) - 1);
      }
    }
    const normalizedPath = path.normalize(
      path.resolve(executedFrom, fs.normalize(result.pathToOpen))
    );
    if (!url.parse(pathToOpen).protocol) {
      result.pathToOpen = normalizedPath;
    }
    await new Promise((resolve, reject) => {
      fs.stat(result.pathToOpen, (err, st) => {
        if (err) {
          if (err.code === 'ENOENT' || err.code === 'EACCES') {
            result.exists = false;
            resolve();
          } else {
            reject(err);
          }
          return;
        }
        result.exists = true;
        result.isFile = st.isFile();
        result.isDirectory = st.isDirectory();
        resolve();
      });
    });
    return result;
  }
  promptForPathToOpen(type, { devMode, safeMode, window }, path = null) {
    return this.promptForPath(
      type,
      async pathsToOpen => {
        let targetWindow;
        if (type === 'folder') {
          targetWindow = null;
        } else if (type === 'file') {
          targetWindow = window;
        } else if (type === 'all') {
          const areDirectories = await Promise.all(
            pathsToOpen.map(
              pathToOpen =>
                new Promise(resolve => fs.isDirectory(pathToOpen, resolve))
            )
          );
          if (!areDirectories.some(Boolean)) {
            targetWindow = window;
          }
        }
        return this.openPaths({
          pathsToOpen,
          devMode,
          safeMode,
          window: targetWindow
        });
      },
      path
    );
  }
  promptForPath(type, callback, path) {
    const properties = (() => {
      switch (type) {
        case 'file':
          return ['openFile'];
        case 'folder':
          return ['openDirectory'];
        case 'all':
          return ['openFile', 'openDirectory'];
        default:
          throw new Error(`${type} is an invalid type for promptForPath`);
      }
    })();
    const parentWindow =
      process.platform === 'darwin' ? null : BrowserWindow.getFocusedWindow();
    const openOptions = {
      properties: properties.concat(['multiSelections', 'createDirectory']),
      title: (() => {
        switch (type) {
          case 'file':
            return 'Open File';
          case 'folder':
            return 'Open Folder';
          default:
            return 'Open';
        }
      })()
    };
    if (path) openOptions.defaultPath = path;
    dialog
      .showOpenDialog(parentWindow, openOptions)
      .then(({ filePaths, bookmarks }) => {
        if (typeof callback === 'function') {
          callback(filePaths, bookmarks);
        }
      });
  }
  async promptForRestart() {
    const result = await dialog.showMessageBox(
      BrowserWindow.getFocusedWindow(),
      {
        type: 'warning',
        title: 'Restart required',
        message:
          'You will need to restart Pulsar for this change to take effect.',
        buttons: ['Restart Pulsar', 'Cancel']
      }
    );
    if (result.response === 0) this.restart();
  }
  restart() {
    const args = [];
    if (this.safeMode) args.push('--safe');
    if (this.logFile != null) args.push(`--log-file=${this.logFile}`);
    if (this.userDataDir != null)
      args.push(`--user-data-dir=${this.userDataDir}`);
    if (this.devMode) {
      args.push('--dev');
      args.push(`--resource-path=${this.resourcePath}`);
    }
    app.relaunch({ args });
    app.quit();
  }
  disableZoomOnDisplayChange() {
    const callback = () => {
      this.getAllWindows().map(window => window.disableZoom());
    };
    screen.on('display-added', callback);
    screen.on('display-removed', callback);
    return new Disposable(() => {
      screen.removeListener('display-added', callback);
      screen.removeListener('display-removed', callback);
    });
  }
};
class WindowStack {
  constructor(windows = []) {
    this.addWindow = this.addWindow.bind(this);
    this.touch = this.touch.bind(this);
    this.removeWindow = this.removeWindow.bind(this);
    this.getLastFocusedWindow = this.getLastFocusedWindow.bind(this);
    this.all = this.all.bind(this);
    this.windows = windows;
  }
  addWindow(window) {
    this.removeWindow(window);
    return this.windows.unshift(window);
  }
  touch(window) {
    return this.addWindow(window);
  }
  removeWindow(window) {
    const currentIndex = this.windows.indexOf(window);
    if (currentIndex > -1) {
      return this.windows.splice(currentIndex, 1);
    }
  }
  getLastFocusedWindow(predicate) {
    if (predicate == null) {
      predicate = win => true;
    }
    return this.windows.find(predicate);
  }
  all() {
    return this.windows;
  }
}

================
File: src/main-process/atom-protocol-handler.js
================
const { protocol } = require('electron');
const fs = require('fs');
const path = require('path');
module.exports = class AtomProtocolHandler {
  constructor(resourcePath, safeMode) {
    this.loadPaths = [];
    if (!safeMode) {
      this.loadPaths.push(path.join(process.env.ATOM_HOME, 'dev', 'packages'));
      this.loadPaths.push(path.join(resourcePath, 'packages'));
    }
    this.loadPaths.push(path.join(process.env.ATOM_HOME, 'packages'));
    this.loadPaths.push(path.join(resourcePath, 'node_modules'));
    this.registerAtomProtocol();
  }
  registerAtomProtocol() {
    protocol.registerFileProtocol('atom', (request, callback) => {
      const relativePath = path.normalize(request.url.substr(7));
      let filePath;
      if (relativePath.indexOf('assets/') === 0) {
        const assetsPath = path.join(process.env.ATOM_HOME, relativePath);
        try {
          const stat = fs.statSync(assetsPath);
          if (stat && stat.isFile()) filePath = assetsPath;
        } catch (e) {}
      }
      if (!filePath) {
        for (let loadPath of this.loadPaths) {
          filePath = path.join(loadPath, relativePath);
          try {
            const stat = fs.statSync(filePath);
            if (stat && stat.isFile()) break;
          } catch (e) {}
        }
      }
      callback(filePath);
    });
  }
};

================
File: src/main-process/atom-window.js
================
const {
  BrowserWindow,
  app,
  dialog,
  ipcMain,
  nativeImage
} = require('electron');
const { getAppName } = require('../get-app-details.js');
const path = require('path');
const fs = require('fs');
const url = require('url');
const { EventEmitter } = require('events');
const StartupTime = require('../startup-time');
let ICON_PATH = path.resolve(process.resourcesPath, 'pulsar.png');
if(!fs.existsSync(ICON_PATH)) {
  ICON_PATH = path.resolve(__dirname, '..', '..', 'resources', 'pulsar.png');
}
let includeShellLoadTime = true;
let nextId = 0;
module.exports = class AtomWindow extends EventEmitter {
  constructor(atomApplication, fileRecoveryService, settings = {}) {
    StartupTime.addMarker('main-process:atom-window:start');
    super();
    this.id = nextId++;
    this.atomApplication = atomApplication;
    this.fileRecoveryService = fileRecoveryService;
    this.isSpec = settings.isSpec;
    this.headless = settings.headless;
    this.safeMode = settings.safeMode;
    this.devMode = settings.devMode;
    this.resourcePath = settings.resourcePath;
    const locationsToOpen = settings.locationsToOpen || [];
    this.loadedPromise = new Promise(resolve => {
      this.resolveLoadedPromise = resolve;
    });
    this.closedPromise = new Promise(resolve => {
      this.resolveClosedPromise = resolve;
    });
    const options = {
      show: false,
      title: getAppName(),
      tabbingIdentifier: 'atom',
      webPreferences: {
        backgroundThrottling: !this.isSpec,
        disableBlinkFeatures: 'Auxclick',
        nodeIntegration: true,
        contextIsolation: false,
        enableRemoteModule: true,
        webviewTag: true,
        enableRemoteModule: true,
        nodeIntegrationInWorker: true
      },
      simpleFullscreen: this.getSimpleFullscreen()
    };
    if (process.platform === 'linux')
      options.icon = nativeImage.createFromPath(ICON_PATH);
    if (this.shouldAddCustomTitleBar()) options.titleBarStyle = 'hidden';
    if (this.shouldAddCustomInsetTitleBar())
      options.titleBarStyle = 'hiddenInset';
    if (this.shouldHideTitleBar()) options.frame = false;
    if(this.atomApplication.config.get('core.allowWindowTransparency')){
      options.transparent = true;
    }
    const BrowserWindowConstructor =
      settings.browserWindowConstructor || BrowserWindow;
    this.browserWindow = new BrowserWindowConstructor(options);
    Object.defineProperty(this.browserWindow, 'loadSettingsJSON', {
      get: () =>
        JSON.stringify(
          Object.assign(
            {
              userSettings: !this.isSpec
                ? this.atomApplication.configFile.get()
                : null
            },
            this.loadSettings
          )
        )
    });
    this.handleEvents();
    this.loadSettings = Object.assign({}, settings);
    this.loadSettings.appVersion = app.getVersion();
    this.loadSettings.appName = getAppName();
    this.loadSettings.resourcePath = this.resourcePath;
    this.loadSettings.atomHome = process.env.ATOM_HOME;
    if (this.loadSettings.devMode == null) this.loadSettings.devMode = false;
    if (this.loadSettings.safeMode == null) this.loadSettings.safeMode = false;
    if (this.loadSettings.clearWindowState == null)
      this.loadSettings.clearWindowState = false;
    this.addLocationsToOpen(locationsToOpen);
    this.loadSettings.hasOpenFiles = locationsToOpen.some(
      location => location.pathToOpen && !location.isDirectory
    );
    this.loadSettings.initialProjectRoots = this.projectRoots;
    StartupTime.addMarker('main-process:atom-window:end');
    Object.defineProperty(this.browserWindow, 'startupMarkers', {
      get: () => {
        const timingData = StartupTime.exportData();
        StartupTime.deleteData();
        return timingData;
      }
    });
    if (includeShellLoadTime && !this.isSpec) {
      includeShellLoadTime = false;
      if (!this.loadSettings.shellLoadTime) {
        this.loadSettings.shellLoadTime = Date.now() - global.shellStartTime;
      }
    }
    if (!this.loadSettings.env) this.env = this.loadSettings.env;
    this.browserWindow.on('window:loaded', () => {
      this.disableZoom();
      this.emit('window:loaded');
      this.resolveLoadedPromise();
    });
    this.browserWindow.on('window:locations-opened', () => {
      this.emit('window:locations-opened');
    });
    this.browserWindow.on('enter-full-screen', () => {
      this.browserWindow.webContents.send('did-enter-full-screen');
    });
    this.browserWindow.on('leave-full-screen', () => {
      this.browserWindow.webContents.send('did-leave-full-screen');
    });
    this.browserWindow.loadURL(
      url.format({
        protocol: 'file',
        pathname: `${this.resourcePath}/static/index.html`,
        slashes: true
      })
    );
    this.browserWindow.showSaveDialog = this.showSaveDialog.bind(this);
    if (this.isSpec) this.browserWindow.focusOnWebView();
    const hasPathToOpen = !(
      locationsToOpen.length === 1 && locationsToOpen[0].pathToOpen == null
    );
    if (hasPathToOpen && !this.isSpecWindow())
      this.openLocations(locationsToOpen);
  }
  hasProjectPaths() {
    return this.projectRoots.length > 0;
  }
  setupContextMenu() {
    const ContextMenu = require('./context-menu');
    this.browserWindow.on('context-menu', menuTemplate => {
      return new ContextMenu(menuTemplate, this);
    });
  }
  containsLocations(locations) {
    return locations.every(location => this.containsLocation(location));
  }
  containsLocation(location) {
    if (!location.pathToOpen) return false;
    return this.projectRoots.some(projectPath => {
      if (location.pathToOpen === projectPath) return true;
      if (location.pathToOpen.startsWith(path.join(projectPath, path.sep))) {
        if (!location.exists) return true;
        if (!location.isDirectory) return true;
      }
      return false;
    });
  }
  handleEvents() {
    this.browserWindow.on('close', async event => {
      if (
        (!this.atomApplication.quitting ||
          this.atomApplication.quittingForUpdate) &&
        !this.unloading
      ) {
        event.preventDefault();
        this.unloading = true;
        this.atomApplication.saveCurrentWindowOptions(false);
        if (await this.prepareToUnload()) this.close();
      }
    });
    this.browserWindow.on('closed', () => {
      this.fileRecoveryService.didCloseWindow(this);
      this.atomApplication.removeWindow(this);
      this.resolveClosedPromise();
    });
    this.browserWindow.on('unresponsive', async () => {
      if (this.isSpec) return;
      const result = await dialog.showMessageBox(this.browserWindow, {
        type: 'warning',
        buttons: ['Force Close', 'Keep Waiting'],
        cancelId: 1,
        message: 'Editor is not responding',
        detail:
          'The editor is not responding. Would you like to force close it or just keep waiting?'
      });
      if (result.response === 0) this.browserWindow.destroy();
    });
    this.browserWindow.webContents.on('render-process-gone', async () => {
      if (this.headless) {
        console.log('Renderer process crashed, exiting');
        this.atomApplication.exit(100);
        return;
      }
      await this.fileRecoveryService.didCrashWindow(this);
      const result = await dialog.showMessageBox(this.browserWindow, {
        type: 'warning',
        buttons: ['Close Window', 'Reload', 'Keep It Open'],
        cancelId: 2,
        message: 'The editor has crashed',
        detail: 'Please report this issue to https://github.com/pulsar-edit/pulsar'
      });
      switch (result.response) {
        case 0:
          this.browserWindow.destroy();
          break;
        case 1:
          this.browserWindow.reload();
          break;
      }
    });
    this.browserWindow.webContents.on('will-navigate', (event, url) => {
      if (url !== this.browserWindow.webContents.getURL())
        event.preventDefault();
    });
    this.setupContextMenu();
    if (this.isSpec)
      this.browserWindow.on('blur', () => this.browserWindow.focusOnWebView());
  }
  async prepareToUnload() {
    if (this.isSpecWindow()) return true;
    this.lastPrepareToUnloadPromise = new Promise(resolve => {
      const callback = (event, result) => {
        if (
          BrowserWindow.fromWebContents(event.sender) === this.browserWindow
        ) {
          ipcMain.removeListener('did-prepare-to-unload', callback);
          if (!result) {
            this.unloading = false;
            this.atomApplication.quitting = false;
          }
          resolve(result);
        }
      };
      ipcMain.on('did-prepare-to-unload', callback);
      this.browserWindow.webContents.send('prepare-to-unload');
    });
    return this.lastPrepareToUnloadPromise;
  }
  openPath(pathToOpen, initialLine, initialColumn) {
    return this.openLocations([{ pathToOpen, initialLine, initialColumn }]);
  }
  async openLocations(locationsToOpen) {
    this.addLocationsToOpen(locationsToOpen);
    await this.loadedPromise;
    this.sendMessage('open-locations', locationsToOpen);
  }
  didChangeUserSettings(settings) {
    this.sendMessage('did-change-user-settings', settings);
  }
  didFailToReadUserSettings(message) {
    this.sendMessage('did-fail-to-read-user-settings', message);
  }
  addLocationsToOpen(locationsToOpen) {
    const roots = new Set(this.projectRoots || []);
    for (const { pathToOpen, isDirectory } of locationsToOpen) {
      if (isDirectory) {
        roots.add(pathToOpen);
      }
    }
    this.projectRoots = Array.from(roots);
    this.projectRoots.sort();
  }
  replaceEnvironment(env) {
    const {
      NODE_ENV,
      NODE_PATH,
      ATOM_HOME,
      ATOM_DISABLE_SHELLING_OUT_FOR_ENVIRONMENT
    } = env;
    this.browserWindow.webContents.send('environment', {
      NODE_ENV,
      NODE_PATH,
      ATOM_HOME,
      ATOM_DISABLE_SHELLING_OUT_FOR_ENVIRONMENT
    });
  }
  sendMessage(message, detail) {
    this.browserWindow.webContents.send('message', message, detail);
  }
  sendCommand(command, ...args) {
    if (this.isSpecWindow()) {
      if (!this.atomApplication.sendCommandToFirstResponder(command)) {
        switch (command) {
          case 'window:reload':
            return this.reload();
          case 'window:toggle-dev-tools':
            return this.toggleDevTools();
          case 'window:close':
            return this.close();
        }
      }
    } else if (this.isWebViewFocused()) {
      this.sendCommandToBrowserWindow(command, ...args);
    } else if (!this.atomApplication.sendCommandToFirstResponder(command)) {
      this.sendCommandToBrowserWindow(command, ...args);
    }
  }
  sendURIMessage(uri) {
    this.browserWindow.webContents.send('uri-message', uri);
  }
  sendCommandToBrowserWindow(command, ...args) {
    const action =
      args[0] && args[0].contextCommand ? 'context-command' : 'command';
    this.browserWindow.webContents.send(action, command, ...args);
  }
  getDimensions() {
    const [x, y] = Array.from(this.browserWindow.getPosition());
    const [width, height] = Array.from(this.browserWindow.getSize());
    return { x, y, width, height };
  }
  getSimpleFullscreen() {
    return this.atomApplication.config.get('core.simpleFullScreenWindows');
  }
  shouldAddCustomTitleBar() {
    return (
      !this.isSpec &&
      process.platform === 'darwin' &&
      this.atomApplication.config.get('core.titleBar') === 'custom'
    );
  }
  shouldAddCustomInsetTitleBar() {
    return (
      !this.isSpec &&
      process.platform === 'darwin' &&
      this.atomApplication.config.get('core.titleBar') === 'custom-inset'
    );
  }
  shouldHideTitleBar() {
    return (
      !this.isSpec &&
      this.atomApplication.config.get('core.titleBar') === 'hidden'
    );
  }
  close() {
    return this.browserWindow.close();
  }
  focus() {
    return this.browserWindow.focus();
  }
  minimize() {
    return this.browserWindow.minimize();
  }
  maximize() {
    return this.browserWindow.maximize();
  }
  unmaximize() {
    return this.browserWindow.unmaximize();
  }
  restore() {
    return this.browserWindow.restore();
  }
  setFullScreen(fullScreen) {
    return this.browserWindow.setFullScreen(fullScreen);
  }
  setAutoHideMenuBar(autoHideMenuBar) {
    return this.browserWindow.setAutoHideMenuBar(autoHideMenuBar);
  }
  handlesAtomCommands() {
    return !this.isSpecWindow() && this.isWebViewFocused();
  }
  isFocused() {
    return this.browserWindow.isFocused();
  }
  isMaximized() {
    return this.browserWindow.isMaximized();
  }
  isMinimized() {
    return this.browserWindow.isMinimized();
  }
  isWebViewFocused() {
    return this.browserWindow.isWebViewFocused();
  }
  isSpecWindow() {
    return this.isSpec;
  }
  reload() {
    this.loadedPromise = new Promise(resolve => {
      this.resolveLoadedPromise = resolve;
    });
    this.prepareToUnload().then(canUnload => {
      if (canUnload) this.browserWindow.reload();
    });
    return this.loadedPromise;
  }
  showSaveDialog(options, callback) {
    options = Object.assign(
      {
        title: 'Save File',
        defaultPath: this.projectRoots[0]
      },
      options
    );
    let promise = dialog.showSaveDialog(this.browserWindow, options);
    if (typeof callback === 'function') {
      promise = promise.then(({ filePath, bookmark }) => {
        callback(filePath, bookmark);
      });
    }
    return promise;
  }
  toggleDevTools() {
    return this.browserWindow.toggleDevTools();
  }
  openDevTools() {
    return this.browserWindow.openDevTools();
  }
  closeDevTools() {
    return this.browserWindow.closeDevTools();
  }
  setDocumentEdited(documentEdited) {
    return this.browserWindow.setDocumentEdited(documentEdited);
  }
  setRepresentedFilename(representedFilename) {
    return this.browserWindow.setRepresentedFilename(representedFilename);
  }
  setProjectRoots(projectRootPaths) {
    this.projectRoots = projectRootPaths;
    this.projectRoots.sort();
    this.loadSettings.initialProjectRoots = this.projectRoots;
    return this.atomApplication.saveCurrentWindowOptions();
  }
  didClosePathWithWaitSession(path) {
    this.atomApplication.windowDidClosePathWithWaitSession(this, path);
  }
  copy() {
    return this.browserWindow.copy();
  }
  disableZoom() {
    return this.browserWindow.webContents.setVisualZoomLevelLimits(1, 1);
  }
  getLoadedPromise() {
    return this.loadedPromise;
  }
};

================
File: src/main-process/context-menu.js
================
const { Menu } = require('electron');
module.exports = class ContextMenu {
  constructor(template, atomWindow) {
    this.atomWindow = atomWindow;
    this.createClickHandlers(template);
    const menu = Menu.buildFromTemplate(template);
    menu.popup(this.atomWindow.browserWindow, { async: true });
  }
  createClickHandlers(template) {
    template.forEach(item => {
      if (item.command) {
        if (!item.commandDetail) item.commandDetail = {};
        item.commandDetail.contextCommand = true;
        item.click = () => {
          global.atomApplication.sendCommandToWindow(
            item.command,
            this.atomWindow,
            item.commandDetail
          );
        };
      } else if (item.submenu) {
        this.createClickHandlers(item.submenu);
      }
    });
  }
};

================
File: src/main-process/file-recovery-service.js
================
const { dialog } = require('electron');
const crypto = require('crypto');
const Path = require('path');
const fs = require('fs-plus');
module.exports = class FileRecoveryService {
  constructor(recoveryDirectory) {
    this.recoveryDirectory = recoveryDirectory;
    this.recoveryFilesByFilePath = new Map();
    this.recoveryFilesByWindow = new WeakMap();
    this.windowsByRecoveryFile = new Map();
  }
  async willSavePath(window, path) {
    const stats = await tryStatFile(path);
    if (!stats) return;
    const recoveryPath = Path.join(
      this.recoveryDirectory,
      RecoveryFile.fileNameForPath(path)
    );
    const recoveryFile =
      this.recoveryFilesByFilePath.get(path) ||
      new RecoveryFile(path, stats.mode, recoveryPath);
    try {
      await recoveryFile.retain();
    } catch (err) {
      console.log(
        `Couldn't retain ${recoveryFile.recoveryPath}. Code: ${
          err.code
        }. Message: ${err.message}`
      );
      return;
    }
    if (!this.recoveryFilesByWindow.has(window)) {
      this.recoveryFilesByWindow.set(window, new Set());
    }
    if (!this.windowsByRecoveryFile.has(recoveryFile)) {
      this.windowsByRecoveryFile.set(recoveryFile, new Set());
    }
    this.recoveryFilesByWindow.get(window).add(recoveryFile);
    this.windowsByRecoveryFile.get(recoveryFile).add(window);
    this.recoveryFilesByFilePath.set(path, recoveryFile);
  }
  async didSavePath(window, path) {
    const recoveryFile = this.recoveryFilesByFilePath.get(path);
    if (recoveryFile != null) {
      try {
        await recoveryFile.release();
      } catch (err) {
        console.log(
          `Couldn't release ${recoveryFile.recoveryPath}. Code: ${
            err.code
          }. Message: ${err.message}`
        );
      }
      if (recoveryFile.isReleased()) this.recoveryFilesByFilePath.delete(path);
      this.recoveryFilesByWindow.get(window).delete(recoveryFile);
      this.windowsByRecoveryFile.get(recoveryFile).delete(window);
    }
  }
  async didCrashWindow(window) {
    if (!this.recoveryFilesByWindow.has(window)) return;
    const promises = [];
    for (const recoveryFile of this.recoveryFilesByWindow.get(window)) {
      promises.push(
        recoveryFile
          .recover()
          .catch(error => {
            const message = 'A file that Pulsar was saving could be corrupted';
            const detail =
              `Error ${error.code}. There was a crash while saving "${
                recoveryFile.originalPath
              }", so this file might be blank or corrupted.\n` +
              `Pulsar couldn't recover it automatically, but a recovery file has been saved at: "${
                recoveryFile.recoveryPath
              }".`;
            console.log(detail);
            dialog.showMessageBox(window, {
              type: 'info',
              buttons: ['OK'],
              message,
              detail
            });
          })
          .then(() => {
            for (let window of this.windowsByRecoveryFile.get(recoveryFile)) {
              this.recoveryFilesByWindow.get(window).delete(recoveryFile);
            }
            this.windowsByRecoveryFile.delete(recoveryFile);
            this.recoveryFilesByFilePath.delete(recoveryFile.originalPath);
          })
      );
    }
    await Promise.all(promises);
  }
  didCloseWindow(window) {
    if (!this.recoveryFilesByWindow.has(window)) return;
    for (let recoveryFile of this.recoveryFilesByWindow.get(window)) {
      this.windowsByRecoveryFile.get(recoveryFile).delete(window);
    }
    this.recoveryFilesByWindow.delete(window);
  }
};
class RecoveryFile {
  static fileNameForPath(path) {
    const extension = Path.extname(path);
    const basename = Path.basename(path, extension).substring(0, 34);
    const randomSuffix = crypto.randomBytes(3).toString('hex');
    return `${basename}-${randomSuffix}${extension}`;
  }
  constructor(originalPath, fileMode, recoveryPath) {
    this.originalPath = originalPath;
    this.fileMode = fileMode;
    this.recoveryPath = recoveryPath;
    this.refCount = 0;
  }
  async store() {
    await copyFile(this.originalPath, this.recoveryPath, this.fileMode);
  }
  async recover() {
    await copyFile(this.recoveryPath, this.originalPath, this.fileMode);
    await this.remove();
  }
  async remove() {
    return new Promise((resolve, reject) =>
      fs.unlink(this.recoveryPath, error =>
        error && error.code !== 'ENOENT' ? reject(error) : resolve()
      )
    );
  }
  async retain() {
    if (this.isReleased()) await this.store();
    this.refCount++;
  }
  async release() {
    this.refCount--;
    if (this.isReleased()) await this.remove();
  }
  isReleased() {
    return this.refCount === 0;
  }
}
async function tryStatFile(path) {
  return new Promise((resolve, reject) =>
    fs.stat(path, (error, result) => resolve(error == null && result))
  );
}
async function copyFile(source, destination, mode) {
  return new Promise((resolve, reject) => {
    fs.mkdir(Path.dirname(destination), {recursive:true}, error => {
      if (error) return reject(error);
      const readStream = fs.createReadStream(source);
      readStream.on('error', reject).once('open', () => {
        const writeStream = fs.createWriteStream(destination, { mode });
        writeStream
          .on('error', reject)
          .on('open', () => readStream.pipe(writeStream))
          .once('close', () => resolve());
      });
    });
  });
}

================
File: src/main-process/main.js
================
const startTime = Date.now();
const StartupTime = require('../startup-time');
StartupTime.setStartTime();
const path = require('path');
const fs = require('fs-plus');
const CSON = require('season');
const yargs = require('yargs');
const { app } = require('electron');
const args = yargs(process.argv)
  .help(false)
  .version(false)
  .alias('d', 'dev')
  .alias('t', 'test')
  .alias('r', 'resource-path').argv;
function isAtomRepoPath(repoPath) {
  let packageJsonPath = path.join(repoPath, 'package.json');
  if (fs.statSyncNoException(packageJsonPath)) {
    try {
      let packageJson = CSON.readFileSync(packageJsonPath);
      return packageJson.name === 'atom';
    } catch (e) {
      return false;
    }
  }
  return false;
}
let resourcePath;
let devResourcePath;
if (args.resourcePath) {
  resourcePath = args.resourcePath;
  devResourcePath = resourcePath;
} else {
  const stableResourcePath = path.dirname(path.dirname(__dirname));
  const defaultRepositoryPath = path.join(
    app.getPath('home'),
    'github',
    'pulsar'
  );
  if (process.env.ATOM_DEV_RESOURCE_PATH) {
    devResourcePath = process.env.ATOM_DEV_RESOURCE_PATH;
  } else if (isAtomRepoPath(process.cwd())) {
    devResourcePath = process.cwd();
  } else if (fs.statSyncNoException(defaultRepositoryPath)) {
    devResourcePath = defaultRepositoryPath;
  } else {
    devResourcePath = stableResourcePath;
  }
  if (args.dev || args.test) {
    resourcePath = devResourcePath;
  } else {
    resourcePath = stableResourcePath;
  }
}
const start = require(path.join(resourcePath, 'src', 'main-process', 'start'));
start(resourcePath, devResourcePath, startTime);

================
File: src/main-process/parse-command-line.js
================
'use strict';
const dedent = require('dedent');
const yargs = require('yargs');
const { app } = require('electron');
module.exports = function parseCommandLine(processArgs) {
  const filteredArgs = processArgs.filter(arg => !arg.startsWith('-psn_'));
  const options = yargs(filteredArgs).wrap(yargs.terminalWidth());
  const version = app.getVersion();
  options.usage(
    dedent`Pulsar Editor v${version}
    Usage:
      pulsar
      pulsar [options] [path ...]
      pulsar file[:line[:column]]
    One or more paths to files or folders may be specified. If there is an
    existing Pulsar window that contains all of the given folders, the paths
    will be opened in that window. Otherwise, they will be opened in a new
    window.
    A file may be opened at the desired line (and optionally column) by
    appending the numbers right after the file name, e.g. \`pulsar file:5:8\`.
    Paths that start with \`atom:
    Environment Variables:
      ATOM_DEV_RESOURCE_PATH  The path from which Pulsar loads source code in dev mode.
                              Defaults to \`~/github/atom\`.
      ATOM_HOME               The root path for all configuration files and folders.
                              Defaults to \`~/.pulsar\`.`
  );
  options
    .alias('d', 'dev')
    .boolean('d')
    .describe('d', 'Run in development mode.');
  options
    .alias('f', 'foreground')
    .boolean('f')
    .describe('f', 'Keep the main process in the foreground.');
  options.help(false)
  options
    .alias('h', 'help')
    .boolean('h')
    .describe('h', 'Print this usage message.')
  options
    .alias('l', 'log-file')
    .string('l')
    .describe('l', 'Log all output to file when running tests.');
  options
    .alias('n', 'new-window')
    .boolean('n')
    .describe('n', 'Open a new window.');
  options
    .boolean('profile-startup')
    .describe(
      'profile-startup',
      'Create a profile of the startup execution time.'
    );
  options
    .alias('r', 'resource-path')
    .string('r')
    .describe(
      'r',
      'Set the path to the Pulsar source directory and enable dev-mode.'
    );
  options
    .boolean('safe')
    .describe(
      'safe',
      'Do not load packages from ~/.pulsar/packages or ~/.pulsar/dev/packages.'
    );
  options
    .boolean('benchmark')
    .describe(
      'benchmark',
      'This option is no longer supported.'
    );
  options
    .boolean('benchmark-test')
    .describe(
      'benchmark-test',
      'This option is no longer supported.'
    );
  options
    .alias('t', 'test')
    .boolean('t')
    .describe(
      't',
      'Run the specified specs and exit with error code on failures.'
    );
  options
    .alias('m', 'main-process')
    .boolean('m')
    .describe('m', 'Run the specified specs in the main process.');
  options
    .string('timeout')
    .describe(
      'timeout',
      'When in test mode, waits until the specified time (in minutes) and kills the process (exit code: 130).'
    );
  options
    .alias('w', 'wait')
    .boolean('w')
    .describe('w', 'Wait for window to be closed before returning.');
  options
    .alias('a', 'add')
    .boolean('a')
    .describe('add', 'Open path as a new project in last used window.');
  options.string('user-data-dir');
  options
    .boolean('clear-window-state')
    .describe('clear-window-state', 'Delete all Pulsar environment state.');
  options
    .boolean('enable-electron-logging')
    .describe(
      'enable-electron-logging',
      'Enable low-level logging messages from Electron.'
    );
  options
    .alias('p', 'package')
    .boolean('p')
    .describe(
      'package',
      'Delegate all commands to Pulsar\'s package management. Run with --package for more details'
    );
  options.boolean('uri-handler');
  options
    .version(
      dedent`Pulsar  : ${version}
             Electron: ${process.versions.electron}
             Chrome  : ${process.versions.chrome}
             Node    : ${process.versions.node}`
    )
    .alias('v', 'version');
  // NB: if --help or --version are given, this also displays the relevant message and exits
  let args = options.argv;
  if (args['package']) {
    const PackageManager = require('../package-manager');
    const cp = require('child_process');
    const ppmPath = PackageManager.possibleApmPaths();
    let ppmArgs = [...processArgs]
    while(true) {
      const arg = ppmArgs.shift()
      if(arg === '-p' || arg === '--package' || ppmArgs.length === 0) break;
    }
    const exitCode = cp.spawnSync(ppmPath, ppmArgs, {stdio: 'inherit'}).status;
    process.exit(exitCode);
    return;
  }
  if (args['help']) {
    options.showHelp();
    process.exit(0);
    return;
  }
  // If --uri-handler is set, then we parse NOTHING else
  if (args.uriHandler) {
    args = {
      uriHandler: true,
      'uri-handler': true,
      _: args._.filter(str => str.startsWith('atom://')).slice(0, 1)
    };
  }
  const addToLastWindow = args['add'];
  const safeMode = args['safe'];
  const benchmark = args['benchmark'];
  const benchmarkTest = args['benchmark-test'];
  const test = args['test'];
  const mainProcess = args['main-process'];
  const timeout = args['timeout'];
  const newWindow = args['new-window'];
  let executedFrom = null;
  if (args['executed-from'] && args['executed-from'].toString()) {
    executedFrom = args['executed-from'].toString();
  } else {
    executedFrom = process.cwd();
  }
  if (newWindow && addToLastWindow) {
    process.stderr.write(
      `Only one of the --add and --new-window options may be specified at the same time.\n\n${options.help()}`
    );
    process.exit(0);
  }
  let pidToKillWhenClosed = null;
  if (args['wait']) {
    pidToKillWhenClosed = args['pid'];
  }
  const logFile = args['log-file'];
  const userDataDir = args['user-data-dir'];
  const profileStartup = args['profile-startup'];
  const clearWindowState = args['clear-window-state'];
  let pathsToOpen = [];
  let urlsToOpen = [];
  let devMode = args['dev'];
  for (const path of args._) {
    if (typeof path !== 'string') {
      continue;
    }
    if (path.startsWith('atom://')) {
      urlsToOpen.push(path);
    } else {
      pathsToOpen.push(path);
    }
  }
  if (args.resourcePath || test) {
    devMode = true;
  }
  if (args['path-environment']) {
    process.env.PATH = args['path-environment'];
  }
  return {
    pathsToOpen,
    urlsToOpen,
    executedFrom,
    test,
    version,
    pidToKillWhenClosed,
    devMode,
    safeMode,
    newWindow,
    logFile,
    userDataDir,
    profileStartup,
    timeout,
    clearWindowState,
    addToLastWindow,
    mainProcess,
    benchmark,
    benchmarkTest,
    env: process.env
  };
};

================
File: src/main-process/start.js
================
const { app } = require('electron');
const path = require('path');
const temp = require('temp');
const parseCommandLine = require('./parse-command-line');
const { getReleaseChannel, getConfigFilePath } = require('../get-app-details.js');
const atomPaths = require('../atom-paths');
const fs = require('fs');
const CSON = require('season');
const Config = require('../config');
const StartupTime = require('../startup-time');
StartupTime.setStartTime();
module.exports = function start(resourcePath, devResourcePath, startTime) {
  global.shellStartTime = startTime;
  StartupTime.addMarker('main-process:start');
  process.on('uncaughtException', function(error = {}) {
    if (error.message != null) {
      console.log(error.message);
    }
    if (error.stack != null) {
      console.log(error.stack);
    }
  });
  process.on('unhandledRejection', function(error = {}) {
    if (error.message != null) {
      console.log(error.message);
    }
    if (error.stack != null) {
      console.log(error.stack);
    }
  });
  app.allowRendererProcessReuse = false;
  app.commandLine.appendSwitch('enable-experimental-web-platform-features');
  const args = parseCommandLine(process.argv.slice(1));
  args.resourcePath = normalizeDriveLetterName(resourcePath);
  args.devResourcePath = normalizeDriveLetterName(devResourcePath);
  atomPaths.setAtomHome(app.getPath('home'));
  atomPaths.setUserData(app);
  const config = getConfig();
  const colorProfile = config.get('core.colorProfile');
  if (colorProfile && colorProfile !== 'default') {
    app.commandLine.appendSwitch('force-color-profile', colorProfile);
  }
  if (args.test && args.mainProcess) {
    app.setPath(
      'userData',
      temp.mkdirSync('atom-user-data-dir-for-main-process-tests')
    );
    app.on('ready', function() {
      const testRunner = require(path.join(
        args.resourcePath,
        'spec/main-process/mocha-test-runner'
      ));
      testRunner(args.pathsToOpen);
    });
    return;
  }
  const releaseChannel = getReleaseChannel(app.getVersion());
  let appUserModelId = 'dev.pulsar-edit.pulsar.' + process.arch;
  if (releaseChannel !== 'stable') {
    appUserModelId += `-${releaseChannel}`;
  }
  app.setAppUserModelId(appUserModelId);
  function addPathToOpen(event, pathToOpen) {
    event.preventDefault();
    args.pathsToOpen.push(pathToOpen);
  }
  function addUrlToOpen(event, urlToOpen) {
    event.preventDefault();
    args.urlsToOpen.push(urlToOpen);
  }
  app.on('open-file', addPathToOpen);
  app.on('open-url', addUrlToOpen);
  if (args.userDataDir != null) {
    app.setPath('userData', args.userDataDir);
  } else if (args.test) {
    app.setPath('userData', temp.mkdirSync('atom-test-data'));
  }
  StartupTime.addMarker('main-process:electron-onready:start');
  app.on('ready', function() {
    StartupTime.addMarker('main-process:electron-onready:end');
    app.removeListener('open-file', addPathToOpen);
    app.removeListener('open-url', addUrlToOpen);
    const AtomApplication = require(path.join(
      args.resourcePath,
      'src',
      'main-process',
      'atom-application'
    ));
    AtomApplication.open(args);
  });
};
function getConfig() {
  const config = new Config();
  let configFilePath = getConfigFilePath();
  if (configFilePath) {
    CSON.readFile(configFilePath, (error, data) => {
      if (error) {
        console.log(error.message);
      } else {
        config.resetUserSettings(data);
      }
    });
  }
  return config;
}
function normalizeDriveLetterName(filePath) {
  if (process.platform === 'win32' && filePath) {
    return filePath.replace(
      /^([a-z]):/,
      ([driveLetter]) => driveLetter.toUpperCase() + ':'
    );
  } else {
    return filePath;
  }
}

================
File: src/main-process/win-shell.js
================
const Registry = require('winreg');
const Path = require('path');
const { getAppName } = require('../get-app-details.js');
const appName = getAppName();
const exeName = Path.basename(process.execPath);
const appPath = `"${process.execPath}"`;
const fileIconPath = `"${Path.join(
  process.execPath,
  '..',
  'resources',
  'pulsar.ico'
)}"`;
class ShellOption {
  constructor(key, parts) {
    this.isRegistered = this.isRegistered.bind(this);
    this.register = this.register.bind(this);
    this.deregister = this.deregister.bind(this);
    this.update = this.update.bind(this);
    this.key = key;
    this.parts = parts;
  }
  isRegistered(callback) {
    new Registry({
      hive: 'HKCU',
      key: `${this.key}\\${this.parts[0].key}`
    }).get(this.parts[0].name, (err, val) =>
      callback(err == null && val != null && val.value === this.parts[0].value)
    );
  }
  register(callback) {
    let doneCount = this.parts.length;
    this.parts.forEach(part => {
      let reg = new Registry({
        hive: 'HKCU',
        key: part.key != null ? `${this.key}\\${part.key}` : this.key
      });
      return reg.create(() =>
        reg.set(part.name, Registry.REG_SZ, part.value, () => {
          if (--doneCount === 0) return callback();
        })
      );
    });
  }
  deregister(callback) {
    this.isRegistered(isRegistered => {
      if (isRegistered) {
        new Registry({ hive: 'HKCU', key: this.key }).destroy(() =>
          callback(null, true)
        );
      } else {
        callback(null, false);
      }
    });
  }
  update(callback) {
    new Registry({
      hive: 'HKCU',
      key: `${this.key}\\${this.parts[0].key}`
    }).get(this.parts[0].name, (err, val) => {
      if (err != null || val == null) {
        callback(err);
      } else {
        this.register(callback);
      }
    });
  }
}
exports.appName = appName;
exports.fileHandler = new ShellOption(
  `\\Software\\Classes\\Applications\\${exeName}`,
  [
    { key: 'shell\\open\\command', name: '', value: `${appPath} "%1"` },
    { key: 'shell\\open', name: 'FriendlyAppName', value: `${appName}` },
    { key: 'DefaultIcon', name: '', value: `${fileIconPath}` }
  ]
);
let contextParts = [
  { key: 'command', name: '', value: `${appPath} "%1"` },
  { name: '', value: `Open with ${appName}` },
  { name: 'Icon', value: `${appPath}` }
];
exports.fileContextMenu = new ShellOption(
  `\\Software\\Classes\\*\\shell\\${appName}`,
  contextParts
);
exports.folderContextMenu = new ShellOption(
  `\\Software\\Classes\\Directory\\shell\\${appName}`,
  contextParts
);
exports.folderBackgroundContextMenu = new ShellOption(
  `\\Software\\Classes\\Directory\\background\\shell\\${appName}`,
  JSON.parse(JSON.stringify(contextParts).replace('%1', '%V'))
);

================
File: src/application-delegate.js
================
const { ipcRenderer, remote, shell } = require('electron');
const ipcHelpers = require('./ipc-helpers');
const { Emitter, Disposable } = require('event-kit');
const getWindowLoadSettings = require('./get-window-load-settings');
module.exports = class ApplicationDelegate {
  constructor() {
    this.pendingSettingsUpdateCount = 0;
    this._ipcMessageEmitter = null;
  }
  ipcMessageEmitter() {
    if (!this._ipcMessageEmitter) {
      this._ipcMessageEmitter = new Emitter();
      ipcRenderer.on('message', (event, message, detail) => {
        this._ipcMessageEmitter.emit(message, detail);
      });
    }
    return this._ipcMessageEmitter;
  }
  getWindowLoadSettings() {
    return getWindowLoadSettings();
  }
  open(params) {
    return ipcRenderer.send('open', params);
  }
  setWindowTheme(params) {
    return ipcRenderer.send('setWindowTheme', params);
  }
  pickFolder(callback) {
    const responseChannel = 'atom-pick-folder-response';
    ipcRenderer.on(responseChannel, function(event, path) {
      ipcRenderer.removeAllListeners(responseChannel);
      return callback(path);
    });
    return ipcRenderer.send('pick-folder', responseChannel);
  }
  getCurrentWindow() {
    return remote.getCurrentWindow();
  }
  closeWindow() {
    return ipcHelpers.call('window-method', 'close');
  }
  async getTemporaryWindowState() {
    const stateJSON = await ipcHelpers.call('get-temporary-window-state');
    return stateJSON && JSON.parse(stateJSON);
  }
  setTemporaryWindowState(state) {
    return ipcHelpers.call('set-temporary-window-state', JSON.stringify(state));
  }
  getWindowSize() {
    const [width, height] = Array.from(remote.getCurrentWindow().getSize());
    return { width, height };
  }
  setWindowSize(width, height) {
    return ipcHelpers.call('set-window-size', width, height);
  }
  getWindowPosition() {
    const [x, y] = Array.from(remote.getCurrentWindow().getPosition());
    return { x, y };
  }
  setWindowPosition(x, y) {
    return ipcHelpers.call('set-window-position', x, y);
  }
  centerWindow() {
    return ipcHelpers.call('center-window');
  }
  focusWindow() {
    return ipcHelpers.call('focus-window');
  }
  showWindow() {
    return ipcHelpers.call('show-window');
  }
  hideWindow() {
    return ipcHelpers.call('hide-window');
  }
  reloadWindow() {
    return ipcHelpers.call('window-method', 'reload');
  }
  restartApplication() {
    return ipcRenderer.send('restart-application');
  }
  minimizeWindow() {
    return ipcHelpers.call('window-method', 'minimize');
  }
  isWindowMaximized() {
    return remote.getCurrentWindow().isMaximized();
  }
  maximizeWindow() {
    return ipcHelpers.call('window-method', 'maximize');
  }
  unmaximizeWindow() {
    return ipcHelpers.call('window-method', 'unmaximize');
  }
  isWindowFullScreen() {
    return remote.getCurrentWindow().isFullScreen();
  }
  setWindowFullScreen(fullScreen = false) {
    return ipcHelpers.call('window-method', 'setFullScreen', fullScreen);
  }
  onDidEnterFullScreen(callback) {
    return ipcHelpers.on(ipcRenderer, 'did-enter-full-screen', callback);
  }
  onDidLeaveFullScreen(callback) {
    return ipcHelpers.on(ipcRenderer, 'did-leave-full-screen', callback);
  }
  async openWindowDevTools() {
    await new Promise(process.nextTick);
    return ipcHelpers.call('window-method', 'openDevTools');
  }
  async closeWindowDevTools() {
    await new Promise(process.nextTick);
    return ipcHelpers.call('window-method', 'closeDevTools');
  }
  async toggleWindowDevTools() {
    await new Promise(process.nextTick);
    return ipcHelpers.call('window-method', 'toggleDevTools');
  }
  executeJavaScriptInWindowDevTools(code) {
    return ipcRenderer.send('execute-javascript-in-dev-tools', code);
  }
  didClosePathWithWaitSession(path) {
    return ipcHelpers.call(
      'window-method',
      'didClosePathWithWaitSession',
      path
    );
  }
  setWindowDocumentEdited(edited) {
    return ipcHelpers.call('window-method', 'setDocumentEdited', edited);
  }
  setRepresentedFilename(filename) {
    return ipcHelpers.call('window-method', 'setRepresentedFilename', filename);
  }
  addRecentDocument(filename) {
    return ipcRenderer.send('add-recent-document', filename);
  }
  setProjectRoots(paths) {
    return ipcHelpers.call('window-method', 'setProjectRoots', paths);
  }
  setAutoHideWindowMenuBar(autoHide) {
    return ipcHelpers.call('window-method', 'setAutoHideMenuBar', autoHide);
  }
  setWindowMenuBarVisibility(visible) {
    return remote.getCurrentWindow().setMenuBarVisibility(visible);
  }
  getPrimaryDisplayWorkAreaSize() {
    return remote.screen.getPrimaryDisplay().workAreaSize;
  }
  getUserDefault(key, type) {
    return remote.systemPreferences.getUserDefault(key, type);
  }
  async setUserSettings(config, configFilePath) {
    this.pendingSettingsUpdateCount++;
    try {
      await ipcHelpers.call(
        'set-user-settings',
        JSON.stringify(config),
        configFilePath
      );
    } finally {
      this.pendingSettingsUpdateCount--;
    }
  }
  onDidChangeUserSettings(callback) {
    return this.ipcMessageEmitter().on('did-change-user-settings', detail => {
      if (this.pendingSettingsUpdateCount === 0) callback(detail);
    });
  }
  onDidFailToReadUserSettings(callback) {
    return this.ipcMessageEmitter().on(
      'did-fail-to-read-user-setting',
      callback
    );
  }
  confirm(options, callback) {
    if (typeof callback === 'function') {
      options = Object.assign(
        { type: 'info', normalizeAccessKeys: true },
        options
      );
      remote.dialog
        .showMessageBox(remote.getCurrentWindow(), options)
        .then(result => {
          callback(result.response, result.checkboxChecked);
        });
    } else {
      let { message, detailedMessage, buttons } = options;
      let buttonLabels;
      if (!buttons) buttons = {};
      if (Array.isArray(buttons)) {
        buttonLabels = buttons;
      } else {
        buttonLabels = Object.keys(buttons);
      }
      const chosen = remote.dialog.showMessageBoxSync(
        remote.getCurrentWindow(),
        {
          type: 'info',
          message,
          detail: detailedMessage,
          buttons: buttonLabels,
          normalizeAccessKeys: true
        }
      );
      if (Array.isArray(buttons)) {
        return chosen;
      } else {
        const callback = buttons[buttonLabels[chosen]];
        if (typeof callback === 'function') return callback();
      }
    }
  }
  showMessageDialog(params) {}
  showSaveDialog(options, callback) {
    if (typeof callback === 'function') {
      this.getCurrentWindow().showSaveDialog(options, callback);
    } else {
      if (typeof options === 'string') {
        options = { defaultPath: options };
      }
      return this.getCurrentWindow().showSaveDialog(options);
    }
  }
  playBeepSound() {
    return shell.beep();
  }
  onDidOpenLocations(callback) {
    return this.ipcMessageEmitter().on('open-locations', callback);
  }
  onApplicationMenuCommand(handler) {
    const outerCallback = (event, ...args) => handler(...args);
    ipcRenderer.on('command', outerCallback);
    return new Disposable(() =>
      ipcRenderer.removeListener('command', outerCallback)
    );
  }
  onContextMenuCommand(handler) {
    const outerCallback = (event, ...args) => handler(...args);
    ipcRenderer.on('context-command', outerCallback);
    return new Disposable(() =>
      ipcRenderer.removeListener('context-command', outerCallback)
    );
  }
  onURIMessage(handler) {
    const outerCallback = (event, ...args) => handler(...args);
    ipcRenderer.on('uri-message', outerCallback);
    return new Disposable(() =>
      ipcRenderer.removeListener('uri-message', outerCallback)
    );
  }
  onDidRequestUnload(callback) {
    const outerCallback = async (event, message) => {
      const shouldUnload = await callback(event);
      ipcRenderer.send('did-prepare-to-unload', shouldUnload);
    };
    ipcRenderer.on('prepare-to-unload', outerCallback);
    return new Disposable(() =>
      ipcRenderer.removeListener('prepare-to-unload', outerCallback)
    );
  }
  onDidChangeHistoryManager(callback) {
    const outerCallback = (event, message) => callback(event);
    ipcRenderer.on('did-change-history-manager', outerCallback);
    return new Disposable(() =>
      ipcRenderer.removeListener('did-change-history-manager', outerCallback)
    );
  }
  didChangeHistoryManager() {
    return ipcRenderer.send('did-change-history-manager');
  }
  openExternal(url) {
    return shell.openExternal(url);
  }
  emitWillSavePath(path) {
    return ipcHelpers.call('will-save-path', path);
  }
  emitDidSavePath(path) {
    return ipcHelpers.call('did-save-path', path);
  }
  resolveProxy(requestId, url) {
    return ipcRenderer.send('resolve-proxy', requestId, url);
  }
  onDidResolveProxy(callback) {
    const outerCallback = (event, requestId, proxy) =>
      callback(requestId, proxy);
    ipcRenderer.on('did-resolve-proxy', outerCallback);
    return new Disposable(() =>
      ipcRenderer.removeListener('did-resolve-proxy', outerCallback)
    );
  }
};

================
File: src/atom-environment.js
================
const crypto = require('crypto');
const path = require('path');
const util = require('util');
const { ipcRenderer } = require('electron');
const _ = require('underscore-plus');
const { deprecate } = require('grim');
const { CompositeDisposable, Disposable, Emitter } = require('event-kit');
const fs = require('fs-plus');
const { mapSourcePosition } = require('@atom/source-map-support');
const semver = require("semver");
const WindowEventHandler = require('./window-event-handler');
const StateStore = require('./state-store');
const registerDefaultCommands = require('./register-default-commands');
const { updateProcessEnv } = require('./update-process-env');
const ConfigSchema = require('./config-schema');
const DeserializerManager = require('./deserializer-manager');
const ViewRegistry = require('./view-registry');
const NotificationManager = require('./notification-manager');
const Config = require('./config');
const KeymapManager = require('./keymap-extensions');
const TooltipManager = require('./tooltip-manager');
const CommandRegistry = require('./command-registry');
const URIHandlerRegistry = require('./uri-handler-registry');
const GrammarRegistry = require('./grammar-registry');
const { HistoryManager } = require('./history-manager');
const ReopenProjectMenuManager = require('./reopen-project-menu-manager');
const StyleManager = require('./style-manager');
const PackageManager = require('./package-manager');
const ThemeManager = require('./theme-manager');
const MenuManager = require('./menu-manager');
const ContextMenuManager = require('./context-menu-manager');
const CommandInstaller = require('./command-installer');
const CoreURIHandlers = require('./core-uri-handlers');
const ProtocolHandlerInstaller = require('./protocol-handler-installer');
const Project = require('./project');
const TitleBar = require('./title-bar');
const Workspace = require('./workspace');
const PaneContainer = require('./pane-container');
const PaneAxis = require('./pane-axis');
const Pane = require('./pane');
const Dock = require('./dock');
const TextEditor = require('./text-editor');
const TextBuffer = require('text-buffer');
const TextEditorRegistry = require('./text-editor-registry');
const StartupTime = require('./startup-time');
const { getReleaseChannel } = require('./get-app-details.js');
const UI = require('./ui.js');
const packagejson = require("../package.json");
const stat = util.promisify(fs.stat);
let nextId = 0;
class AtomEnvironment {
  constructor(params = {}) {
    this.id = params.id != null ? params.id : nextId++;
    this.clipboard = params.clipboard;
    this.updateProcessEnv = params.updateProcessEnv || updateProcessEnv;
    this.enablePersistence = params.enablePersistence;
    this.applicationDelegate = params.applicationDelegate;
    this.nextProxyRequestId = 0;
    this.unloading = false;
    this.loadTime = null;
    this.emitter = new Emitter();
    this.disposables = new CompositeDisposable();
    this.pathsWithWaitSessions = new Set();
    this.deserializers = new DeserializerManager(this);
    this.deserializeTimings = {};
    this.views = new ViewRegistry(this);
    this.notifications = new NotificationManager();
    this.stateStore = new StateStore('AtomEnvironments', 1);
    this.config = new Config({
      saveCallback: settings => {
        if (this.enablePersistence) {
          this.applicationDelegate.setUserSettings(
            settings,
            this.config.getUserConfigPath()
          );
        }
      }
    });
    this.config.setSchema(null, {
      type: 'object',
      properties: _.clone(ConfigSchema)
    });
    this.keymaps = new KeymapManager({
      notificationManager: this.notifications
    });
    this.tooltips = new TooltipManager({
      keymapManager: this.keymaps,
      viewRegistry: this.views
    });
    this.commands = new CommandRegistry();
    this.uriHandlerRegistry = new URIHandlerRegistry();
    this.grammars = new GrammarRegistry({ config: this.config });
    this.styles = new StyleManager();
    this.packages = new PackageManager({
      config: this.config,
      styleManager: this.styles,
      commandRegistry: this.commands,
      keymapManager: this.keymaps,
      notificationManager: this.notifications,
      grammarRegistry: this.grammars,
      deserializerManager: this.deserializers,
      viewRegistry: this.views,
      uriHandlerRegistry: this.uriHandlerRegistry
    });
    this.themes = new ThemeManager({
      packageManager: this.packages,
      config: this.config,
      styleManager: this.styles,
      notificationManager: this.notifications,
      viewRegistry: this.views,
      applicationDelegate: this.applicationDelegate
    });
    this.menu = new MenuManager({
      keymapManager: this.keymaps,
      packageManager: this.packages
    });
    this.contextMenu = new ContextMenuManager({ keymapManager: this.keymaps });
    this.packages.setMenuManager(this.menu);
    this.packages.setContextMenuManager(this.contextMenu);
    this.packages.setThemeManager(this.themes);
    this.project = new Project({
      notificationManager: this.notifications,
      packageManager: this.packages,
      grammarRegistry: this.grammars,
      config: this.config,
      applicationDelegate: this.applicationDelegate
    });
    this.commandInstaller = new CommandInstaller(this.applicationDelegate);
    this.protocolHandlerInstaller = new ProtocolHandlerInstaller();
    this.textEditors = new TextEditorRegistry({
      config: this.config,
      grammarRegistry: this.grammars,
      assert: this.assert.bind(this),
      packageManager: this.packages
    });
    this.workspace = new Workspace({
      config: this.config,
      project: this.project,
      packageManager: this.packages,
      grammarRegistry: this.grammars,
      deserializerManager: this.deserializers,
      notificationManager: this.notifications,
      applicationDelegate: this.applicationDelegate,
      viewRegistry: this.views,
      assert: this.assert.bind(this),
      textEditorRegistry: this.textEditors,
      styleManager: this.styles,
      enablePersistence: this.enablePersistence
    });
    this.themes.workspace = this.workspace;
    if (this.keymaps.canLoadBundledKeymapsFromMemory()) {
      this.keymaps.loadBundledKeymaps();
    }
    this.registerDefaultCommands();
    this.registerDefaultOpeners();
    this.registerDefaultDeserializers();
    this.windowEventHandler = new WindowEventHandler({
      atomEnvironment: this,
      applicationDelegate: this.applicationDelegate
    });
    this.history = new HistoryManager({
      project: this.project,
      commands: this.commands,
      stateStore: this.stateStore
    });
    this.branding = {
      id: packagejson.branding.id,
      name: packagejson.branding.name,
      urlWeb: packagejson.branding.urlWeb,
      urlGH: packagejson.branding.urlGH,
      urlForum: packagejson.branding.urlForum,
      urlCoreRepo: packagejson.repository.url
    };
    this.ui = UI;
    this.disposables.add(
      this.history.onDidChangeProjects(event => {
        if (!event.reloaded) this.applicationDelegate.didChangeHistoryManager();
      })
    );
  }
  initialize(params = {}) {
    require('./text-editor-element');
    this.window = params.window;
    this.document = params.document;
    this.blobStore = params.blobStore;
    this.configDirPath = params.configDirPath;
    const {
      devMode,
      safeMode,
      resourcePath,
      userSettings,
      projectSpecification
    } = this.getLoadSettings();
    ConfigSchema.projectHome = {
      type: 'string',
      default: path.join(fs.getHomeDirectory(), 'github'),
      description:
        'The directory where projects are assumed to be located. Packages created using the Package Generator will be stored here by default.'
    };
    this.config.initialize({
      mainSource:
        this.enablePersistence && path.join(this.configDirPath, 'config.cson'),
      projectHomeSchema: ConfigSchema.projectHome
    });
    this.config.resetUserSettings(userSettings);
    if (projectSpecification != null && projectSpecification.config != null) {
      this.project.replace(projectSpecification);
    }
    this.menu.initialize({ resourcePath });
    this.contextMenu.initialize({ resourcePath, devMode });
    this.keymaps.configDirPath = this.configDirPath;
    this.keymaps.resourcePath = resourcePath;
    this.keymaps.devMode = devMode;
    if (!this.keymaps.canLoadBundledKeymapsFromMemory()) {
      this.keymaps.loadBundledKeymaps();
    }
    this.commands.attach(this.window);
    this.styles.initialize({ configDirPath: this.configDirPath });
    this.packages.initialize({
      devMode,
      configDirPath: this.configDirPath,
      resourcePath,
      safeMode
    });
    this.themes.initialize({
      configDirPath: this.configDirPath,
      resourcePath,
      safeMode,
      devMode
    });
    this.commandInstaller.initialize(this.getVersion());
    this.uriHandlerRegistry.registerHostHandler(
      'core',
      CoreURIHandlers.create(this)
    );
    this.protocolHandlerInstaller.initialize(this.config, this.notifications);
    this.themes.loadBaseStylesheets();
    this.initialStyleElements = this.styles.getSnapshot();
    if (params.onlyLoadBaseStyleSheets) this.themes.initialLoadComplete = true;
    this.setBodyPlatformClass();
    this.stylesElement = this.styles.buildStylesElement();
    this.document.head.appendChild(this.stylesElement);
    this.keymaps.subscribeToFileReadFailure();
    this.installUncaughtErrorHandler();
    this.attachSaveStateListeners();
    this.windowEventHandler.initialize(this.window, this.document);
    this.workspace.initialize();
    const didChangeStyles = this.didChangeStyles.bind(this);
    this.disposables.add(this.styles.onDidAddStyleElement(didChangeStyles));
    this.disposables.add(this.styles.onDidUpdateStyleElement(didChangeStyles));
    this.disposables.add(this.styles.onDidRemoveStyleElement(didChangeStyles));
    this.observeAutoHideMenuBar();
    this.disposables.add(
      this.applicationDelegate.onDidChangeHistoryManager(() =>
        this.history.loadState()
      )
    );
  }
  preloadPackages() {
    return this.packages.preloadPackages();
  }
  attachSaveStateListeners() {
    const saveState = _.debounce(() => {
      this.window.requestIdleCallback(() => {
        if (!this.unloading) this.saveState({ isUnloading: false });
      });
    }, this.saveStateDebounceInterval);
    this.document.addEventListener('mousedown', saveState, { capture: true });
    this.document.addEventListener('keydown', saveState, { capture: true });
    this.disposables.add(
      new Disposable(() => {
        this.document.removeEventListener('mousedown', saveState, {
          capture: true
        });
        this.document.removeEventListener('keydown', saveState, {
          capture: true
        });
      })
    );
  }
  registerDefaultDeserializers() {
    this.deserializers.add(Workspace);
    this.deserializers.add(PaneContainer);
    this.deserializers.add(PaneAxis);
    this.deserializers.add(Pane);
    this.deserializers.add(Dock);
    this.deserializers.add(Project);
    this.deserializers.add(TextEditor);
    this.deserializers.add(TextBuffer);
  }
  registerDefaultCommands() {
    registerDefaultCommands({
      commandRegistry: this.commands,
      config: this.config,
      commandInstaller: this.commandInstaller,
      notificationManager: this.notifications,
      project: this.project,
      clipboard: this.clipboard
    });
  }
  registerDefaultOpeners() {
    this.workspace.addOpener(uri => {
      switch (uri) {
        case 'atom://.pulsar/stylesheet':
          return this.workspace.openTextFile(
            this.styles.getUserStyleSheetPath()
          );
        case 'atom://.pulsar/keymap':
          return this.workspace.openTextFile(this.keymaps.getUserKeymapPath());
        case 'atom://.pulsar/config':
          return this.workspace.openTextFile(this.config.getUserConfigPath());
        case 'atom://.pulsar/init-script':
          return this.workspace.openTextFile(this.getUserInitScriptPath());
      }
    });
  }
  registerDefaultTargetForKeymaps() {
    this.keymaps.defaultTarget = this.workspace.getElement();
  }
  observeAutoHideMenuBar() {
    this.disposables.add(
      this.config.onDidChange('core.autoHideMenuBar', ({ newValue }) => {
        this.setAutoHideMenuBar(newValue);
      })
    );
    if (this.config.get('core.autoHideMenuBar')) this.setAutoHideMenuBar(true);
  }
  async reset() {
    this.deserializers.clear();
    this.registerDefaultDeserializers();
    this.config.clear();
    this.config.setSchema(null, {
      type: 'object',
      properties: _.clone(ConfigSchema)
    });
    this.keymaps.clear();
    this.keymaps.loadBundledKeymaps();
    this.commands.clear();
    this.registerDefaultCommands();
    this.styles.restoreSnapshot(this.initialStyleElements);
    this.menu.clear();
    this.clipboard.reset();
    this.notifications.clear();
    this.contextMenu.clear();
    await this.packages.reset();
    this.workspace.reset(this.packages);
    this.registerDefaultOpeners();
    this.project.reset(this.packages);
    this.workspace.initialize();
    this.grammars.clear();
    this.textEditors.clear();
    this.views.clear();
    this.pathsWithWaitSessions.clear();
  }
  destroy() {
    if (!this.project) return;
    this.disposables.dispose();
    if (this.workspace) this.workspace.destroy();
    this.workspace = null;
    this.themes.workspace = null;
    if (this.project) this.project.destroy();
    this.project = null;
    this.commands.clear();
    if (this.stylesElement) this.stylesElement.remove();
    this.uriHandlerRegistry.destroy();
    this.uninstallWindowEventHandler();
  }
  onDidBeep(callback) {
    return this.emitter.on('did-beep', callback);
  }
  onWillThrowError(callback) {
    return this.emitter.on('will-throw-error', callback);
  }
  onDidThrowError(callback) {
    return this.emitter.on('did-throw-error', callback);
  }
  onDidFailAssertion(callback) {
    return this.emitter.on('did-fail-assertion', callback);
  }
  whenShellEnvironmentLoaded(callback) {
    if (this.shellEnvironmentLoaded) {
      callback();
      return new Disposable();
    } else {
      return this.emitter.once('loaded-shell-environment', callback);
    }
  }
  inDevMode() {
    if (this.devMode == null) this.devMode = this.getLoadSettings().devMode;
    return this.devMode;
  }
  inSafeMode() {
    if (this.safeMode == null) this.safeMode = this.getLoadSettings().safeMode;
    return this.safeMode;
  }
  inSpecMode() {
    if (this.specMode == null) this.specMode = this.getLoadSettings().isSpec;
    return this.specMode;
  }
  isFirstLoad() {
    if (this.firstLoad == null)
      this.firstLoad = this.getLoadSettings().firstLoad;
    return this.firstLoad;
  }
  getAppName() {
    if (this.appName == null) this.appName = this.getLoadSettings().appName;
    return this.appName;
  }
  getVersion() {
    if (this.appVersion == null)
      this.appVersion = this.getLoadSettings().appVersion;
    return this.appVersion;
  }
  versionSatisfies(value) {
    return semver.satisfies(this.getVersion(), value);
  }
  getReleaseChannel() {
    return getReleaseChannel(this.getVersion());
  }
  isReleasedVersion() {
    return this.getReleaseChannel().match(/stable|beta|nightly/) != null;
  }
  getWindowLoadTime() {
    return this.loadTime;
  }
  getStartupMarkers() {
    const data = StartupTime.exportData();
    return data ? data.markers : [];
  }
  getLoadSettings() {
    return this.applicationDelegate.getWindowLoadSettings();
  }
  open(params) {
    return this.applicationDelegate.open(params);
  }
  pickFolder(callback) {
    return this.applicationDelegate.pickFolder(callback);
  }
  close() {
    return this.applicationDelegate.closeWindow();
  }
  getSize() {
    return this.applicationDelegate.getWindowSize();
  }
  setSize(width, height) {
    return this.applicationDelegate.setWindowSize(width, height);
  }
  getPosition() {
    return this.applicationDelegate.getWindowPosition();
  }
  setPosition(x, y) {
    return this.applicationDelegate.setWindowPosition(x, y);
  }
  getCurrentWindow() {
    return this.applicationDelegate.getCurrentWindow();
  }
  center() {
    return this.applicationDelegate.centerWindow();
  }
  focus() {
    this.applicationDelegate.focusWindow();
    return this.window.focus();
  }
  show() {
    return this.applicationDelegate.showWindow();
  }
  hide() {
    return this.applicationDelegate.hideWindow();
  }
  reload() {
    return this.applicationDelegate.reloadWindow();
  }
  restartApplication() {
    return this.applicationDelegate.restartApplication();
  }
  isMaximized() {
    return this.applicationDelegate.isWindowMaximized();
  }
  maximize() {
    return this.applicationDelegate.maximizeWindow();
  }
  isFullScreen() {
    return this.applicationDelegate.isWindowFullScreen();
  }
  setFullScreen(fullScreen = false) {
    return this.applicationDelegate.setWindowFullScreen(fullScreen);
  }
  toggleFullScreen() {
    return this.setFullScreen(!this.isFullScreen());
  }
  async displayWindow() {
    await this.restoreWindowDimensions();
    const steps = [this.restoreWindowBackground(), this.show(), this.focus()];
    if (this.windowDimensions && this.windowDimensions.fullScreen) {
      steps.push(this.setFullScreen(true));
    }
    if (
      this.windowDimensions &&
      this.windowDimensions.maximized &&
      process.platform !== 'darwin'
    ) {
      steps.push(this.maximize());
    }
    await Promise.all(steps);
  }
  getWindowDimensions() {
    const browserWindow = this.getCurrentWindow();
    const [x, y] = browserWindow.getPosition();
    const [width, height] = browserWindow.getSize();
    const maximized = browserWindow.isMaximized();
    return { x, y, width, height, maximized };
  }
  setWindowDimensions({ x, y, width, height }) {
    const steps = [];
    if (width != null && height != null) {
      steps.push(this.setSize(width, height));
    }
    if (x != null && y != null) {
      steps.push(this.setPosition(x, y));
    } else {
      steps.push(this.center());
    }
    return Promise.all(steps);
  }
  isValidDimensions({ x, y, width, height } = {}) {
    return width > 0 && height > 0 && x + width > 0 && y + height > 0;
  }
  storeWindowDimensions() {
    this.windowDimensions = this.getWindowDimensions();
    if (this.isValidDimensions(this.windowDimensions)) {
      localStorage.setItem(
        'defaultWindowDimensions',
        JSON.stringify(this.windowDimensions)
      );
    }
  }
  getDefaultWindowDimensions() {
    const { windowDimensions } = this.getLoadSettings();
    if (windowDimensions) return windowDimensions;
    let dimensions;
    try {
      dimensions = JSON.parse(localStorage.getItem('defaultWindowDimensions'));
    } catch (error) {
      console.warn('Error parsing default window dimensions', error);
      localStorage.removeItem('defaultWindowDimensions');
    }
    if (dimensions && this.isValidDimensions(dimensions)) {
      return dimensions;
    } else {
      const {
        width,
        height
      } = this.applicationDelegate.getPrimaryDisplayWorkAreaSize();
      return { x: 0, y: 0, width: Math.min(1024, width), height };
    }
  }
  async restoreWindowDimensions() {
    if (
      !this.windowDimensions ||
      !this.isValidDimensions(this.windowDimensions)
    ) {
      this.windowDimensions = this.getDefaultWindowDimensions();
    }
    await this.setWindowDimensions(this.windowDimensions);
    return this.windowDimensions;
  }
  restoreWindowBackground() {
    const backgroundColor = window.localStorage.getItem(
      'atom:window-background-color'
    );
    if (backgroundColor) {
      this.backgroundStylesheet = document.createElement('style');
      this.backgroundStylesheet.type = 'text/css';
      this.backgroundStylesheet.innerText = `html, body { background: ${backgroundColor} !important; }`;
      document.head.appendChild(this.backgroundStylesheet);
    }
  }
  storeWindowBackground() {
    if (this.inSpecMode()) return;
    const backgroundColor = this.window.getComputedStyle(
      this.workspace.getElement()
    )['background-color'];
    this.window.localStorage.setItem(
      'atom:window-background-color',
      backgroundColor
    );
  }
  async startEditorWindow() {
    StartupTime.addMarker('window:environment:start-editor-window:start');
    if (this.getLoadSettings().clearWindowState) {
      await this.stateStore.clear();
    }
    this.unloading = false;
    const updateProcessEnvPromise = this.updateProcessEnvAndTriggerHooks();
    const loadStatePromise = this.loadState().then(async state => {
      this.windowDimensions = state && state.windowDimensions;
      if (!this.getLoadSettings().headless) {
        StartupTime.addMarker(
          'window:environment:start-editor-window:display-window'
        );
        await this.displayWindow();
      }
      this.commandInstaller.installAtomCommand(false, error => {
        if (error) console.warn(error.message);
      });
      this.commandInstaller.installApmCommand(false, error => {
        if (error) console.warn(error.message);
      });
      this.disposables.add(
        this.applicationDelegate.onDidChangeUserSettings(settings =>
          this.config.resetUserSettings(settings)
        )
      );
      this.disposables.add(
        this.applicationDelegate.onDidFailToReadUserSettings(message =>
          this.notifications.addError(message)
        )
      );
      this.disposables.add(
        this.applicationDelegate.onDidOpenLocations(
          this.openLocations.bind(this)
        )
      );
      this.disposables.add(
        this.applicationDelegate.onApplicationMenuCommand(
          this.dispatchApplicationMenuCommand.bind(this)
        )
      );
      this.disposables.add(
        this.applicationDelegate.onContextMenuCommand(
          this.dispatchContextMenuCommand.bind(this)
        )
      );
      this.disposables.add(
        this.applicationDelegate.onURIMessage(
          this.dispatchURIMessage.bind(this)
        )
      );
      this.disposables.add(
        this.applicationDelegate.onDidRequestUnload(
          this.prepareToUnloadEditorWindow.bind(this)
        )
      );
      this.registerDefaultTargetForKeymaps();
      StartupTime.addMarker(
        'window:environment:start-editor-window:load-packages'
      );
      this.packages.loadPackages();
      const startTime = Date.now();
      StartupTime.addMarker(
        'window:environment:start-editor-window:deserialize-state'
      );
      await this.deserialize(state);
      this.deserializeTimings.atom = Date.now() - startTime;
      if (
        process.platform === 'darwin' &&
        this.config.get('core.titleBar') === 'custom'
      ) {
        this.workspace.addHeaderPanel({
          item: new TitleBar({
            workspace: this.workspace,
            themes: this.themes,
            applicationDelegate: this.applicationDelegate
          })
        });
        this.document.body.classList.add('custom-title-bar');
      }
      if (
        process.platform === 'darwin' &&
        this.config.get('core.titleBar') === 'custom-inset'
      ) {
        this.workspace.addHeaderPanel({
          item: new TitleBar({
            workspace: this.workspace,
            themes: this.themes,
            applicationDelegate: this.applicationDelegate
          })
        });
        this.document.body.classList.add('custom-inset-title-bar');
      }
      if (
        process.platform === 'darwin' &&
        this.config.get('core.titleBar') === 'hidden'
      ) {
        this.document.body.classList.add('hidden-title-bar');
      }
      this.document.body.appendChild(this.workspace.getElement());
      if (this.backgroundStylesheet) this.backgroundStylesheet.remove();
      let previousProjectPaths = this.project.getPaths();
      this.disposables.add(
        this.project.onDidChangePaths(newPaths => {
          for (let path of previousProjectPaths) {
            if (
              this.pathsWithWaitSessions.has(path) &&
              !newPaths.includes(path)
            ) {
              this.applicationDelegate.didClosePathWithWaitSession(path);
            }
          }
          previousProjectPaths = newPaths;
          this.applicationDelegate.setProjectRoots(newPaths);
        })
      );
      this.disposables.add(
        this.workspace.onDidDestroyPaneItem(({ item }) => {
          const path = item.getPath && item.getPath();
          if (this.pathsWithWaitSessions.has(path)) {
            this.applicationDelegate.didClosePathWithWaitSession(path);
          }
        })
      );
      StartupTime.addMarker(
        'window:environment:start-editor-window:activate-packages'
      );
      this.packages.activate();
      this.keymaps.loadUserKeymap();
      if (!this.getLoadSettings().safeMode) this.requireUserInitScript();
      this.menu.update();
      StartupTime.addMarker(
        'window:environment:start-editor-window:open-editor'
      );
      await this.openInitialEmptyEditorIfNecessary();
    });
    const loadHistoryPromise = this.history.loadState().then(() => {
      this.reopenProjectMenuManager = new ReopenProjectMenuManager({
        menu: this.menu,
        commands: this.commands,
        history: this.history,
        config: this.config,
        open: paths =>
          this.open({
            pathsToOpen: paths,
            safeMode: this.inSafeMode(),
            devMode: this.inDevMode()
          })
      });
      this.reopenProjectMenuManager.update();
    });
    const output = await Promise.all([
      loadStatePromise,
      loadHistoryPromise,
      updateProcessEnvPromise
    ]);
    StartupTime.addMarker('window:environment:start-editor-window:end');
    return output;
  }
  serialize(options) {
    return {
      version: this.constructor.version,
      project: this.project.serialize(options),
      workspace: this.workspace.serialize(),
      packageStates: this.packages.serialize(),
      grammars: this.grammars.serialize(),
      fullScreen: this.isFullScreen(),
      windowDimensions: this.windowDimensions
    };
  }
  async prepareToUnloadEditorWindow() {
    try {
      await this.saveState({ isUnloading: true });
    } catch (error) {
      console.error(error);
    }
    const closing =
      !this.workspace ||
      (await this.workspace.confirmClose({
        windowCloseRequested: true,
        projectHasPaths: this.project.getPaths().length > 0
      }));
    if (closing) {
      this.unloading = true;
      await this.packages.deactivatePackages();
    }
    return closing;
  }
  unloadEditorWindow() {
    if (!this.project) return;
    this.storeWindowBackground();
    this.saveBlobStoreSync();
  }
  saveBlobStoreSync() {
    if (this.enablePersistence) {
      this.blobStore.save();
    }
  }
  openInitialEmptyEditorIfNecessary() {
    if (!this.config.get('core.openEmptyEditorOnStart')) return;
    const { hasOpenFiles } = this.getLoadSettings();
    if (!hasOpenFiles && this.workspace.getPaneItems().length === 0) {
      return this.workspace.open(null, { pending: true });
    }
  }
  installUncaughtErrorHandler() {
    this.previousWindowErrorHandler = this.window.onerror;
    this.window.onerror = (message, url, line, column, originalError) => {
      const mapping = mapSourcePosition({ source: url, line, column });
      line = mapping.line;
      column = mapping.column;
      if (url === '<embedded>') url = mapping.source;
      const eventObject = { message, url, line, column, originalError };
      let openDevTools = true;
      eventObject.preventDefault = () => {
        openDevTools = false;
      };
      this.emitter.emit('will-throw-error', eventObject);
      if (openDevTools) {
        this.openDevTools().then(() =>
          this.executeJavaScriptInDevTools('DevToolsAPI.showPanel("console")')
        );
      }
      this.emitter.emit('did-throw-error', {
        message,
        url,
        line,
        column,
        originalError
      });
    };
  }
  uninstallUncaughtErrorHandler() {
    this.window.onerror = this.previousWindowErrorHandler;
  }
  installWindowEventHandler() {
    this.windowEventHandler = new WindowEventHandler({
      atomEnvironment: this,
      applicationDelegate: this.applicationDelegate
    });
    this.windowEventHandler.initialize(this.window, this.document);
  }
  uninstallWindowEventHandler() {
    if (this.windowEventHandler) {
      this.windowEventHandler.unsubscribe();
    }
    this.windowEventHandler = null;
  }
  didChangeStyles(styleElement) {
    TextEditor.didUpdateStyles();
    if (styleElement.textContent.indexOf('scrollbar') >= 0) {
      TextEditor.didUpdateScrollbarStyles();
    }
  }
  async updateProcessEnvAndTriggerHooks() {
    await this.updateProcessEnv(this.getLoadSettings().env);
    this.shellEnvironmentLoaded = true;
    this.emitter.emit('loaded-shell-environment');
    this.packages.triggerActivationHook('core:loaded-shell-environment');
  }
  beep() {
    if (this.config.get('core.audioBeep'))
      this.applicationDelegate.playBeepSound();
    this.emitter.emit('did-beep');
  }
  confirm(options = {}, callback) {
    if (callback) {
      this.applicationDelegate.confirm(options, callback);
    } else {
      return this.applicationDelegate.confirm(options);
    }
  }
  openDevTools() {
    return this.applicationDelegate.openWindowDevTools();
  }
  toggleDevTools() {
    return this.applicationDelegate.toggleWindowDevTools();
  }
  executeJavaScriptInDevTools(code) {
    return this.applicationDelegate.executeJavaScriptInWindowDevTools(code);
  }
  assert(condition, message, callbackOrMetadata) {
    if (condition) return true;
    const error = new Error(`Assertion failed: ${message}`);
    Error.captureStackTrace(error, this.assert);
    if (callbackOrMetadata) {
      if (typeof callbackOrMetadata === 'function') {
        callbackOrMetadata(error);
      } else {
        error.metadata = callbackOrMetadata;
      }
    }
    this.emitter.emit('did-fail-assertion', error);
    if (!this.isReleasedVersion()) throw error;
    return false;
  }
  loadThemes() {
    return this.themes.load();
  }
  setDocumentEdited(edited) {
    if (
      typeof this.applicationDelegate.setWindowDocumentEdited === 'function'
    ) {
      this.applicationDelegate.setWindowDocumentEdited(edited);
    }
  }
  setRepresentedFilename(filename) {
    if (
      typeof this.applicationDelegate.setWindowRepresentedFilename ===
      'function'
    ) {
      this.applicationDelegate.setWindowRepresentedFilename(filename);
    }
  }
  addProjectFolder() {
    return new Promise(resolve => {
      this.pickFolder(selectedPaths => {
        this.addToProject(selectedPaths || []).then(resolve);
      });
    });
  }
  async addToProject(projectPaths) {
    const state = await this.loadState(this.getStateKey(projectPaths));
    if (state && this.project.getPaths().length === 0) {
      this.attemptRestoreProjectStateForPaths(state, projectPaths);
    } else {
      projectPaths.map(folder => this.project.addPath(folder));
    }
  }
  async attemptRestoreProjectStateForPaths(
    state,
    projectPaths,
    filesToOpen = []
  ) {
    const center = this.workspace.getCenter();
    const windowIsUnused = () => {
      for (let container of this.workspace.getPaneContainers()) {
        for (let item of container.getPaneItems()) {
          if (item instanceof TextEditor) {
            if (item.getPath() || item.isModified()) return false;
          } else {
            if (container === center) return false;
          }
        }
      }
      return true;
    };
    if (windowIsUnused()) {
      await this.restoreStateIntoThisEnvironment(state);
      return Promise.all(filesToOpen.map(file => this.workspace.open(file)));
    } else {
      let resolveDiscardStatePromise = null;
      const discardStatePromise = new Promise(resolve => {
        resolveDiscardStatePromise = resolve;
      });
      const nouns = projectPaths.length === 1 ? 'folder' : 'folders';
      this.confirm(
        {
          message: 'Previous automatically-saved project state detected',
          detail:
            `There is previously saved state for the selected ${nouns}. ` +
            `Would you like to add the ${nouns} to this window, permanently discarding the saved state, ` +
            `or open the ${nouns} in a new window, restoring the saved state?`,
          buttons: [
            '&Open in new window and recover state',
            '&Add to this window and discard state'
          ]
        },
        response => {
          if (response === 0) {
            this.open({
              pathsToOpen: projectPaths.concat(filesToOpen),
              newWindow: true,
              devMode: this.inDevMode(),
              safeMode: this.inSafeMode()
            });
            resolveDiscardStatePromise(Promise.resolve(null));
          } else if (response === 1) {
            for (let selectedPath of projectPaths) {
              this.project.addPath(selectedPath);
            }
            resolveDiscardStatePromise(
              Promise.all(filesToOpen.map(file => this.workspace.open(file)))
            );
          }
        }
      );
      return discardStatePromise;
    }
  }
  restoreStateIntoThisEnvironment(state) {
    state.fullScreen = this.isFullScreen();
    for (let pane of this.workspace.getPanes()) {
      pane.destroy();
    }
    return this.deserialize(state);
  }
  showSaveDialogSync(options = {}) {
    deprecate(`atom.showSaveDialogSync is deprecated and will be removed soon.
Please, implement ::saveAs and ::getSaveDialogOptions instead for pane items
or use Pane::saveItemAs for programmatic saving.`);
    return this.applicationDelegate.showSaveDialog(options);
  }
  async saveState(options, storageKey) {
    if (this.enablePersistence && this.project) {
      const state = this.serialize(options);
      if (!storageKey)
        storageKey = this.getStateKey(this.project && this.project.getPaths());
      if (storageKey) {
        await this.stateStore.save(storageKey, state);
      } else {
        await this.applicationDelegate.setTemporaryWindowState(state);
      }
    }
  }
  loadState(stateKey) {
    if (this.enablePersistence) {
      if (!stateKey)
        stateKey = this.getStateKey(this.getLoadSettings().initialProjectRoots);
      if (stateKey) {
        return this.stateStore.load(stateKey);
      } else {
        return this.applicationDelegate.getTemporaryWindowState();
      }
    } else {
      return Promise.resolve(null);
    }
  }
  async deserialize(state) {
    if (!state) return Promise.resolve();
    this.setFullScreen(state.fullScreen);
    const missingProjectPaths = [];
    this.packages.packageStates = state.packageStates || {};
    let startTime = Date.now();
    if (state.project) {
      try {
        await this.project.deserialize(state.project, this.deserializers);
      } catch (error) {
        if (!error.missingProjectPaths) {
          this.notifications.addError('Unable to deserialize project', {
            description: error.message,
            stack: error.stack
          });
        }
      }
    }
    this.deserializeTimings.project = Date.now() - startTime;
    if (state.grammars) this.grammars.deserialize(state.grammars);
    startTime = Date.now();
    if (state.workspace)
      this.workspace.deserialize(state.workspace, this.deserializers);
    this.deserializeTimings.workspace = Date.now() - startTime;
    if (missingProjectPaths.length > 0) {
      const count =
        missingProjectPaths.length === 1
          ? ''
          : missingProjectPaths.length + ' ';
      const noun = missingProjectPaths.length === 1 ? 'folder' : 'folders';
      const toBe = missingProjectPaths.length === 1 ? 'is' : 'are';
      const escaped = missingProjectPaths.map(
        projectPath => `\`${projectPath}\``
      );
      let group;
      switch (escaped.length) {
        case 1:
          group = escaped[0];
          break;
        case 2:
          group = `${escaped[0]} and ${escaped[1]}`;
          break;
        default:
          group =
            escaped.slice(0, -1).join(', ') +
            `, and ${escaped[escaped.length - 1]}`;
      }
      this.notifications.addError(`Unable to open ${count}project ${noun}`, {
        description: `Project ${noun} ${group} ${toBe} no longer on disk.`
      });
    }
  }
  getStateKey(paths) {
    if (paths && paths.length > 0) {
      const sha1 = crypto
        .createHash('sha1')
        .update(
          paths
            .slice()
            .sort()
            .join('\n')
        )
        .digest('hex');
      return `editor-${sha1}`;
    } else {
      return null;
    }
  }
  getConfigDirPath() {
    if (!this.configDirPath) this.configDirPath = process.env.ATOM_HOME;
    return this.configDirPath;
  }
  getUserInitScriptPath() {
    const initScriptPath = fs.resolve(this.getConfigDirPath(), 'init', [
      'js',
      'coffee'
    ]);
    return initScriptPath || path.join(this.getConfigDirPath(), 'init.js');
  }
  requireUserInitScript() {
    const userInitScriptPath = this.getUserInitScriptPath();
    if (userInitScriptPath) {
      try {
        if (fs.isFileSync(userInitScriptPath)) require(userInitScriptPath);
      } catch (error) {
        this.notifications.addError(
          `Failed to load \`${userInitScriptPath}\``,
          {
            detail: error.message,
            dismissable: true
          }
        );
      }
    }
  }
  setBodyPlatformClass() {
    this.document.body.classList.add(`platform-${process.platform}`);
  }
  setAutoHideMenuBar(autoHide) {
    this.applicationDelegate.setAutoHideWindowMenuBar(autoHide);
    this.applicationDelegate.setWindowMenuBarVisibility(!autoHide);
  }
  dispatchApplicationMenuCommand(command, arg) {
    let { activeElement } = this.document;
    if (activeElement === this.document.body) {
      activeElement = this.workspace.getElement();
    }
    this.commands.dispatch(activeElement, command, arg);
  }
  dispatchContextMenuCommand(command, ...args) {
    this.commands.dispatch(this.contextMenu.activeElement, command, args);
  }
  dispatchURIMessage(uri) {
    if (this.packages.hasLoadedInitialPackages()) {
      this.uriHandlerRegistry.handleURI(uri);
    } else {
      let subscription = this.packages.onDidLoadInitialPackages(() => {
        subscription.dispose();
        this.uriHandlerRegistry.handleURI(uri);
      });
    }
  }
  async openLocations(locations) {
    const needsProjectPaths =
      this.project && this.project.getPaths().length === 0;
    const foldersToAddToProject = new Set();
    const fileLocationsToOpen = [];
    const missingFolders = [];
    const locationStats = await Promise.all(
      locations.map(async location => {
        const stats = location.pathToOpen
          ? await stat(location.pathToOpen).catch(() => null)
          : null;
        return { location, stats };
      })
    );
    for (const { location, stats } of locationStats) {
      const { pathToOpen } = location;
      if (!pathToOpen) {
        fileLocationsToOpen.push(location);
        continue;
      }
      if (stats !== null) {
        if (stats.isDirectory()) {
          foldersToAddToProject.add(
            this.project.getDirectoryForProjectPath(pathToOpen).getPath()
          );
        } else if (stats.isFile()) {
          if (location.isDirectory) {
            missingFolders.push(location);
          } else {
            fileLocationsToOpen.push(location);
          }
        }
      } else {
        const directory = this.project.getProvidedDirectoryForProjectPath(
          pathToOpen
        );
        if (directory) {
          foldersToAddToProject.add(directory.getPath());
        } else if (location.isDirectory) {
          missingFolders.push(location);
        } else {
          fileLocationsToOpen.push(location);
        }
      }
      if (location.hasWaitSession) this.pathsWithWaitSessions.add(pathToOpen);
    }
    let restoredState = false;
    if (foldersToAddToProject.size > 0 || missingFolders.length > 0) {
      const foldersForStateKey = Array.from(foldersToAddToProject).concat(
        missingFolders.map(location => location.pathToOpen)
      );
      const state = await this.loadState(
        this.getStateKey(Array.from(foldersForStateKey))
      );
      if (state && needsProjectPaths) {
        const files = fileLocationsToOpen.map(location => location.pathToOpen);
        await this.attemptRestoreProjectStateForPaths(
          state,
          Array.from(foldersToAddToProject),
          files
        );
        restoredState = true;
      } else {
        for (let folder of foldersToAddToProject) {
          this.project.addPath(folder);
        }
      }
    }
    if (!restoredState) {
      const fileOpenPromises = [];
      for (const {
        pathToOpen,
        initialLine,
        initialColumn
      } of fileLocationsToOpen) {
        fileOpenPromises.push(
          this.workspace &&
            this.workspace.open(pathToOpen, { initialLine, initialColumn })
        );
      }
      await Promise.all(fileOpenPromises);
    }
    if (missingFolders.length > 0) {
      let message = 'Unable to open project folder';
      if (missingFolders.length > 1) {
        message += 's';
      }
      let description = 'The ';
      if (missingFolders.length === 1) {
        description += 'directory `';
        description += missingFolders[0].pathToOpen;
        description += '` does not exist.';
      } else if (missingFolders.length === 2) {
        description += `directories \`${missingFolders[0].pathToOpen}\` `;
        description += `and \`${missingFolders[1].pathToOpen}\` do not exist.`;
      } else {
        description += 'directories ';
        description += missingFolders
          .slice(0, -1)
          .map(location => location.pathToOpen)
          .map(pathToOpen => '`' + pathToOpen + '`, ')
          .join('');
        description +=
          'and `' +
          missingFolders[missingFolders.length - 1].pathToOpen +
          '` do not exist.';
      }
      this.notifications.addWarning(message, { description });
    }
    ipcRenderer.send('window-command', 'window:locations-opened');
  }
  resolveProxy(url) {
    return new Promise((resolve, reject) => {
      const requestId = this.nextProxyRequestId++;
      const disposable = this.applicationDelegate.onDidResolveProxy(
        (id, proxy) => {
          if (id === requestId) {
            disposable.dispose();
            resolve(proxy);
          }
        }
      );
      return this.applicationDelegate.resolveProxy(requestId, url);
    });
  }
}
AtomEnvironment.version = 1;
AtomEnvironment.prototype.saveStateDebounceInterval = 1000;
module.exports = AtomEnvironment;
Promise.prototype.done = function (callback) {
  deprecate('Pulsar now uses ES6 Promises instead of Q. Call promise.then instead of promise.done')
  return this.then(callback)
}

================
File: src/atom-paths.js
================
const fs = require('fs-plus');
const path = require('path');
const hasWriteAccess = dir => {
  const testFilePath = path.join(dir, 'write.test');
  try {
    fs.writeFileSync(testFilePath, new Date().toISOString(), { flag: 'w+' });
    fs.unlinkSync(testFilePath);
    return true;
  } catch (err) {
    return false;
  }
};
const getAppDirectory = () => {
  switch (process.platform) {
    case 'darwin':
      return process.execPath.substring(
        0,
        process.execPath.indexOf('.app') + 4
      );
    case 'linux':
    case 'win32':
      return path.join(process.execPath, '..');
  }
};
module.exports = {
  setAtomHome: homePath => {
    const portableHomePath = path.join(getAppDirectory(), '..', '.pulsar');
    if (fs.existsSync(portableHomePath)) {
      if (hasWriteAccess(portableHomePath)) {
        process.env.ATOM_HOME = portableHomePath;
      } else {
        console.log(
          `Insufficient permission to portable Pulsar home "${portableHomePath}".`
        );
      }
    }
    if (process.env.ATOM_HOME !== undefined) {
      return;
    }
    process.env.ATOM_HOME = path.join(homePath, '.pulsar');
  },
  setUserData: app => {
    const electronUserDataPath = path.join(
      process.env.ATOM_HOME,
      'electronUserData'
    );
    if (fs.existsSync(electronUserDataPath)) {
      if (hasWriteAccess(electronUserDataPath)) {
        app.setPath('userData', electronUserDataPath);
      } else {
        console.log(
          `Insufficient permission to Electron user data "${electronUserDataPath}".`
        );
      }
    }
  },
  getAppDirectory: getAppDirectory
};

================
File: src/babel.config.js
================
let presets = [
  [
    'babel-preset-atomic',
    {
      keepModules: false,
      notStrictDirectiveTriggers: ['use babel'],
      notStrictCommentTriggers: ['@babel', '@flow', '* @babel', '* @flow']
    }
  ]
];
let plugins = [];
module.exports = {
  presets: presets,
  plugins: plugins,
  exclude: 'node_modules/**',
  sourceMap: 'inline'
};

================
File: src/babel.js
================
'use strict';
const crypto = require('crypto');
const path = require('path');
const defaultOptions = require('./babel.config.js');
const configFile = path.join(__dirname, './babel.config.js');
let babel = null;
let babelVersionDirectory = null;
const PREFIXES = [
  '/** @babel */',
  '"use babel"',
  "'use babel'",
  '/* @flow */',
  '// @flow'
];
const PREFIX_LENGTH = Math.max.apply(
  Math,
  PREFIXES.map(function(prefix) {
    return prefix.length;
  })
);
exports.shouldCompile = function(sourceCode) {
  const start = sourceCode.substr(0, PREFIX_LENGTH);
  return PREFIXES.some(function(prefix) {
    return start.indexOf(prefix) === 0;
  });
};
exports.getCachePath = function(sourceCode) {
  if (babelVersionDirectory == null) {
    const babelVersion = require('@babel/core/package.json').version;
    babelVersionDirectory = path.join(
      'js',
      'babel',
      createVersionAndOptionsDigest(babelVersion, defaultOptions)
    );
  }
  return path.join(
    babelVersionDirectory,
    crypto
      .createHash('sha1')
      .update(sourceCode, 'utf8')
      .digest('hex') + '.js'
  );
};
exports.compile = function(sourceCode, filePath) {
  if (!babel) {
    babel = require('@babel/core');
  }
  if (process.platform === 'win32') {
    filePath = 'file:///' + path.resolve(filePath).replace(/\\/g, '/');
  }
  return babel.transformSync(sourceCode, {
    filename: filePath,
    configFile
  }).code;
};
function createVersionAndOptionsDigest(version, options) {
  return crypto
    .createHash('sha1')
    .update('@babel/core', 'utf8')
    .update('\0', 'utf8')
    .update(version, 'utf8')
    .update('\0', 'utf8')
    .update(JSON.stringify(options), 'utf8')
    .digest('hex');
}

================
File: src/buffered-node-process.js
================
const BufferedProcess = require('./buffered-process');
module.exports = class BufferedNodeProcess extends BufferedProcess {
  constructor({ command, args, options = {}, stdout, stderr, exit }) {
    options.env = options.env || Object.create(process.env);
    options.env.ELECTRON_RUN_AS_NODE = 1;
    options.env.ELECTRON_NO_ATTACH_CONSOLE = 1;
    args = args ? args.slice() : [];
    args.unshift(command);
    args.unshift('--no-deprecation');
    super({
      command: process.execPath,
      args,
      options,
      stdout,
      stderr,
      exit
    });
  }
};

================
File: src/buffered-process.js
================
const _ = require('underscore-plus');
const ChildProcess = require('child_process');
const { Emitter } = require('event-kit');
const path = require('path');
module.exports = class BufferedProcess {
  constructor({
    command,
    args,
    options = {},
    stdout,
    stderr,
    exit,
    autoStart = true
  } = {}) {
    this.emitter = new Emitter();
    this.command = command;
    this.args = args;
    this.options = options;
    this.stdout = stdout;
    this.stderr = stderr;
    this.exit = exit;
    if (autoStart === true) {
      this.start();
    }
    this.killed = false;
  }
  start() {
    if (this.started === true) return;
    this.started = true;
    if (process.platform === 'win32' && this.options.shell === undefined) {
      this.spawnWithEscapedWindowsArgs(this.command, this.args, this.options);
    } else {
      this.spawn(this.command, this.args, this.options);
    }
    this.handleEvents(this.stdout, this.stderr, this.exit);
  }
  spawnWithEscapedWindowsArgs(command, args, options) {
    let cmdArgs = [];
    if (args) {
      cmdArgs = args
        .filter(arg => arg != null)
        .map(arg => {
          if (this.isExplorerCommand(command) && /^\/[a-zA-Z]+,.*$/.test(arg)) {
            return arg;
          } else {
            return `"${arg.toString().replace(/"/g, '\\"')}"`;
          }
        });
    }
    cmdArgs.unshift(
      /\s|&|\^|\(|\)|\||#/.test(command) ? `"${command}"` : command
    );
    const cmdOptions = _.clone(options);
    cmdOptions.windowsVerbatimArguments = true;
    this.spawn(
      this.getCmdPath(),
      ['/s', '/d', '/c', `"${cmdArgs.join(' ')}"`],
      cmdOptions
    );
  }
  onWillThrowError(callback) {
    return this.emitter.on('will-throw-error', callback);
  }
  bufferStream(stream, onLines, onDone) {
    stream.setEncoding('utf8');
    let buffered = '';
    stream.on('data', data => {
      if (this.killed) return;
      let bufferedLength = buffered.length;
      buffered += data;
      let lastNewlineIndex = data.lastIndexOf('\n');
      if (lastNewlineIndex !== -1) {
        let lineLength = lastNewlineIndex + bufferedLength + 1;
        onLines(buffered.substring(0, lineLength));
        buffered = buffered.substring(lineLength);
      }
    });
    stream.on('close', () => {
      if (this.killed) return;
      if (buffered.length > 0) onLines(buffered);
      onDone();
    });
  }
  killOnWindows() {
    if (!this.process) return;
    const parentPid = this.process.pid;
    const cmd = 'wmic';
    const args = [
      'process',
      'where',
      `(ParentProcessId=${parentPid})`,
      'get',
      'processid'
    ];
    let wmicProcess;
    try {
      wmicProcess = ChildProcess.spawn(cmd, args);
    } catch (spawnError) {
      this.killProcess();
      return;
    }
    wmicProcess.on('error', () => {});
    let output = '';
    wmicProcess.stdout.on('data', data => {
      output += data;
    });
    wmicProcess.stdout.on('close', () => {
      for (let pid of output.split(/\s+/)) {
        if (!/^\d{1,10}$/.test(pid)) continue;
        pid = parseInt(pid, 10);
        if (!pid || pid === parentPid) continue;
        try {
          process.kill(pid);
        } catch (error) {}
      }
      this.killProcess();
    });
  }
  killProcess() {
    if (this.process) this.process.kill();
    this.process = null;
  }
  isExplorerCommand(command) {
    if (command === 'explorer.exe' || command === 'explorer') {
      return true;
    } else if (process.env.SystemRoot) {
      return (
        command === path.join(process.env.SystemRoot, 'explorer.exe') ||
        command === path.join(process.env.SystemRoot, 'explorer')
      );
    } else {
      return false;
    }
  }
  getCmdPath() {
    if (process.env.comspec) {
      return process.env.comspec;
    } else if (process.env.SystemRoot) {
      return path.join(process.env.SystemRoot, 'System32', 'cmd.exe');
    } else {
      return 'cmd.exe';
    }
  }
  kill() {
    if (this.killed) return;
    this.killed = true;
    if (process.platform === 'win32') {
      this.killOnWindows();
    } else {
      this.killProcess();
    }
  }
  spawn(command, args, options) {
    try {
      this.process = ChildProcess.spawn(command, args, options);
    } catch (spawnError) {
      process.nextTick(() => this.handleError(spawnError));
    }
  }
  handleEvents(stdout, stderr, exit) {
    if (!this.process) return;
    const triggerExitCallback = () => {
      if (this.killed) return;
      if (
        stdoutClosed &&
        stderrClosed &&
        processExited &&
        typeof exit === 'function'
      ) {
        exit(exitCode);
      }
    };
    let stdoutClosed = true;
    let stderrClosed = true;
    let processExited = true;
    let exitCode = 0;
    if (stdout) {
      stdoutClosed = false;
      this.bufferStream(this.process.stdout, stdout, () => {
        stdoutClosed = true;
        triggerExitCallback();
      });
    }
    if (stderr) {
      stderrClosed = false;
      this.bufferStream(this.process.stderr, stderr, () => {
        stderrClosed = true;
        triggerExitCallback();
      });
    }
    if (exit) {
      processExited = false;
      this.process.on('exit', code => {
        exitCode = code;
        processExited = true;
        triggerExitCallback();
      });
    }
    this.process.on('error', error => {
      this.handleError(error);
    });
  }
  handleError(error) {
    let handled = false;
    const handle = () => {
      handled = true;
    };
    this.emitter.emit('will-throw-error', { error, handle });
    if (error.code === 'ENOENT' && error.syscall.indexOf('spawn') === 0) {
      error = new Error(
        `Failed to spawn command \`${this.command}\`. Make sure \`${
          this.command
        }\` is installed and on your PATH`,
        error.path
      );
      error.name = 'BufferedProcessError';
    }
    if (!handled) throw error;
  }
};

================
File: src/clipboard.js
================
const crypto = require('crypto');
const { clipboard } = require('electron');
module.exports = class Clipboard {
  constructor() {
    this.reset();
  }
  reset() {
    this.metadata = null;
    this.signatureForMetadata = null;
  }
  md5(text) {
    return crypto
      .createHash('md5')
      .update(text, 'utf8')
      .digest('hex');
  }
  write(text, metadata) {
    text = text.replace(/\r?\n/g, process.platform === 'win32' ? '\r\n' : '\n');
    this.signatureForMetadata = this.md5(text);
    this.metadata = metadata;
    clipboard.writeText(text);
  }
  read() {
    return clipboard.readText();
  }
  writeFindText(text) {
    clipboard.writeFindText(text);
  }
  readFindText() {
    return clipboard.readFindText();
  }
  readWithMetadata() {
    const text = this.read();
    if (this.signatureForMetadata === this.md5(text)) {
      return { text, metadata: this.metadata };
    } else {
      return { text };
    }
  }
};

================
File: src/coffee-script.js
================
'use strict';
const crypto = require('crypto');
const path = require('path');
let CoffeeScript = null;
exports.shouldCompile = function() {
  return true;
};
exports.getCachePath = function(sourceCode) {
  return path.join(
    'coffee',
    crypto
      .createHash('sha1')
      .update(sourceCode, 'utf8')
      .digest('hex') + '.js'
  );
};
exports.compile = function(sourceCode, filePath) {
  if (!CoffeeScript) {
    const previousPrepareStackTrace = Error.prepareStackTrace;
    CoffeeScript = require('coffeescript');
    Error.prepareStackTrace = previousPrepareStackTrace;
  }
  if (process.platform === 'win32') {
    filePath = 'file:///' + path.resolve(filePath).replace(/\\/g, '/');
  }
  const output = CoffeeScript.compile(sourceCode, {
    filename: filePath,
    sourceFiles: [filePath],
    inlineMap: true
  });
  return output.replace(/\/\/# sourceURL=[^'"\n]+\s*$/, '');
};

================
File: src/color.js
================
let ParsedColor = null;
module.exports = class Color {
  static parse(value) {
    switch (typeof value) {
      case 'string':
        break;
      case 'object':
        if (Array.isArray(value)) {
          return null;
        }
        value = Object.values(value);
        break;
      default:
        return null;
    }
    if (!ParsedColor) {
      ParsedColor = require('color');
    }
    try {
      var parsedColor = ParsedColor(value);
    } catch (error) {
      return null;
    }
    return new Color(
      parsedColor.red(),
      parsedColor.green(),
      parsedColor.blue(),
      parsedColor.alpha()
    );
  }
  constructor(red, green, blue, alpha) {
    this.red = red;
    this.green = green;
    this.blue = blue;
    this.alpha = alpha;
  }
  set red(red) {
    this._red = parseColor(red);
  }
  set green(green) {
    this._green = parseColor(green);
  }
  set blue(blue) {
    this._blue = parseColor(blue);
  }
  set alpha(alpha) {
    this._alpha = parseAlpha(alpha);
  }
  get red() {
    return this._red;
  }
  get green() {
    return this._green;
  }
  get blue() {
    return this._blue;
  }
  get alpha() {
    return this._alpha;
  }
  toHexString() {
    return `#${numberToHexString(this.red)}${numberToHexString(
      this.green
    )}${numberToHexString(this.blue)}`;
  }
  toRGBAString() {
    return `rgba(${this.red}, ${this.green}, ${this.blue}, ${this.alpha})`;
  }
  toJSON() {
    return this.alpha === 1 ? this.toHexString() : this.toRGBAString();
  }
  toString() {
    return this.toRGBAString();
  }
  isEqual(color) {
    if (this === color) {
      return true;
    }
    if (!(color instanceof Color)) {
      color = Color.parse(color);
    }
    if (color == null) {
      return false;
    }
    return (
      color.red === this.red &&
      color.blue === this.blue &&
      color.green === this.green &&
      color.alpha === this.alpha
    );
  }
  clone() {
    return new Color(this.red, this.green, this.blue, this.alpha);
  }
};
function parseColor(colorString) {
  const color = parseInt(colorString, 10);
  return isNaN(color) ? 0 : Math.min(Math.max(color, 0), 255);
}
function parseAlpha(alphaString) {
  const alpha = parseFloat(alphaString);
  return isNaN(alpha) ? 1 : Math.min(Math.max(alpha, 0), 1);
}
function numberToHexString(number) {
  const hex = number.toString(16);
  return number < 16 ? `0${hex}` : hex;
}

================
File: src/command-installer.js
================
const path = require('path');
const fs = require('fs-plus');
module.exports = class CommandInstaller {
  constructor(applicationDelegate) {
    this.applicationDelegate = applicationDelegate;
  }
  initialize(appVersion) {
    this.appVersion = appVersion;
  }
  getInstallDirectory() {
    return '/usr/local/bin';
  }
  getResourcesDirectory() {
    return process.resourcesPath;
  }
  installShellCommandsInteractively() {
    const showErrorDialog = error => {
      this.applicationDelegate.confirm(
        {
          message: 'Failed to install shell commands',
          detail: error.message
        },
        () => {}
      );
    };
    this.installAtomCommand(true, (error, atomCommandName) => {
      if (error) return showErrorDialog(error);
      this.installApmCommand(true, (error, apmCommandName) => {
        if (error) return showErrorDialog(error);
        this.applicationDelegate.confirm(
          {
            message: 'Commands installed.',
            detail: `The shell commands \`${atomCommandName}\` and \`${apmCommandName}\` are installed.`
          },
          () => {}
        );
      });
    });
  }
  getCommandNameForChannel(commandName) {
    let channelMatch = this.appVersion.match(/beta|nightly/);
    let channel = channelMatch ? channelMatch[0] : '';
    switch (channel) {
      case 'beta':
        return `${commandName}-beta`;
      case 'nightly':
        return `${commandName}-nightly`;
      default:
        return commandName;
    }
  }
  installAtomCommand(askForPrivilege, callback) {
    this.installCommand(
      path.join(this.getResourcesDirectory(), 'pulsar.sh'),
      'pulsar',
      askForPrivilege,
      callback
    );
  }
  installApmCommand(askForPrivilege, callback) {
    this.installCommand(
      path.join(
        this.getResourcesDirectory(),
        'app',
        'ppm',
        'bin',
        'apm'
      ),
      'ppm',
      askForPrivilege,
      callback
    );
  }
  installCommand(commandPath, commandName, askForPrivilege, callback) {
    if (process.platform !== 'darwin') return callback();
    const destinationPath = path.join(this.getInstallDirectory(), commandName);
    fs.readlink(destinationPath, (error, realpath) => {
      if (error && error.code !== 'ENOENT') return callback(error);
      if (realpath === commandPath) return callback(null, commandName);
      this.createSymlink(fs, commandPath, destinationPath, error => {
        if (error && error.code === 'EACCES' && askForPrivilege) {
          const fsAdmin = require('fs-admin');
          this.createSymlink(fsAdmin, commandPath, destinationPath, error => {
            callback(error, commandName);
          });
        } else {
          callback(error);
        }
      });
    });
  }
  createSymlink(fs, sourcePath, destinationPath, callback) {
    fs.unlink(destinationPath, error => {
      if (error && error.code !== 'ENOENT') return callback(error);
      fs.makeTree(path.dirname(destinationPath), error => {
        if (error) return callback(error);
        fs.symlink(sourcePath, destinationPath, callback);
      });
    });
  }
};

================
File: src/command-registry.js
================
'use strict';
const { Emitter, Disposable, CompositeDisposable } = require('event-kit');
const { calculateSpecificity, validateSelector } = require('clear-cut');
const _ = require('underscore-plus');
let SequenceCount = 0;
module.exports = class CommandRegistry {
  constructor() {
    this.handleCommandEvent = this.handleCommandEvent.bind(this);
    this.rootNode = null;
    this.clear();
  }
  clear() {
    this.registeredCommands = {};
    this.selectorBasedListenersByCommandName = {};
    this.inlineListenersByCommandName = {};
    this.emitter = new Emitter();
  }
  attach(rootNode) {
    this.rootNode = rootNode;
    for (const command in this.selectorBasedListenersByCommandName) {
      this.commandRegistered(command);
    }
    for (const command in this.inlineListenersByCommandName) {
      this.commandRegistered(command);
    }
  }
  destroy() {
    for (const commandName in this.registeredCommands) {
      this.rootNode.removeEventListener(
        commandName,
        this.handleCommandEvent,
        true
      );
    }
  }
  add(target, commandName, listener, throwOnInvalidSelector = true) {
    if (typeof commandName === 'object') {
      const commands = commandName;
      throwOnInvalidSelector = listener;
      const disposable = new CompositeDisposable();
      for (commandName in commands) {
        listener = commands[commandName];
        disposable.add(
          this.add(target, commandName, listener, throwOnInvalidSelector)
        );
      }
      return disposable;
    }
    if (listener == null) {
      throw new Error('Cannot register a command with a null listener.');
    }
    if (
      typeof listener !== 'function' &&
      typeof listener.didDispatch !== 'function'
    ) {
      throw new Error(
        'Listener must be a callback function or an object with a didDispatch method.'
      );
    }
    if (typeof target === 'string') {
      if (throwOnInvalidSelector) {
        validateSelector(target);
      }
      return this.addSelectorBasedListener(target, commandName, listener);
    } else {
      return this.addInlineListener(target, commandName, listener);
    }
  }
  addSelectorBasedListener(selector, commandName, listener) {
    if (this.selectorBasedListenersByCommandName[commandName] == null) {
      this.selectorBasedListenersByCommandName[commandName] = [];
    }
    const listenersForCommand = this.selectorBasedListenersByCommandName[
      commandName
    ];
    const selectorListener = new SelectorBasedListener(
      selector,
      commandName,
      listener
    );
    listenersForCommand.push(selectorListener);
    this.commandRegistered(commandName);
    return new Disposable(() => {
      listenersForCommand.splice(
        listenersForCommand.indexOf(selectorListener),
        1
      );
      if (listenersForCommand.length === 0) {
        delete this.selectorBasedListenersByCommandName[commandName];
      }
    });
  }
  addInlineListener(element, commandName, listener) {
    if (this.inlineListenersByCommandName[commandName] == null) {
      this.inlineListenersByCommandName[commandName] = new WeakMap();
    }
    const listenersForCommand = this.inlineListenersByCommandName[commandName];
    let listenersForElement = listenersForCommand.get(element);
    if (!listenersForElement) {
      listenersForElement = [];
      listenersForCommand.set(element, listenersForElement);
    }
    const inlineListener = new InlineListener(commandName, listener);
    listenersForElement.push(inlineListener);
    this.commandRegistered(commandName);
    return new Disposable(() => {
      listenersForElement.splice(
        listenersForElement.indexOf(inlineListener),
        1
      );
      if (listenersForElement.length === 0) {
        listenersForCommand.delete(element);
      }
    });
  }
  findCommands({ target }) {
    const commandNames = new Set();
    const commands = [];
    let currentTarget = target;
    while (true) {
      let listeners;
      for (const name in this.inlineListenersByCommandName) {
        listeners = this.inlineListenersByCommandName[name];
        if (listeners.has(currentTarget) && !commandNames.has(name)) {
          commandNames.add(name);
          const targetListeners = listeners.get(currentTarget);
          commands.push(
            ...targetListeners.map(listener => listener.descriptor)
          );
        }
      }
      for (const commandName in this.selectorBasedListenersByCommandName) {
        listeners = this.selectorBasedListenersByCommandName[commandName];
        for (const listener of listeners) {
          if (listener.matchesTarget(currentTarget)) {
            if (!commandNames.has(commandName)) {
              commandNames.add(commandName);
              commands.push(listener.descriptor);
            }
          }
        }
      }
      if (currentTarget === window) {
        break;
      }
      currentTarget = currentTarget.parentNode || window;
    }
    return commands;
  }
  dispatch(target, commandName, detail) {
    const event = new CustomEvent(commandName, { bubbles: true, detail });
    Object.defineProperty(event, 'target', { value: target });
    return this.handleCommandEvent(event);
  }
  onWillDispatch(callback) {
    return this.emitter.on('will-dispatch', callback);
  }
  onDidDispatch(callback) {
    return this.emitter.on('did-dispatch', callback);
  }
  getSnapshot() {
    const snapshot = {};
    for (const commandName in this.selectorBasedListenersByCommandName) {
      const listeners = this.selectorBasedListenersByCommandName[commandName];
      snapshot[commandName] = listeners.slice();
    }
    return snapshot;
  }
  restoreSnapshot(snapshot) {
    this.selectorBasedListenersByCommandName = {};
    for (const commandName in snapshot) {
      const listeners = snapshot[commandName];
      this.selectorBasedListenersByCommandName[commandName] = listeners.slice();
    }
  }
  handleCommandEvent(event) {
    let propagationStopped = false;
    let immediatePropagationStopped = false;
    let matched = [];
    let currentTarget = event.target;
    const dispatchedEvent = new CustomEvent(event.type, {
      bubbles: true,
      detail: event.detail
    });
    Object.defineProperty(dispatchedEvent, 'eventPhase', {
      value: Event.BUBBLING_PHASE
    });
    Object.defineProperty(dispatchedEvent, 'currentTarget', {
      get() {
        return currentTarget;
      }
    });
    Object.defineProperty(dispatchedEvent, 'target', { value: currentTarget });
    Object.defineProperty(dispatchedEvent, 'preventDefault', {
      value() {
        return event.preventDefault();
      }
    });
    Object.defineProperty(dispatchedEvent, 'stopPropagation', {
      value() {
        event.stopPropagation();
        propagationStopped = true;
      }
    });
    Object.defineProperty(dispatchedEvent, 'stopImmediatePropagation', {
      value() {
        event.stopImmediatePropagation();
        propagationStopped = true;
        immediatePropagationStopped = true;
      }
    });
    Object.defineProperty(dispatchedEvent, 'abortKeyBinding', {
      value() {
        if (typeof event.abortKeyBinding === 'function') {
          event.abortKeyBinding();
        }
      }
    });
    for (const key of Object.keys(event)) {
      if (!(key in dispatchedEvent)) {
        dispatchedEvent[key] = event[key];
      }
    }
    this.emitter.emit('will-dispatch', dispatchedEvent);
    while (true) {
      const commandInlineListeners = this.inlineListenersByCommandName[
        event.type
      ]
        ? this.inlineListenersByCommandName[event.type].get(currentTarget)
        : null;
      let listeners = commandInlineListeners || [];
      if (currentTarget.webkitMatchesSelector != null) {
        const selectorBasedListeners = (
          this.selectorBasedListenersByCommandName[event.type] || []
        )
          .filter(listener => listener.matchesTarget(currentTarget))
          .sort((a, b) => a.compare(b));
        listeners = selectorBasedListeners.concat(listeners);
      }
      for (let i = listeners.length - 1; i >= 0; i--) {
        const listener = listeners[i];
        if (immediatePropagationStopped) {
          break;
        }
        matched.push(listener.didDispatch.call(currentTarget, dispatchedEvent));
      }
      if (currentTarget === window) {
        break;
      }
      if (propagationStopped) {
        break;
      }
      currentTarget = currentTarget.parentNode || window;
    }
    this.emitter.emit('did-dispatch', dispatchedEvent);
    return matched.length > 0 ? Promise.all(matched) : null;
  }
  commandRegistered(commandName) {
    if (this.rootNode != null && !this.registeredCommands[commandName]) {
      this.rootNode.addEventListener(commandName, this.handleCommandEvent, {
        capture: true
      });
      return (this.registeredCommands[commandName] = true);
    }
  }
};
class SelectorBasedListener {
  constructor(selector, commandName, listener) {
    this.selector = selector;
    this.didDispatch = extractDidDispatch(listener);
    this.descriptor = extractDescriptor(commandName, listener);
    this.specificity = calculateSpecificity(this.selector);
    this.sequenceNumber = SequenceCount++;
  }
  compare(other) {
    return (
      this.specificity - other.specificity ||
      this.sequenceNumber - other.sequenceNumber
    );
  }
  matchesTarget(target) {
    return (
      target.webkitMatchesSelector &&
      target.webkitMatchesSelector(this.selector)
    );
  }
}
class InlineListener {
  constructor(commandName, listener) {
    this.didDispatch = extractDidDispatch(listener);
    this.descriptor = extractDescriptor(commandName, listener);
  }
}
function extractDescriptor(name, listener) {
  return Object.assign(_.omit(listener, 'didDispatch'), {
    name,
    displayName: listener.displayName
      ? listener.displayName
      : _.humanizeEventName(name)
  });
}
function extractDidDispatch(listener) {
  return typeof listener === 'function' ? listener : listener.didDispatch;
}

================
File: src/comment-utils.js
================
function normalizeDelimiters(meta = {}) {
  if (
    ('commentStartString' in meta && 'commentEndString' in meta) && !('line' in meta || 'block' in meta)
  ) {
    let { commentStartString: start, commentEndString: end } = meta;
    meta = { start, end };
  }
  let { line, block } = meta;
  if (block && (!Array.isArray(block))) {
    let { start, end } = block;
    block = [start, end];
  }
  if (!block && meta.start && meta.end) {
    block = [meta.start.trim(), meta.end.trim()];
  }
  if (!line && meta.start && !meta.end) {
    line = meta.start.trim();
  }
  return { line, block };
}
function commentStringsFromDelimiters(meta) {
  let { line, block } = normalizeDelimiters(meta);
  let commentStartString;
  let commentEndString;
  let commentDelimiters = { line, block };
  let blockIsValid = block != null && Array.isArray(block);
  let lineIsValid = typeof line === 'string';
  if (lineIsValid || blockIsValid) {
    commentDelimiters = { line, block };
    if (lineIsValid) {
      commentStartString = line;
    } else if (blockIsValid) {
      [commentStartString, commentEndString] = block;
    }
  }
  let result = { commentStartString, commentEndString, commentDelimiters };
  return result;
}
function getDelimitersForScope(scope) {
  let reversed = [...scope.scopes].reverse();
  let mapped = reversed.map(scope => {
    return atom.config.get('editor.commentDelimiters', { scope: [scope] })
  })
  let result = mapped.find(setting => !!setting)
  return result ? normalizeDelimiters(result) : result
}
module.exports = {
  normalizeDelimiters,
  commentStringsFromDelimiters,
  getDelimitersForScope
};

================
File: src/compile-cache.js
================
'use strict';
const path = require('path');
const fs = require('fs-plus');
const sourceMapSupport = require('@atom/source-map-support');
const PackageTranspilationRegistry = require('./package-transpilation-registry');
let CSON = null;
const packageTranspilationRegistry = new PackageTranspilationRegistry();
const COMPILERS = {
  '.js': packageTranspilationRegistry.wrapTranspiler(require('./babel')),
  '.ts': packageTranspilationRegistry.wrapTranspiler(require('./typescript')),
  '.tsx': packageTranspilationRegistry.wrapTranspiler(require('./typescript')),
  '.coffee': packageTranspilationRegistry.wrapTranspiler(
    require('./coffee-script')
  )
};
exports.addTranspilerConfigForPath = function(
  packagePath,
  packageName,
  packageMeta,
  config
) {
  packagePath = fs.realpathSync(packagePath);
  packageTranspilationRegistry.addTranspilerConfigForPath(
    packagePath,
    packageName,
    packageMeta,
    config
  );
};
exports.removeTranspilerConfigForPath = function(packagePath) {
  packagePath = fs.realpathSync(packagePath);
  packageTranspilationRegistry.removeTranspilerConfigForPath(packagePath);
};
const cacheStats = {};
let cacheDirectory = null;
exports.setAtomHomeDirectory = function(atomHome) {
  let cacheDir = path.join(atomHome, 'compile-cache');
  if (
    process.env.USER === 'root' &&
    process.env.SUDO_USER &&
    process.env.SUDO_USER !== process.env.USER
  ) {
    cacheDir = path.join(cacheDir, 'root');
  }
  this.setCacheDirectory(cacheDir);
};
exports.setCacheDirectory = function(directory) {
  cacheDirectory = directory;
};
exports.getCacheDirectory = function() {
  return cacheDirectory;
};
exports.addPathToCache = function(filePath, atomHome) {
  this.setAtomHomeDirectory(atomHome);
  const extension = path.extname(filePath);
  if (extension === '.cson') {
    if (!CSON) {
      CSON = require('season');
      CSON.setCacheDir(this.getCacheDirectory());
    }
    return CSON.readFileSync(filePath);
  } else {
    const compiler = COMPILERS[extension];
    if (compiler) {
      return compileFileAtPath(compiler, filePath, extension);
    }
  }
};
exports.getCacheStats = function() {
  return cacheStats;
};
exports.resetCacheStats = function() {
  Object.keys(COMPILERS).forEach(function(extension) {
    cacheStats[extension] = {
      hits: 0,
      misses: 0
    };
  });
};
function compileFileAtPath(compiler, filePath, extension) {
  const sourceCode = fs.readFileSync(filePath, 'utf8');
  if (compiler.shouldCompile(sourceCode, filePath)) {
    const cachePath = compiler.getCachePath(sourceCode, filePath);
    let compiledCode = readCachedJavaScript(cachePath);
    if (compiledCode != null) {
      cacheStats[extension].hits++;
    } else {
      cacheStats[extension].misses++;
      compiledCode = compiler.compile(sourceCode, filePath);
      writeCachedJavaScript(cachePath, compiledCode);
    }
    return compiledCode;
  }
  return sourceCode;
}
function readCachedJavaScript(relativeCachePath) {
  const cachePath = path.join(cacheDirectory, relativeCachePath);
  if (fs.isFileSync(cachePath)) {
    try {
      return fs.readFileSync(cachePath, 'utf8');
    } catch (error) {}
  }
  return null;
}
function writeCachedJavaScript(relativeCachePath, code) {
  const cachePath = path.join(cacheDirectory, relativeCachePath);
  fs.writeFileSync(cachePath, code, 'utf8');
}
const INLINE_SOURCE_MAP_REGEXP = /\/\/[#@]\s*sourceMappingURL=([^'"\n]+)\s*$/gm;
exports.install = function(resourcesPath, nodeRequire) {
  const snapshotSourceMapConsumer = {
    originalPositionFor({ line, column }) {
      const { relativePath, row } = snapshotResult.translateSnapshotRow(line);
      return {
        column,
        line: row,
        source: path.join(resourcesPath, 'app', 'static', relativePath),
        name: null
      };
    }
  };
  sourceMapSupport.install({
    handleUncaughtExceptions: false,
    retrieveSourceMap: function(filePath) {
      if (filePath === '<embedded>') {
        return { map: snapshotSourceMapConsumer };
      }
      if (!cacheDirectory || !fs.isFileSync(filePath)) {
        return null;
      }
      try {
        var sourceCode = fs.readFileSync(filePath, 'utf8');
      } catch (error) {
        console.warn('Error reading source file', error.stack);
        return null;
      }
      let compiler = COMPILERS[path.extname(filePath)];
      if (!compiler) compiler = COMPILERS['.js'];
      try {
        var fileData = readCachedJavaScript(
          compiler.getCachePath(sourceCode, filePath)
        );
      } catch (error) {
        console.warn('Error reading compiled file', error.stack);
        return null;
      }
      if (fileData == null) {
        return null;
      }
      let match, lastMatch;
      INLINE_SOURCE_MAP_REGEXP.lastIndex = 0;
      while ((match = INLINE_SOURCE_MAP_REGEXP.exec(fileData))) {
        lastMatch = match;
      }
      if (lastMatch == null) {
        return null;
      }
      const sourceMappingURL = lastMatch[1];
      const rawData = sourceMappingURL.slice(sourceMappingURL.indexOf(',') + 1);
      try {
        var sourceMap = JSON.parse(Buffer.from(rawData, 'base64'));
      } catch (error) {
        console.warn('Error parsing source map', error.stack);
        return null;
      }
      return {
        map: sourceMap,
        url: null
      };
    }
  });
  const prepareStackTraceWithSourceMapping = Error.prepareStackTrace;
  var prepareStackTrace = prepareStackTraceWithSourceMapping;
  function prepareStackTraceWithRawStackAssignment(error, frames) {
    if (error.rawStack) {
      return prepareStackTraceWithSourceMapping(error, frames);
    } else {
      error.rawStack = frames;
      return prepareStackTrace(error, frames);
    }
  }
  Error.stackTraceLimit = 30;
  Object.defineProperty(Error, 'prepareStackTrace', {
    get: function() {
      return prepareStackTraceWithRawStackAssignment;
    },
    set: function(newValue) {
      prepareStackTrace = newValue;
      process.nextTick(function() {
        prepareStackTrace = prepareStackTraceWithSourceMapping;
      });
    }
  });
  Error.prototype.getRawStack = function() {
    this.stack;
    return this.rawStack;
  };
  Object.keys(COMPILERS).forEach(function(extension) {
    const compiler = COMPILERS[extension];
    Object.defineProperty(nodeRequire.extensions, extension, {
      enumerable: true,
      writable: false,
      value: function(module, filePath) {
        const code = compileFileAtPath(compiler, filePath, extension);
        return module._compile(code, filePath);
      }
    });
  });
};
exports.supportedExtensions = Object.keys(COMPILERS);
exports.resetCacheStats();

================
File: src/config-file.js
================
const _ = require('underscore-plus');
const fs = require('fs-plus');
const dedent = require('dedent');
const { Disposable, Emitter } = require('event-kit');
const CSON = require('season');
const Path = require('path');
const asyncQueue = require('async/queue');
const nsfw = require('nsfw');
const EVENT_TYPES = new Set([nsfw.actions.CREATED, nsfw.actions.MODIFIED, nsfw.actions.RENAMED]);
module.exports = class ConfigFile {
  static at(path) {
    if (!this._known) {
      this._known = new Map();
    }
    const existing = this._known.get(path);
    if (existing) {
      return existing;
    }
    const created = new ConfigFile(path);
    this._known.set(path, created);
    return created;
  }
  constructor(path) {
    this.path = path;
    this.emitter = new Emitter();
    this.value = {};
    this.reloadCallbacks = [];
    const writeQueue = asyncQueue((data, callback) =>
      CSON.writeFile(this.path, data, error => {
        if (error) {
          this.emitter.emit(
            'did-error',
            dedent`
              Failed to write \`${Path.basename(this.path)}\`.
              ${error.message}
            `
          );
        }
        callback();
      })
    );
    this.requestLoad = _.debounce(() => this.reload(), 200);
    this.requestSave = _.debounce(data => writeQueue.push(data), 200);
  }
  get() {
    return this.value;
  }
  update(value) {
    return new Promise(resolve => {
      this.requestSave(value);
      this.reloadCallbacks.push(resolve);
    });
  }
  async watch() {
    if (!fs.existsSync(this.path)) {
      fs.makeTreeSync(Path.dirname(this.path));
      CSON.writeFileSync(this.path, {}, { flag: 'wx' });
    }
    await this.reload();
    try {
      const watcher = await nsfw(this.path, events => {
        if (events.some(event => EVENT_TYPES.has(event.action))) {
          this.requestLoad();
        }
      })
      watcher.start();
      return { dispose: () => watcher.stop() };
    } catch (error) {
      //TODO_PULSAR: Find out why the atom global variable isn't available at this point
      this.emitter.emit(
        'did-error',
        dedent`
        Unable to watch path: \`${Path.basename(this.path)}\`.
        Make sure you have permissions to \`${this.path}\`.
        On linux there are currently problems with watch sizes.
        See [this document][watches] for more info.
        [watches]:https:
      `//TODO: Update the above to the pulsar docs if we choose to add this
      );
      return new Disposable();
    }
  }
  onDidChange(callback) {
    return this.emitter.on('did-change', callback);
  }
  onDidError(callback) {
    return this.emitter.on('did-error', callback);
  }
  reload() {
    return new Promise(resolve => {
      CSON.readFile(this.path, (error, data) => {
        if (error) {
          this.emitter.emit(
            'did-error',
            `Failed to load \`${Path.basename(this.path)}\` - ${error.message}`
          );
        } else {
          this.value = data || {};
          this.emitter.emit('did-change', this.value);
          for (const callback of this.reloadCallbacks) callback();
          this.reloadCallbacks.length = 0;
        }
        resolve();
      });
    });
  }
};

================
File: src/config-schema.js
================
const configSchema = {
  core: {
    type: 'object',
    properties: {
      ignoredNames: {
        type: 'array',
        default: [
          '.git',
          '.hg',
          '.svn',
          '.DS_Store',
          '._*',
          'Thumbs.db',
          'desktop.ini'
        ],
        items: {
          type: 'string'
        },
        description:
          'List of [glob patterns](https://en.wikipedia.org/wiki/Glob_%28programming%29). Files and directories matching these patterns will be ignored by some packages, such as the fuzzy finder and tree view. Individual packages might have additional config settings for ignoring names.'
      },
      excludeVcsIgnoredPaths: {
        type: 'boolean',
        default: true,
        title: 'Exclude VCS Ignored Paths',
        description:
          "Files and directories ignored by the current project's VCS will be ignored by some packages, such as the fuzzy finder and find and replace. For example, projects using Git have these paths defined in the .gitignore file. Individual packages might have additional config settings for ignoring VCS ignored files and folders."
      },
      followSymlinks: {
        type: 'boolean',
        default: true,
        description:
          'Follow symbolic links when searching files and when opening files with the fuzzy finder.'
      },
      disabledPackages: {
        type: 'array',
        default: [],
        items: {
          type: 'string'
        },
        description:
          'List of names of installed packages which are not loaded at startup.'
      },
      titleBar: {
        type: 'string',
        default: 'native',
        enum: ['native', 'hidden'],
        description:
          'Experimental:  The title bar can  be completely `hidden`.<br>This setting will require a relaunch of Pulsar to take effect.'
      },
      versionPinnedPackages: {
        type: 'array',
        default: [],
        items: {
          type: 'string'
        },
        description:
          'List of names of installed packages which are not automatically updated.'
      },
      customFileTypes: {
        type: 'object',
        default: {},
        description:
          'Associates scope names (e.g. `"source.js"`) with arrays of file extensions and file names (e.g. `["Somefile", ".js2"]`)',
        additionalProperties: {
          type: 'array',
          items: {
            type: 'string'
          }
        }
      },
      uriHandlerRegistration: {
        type: 'string',
        default: 'prompt',
        description:
          'When should Pulsar register itself as the default handler for atom:// URIs',
        enum: [
          {
            value: 'prompt',
            description:
              'Prompt to register Pulsar as the default atom:// URI handler'
          },
          {
            value: 'always',
            description:
              'Always become the default atom:// URI handler automatically'
          },
          {
            value: 'never',
            description: 'Never become the default atom:// URI handler'
          }
        ]
      },
      themes: {
        type: 'array',
        default: ['one-dark-ui', 'one-dark-syntax'],
        items: {
          type: 'string'
        },
        description:
          'Names of UI and syntax themes which will be used when Pulsar starts.'
      },
      audioBeep: {
        type: 'boolean',
        default: true,
        description:
          "Trigger the system's beep sound when certain actions cannot be executed or there are no results."
      },
      closeDeletedFileTabs: {
        type: 'boolean',
        default: false,
        title: 'Close Deleted File Tabs',
        description:
          'Close corresponding editors when a file is deleted outside Pulsar.'
      },
      destroyEmptyPanes: {
        type: 'boolean',
        default: true,
        title: 'Remove Empty Panes',
        description:
          'When the last tab of a pane is closed, remove that pane as well.'
      },
      closeEmptyWindows: {
        type: 'boolean',
        default: true,
        description:
          "When a window with no open tabs or panes is given the 'Close Tab' command, close that window."
      },
      fileEncoding: {
        description:
          'Default character set encoding to use when reading and writing files.',
        type: 'string',
        default: 'utf8',
        enum: [
          {
            value: 'iso88596',
            description: 'Arabic (ISO 8859-6)'
          },
          {
            value: 'windows1256',
            description: 'Arabic (Windows 1256)'
          },
          {
            value: 'iso88594',
            description: 'Baltic (ISO 8859-4)'
          },
          {
            value: 'windows1257',
            description: 'Baltic (Windows 1257)'
          },
          {
            value: 'iso885914',
            description: 'Celtic (ISO 8859-14)'
          },
          {
            value: 'iso88592',
            description: 'Central European (ISO 8859-2)'
          },
          {
            value: 'windows1250',
            description: 'Central European (Windows 1250)'
          },
          {
            value: 'gb18030',
            description: 'Chinese (GB18030)'
          },
          {
            value: 'gbk',
            description: 'Chinese (GBK)'
          },
          {
            value: 'cp950',
            description: 'Traditional Chinese (Big5)'
          },
          {
            value: 'big5hkscs',
            description: 'Traditional Chinese (Big5-HKSCS)'
          },
          {
            value: 'cp866',
            description: 'Cyrillic (CP 866)'
          },
          {
            value: 'iso88595',
            description: 'Cyrillic (ISO 8859-5)'
          },
          {
            value: 'koi8r',
            description: 'Cyrillic (KOI8-R)'
          },
          {
            value: 'koi8u',
            description: 'Cyrillic (KOI8-U)'
          },
          {
            value: 'windows1251',
            description: 'Cyrillic (Windows 1251)'
          },
          {
            value: 'cp437',
            description: 'DOS (CP 437)'
          },
          {
            value: 'cp850',
            description: 'DOS (CP 850)'
          },
          {
            value: 'iso885913',
            description: 'Estonian (ISO 8859-13)'
          },
          {
            value: 'iso88597',
            description: 'Greek (ISO 8859-7)'
          },
          {
            value: 'windows1253',
            description: 'Greek (Windows 1253)'
          },
          {
            value: 'iso88598',
            description: 'Hebrew (ISO 8859-8)'
          },
          {
            value: 'windows1255',
            description: 'Hebrew (Windows 1255)'
          },
          {
            value: 'cp932',
            description: 'Japanese (CP 932)'
          },
          {
            value: 'eucjp',
            description: 'Japanese (EUC-JP)'
          },
          {
            value: 'shiftjis',
            description: 'Japanese (Shift JIS)'
          },
          {
            value: 'euckr',
            description: 'Korean (EUC-KR)'
          },
          {
            value: 'iso885910',
            description: 'Nordic (ISO 8859-10)'
          },
          {
            value: 'iso885916',
            description: 'Romanian (ISO 8859-16)'
          },
          {
            value: 'iso88599',
            description: 'Turkish (ISO 8859-9)'
          },
          {
            value: 'windows1254',
            description: 'Turkish (Windows 1254)'
          },
          {
            value: 'utf8',
            description: 'Unicode (UTF-8)'
          },
          {
            value: 'utf16le',
            description: 'Unicode (UTF-16 LE)'
          },
          {
            value: 'utf16be',
            description: 'Unicode (UTF-16 BE)'
          },
          {
            value: 'windows1258',
            description: 'Vietnamese (Windows 1258)'
          },
          {
            value: 'iso88591',
            description: 'Western (ISO 8859-1)'
          },
          {
            value: 'iso88593',
            description: 'Western (ISO 8859-3)'
          },
          {
            value: 'iso885915',
            description: 'Western (ISO 8859-15)'
          },
          {
            value: 'macroman',
            description: 'Western (Mac Roman)'
          },
          {
            value: 'windows1252',
            description: 'Western (Windows 1252)'
          }
        ]
      },
      openEmptyEditorOnStart: {
        description:
          'When checked opens an untitled editor when loading a blank environment (such as with _File > New Window_ or when "Restore Previous Windows On Start" is unchecked); otherwise no editor is opened when loading a blank environment. This setting has no effect when restoring a previous state.',
        type: 'boolean',
        default: true
      },
      restorePreviousWindowsOnStart: {
        type: 'string',
        enum: ['no', 'yes', 'always'],
        default: 'yes',
        description:
          "When selected 'no', a blank environment is loaded. When selected 'yes' and Pulsar is started from the icon or `pulsar` by itself from the command line, restores the last state of all Pulsar windows; otherwise a blank environment is loaded. When selected 'always', restores the last state of all Pulsar windows always, no matter how Pulsar is started."
      },
      reopenProjectMenuCount: {
        description:
          'How many recent projects to show in the Reopen Project menu.',
        type: 'integer',
        default: 15
      },
      automaticallyUpdate: {
        description:
          'Automatically update Pulsar when a new release is available. **Note**: Currently not functional, please download new releases from [pulsar-edit.dev](https://pulsar-edit.dev/download.html)',
        type: 'boolean',
        default: false
      },
      useProxySettingsWhenCallingApm: {
        title: 'Use Proxy Settings When Calling PPM',
        description:
          'Use detected proxy settings when calling the `pulsar -p` or `ppm` command-line tool.',
        type: 'boolean',
        default: true
      },
      allowPendingPaneItems: {
        description:
          'Allow items to be previewed without adding them to a pane permanently, such as when single clicking files in the tree view.',
        type: 'boolean',
        default: true
      },
      warnOnLargeFileLimit: {
        description:
          'Warn before opening files larger than this number of megabytes.',
        type: 'number',
        default: 40
      },
      fileSystemWatcher: {
        description:
          'Choose the underlying implementation used to watch for filesystem changes. Emulating changes will miss any events caused by applications other than Pulsar, but may help prevent crashes or freezes.',
        type: 'string',
        default: 'native',
        enum: [
          {
            value: 'native',
            description: 'Native operating system APIs'
          }
        ]
      },
      useTreeSitterParsers: {
        type: 'boolean',
        default: true,
        title: 'Use Tree-sitter Parsers',
        description: 'Use Tree-sitter parsers for supported languages.'
      },
      useLegacyTreeSitter: {
        type: 'boolean',
        default: false,
        title: 'Use Legacy Tree-sitter Implementation',
        description: 'Opt into the legacy Atom Tree-sitter system instead of the modern system added by Pulsar. (We plan to remove this legacy system soon.) Has no effect unless “Use Tree-sitter Parsers” is also checked.'
      },
      colorProfile: {
        description:
          "Specify whether Pulsar should use the operating system's color profile (recommended) or an alternative color profile.<br>Changing this setting will require a relaunch of Pulsar to take effect.",
        type: 'string',
        default: 'default',
        enum: [
          {
            value: 'default',
            description: 'Use color profile configured in the operating system'
          },
          {
            value: 'srgb',
            description: 'Use sRGB color profile'
          }
        ]
      },
      transformDeprecatedStyleSheetSelectors: {
        description: 'Whether Pulsar should transform deprecated DOM Selectors in community package style sheets. Increases compatibility, as well as startup time.',
        type: 'boolean',
        default: true
      },
      transformDeprecatedStyleSheetMathExpressions: {
        description: 'Whether Pulsar should transform deprecated Mathematical Expressions in community package style sheets. Increases compatibility, as well as startup time.',
        type: 'boolean',
        default: true
      },
      addCurrentTabToWindowTitle: {
        description: 'Add the current tab title to the Pulsar Window title.',
        type: 'boolean',
        default: true
      },
      syncWindowThemeWithPulsarTheme: {
        description: 'When changing the theme within Pulsar also change the theme of the window on the operating system.',
        type: 'boolean',
        default: false
      },
      allowWindowTransparency: {
        type: 'boolean',
        default: false,
        title: 'Allow Window Transparency',
        description: `Allows editor windows to be see-through. When this setting is enabled, UI themes and user stylesheets can use background colors with an alpha channel to make editor windows translucent. Takes effect after a restart of Pulsar.`
      }
    }
  },
  editor: {
    type: 'object',
    properties: {
      commentStart: {
        type: ['string', 'null']
      },
      commentEnd: {
        type: ['string', 'null']
      },
      increaseIndentPattern: {
        type: ['string', 'null']
      },
      decreaseIndentPattern: {
        type: ['string', 'null']
      },
      foldEndPattern: {
        type: ['string', 'null']
      },
      fontFamily: {
        type: 'string',
        default: 'Menlo, Consolas, DejaVu Sans Mono, monospace',
        description: 'The name of the font family used for editor text.'
      },
      fontSize: {
        type: 'integer',
        default: 14,
        minimum: 1,
        maximum: 100,
        description: 'Height in pixels of editor text.'
      },
      defaultFontSize: {
        type: 'integer',
        default: 14,
        minimum: 1,
        maximum: 100,
        description:
          'Default height in pixels of the editor text. Useful when resetting font size'
      },
      lineHeight: {
        type: ['string', 'number'],
        default: 1.5,
        description: 'Height of editor lines, as a multiplier of font size.'
      },
      showCursorOnSelection: {
        type: 'boolean',
        default: true,
        description: 'Show cursor while there is a selection.'
      },
      showInvisibles: {
        type: 'boolean',
        default: false,
        description:
          'Render placeholders for invisible characters, such as tabs, spaces and newlines.'
      },
      showIndentGuide: {
        type: 'boolean',
        default: false,
        description: 'Show indentation indicators in the editor.'
      },
      showLineNumbers: {
        type: 'boolean',
        default: true,
        description: "Show line numbers in the editor's gutter."
      },
      atomicSoftTabs: {
        type: 'boolean',
        default: true,
        description:
          'Skip over tab-length runs of leading whitespace when moving the cursor.'
      },
      autoIndent: {
        type: 'boolean',
        default: true,
        description: 'Automatically indent the cursor when inserting a newline.'
      },
      autoIndentOnPaste: {
        type: 'boolean',
        default: true,
        description:
          'Automatically indent pasted text based on the indentation of the previous line.'
      },
      nonWordCharacters: {
        type: 'string',
        default: '/\\()"\':,.;<>~!@#$%^&*|+=[]{}`?-…',
        description:
          'A string of non-word characters to define word boundaries.'
      },
      preferredLineLength: {
        type: 'integer',
        default: 80,
        minimum: 1,
        description:
          'Identifies the length of a line which is used when wrapping text with the `Soft Wrap At Preferred Line Length` setting enabled, in number of characters.'
      },
      maxScreenLineLength: {
        type: 'integer',
        default: 500,
        minimum: 500,
        description:
          'Defines the maximum width of the editor window before soft wrapping is enforced, in number of characters.'
      },
      tabLength: {
        type: 'integer',
        default: 2,
        minimum: 1,
        description: 'Number of spaces used to represent a tab.'
      },
      softWrap: {
        type: 'boolean',
        default: false,
        description:
          'Wraps lines that exceed the width of the window. When `Soft Wrap At Preferred Line Length` is set, it will wrap to the number of characters defined by the `Preferred Line Length` setting.'
      },
      softTabs: {
        type: 'boolean',
        default: true,
        description:
          'If the `Tab Type` config setting is set to "auto" and autodetection of tab type from buffer content fails, then this config setting determines whether a soft tab or a hard tab will be inserted when the Tab key is pressed.'
      },
      tabType: {
        type: 'string',
        default: 'auto',
        enum: ['auto', 'soft', 'hard'],
        description:
          'Determine character inserted when Tab key is pressed. Possible values: "auto", "soft" and "hard". When set to "soft" or "hard", soft tabs (spaces) or hard tabs (tab characters) are used. When set to "auto", the editor auto-detects the tab type based on the contents of the buffer (it uses the first leading whitespace on a non-comment line), or uses the value of the Soft Tabs config setting if auto-detection fails.'
      },
      softWrapAtPreferredLineLength: {
        type: 'boolean',
        default: false,
        description:
          "Instead of wrapping lines to the window's width, wrap lines to the number of characters defined by the `Preferred Line Length` setting. This will only take effect when the soft wrap config setting is enabled globally or for the current language. **Note:** If you want to hide the wrap guide (the vertical line) you can disable the `wrap-guide` package."
      },
      softWrapHangingIndent: {
        type: 'integer',
        default: 0,
        minimum: 0,
        description:
          'When soft wrap is enabled, defines length of additional indentation applied to wrapped lines, in number of characters.'
      },
      scrollSensitivity: {
        type: 'integer',
        default: 40,
        minimum: 10,
        maximum: 200,
        description:
          'Determines how fast the editor scrolls when using a mouse or trackpad.'
      },
      scrollPastEnd: {
        type: 'boolean',
        default: false,
        description:
          'Allow the editor to be scrolled past the end of the last line.'
      },
      undoGroupingInterval: {
        type: 'integer',
        default: 300,
        minimum: 0,
        description:
          'Time interval in milliseconds within which text editing operations will be grouped together in the undo history.'
      },
      confirmCheckoutHeadRevision: {
        type: 'boolean',
        default: true,
        title: 'Confirm Checkout HEAD Revision',
        description:
          'Show confirmation dialog when checking out the HEAD revision and discarding changes to current file since last commit.'
      },
      invisibles: {
        type: 'object',
        description:
          'A hash of characters Pulsar will use to render whitespace characters. Keys are whitespace character types, values are rendered characters (use value false to turn off individual whitespace character types).',
        properties: {
          eol: {
            type: ['boolean', 'string'],
            default: '¬',
            maximumLength: 1,
            description:
              'Character used to render newline characters (\\n) when the `Show Invisibles` setting is enabled. '
          },
          space: {
            type: ['boolean', 'string'],
            default: '·',
            maximumLength: 1,
            description:
              'Character used to render leading and trailing space characters when the `Show Invisibles` setting is enabled.'
          },
          tab: {
            type: ['boolean', 'string'],
            default: '»',
            maximumLength: 1,
            description:
              'Character used to render hard tab characters (\\t) when the `Show Invisibles` setting is enabled.'
          },
          cr: {
            type: ['boolean', 'string'],
            default: '¤',
            maximumLength: 1,
            description:
              'Character used to render carriage return characters (for Microsoft-style line endings) when the `Show Invisibles` setting is enabled.'
          }
        }
      },
      zoomFontWhenCtrlScrolling: {
        type: 'boolean',
        default: process.platform !== 'darwin',
        description:
          'Change the editor font size when pressing the Ctrl key and scrolling the mouse up/down.'
      },
      multiCursorOnClick: {
        type: 'boolean',
        default: true,
        description:
          'Add multiple cursors when pressing the Ctrl key (Command key on macOS) and clicking the editor.'
      }
    }
  }
};
if (['win32', 'linux'].includes(process.platform)) {
  configSchema.core.properties.autoHideMenuBar = {
    type: 'boolean',
    default: false,
    description:
      'Automatically hide the menu bar and toggle it by pressing Alt. This is only supported on Windows & Linux.'
  };
}
if (process.platform === 'darwin') {
  configSchema.core.properties.titleBar = {
    type: 'string',
    default: 'native',
    enum: ['native', 'custom', 'custom-inset', 'hidden'],
    description:
      'Experimental: A `custom` title bar adapts to theme colors. Choosing `custom-inset` adds a bit more padding. The title bar can also be completely `hidden`.<br>Note: Switching to a custom or hidden title bar will compromise some functionality.<br>This setting will require a relaunch of Pulsar to take effect.'
  };
  configSchema.core.properties.simpleFullScreenWindows = {
    type: 'boolean',
    default: false,
    description:
      'Use pre-Lion fullscreen on macOS. This does not create a new desktop space for Pulsar on fullscreen mode.'
  };
}
if (process.platform === 'linux') {
  configSchema.editor.properties.selectionClipboard = {
    type: 'boolean',
    default: true,
    description: 'Enable pasting on middle mouse button click'
  };
}
module.exports = configSchema;

================
File: src/config.js
================
const _ = require('underscore-plus');
const { Emitter } = require('event-kit');
const {
  getValueAtKeyPath,
  setValueAtKeyPath,
  deleteValueAtKeyPath,
  pushKeyPath,
  splitKeyPath
} = require('key-path-helpers');
const Color = require('./color');
const ScopedPropertyStore = require('scoped-property-store');
const ScopeDescriptor = require('./scope-descriptor');
const schemaEnforcers = {};
class Config {
  static addSchemaEnforcer(typeName, enforcerFunction) {
    if (schemaEnforcers[typeName] == null) {
      schemaEnforcers[typeName] = [];
    }
    return schemaEnforcers[typeName].push(enforcerFunction);
  }
  static addSchemaEnforcers(filters) {
    for (let typeName in filters) {
      const functions = filters[typeName];
      for (let name in functions) {
        const enforcerFunction = functions[name];
        this.addSchemaEnforcer(typeName, enforcerFunction);
      }
    }
  }
  static executeSchemaEnforcers(keyPath, value, schema) {
    let error = null;
    let types = schema.type;
    if (!Array.isArray(types)) {
      types = [types];
    }
    for (let type of types) {
      try {
        const enforcerFunctions = schemaEnforcers[type].concat(
          schemaEnforcers['*']
        );
        for (let enforcer of enforcerFunctions) {
          value = enforcer.call(this, keyPath, value, schema);
        }
        error = null;
        break;
      } catch (e) {
        error = e;
      }
    }
    if (error != null) {
      throw error;
    }
    return value;
  }
  constructor(params = {}) {
    this.clear();
    this.initialize(params);
  }
  initialize({ saveCallback, mainSource, projectHomeSchema }) {
    if (saveCallback) {
      this.saveCallback = saveCallback;
    }
    if (mainSource) this.mainSource = mainSource;
    if (projectHomeSchema) {
      this.schema.properties.core.properties.projectHome = projectHomeSchema;
      this.defaultSettings.core.projectHome = projectHomeSchema.default;
    }
  }
  clear() {
    this.emitter = new Emitter();
    this.schema = {
      type: 'object',
      properties: {}
    };
    this.defaultSettings = {};
    this.settings = {};
    this.projectSettings = {};
    this.projectFile = null;
    this.scopedSettingsStore = new ScopedPropertyStore();
    this.settingsLoaded = false;
    this.transactDepth = 0;
    this.pendingOperations = [];
    this.legacyScopeAliases = new Map();
    this.requestSave = _.debounce(() => this.save(), 1);
  }
  observe(...args) {
    let callback, keyPath, options, scopeDescriptor;
    if (args.length === 2) {
      [keyPath, callback] = args;
    } else if (
      args.length === 3 &&
      (_.isString(args[0]) && _.isObject(args[1]))
    ) {
      [keyPath, options, callback] = args;
      scopeDescriptor = options.scope;
    } else {
      console.error(
        'An unsupported form of Config::observe is being used. See https://atom.io/docs/api/latest/Config for details'
      );
      return;
    }
    if (scopeDescriptor != null) {
      return this.observeScopedKeyPath(scopeDescriptor, keyPath, callback);
    } else {
      return this.observeKeyPath(
        keyPath,
        options ?? {},
        callback
      );
    }
  }
  onDidChange(...args) {
    let callback, keyPath, scopeDescriptor;
    if (args.length === 1) {
      [callback] = args;
    } else if (args.length === 2) {
      [keyPath, callback] = args;
    } else {
      let options;
      [keyPath, options, callback] = args;
      scopeDescriptor = options.scope;
    }
    if (scopeDescriptor != null) {
      return this.onDidChangeScopedKeyPath(scopeDescriptor, keyPath, callback);
    } else {
      return this.onDidChangeKeyPath(keyPath, callback);
    }
  }
  get(...args) {
    let keyPath, options, scope;
    if (args.length > 1) {
      if (typeof args[0] === 'string' || args[0] == null) {
        [keyPath, options] = args;
        ({ scope } = options);
      }
    } else {
      [keyPath] = args;
    }
    if (scope != null) {
      const value = this.getRawScopedValue(scope, keyPath, options);
      return value != null ? value : this.getRawValue(keyPath, options);
    } else {
      return this.getRawValue(keyPath, options);
    }
  }
  getAll(keyPath, options) {
    let globalValue, result, scope;
    if (options != null) {
      ({ scope } = options);
    }
    if (scope != null) {
      let legacyScopeDescriptor;
      const scopeDescriptor = ScopeDescriptor.fromObject(scope);
      result = this.scopedSettingsStore.getAll(
        scopeDescriptor.getScopeChain(),
        keyPath,
        options
      );
      legacyScopeDescriptor = this.getLegacyScopeDescriptorForNewScopeDescriptor(
        scopeDescriptor
      );
      if (legacyScopeDescriptor) {
        result.push(
          ...Array.from(
            this.scopedSettingsStore.getAll(
              legacyScopeDescriptor.getScopeChain(),
              keyPath,
              options
            ) || []
          )
        );
      }
    } else {
      result = [];
    }
    globalValue = this.getRawValue(keyPath, options);
    if (globalValue) {
      result.push({ scopeSelector: '*', value: globalValue });
    }
    return result;
  }
  set(...args) {
    let [keyPath, value, options = {}] = args;
    if (!this.settingsLoaded) {
      this.pendingOperations.push(() => this.set(keyPath, value, options));
    }
    const scopeSelector =
      options.scopeSelector !== '*' ? options.scopeSelector : undefined;
    let source = options.source;
    const shouldSave = options.save != null ? options.save : true;
    if (source && !scopeSelector && source !== this.projectFile) {
      throw new Error(
        "::set with a 'source' and no 'scopeSelector' is not yet implemented!"
      );
    }
    if (!source) source = this.mainSource;
    if (value !== undefined) {
      try {
        value = this.makeValueConformToSchema(keyPath, value);
      } catch (e) {
        return false;
      }
    }
    if (scopeSelector != null) {
      this.setRawScopedValue(keyPath, value, source, scopeSelector);
    } else {
      this.setRawValue(keyPath, value, { source });
    }
    if (source === this.mainSource && shouldSave && this.settingsLoaded) {
      this.requestSave();
    }
    return true;
  }
  unset(keyPath, options) {
    if (!this.settingsLoaded) {
      this.pendingOperations.push(() => this.unset(keyPath, options));
    }
    let { scopeSelector, source } = options != null ? options : {};
    if (source == null) {
      source = this.mainSource;
    }
    if (scopeSelector != null) {
      if (keyPath != null) {
        let settings = this.scopedSettingsStore.propertiesForSourceAndSelector(
          source,
          scopeSelector
        );
        if (getValueAtKeyPath(settings, keyPath) != null) {
          this.scopedSettingsStore.removePropertiesForSourceAndSelector(
            source,
            scopeSelector
          );
          setValueAtKeyPath(settings, keyPath, undefined);
          settings = withoutEmptyObjects(settings);
          if (settings != null) {
            this.set(null, settings, {
              scopeSelector,
              source,
              priority: this.priorityForSource(source)
            });
          }
          const configIsReady =
            source === this.mainSource && this.settingsLoaded;
          if (configIsReady) {
            return this.requestSave();
          }
        }
      } else {
        this.scopedSettingsStore.removePropertiesForSourceAndSelector(
          source,
          scopeSelector
        );
        return this.emitChangeEvent();
      }
    } else {
      for (scopeSelector in this.scopedSettingsStore.propertiesForSource(
        source
      )) {
        this.unset(keyPath, { scopeSelector, source });
      }
      if (keyPath != null && source === this.mainSource) {
        return this.set(
          keyPath,
          getValueAtKeyPath(this.defaultSettings, keyPath)
        );
      }
    }
  }
  getSources() {
    return _.uniq(
      _.pluck(this.scopedSettingsStore.propertySets, 'source')
    ).sort();
  }
  getSchema(keyPath) {
    const keys = splitKeyPath(keyPath);
    let { schema } = this;
    for (let key of keys) {
      let childSchema;
      if (schema.type === 'object') {
        childSchema =
          schema.properties != null ? schema.properties[key] : undefined;
        if (childSchema == null) {
          if (isPlainObject(schema.additionalProperties)) {
            childSchema = schema.additionalProperties;
          } else if (schema.additionalProperties === false) {
            return null;
          } else {
            return { type: 'any' };
          }
        }
      } else {
        return null;
      }
      schema = childSchema;
    }
    return schema;
  }
  getUserConfigPath() {
    return this.mainSource;
  }
  transact(callback) {
    this.beginTransaction();
    try {
      return callback();
    } finally {
      this.endTransaction();
    }
  }
  getLegacyScopeDescriptorForNewScopeDescriptor(scopeDescriptor) {
    return null;
  }
  transactAsync(callback) {
    let endTransaction;
    this.beginTransaction();
    try {
      endTransaction = fn => (...args) => {
        this.endTransaction();
        return fn(...args);
      };
      const result = callback();
      return new Promise((resolve, reject) => {
        return result
          .then(endTransaction(resolve))
          .catch(endTransaction(reject));
      });
    } catch (error) {
      this.endTransaction();
      return Promise.reject(error);
    }
  }
  beginTransaction() {
    this.transactDepth++;
  }
  endTransaction() {
    this.transactDepth--;
    this.emitChangeEvent();
  }
  pushAtKeyPath(keyPath, value) {
    const left = this.get(keyPath);
    const arrayValue = left == null ? [] : left;
    const result = arrayValue.push(value);
    this.set(keyPath, arrayValue);
    return result;
  }
  unshiftAtKeyPath(keyPath, value) {
    const left = this.get(keyPath);
    const arrayValue = left == null ? [] : left;
    const result = arrayValue.unshift(value);
    this.set(keyPath, arrayValue);
    return result;
  }
  removeAtKeyPath(keyPath, value) {
    const left = this.get(keyPath);
    const arrayValue = left == null ? [] : left;
    const result = _.remove(arrayValue, value);
    this.set(keyPath, arrayValue);
    return result;
  }
  setSchema(keyPath, schema) {
    if (!isPlainObject(schema)) {
      throw new Error(
        `Error loading schema for ${keyPath}: schemas can only be objects!`
      );
    }
    if (schema.type == null) {
      throw new Error(
        `Error loading schema for ${keyPath}: schema objects must have a type attribute`
      );
    }
    let rootSchema = this.schema;
    if (keyPath) {
      for (let key of splitKeyPath(keyPath)) {
        rootSchema.type = 'object';
        if (rootSchema.properties == null) {
          rootSchema.properties = {};
        }
        const { properties } = rootSchema;
        if (properties[key] == null) {
          properties[key] = {};
        }
        rootSchema = properties[key];
      }
    }
    Object.assign(rootSchema, schema);
    this.transact(() => {
      this.setDefaults(keyPath, this.extractDefaultsFromSchema(schema));
      this.setScopedDefaultsFromSchema(keyPath, schema);
      this.resetSettingsForSchemaChange();
    });
  }
  save() {
    if (this.saveCallback) {
      let allSettings = { '*': this.settings };
      allSettings = Object.assign(
        allSettings,
        this.scopedSettingsStore.propertiesForSource(this.mainSource)
      );
      allSettings = sortObject(allSettings);
      this.saveCallback(allSettings);
    }
  }
  resetUserSettings(newSettings, options = {}) {
    this._resetSettings(newSettings, options);
  }
  _resetSettings(newSettings, options = {}) {
    const source = options.source;
    newSettings = Object.assign({}, newSettings);
    if (newSettings.global != null) {
      newSettings['*'] = newSettings.global;
      delete newSettings.global;
    }
    if (newSettings['*'] != null) {
      const scopedSettings = newSettings;
      newSettings = newSettings['*'];
      delete scopedSettings['*'];
      this.resetScopedSettings(scopedSettings, { source });
    }
    return this.transact(() => {
      this._clearUnscopedSettingsForSource(source);
      this.settingsLoaded = true;
      for (let key in newSettings) {
        const value = newSettings[key];
        this.set(key, value, { save: false, source });
      }
      if (this.pendingOperations.length) {
        for (let op of this.pendingOperations) {
          op();
        }
        this.pendingOperations = [];
      }
    });
  }
  _clearUnscopedSettingsForSource(source) {
    if (source === this.projectFile) {
      this.projectSettings = {};
    } else {
      this.settings = {};
    }
  }
  resetProjectSettings(newSettings, projectFile) {
    newSettings = Object.assign({}, newSettings);
    const oldProjectFile = this.projectFile;
    this.projectFile = projectFile;
    if (this.projectFile != null) {
      this._resetSettings(newSettings, { source: this.projectFile });
    } else {
      this.scopedSettingsStore.removePropertiesForSource(oldProjectFile);
      this.projectSettings = {};
    }
  }
  clearProjectSettings() {
    this.resetProjectSettings({}, null);
  }
  getRawValue(keyPath, options = {}) {
    let { excludeSources, sources } = options;
    let value;
    if (!excludeSources || !excludeSources.includes(this.mainSource)) {
      value = getValueAtKeyPath(this.settings, keyPath);
      if (
        this.projectFile != null &&
        (
          !excludeSources || !excludeSources.includes(this.projectFile)
        ) &&
        (
          !sources || sources.includes(this.projectFile)
        )
      ) {
        let projectValue = getValueAtKeyPath(this.projectSettings, keyPath);
        if (projectValue === undefined) {
        } else if (isPlainObject(value) && isPlainObject(projectValue)) {
          projectValue = this.deepClone(projectValue);
          this.deepDefaults(projectValue, value);
          value = projectValue;
        } else {
          value = projectValue;
        }
      }
    }
    let defaultValue;
    if (!options.sources || options.sources.length === 0) {
      defaultValue = getValueAtKeyPath(this.defaultSettings, keyPath);
    }
    if (value != null) {
      value = this.deepClone(value);
      if (isPlainObject(value) && isPlainObject(defaultValue)) {
        this.deepDefaults(value, defaultValue);
      }
      return value;
    } else {
      return this.deepClone(defaultValue);
    }
  }
  setRawValue(keyPath, value, options = {}) {
    const source = options.source ? options.source : undefined;
    const settingsToChange =
      source === this.projectFile ? 'projectSettings' : 'settings';
    const defaultValue = getValueAtKeyPath(this.defaultSettings, keyPath);
    if (_.isEqual(defaultValue, value)) {
      if (keyPath != null) {
        deleteValueAtKeyPath(this[settingsToChange], keyPath);
      } else {
        this[settingsToChange] = null;
      }
    } else {
      if (keyPath != null) {
        setValueAtKeyPath(this[settingsToChange], keyPath, value);
      } else {
        this[settingsToChange] = value;
      }
    }
    return this.emitChangeEvent();
  }
  observeKeyPath(keyPath, options, callback) {
    callback(this.get(keyPath));
    return this.onDidChangeKeyPath(keyPath, event => callback(event.newValue));
  }
  onDidChangeKeyPath(keyPath, callback) {
    let oldValue = this.get(keyPath);
    return this.emitter.on('did-change', () => {
      const newValue = this.get(keyPath);
      if (!_.isEqual(oldValue, newValue)) {
        const event = { oldValue, newValue };
        oldValue = newValue;
        return callback(event);
      }
    });
  }
  isSubKeyPath(keyPath, subKeyPath) {
    if (keyPath == null || subKeyPath == null) {
      return false;
    }
    const pathSubTokens = splitKeyPath(subKeyPath);
    const pathTokens = splitKeyPath(keyPath).slice(0, pathSubTokens.length);
    return _.isEqual(pathTokens, pathSubTokens);
  }
  setRawDefault(keyPath, value) {
    setValueAtKeyPath(this.defaultSettings, keyPath, value);
    return this.emitChangeEvent();
  }
  setDefaults(keyPath, defaults) {
    if (defaults != null && isPlainObject(defaults)) {
      const keys = splitKeyPath(keyPath);
      this.transact(() => {
        const result = [];
        for (let key in defaults) {
          const childValue = defaults[key];
          if (!defaults.hasOwnProperty(key)) {
            continue;
          }
          result.push(
            this.setDefaults(keys.concat([key]).join('.'), childValue)
          );
        }
        return result;
      });
    } else {
      try {
        defaults = this.makeValueConformToSchema(keyPath, defaults);
        this.setRawDefault(keyPath, defaults);
      } catch (e) {
        console.warn(
          `'${keyPath}' could not set the default. Attempted default: ${JSON.stringify(
            defaults
          )}; Schema: ${JSON.stringify(this.getSchema(keyPath))}`
        );
      }
    }
  }
  deepClone(object) {
    if (object instanceof Color) {
      return object.clone();
    } else if (Array.isArray(object)) {
      return object.map(value => this.deepClone(value));
    } else if (isPlainObject(object)) {
      return _.mapObject(object, (key, value) => [key, this.deepClone(value)]);
    } else {
      return object;
    }
  }
  deepDefaults(target) {
    let result = target;
    let i = 0;
    while (++i < arguments.length) {
      const object = arguments[i];
      if (isPlainObject(result) && isPlainObject(object)) {
        for (let key of Object.keys(object)) {
          result[key] = this.deepDefaults(result[key], object[key]);
        }
      } else {
        if (result == null) {
          result = this.deepClone(object);
        }
      }
    }
    return result;
  }
  setScopedDefaultsFromSchema(keyPath, schema) {
    if (schema.scopes != null && isPlainObject(schema.scopes)) {
      const scopedDefaults = {};
      for (let scope in schema.scopes) {
        const scopeSchema = schema.scopes[scope];
        if (!scopeSchema.hasOwnProperty('default')) {
          continue;
        }
        scopedDefaults[scope] = {};
        setValueAtKeyPath(scopedDefaults[scope], keyPath, scopeSchema.default);
      }
      this.scopedSettingsStore.addProperties('schema-default', scopedDefaults);
    }
    if (
      schema.type === 'object' &&
      schema.properties != null &&
      isPlainObject(schema.properties)
    ) {
      const keys = splitKeyPath(keyPath);
      for (let key in schema.properties) {
        const childValue = schema.properties[key];
        if (!schema.properties.hasOwnProperty(key)) {
          continue;
        }
        this.setScopedDefaultsFromSchema(
          keys.concat([key]).join('.'),
          childValue
        );
      }
    }
  }
  extractDefaultsFromSchema(schema) {
    if (schema.default != null) {
      return schema.default;
    } else if (
      schema.type === 'object' &&
      schema.properties != null &&
      isPlainObject(schema.properties)
    ) {
      const defaults = {};
      const properties = schema.properties || {};
      for (let key in properties) {
        const value = properties[key];
        defaults[key] = this.extractDefaultsFromSchema(value);
      }
      return defaults;
    }
  }
  makeValueConformToSchema(keyPath, value, options) {
    if (options != null ? options.suppressException : undefined) {
      try {
        return this.makeValueConformToSchema(keyPath, value);
      } catch (e) {
        return undefined;
      }
    } else {
      let schema;
      if ((schema = this.getSchema(keyPath)) == null) {
        if (schema === false) {
          throw new Error(`Illegal key path ${keyPath}`);
        }
      }
      return this.constructor.executeSchemaEnforcers(keyPath, value, schema);
    }
  }
  resetSettingsForSchemaChange(source) {
    if (source == null) {
      source = this.mainSource;
    }
    return this.transact(() => {
      this.settings = this.makeValueConformToSchema(null, this.settings, {
        suppressException: true
      });
      const selectorsAndSettings = this.scopedSettingsStore.propertiesForSource(
        source
      );
      this.scopedSettingsStore.removePropertiesForSource(source);
      for (let scopeSelector in selectorsAndSettings) {
        let settings = selectorsAndSettings[scopeSelector];
        settings = this.makeValueConformToSchema(null, settings, {
          suppressException: true
        });
        this.setRawScopedValue(null, settings, source, scopeSelector);
      }
    });
  }
  priorityForSource(source) {
    switch (source) {
      case this.mainSource:
        return 1000;
      case this.projectFile:
        return 2000;
      default:
        return 0;
    }
  }
  emitChangeEvent() {
    if (this.transactDepth <= 0) {
      return this.emitter.emit('did-change');
    }
  }
  resetScopedSettings(newScopedSettings, options = {}) {
    const source = options.source == null ? this.mainSource : options.source;
    const priority = this.priorityForSource(source);
    this.scopedSettingsStore.removePropertiesForSource(source);
    for (let scopeSelector in newScopedSettings) {
      let settings = newScopedSettings[scopeSelector];
      settings = this.makeValueConformToSchema(null, settings, {
        suppressException: true
      });
      const validatedSettings = {};
      validatedSettings[scopeSelector] = withoutEmptyObjects(settings);
      if (validatedSettings[scopeSelector] != null) {
        this.scopedSettingsStore.addProperties(source, validatedSettings, {
          priority
        });
      }
    }
    return this.emitChangeEvent();
  }
  setRawScopedValue(keyPath, value, source, selector, options) {
    if (keyPath != null) {
      const newValue = {};
      setValueAtKeyPath(newValue, keyPath, value);
      value = newValue;
    }
    const settingsBySelector = {};
    settingsBySelector[selector] = value;
    this.scopedSettingsStore.addProperties(source, settingsBySelector, {
      priority: this.priorityForSource(source)
    });
    return this.emitChangeEvent();
  }
  getRawScopedValue(scopeDescriptor, keyPath, options) {
    scopeDescriptor = ScopeDescriptor.fromObject(scopeDescriptor);
    const result = this.scopedSettingsStore.getPropertyValue(
      scopeDescriptor.getScopeChain(),
      keyPath,
      options
    );
    const legacyScopeDescriptor = this.getLegacyScopeDescriptorForNewScopeDescriptor(
      scopeDescriptor
    );
    if (result != null) {
      return result;
    } else if (legacyScopeDescriptor) {
      return this.scopedSettingsStore.getPropertyValue(
        legacyScopeDescriptor.getScopeChain(),
        keyPath,
        options
      );
    }
  }
  observeScopedKeyPath(scope, keyPath, callback) {
    callback(this.get(keyPath, { scope }));
    return this.onDidChangeScopedKeyPath(scope, keyPath, event =>
      callback(event.newValue)
    );
  }
  onDidChangeScopedKeyPath(scope, keyPath, callback) {
    let oldValue = this.get(keyPath, { scope });
    return this.emitter.on('did-change', () => {
      const newValue = this.get(keyPath, { scope });
      if (!_.isEqual(oldValue, newValue)) {
        const event = { oldValue, newValue };
        oldValue = newValue;
        callback(event);
      }
    });
  }
}
Config.addSchemaEnforcers({
  any: {
    coerce(keyPath, value, schema) {
      return value;
    }
  },
  integer: {
    coerce(keyPath, value, schema) {
      value = parseInt(value);
      if (isNaN(value) || !isFinite(value)) {
        throw new Error(
          `Validation failed at ${keyPath}, ${JSON.stringify(
            value
          )} cannot be coerced into an int`
        );
      }
      return value;
    }
  },
  number: {
    coerce(keyPath, value, schema) {
      value = parseFloat(value);
      if (isNaN(value) || !isFinite(value)) {
        throw new Error(
          `Validation failed at ${keyPath}, ${JSON.stringify(
            value
          )} cannot be coerced into a number`
        );
      }
      return value;
    }
  },
  boolean: {
    coerce(keyPath, value, schema) {
      switch (typeof value) {
        case 'string':
          if (value.toLowerCase() === 'true') {
            return true;
          } else if (value.toLowerCase() === 'false') {
            return false;
          } else {
            throw new Error(
              `Validation failed at ${keyPath}, ${JSON.stringify(
                value
              )} must be a boolean or the string 'true' or 'false'`
            );
          }
        case 'boolean':
          return value;
        default:
          throw new Error(
            `Validation failed at ${keyPath}, ${JSON.stringify(
              value
            )} must be a boolean or the string 'true' or 'false'`
          );
      }
    }
  },
  string: {
    validate(keyPath, value, schema) {
      if (typeof value !== 'string') {
        throw new Error(
          `Validation failed at ${keyPath}, ${JSON.stringify(
            value
          )} must be a string`
        );
      }
      return value;
    },
    validateMaximumLength(keyPath, value, schema) {
      if (
        typeof schema.maximumLength === 'number' &&
        value.length > schema.maximumLength
      ) {
        return value.slice(0, schema.maximumLength);
      } else {
        return value;
      }
    }
  },
  null: {
    coerce(keyPath, value, schema) {
      if (![undefined, null].includes(value)) {
        throw new Error(
          `Validation failed at ${keyPath}, ${JSON.stringify(
            value
          )} must be null`
        );
      }
      return value;
    }
  },
  object: {
    coerce(keyPath, value, schema) {
      if (!isPlainObject(value)) {
        throw new Error(
          `Validation failed at ${keyPath}, ${JSON.stringify(
            value
          )} must be an object`
        );
      }
      if (schema.properties == null) {
        return value;
      }
      let defaultChildSchema = null;
      let allowsAdditionalProperties = true;
      if (isPlainObject(schema.additionalProperties)) {
        defaultChildSchema = schema.additionalProperties;
      }
      if (schema.additionalProperties === false) {
        allowsAdditionalProperties = false;
      }
      const newValue = {};
      for (let prop in value) {
        const propValue = value[prop];
        const childSchema =
          schema.properties[prop] != null
            ? schema.properties[prop]
            : defaultChildSchema;
        if (childSchema != null) {
          try {
            newValue[prop] = this.executeSchemaEnforcers(
              pushKeyPath(keyPath, prop),
              propValue,
              childSchema
            );
          } catch (error) {
            console.warn(`Error setting item in object: ${error.message}`);
          }
        } else if (allowsAdditionalProperties) {
          newValue[prop] = propValue;
        } else {
          console.warn(`Illegal object key: ${keyPath}.${prop}`);
        }
      }
      return newValue;
    }
  },
  array: {
    coerce(keyPath, value, schema) {
      if (!Array.isArray(value)) {
        throw new Error(
          `Validation failed at ${keyPath}, ${JSON.stringify(
            value
          )} must be an array`
        );
      }
      const itemSchema = schema.items;
      if (itemSchema != null) {
        const newValue = [];
        for (let item of value) {
          try {
            newValue.push(
              this.executeSchemaEnforcers(keyPath, item, itemSchema)
            );
          } catch (error) {
            console.warn(`Error setting item in array: ${error.message}`);
          }
        }
        return newValue;
      } else {
        return value;
      }
    }
  },
  color: {
    coerce(keyPath, value, schema) {
      const color = Color.parse(value);
      if (color == null) {
        throw new Error(
          `Validation failed at ${keyPath}, ${JSON.stringify(
            value
          )} cannot be coerced into a color`
        );
      }
      return color;
    }
  },
  '*': {
    coerceMinimumAndMaximum(keyPath, value, schema) {
      if (typeof value !== 'number') {
        return value;
      }
      if (schema.minimum != null && typeof schema.minimum === 'number') {
        value = Math.max(value, schema.minimum);
      }
      if (schema.maximum != null && typeof schema.maximum === 'number') {
        value = Math.min(value, schema.maximum);
      }
      return value;
    },
    validateEnum(keyPath, value, schema) {
      let possibleValues = schema.enum;
      if (Array.isArray(possibleValues)) {
        possibleValues = possibleValues.map(value => {
          if (value.hasOwnProperty('value')) {
            return value.value;
          } else {
            return value;
          }
        });
      }
      if (
        possibleValues == null ||
        !Array.isArray(possibleValues) ||
        !possibleValues.length
      ) {
        return value;
      }
      for (let possibleValue of possibleValues) {
        if (_.isEqual(possibleValue, value)) {
          return value;
        }
      }
      throw new Error(
        `Validation failed at ${keyPath}, ${JSON.stringify(
          value
        )} is not one of ${JSON.stringify(possibleValues)}`
      );
    }
  }
});
let isPlainObject = value =>
  _.isObject(value) &&
  !Array.isArray(value) &&
  !_.isFunction(value) &&
  !_.isString(value) &&
  !(value instanceof Color);
let sortObject = value => {
  if (!isPlainObject(value)) {
    return value;
  }
  const result = {};
  for (let key of Object.keys(value).sort()) {
    result[key] = sortObject(value[key]);
  }
  return result;
};
const withoutEmptyObjects = object => {
  let resultObject;
  if (isPlainObject(object)) {
    for (let key in object) {
      const value = object[key];
      const newValue = withoutEmptyObjects(value);
      if (newValue != null) {
        if (resultObject == null) {
          resultObject = {};
        }
        resultObject[key] = newValue;
      }
    }
  } else {
    resultObject = object;
  }
  return resultObject;
};
module.exports = Config;

================
File: src/context-menu-manager.js
================
const path = require('path');
const CSON = require('season');
const fs = require('fs-plus');
const {calculateSpecificity, validateSelector} = require('clear-cut');
const {Disposable} = require('event-kit');
const {remote} = require('electron');
const MenuHelpers = require('./menu-helpers');
const {sortMenuItems} = require('./menu-sort-helpers');
const _ = require('underscore-plus');
const buildMetadata = require('../package.json');
var platformContextMenu;
if (buildMetadata != null && buildMetadata._atomMenu != null && buildMetadata._atomMenu['context-menu']) {
  platformContextMenu = buildMetadata._atomMenu['context-menu'];
}
module.exports = class ContextMenuManager {
  constructor({keymapManager}) {
    this.keymapManager = keymapManager;
    this.definitions = {
      '.overlayer': []
    };
    this.clear();
    this.keymapManager.onDidLoadBundledKeymaps(() => this.loadPlatformItems());
  }
  initialize({resourcePath, devMode}) {
    this.resourcePath = resourcePath;
    this.devMode = devMode;
  }
  loadPlatformItems() {
    if (platformContextMenu != null) {
      return this.add(platformContextMenu, this.devMode || false);
    } else {
      const menusDirPath = path.join(this.resourcePath, 'menus');
      const platformMenuPath = fs.resolve(menusDirPath, process.platform, ['cson', 'json']);
      const map = CSON.readFileSync(platformMenuPath);
      return this.add(map['context-menu']);
    }
  }
  add(itemsBySelector, throwOnInvalidSelector = true) {
    const addedItemSets = [];
    for (let selector in itemsBySelector) {
      const items = itemsBySelector[selector];
      if (throwOnInvalidSelector) {
        validateSelector(selector);
      }
      const itemSet = new ContextMenuItemSet(selector, items);
      addedItemSets.push(itemSet);
      this.itemSets.push(itemSet);
    }
    return new Disposable(() => {
      for (let itemSet of addedItemSets) {
        this.itemSets.splice(this.itemSets.indexOf(itemSet), 1);
      }
    });
  }
  templateForElement(target) {
    return this.templateForEvent({target});
  }
  templateForEvent(event) {
    const template = [];
    let currentTarget = event.target;
    while (currentTarget != null) {
      const currentTargetItems = [];
      const matchingItemSets = this.itemSets.filter((itemSet) => currentTarget.webkitMatchesSelector(itemSet.selector));
      for (let itemSet of matchingItemSets) {
        for (let item of itemSet.items) {
          const itemForEvent = this.cloneItemForEvent(item, event);
          if (itemForEvent) {
            MenuHelpers.merge(currentTargetItems, itemForEvent, itemSet.specificity);
          }
        }
      }
      for (let item of currentTargetItems) {
        MenuHelpers.merge(template, item, false);
      }
      currentTarget = currentTarget.parentElement;
    }
    this.pruneRedundantSeparators(template);
    this.addAccelerators(template);
    return this.sortTemplate(template);
  }
  addAccelerators(template) {
    for (let id in template) {
      const item = template[id];
      if (item.command) {
        const keymaps = this.keymapManager.findKeyBindings({command: item.command, target: document.activeElement});
        const keystrokes = (keymaps && keymaps[0]) ? keymaps[0].keystrokes : undefined;
        if (keystrokes) {
          if (keystrokes.includes(' ')) {
            item.label += ` [${_.humanizeKeystroke(keystrokes)}]`;
          } else {
            item.accelerator = MenuHelpers.acceleratorForKeystroke(keystrokes);
          }
        }
      }
      if (Array.isArray(item.submenu)) {
        this.addAccelerators(item.submenu);
      }
    }
  }
  pruneRedundantSeparators(menu) {
    let keepNextItemIfSeparator = false;
    let index = 0;
    while (index < menu.length) {
      if (menu[index].type === 'separator') {
        if (!keepNextItemIfSeparator || index === menu.length - 1) {
          menu.splice(index, 1);
        } else {
          index++;
        }
      } else {
        keepNextItemIfSeparator = true;
        index++;
      }
    }
  }
  sortTemplate(template) {
    template = sortMenuItems(template);
    for (let id in template) {
      const item = template[id];
      if (Array.isArray(item.submenu)) {
        item.submenu = this.sortTemplate(item.submenu);
      }
    }
    return template;
  }
  cloneItemForEvent(item, event) {
    if (item.devMode && !this.devMode) {
      return null;
    }
    item = Object.create(item);
    if (typeof item.shouldDisplay === 'function' && !item.shouldDisplay(event)) {
      return null;
    }
    if (typeof item.created === "function") {
      item.created(event);
    }
    if (Array.isArray(item.submenu)) {
      item.submenu = item.submenu
        .map((submenuItem) => this.cloneItemForEvent(submenuItem, event))
        .filter((submenuItem) => submenuItem !== null);
    }
    return item;
  }
  showForEvent(event) {
    this.activeElement = event.target;
    const menuTemplate = this.templateForEvent(event);
    if (!(menuTemplate && menuTemplate.length > 0)) {
      return;
    }
    remote.getCurrentWindow().emit('context-menu', menuTemplate);
  }
  clear() {
    this.activeElement = null;
    this.itemSets = [];
    const inspectElement = {
      'atom-workspace': [
        {
          label: 'Inspect Element',
          command: 'application:inspect',
          devMode: true,
          created: function(event) {
            const {pageX, pageY} = event;
            this.commandDetail = {x: pageX, y: pageY};
          }
        }
      ]
    };
    this.add(inspectElement, false);
  }
};
var ContextMenuItemSet = class ContextMenuItemSet {
  constructor(selector1, items1) {
    this.selector = selector1;
    this.items = items1;
    this.specificity = calculateSpecificity(this.selector);
  }
};

================
File: src/core-uri-handlers.js
================
const fs = require('fs-plus');
function getLineColNumber(numStr) {
  const num = parseInt(numStr || 0, 10);
  return Math.max(num - 1, 0);
}
function openFile(atom, { query }) {
  const { filename, line, column } = query;
  atom.workspace.open(filename, {
    initialLine: getLineColNumber(line),
    initialColumn: getLineColNumber(column),
    searchAllPanes: true
  });
}
function windowShouldOpenFile({ query }) {
  const { filename } = query;
  const stat = fs.statSyncNoException(filename);
  return win =>
    win.containsLocation({
      pathToOpen: filename,
      exists: Boolean(stat),
      isFile: stat.isFile(),
      isDirectory: stat.isDirectory()
    });
}
const ROUTER = {
  '/open/file': { handler: openFile, getWindowPredicate: windowShouldOpenFile }
};
module.exports = {
  create(atomEnv) {
    return function coreURIHandler(parsed) {
      const config = ROUTER[parsed.pathname];
      if (config) {
        config.handler(atomEnv, parsed);
      }
    };
  },
  windowPredicate(parsed) {
    const config = ROUTER[parsed.pathname];
    if (config && config.getWindowPredicate) {
      return config.getWindowPredicate(parsed);
    } else {
      return () => true;
    }
  }
};

================
File: src/cursor.js
================
const { Point, Range } = require('text-buffer');
const { Emitter } = require('event-kit');
const _ = require('underscore-plus');
const Model = require('./model');
const EmptyLineRegExp = /(\r\n[\t ]*\r\n)|(\n[\t ]*\n)/g;
module.exports = class Cursor extends Model {
  constructor(params) {
    super(params);
    this.editor = params.editor;
    this.marker = params.marker;
    this.emitter = new Emitter();
  }
  destroy() {
    this.marker.destroy();
  }
  onDidChangePosition(callback) {
    return this.emitter.on('did-change-position', callback);
  }
  onDidDestroy(callback) {
    return this.emitter.once('did-destroy', callback);
  }
  setScreenPosition(screenPosition, options = {}) {
    this.changePosition(options, () => {
      this.marker.setHeadScreenPosition(screenPosition, options);
    });
  }
  getScreenPosition() {
    return this.marker.getHeadScreenPosition();
  }
  setBufferPosition(bufferPosition, options = {}) {
    this.changePosition(options, () => {
      this.marker.setHeadBufferPosition(bufferPosition, options);
    });
  }
  getBufferPosition() {
    return this.marker.getHeadBufferPosition();
  }
  getScreenRow() {
    return this.getScreenPosition().row;
  }
  getScreenColumn() {
    return this.getScreenPosition().column;
  }
  getBufferRow() {
    return this.getBufferPosition().row;
  }
  getBufferColumn() {
    return this.getBufferPosition().column;
  }
  getCurrentBufferLine() {
    return this.editor.lineTextForBufferRow(this.getBufferRow());
  }
  isAtBeginningOfLine() {
    return this.getBufferPosition().column === 0;
  }
  isAtEndOfLine() {
    return this.getBufferPosition().isEqual(
      this.getCurrentLineBufferRange().end
    );
  }
  getMarker() {
    return this.marker;
  }
  isSurroundedByWhitespace() {
    const { row, column } = this.getBufferPosition();
    const range = [[row, column - 1], [row, column + 1]];
    return /^\s+$/.test(this.editor.getTextInBufferRange(range));
  }
  isBetweenWordAndNonWord() {
    if (this.isAtBeginningOfLine() || this.isAtEndOfLine()) return false;
    const { row, column } = this.getBufferPosition();
    const range = [[row, column - 1], [row, column + 1]];
    const text = this.editor.getTextInBufferRange(range);
    if (/\s/.test(text[0]) || /\s/.test(text[1])) return false;
    const nonWordCharacters = this.getNonWordCharacters();
    return (
      nonWordCharacters.includes(text[0]) !==
      nonWordCharacters.includes(text[1])
    );
  }
  isInsideWord(options) {
    const { row, column } = this.getBufferPosition();
    const range = [[row, column], [row, Infinity]];
    const text = this.editor.getTextInBufferRange(range);
    return (
      text.search((options && options.wordRegex) || this.wordRegExp()) === 0
    );
  }
  getIndentLevel() {
    if (this.editor.getSoftTabs()) {
      return this.getBufferColumn() / this.editor.getTabLength();
    } else {
      return this.getBufferColumn();
    }
  }
  getScopeDescriptor() {
    return this.editor.scopeDescriptorForBufferPosition(
      this.getBufferPosition()
    );
  }
  getSyntaxTreeScopeDescriptor() {
    return this.editor.syntaxTreeScopeDescriptorForBufferPosition(
      this.getBufferPosition()
    );
  }
  hasPrecedingCharactersOnLine() {
    const bufferPosition = this.getBufferPosition();
    const line = this.editor.lineTextForBufferRow(bufferPosition.row);
    const firstCharacterColumn = line.search(/\S/);
    if (firstCharacterColumn === -1) {
      return false;
    } else {
      return bufferPosition.column > firstCharacterColumn;
    }
  }
  isLastCursor() {
    return this === this.editor.getLastCursor();
  }
  moveUp(rowCount = 1, { moveToEndOfSelection } = {}) {
    let row, column;
    const range = this.marker.getScreenRange();
    if (moveToEndOfSelection && !range.isEmpty()) {
      ({ row, column } = range.start);
    } else {
      ({ row, column } = this.getScreenPosition());
    }
    if (this.goalColumn != null) column = this.goalColumn;
    this.setScreenPosition(
      { row: row - rowCount, column },
      { skipSoftWrapIndentation: true }
    );
    this.goalColumn = column;
  }
  moveDown(rowCount = 1, { moveToEndOfSelection } = {}) {
    let row, column;
    const range = this.marker.getScreenRange();
    if (moveToEndOfSelection && !range.isEmpty()) {
      ({ row, column } = range.end);
    } else {
      ({ row, column } = this.getScreenPosition());
    }
    if (this.goalColumn != null) column = this.goalColumn;
    this.setScreenPosition(
      { row: row + rowCount, column },
      { skipSoftWrapIndentation: true }
    );
    this.goalColumn = column;
  }
  moveLeft(columnCount = 1, { moveToEndOfSelection } = {}) {
    const range = this.marker.getScreenRange();
    if (moveToEndOfSelection && !range.isEmpty()) {
      this.setScreenPosition(range.start);
    } else {
      let { row, column } = this.getScreenPosition();
      while (columnCount > column && row > 0) {
        columnCount -= column;
        column = this.editor.lineLengthForScreenRow(--row);
        columnCount--;
      }
      column = column - columnCount;
      this.setScreenPosition({ row, column }, { clipDirection: 'backward' });
    }
  }
  moveRight(columnCount = 1, { moveToEndOfSelection } = {}) {
    const range = this.marker.getScreenRange();
    if (moveToEndOfSelection && !range.isEmpty()) {
      this.setScreenPosition(range.end);
    } else {
      let { row, column } = this.getScreenPosition();
      const maxLines = this.editor.getScreenLineCount();
      let rowLength = this.editor.lineLengthForScreenRow(row);
      let columnsRemainingInLine = rowLength - column;
      while (columnCount > columnsRemainingInLine && row < maxLines - 1) {
        columnCount -= columnsRemainingInLine;
        columnCount--;
        column = 0;
        rowLength = this.editor.lineLengthForScreenRow(++row);
        columnsRemainingInLine = rowLength;
      }
      column = column + columnCount;
      this.setScreenPosition({ row, column }, { clipDirection: 'forward' });
    }
  }
  moveToTop() {
    this.setBufferPosition([0, 0]);
  }
  moveToBottom() {
    const column = this.goalColumn;
    this.setBufferPosition(this.editor.getEofBufferPosition());
    this.goalColumn = column;
  }
  moveToBeginningOfScreenLine() {
    this.setScreenPosition([this.getScreenRow(), 0]);
  }
  moveToBeginningOfLine() {
    this.setBufferPosition([this.getBufferRow(), 0]);
  }
  moveToFirstCharacterOfLine() {
    let targetBufferColumn;
    const screenRow = this.getScreenRow();
    const screenLineStart = this.editor.clipScreenPosition([screenRow, 0], {
      skipSoftWrapIndentation: true
    });
    const screenLineEnd = [screenRow, Infinity];
    const screenLineBufferRange = this.editor.bufferRangeForScreenRange([
      screenLineStart,
      screenLineEnd
    ]);
    let firstCharacterColumn = null;
    this.editor.scanInBufferRange(
      /\S/,
      screenLineBufferRange,
      ({ range, stop }) => {
        firstCharacterColumn = range.start.column;
        stop();
      }
    );
    if (
      firstCharacterColumn != null &&
      firstCharacterColumn !== this.getBufferColumn()
    ) {
      targetBufferColumn = firstCharacterColumn;
    } else {
      targetBufferColumn = screenLineBufferRange.start.column;
    }
    this.setBufferPosition([
      screenLineBufferRange.start.row,
      targetBufferColumn
    ]);
  }
  moveToEndOfScreenLine() {
    this.setScreenPosition([this.getScreenRow(), Infinity]);
  }
  moveToEndOfLine() {
    this.setBufferPosition([this.getBufferRow(), Infinity]);
  }
  moveToBeginningOfWord() {
    this.setBufferPosition(this.getBeginningOfCurrentWordBufferPosition());
  }
  moveToEndOfWord() {
    const position = this.getEndOfCurrentWordBufferPosition();
    if (position) this.setBufferPosition(position);
  }
  moveToBeginningOfNextWord() {
    const position = this.getBeginningOfNextWordBufferPosition();
    if (position) this.setBufferPosition(position);
  }
  moveToPreviousWordBoundary() {
    const position = this.getPreviousWordBoundaryBufferPosition();
    if (position) this.setBufferPosition(position);
  }
  moveToNextWordBoundary() {
    const position = this.getNextWordBoundaryBufferPosition();
    if (position) this.setBufferPosition(position);
  }
  moveToPreviousSubwordBoundary() {
    const options = { wordRegex: this.subwordRegExp({ backwards: true }) };
    const position = this.getPreviousWordBoundaryBufferPosition(options);
    if (position) this.setBufferPosition(position);
  }
  moveToNextSubwordBoundary() {
    const options = { wordRegex: this.subwordRegExp() };
    const position = this.getNextWordBoundaryBufferPosition(options);
    if (position) this.setBufferPosition(position);
  }
  skipLeadingWhitespace() {
    const position = this.getBufferPosition();
    const scanRange = this.getCurrentLineBufferRange();
    let endOfLeadingWhitespace = null;
    this.editor.scanInBufferRange(/^[ \t]*/, scanRange, ({ range }) => {
      endOfLeadingWhitespace = range.end;
    });
    if (endOfLeadingWhitespace.isGreaterThan(position))
      this.setBufferPosition(endOfLeadingWhitespace);
  }
  moveToBeginningOfNextParagraph() {
    const position = this.getBeginningOfNextParagraphBufferPosition();
    if (position) this.setBufferPosition(position);
  }
  moveToBeginningOfPreviousParagraph() {
    const position = this.getBeginningOfPreviousParagraphBufferPosition();
    if (position) this.setBufferPosition(position);
  }
  getPreviousWordBoundaryBufferPosition(options = {}) {
    const currentBufferPosition = this.getBufferPosition();
    const previousNonBlankRow = this.editor.buffer.previousNonBlankRow(
      currentBufferPosition.row
    );
    const scanRange = Range(
      Point(previousNonBlankRow || 0, 0),
      currentBufferPosition
    );
    const ranges = this.editor.buffer.findAllInRangeSync(
      options.wordRegex || this.wordRegExp(),
      scanRange
    );
    const range = ranges[ranges.length - 1];
    if (range) {
      if (
        range.start.row < currentBufferPosition.row &&
        currentBufferPosition.column > 0
      ) {
        return Point(currentBufferPosition.row, 0);
      } else if (currentBufferPosition.isGreaterThan(range.end)) {
        return Point.fromObject(range.end);
      } else {
        return Point.fromObject(range.start);
      }
    } else {
      return currentBufferPosition;
    }
  }
  getNextWordBoundaryBufferPosition(options = {}) {
    const currentBufferPosition = this.getBufferPosition();
    const scanRange = Range(
      currentBufferPosition,
      this.editor.getEofBufferPosition()
    );
    const range = this.editor.buffer.findInRangeSync(
      options.wordRegex || this.wordRegExp(),
      scanRange
    );
    if (range) {
      if (range.start.row > currentBufferPosition.row) {
        return Point(range.start.row, 0);
      } else if (currentBufferPosition.isLessThan(range.start)) {
        return Point.fromObject(range.start);
      } else {
        return Point.fromObject(range.end);
      }
    } else {
      return currentBufferPosition;
    }
  }
  getBeginningOfCurrentWordBufferPosition(options = {}) {
    const allowPrevious = options.allowPrevious !== false;
    const position = this.getBufferPosition();
    const scanRange = allowPrevious
      ? new Range(new Point(position.row - 1, 0), position)
      : new Range(new Point(position.row, 0), position);
    const ranges = this.editor.buffer.findAllInRangeSync(
      options.wordRegex || this.wordRegExp(options),
      scanRange
    );
    let result;
    for (let range of ranges) {
      if (position.isLessThanOrEqual(range.start)) break;
      if (allowPrevious || position.isLessThanOrEqual(range.end))
        result = Point.fromObject(range.start);
    }
    return result || (allowPrevious ? new Point(0, 0) : position);
  }
  getEndOfCurrentWordBufferPosition(options = {}) {
    const allowNext = options.allowNext !== false;
    const position = this.getBufferPosition();
    const scanRange = allowNext
      ? new Range(position, new Point(position.row + 2, 0))
      : new Range(position, new Point(position.row, Infinity));
    const ranges = this.editor.buffer.findAllInRangeSync(
      options.wordRegex || this.wordRegExp(options),
      scanRange
    );
    for (let range of ranges) {
      if (position.isLessThan(range.start) && !allowNext) break;
      if (position.isLessThan(range.end)) return Point.fromObject(range.end);
    }
    return allowNext ? this.editor.getEofBufferPosition() : position;
  }
  getBeginningOfNextWordBufferPosition(options = {}) {
    const currentBufferPosition = this.getBufferPosition();
    const start = this.isInsideWord(options)
      ? this.getEndOfCurrentWordBufferPosition(options)
      : currentBufferPosition;
    const scanRange = [start, this.editor.getEofBufferPosition()];
    let beginningOfNextWordPosition;
    this.editor.scanInBufferRange(
      options.wordRegex || this.wordRegExp(),
      scanRange,
      ({ range, stop }) => {
        beginningOfNextWordPosition = range.start;
        stop();
      }
    );
    return beginningOfNextWordPosition || currentBufferPosition;
  }
  getCurrentWordBufferRange(options = {}) {
    const position = this.getBufferPosition();
    const ranges = this.editor.buffer.findAllInRangeSync(
      options.wordRegex || this.wordRegExp(options),
      new Range(new Point(position.row, 0), new Point(position.row, Infinity))
    );
    const range = ranges.find(
      range =>
        range.end.column >= position.column &&
        range.start.column <= position.column
    );
    return range ? Range.fromObject(range) : new Range(position, position);
  }
  getCurrentLineBufferRange(options) {
    return this.editor.bufferRangeForBufferRow(this.getBufferRow(), options);
  }
  getCurrentParagraphBufferRange() {
    return this.editor.rowRangeForParagraphAtBufferRow(this.getBufferRow());
  }
  getCurrentWordPrefix() {
    return this.editor.getTextInBufferRange([
      this.getBeginningOfCurrentWordBufferPosition(),
      this.getBufferPosition()
    ]);
  }
  compare(otherCursor) {
    return this.getBufferPosition().compare(otherCursor.getBufferPosition());
  }
  clearSelection(options) {
    if (this.selection) this.selection.clear(options);
  }
  wordRegExp(options) {
    const nonWordCharacters = _.escapeRegExp(this.getNonWordCharacters());
    let source = `^[\t ]*$|[^\\s${nonWordCharacters}]+`;
    if (!options || options.includeNonWordCharacters !== false) {
      source += `|${`[${nonWordCharacters}]+`}`;
    }
    return new RegExp(source, 'g');
  }
  subwordRegExp(options = {}) {
    const nonWordCharacters = this.getNonWordCharacters();
    const lowercaseLetters = 'a-z\\u00DF-\\u00F6\\u00F8-\\u00FF';
    const uppercaseLetters = 'A-Z\\u00C0-\\u00D6\\u00D8-\\u00DE';
    const snakeCamelSegment = `[${uppercaseLetters}]?[${lowercaseLetters}]+`;
    const segments = [
      '^[\t ]+',
      '[\t ]+$',
      `[${uppercaseLetters}]+(?![${lowercaseLetters}])`,
      '\\d+'
    ];
    if (options.backwards) {
      segments.push(`${snakeCamelSegment}_*`);
      segments.push(`[${_.escapeRegExp(nonWordCharacters)}]+\\s*`);
    } else {
      segments.push(`_*${snakeCamelSegment}`);
      segments.push(`\\s*[${_.escapeRegExp(nonWordCharacters)}]+`);
    }
    segments.push('_+');
    return new RegExp(segments.join('|'), 'g');
  }
  getNonWordCharacters() {
    return this.editor.getNonWordCharacters(this.getBufferPosition());
  }
  changePosition(options, fn) {
    this.clearSelection({ autoscroll: false });
    fn();
    this.goalColumn = null;
    const autoscroll =
      options && options.autoscroll != null
        ? options.autoscroll
        : this.isLastCursor();
    if (autoscroll) this.autoscroll();
  }
  getScreenRange() {
    const { row, column } = this.getScreenPosition();
    return new Range(new Point(row, column), new Point(row, column + 1));
  }
  autoscroll(options = {}) {
    options.clip = false;
    this.editor.scrollToScreenRange(this.getScreenRange(), options);
  }
  getBeginningOfNextParagraphBufferPosition() {
    const start = this.getBufferPosition();
    const eof = this.editor.getEofBufferPosition();
    const scanRange = [start, eof];
    const { row, column } = eof;
    let position = new Point(row, column - 1);
    this.editor.scanInBufferRange(
      EmptyLineRegExp,
      scanRange,
      ({ range, stop }) => {
        position = range.start.traverse(Point(1, 0));
        if (!position.isEqual(start)) stop();
      }
    );
    return position;
  }
  getBeginningOfPreviousParagraphBufferPosition() {
    const start = this.getBufferPosition();
    const { row, column } = start;
    const scanRange = [[row - 1, column], [0, 0]];
    let position = new Point(0, 0);
    this.editor.backwardsScanInBufferRange(
      EmptyLineRegExp,
      scanRange,
      ({ range, stop }) => {
        position = range.start.traverse(Point(1, 0));
        if (!position.isEqual(start)) stop();
      }
    );
    return position;
  }
};

================
File: src/decoration-manager.js
================
const { Emitter } = require('event-kit');
const Decoration = require('./decoration');
const LayerDecoration = require('./layer-decoration');
module.exports = class DecorationManager {
  constructor(editor) {
    this.editor = editor;
    this.displayLayer = this.editor.displayLayer;
    this.emitter = new Emitter();
    this.decorationCountsByLayer = new Map();
    this.markerDecorationCountsByLayer = new Map();
    this.decorationsByMarker = new Map();
    this.layerDecorationsByMarkerLayer = new Map();
    this.overlayDecorations = new Set();
    this.layerUpdateDisposablesByLayer = new WeakMap();
  }
  observeDecorations(callback) {
    const decorations = this.getDecorations();
    for (let i = 0; i < decorations.length; i++) {
      callback(decorations[i]);
    }
    return this.onDidAddDecoration(callback);
  }
  onDidAddDecoration(callback) {
    return this.emitter.on('did-add-decoration', callback);
  }
  onDidRemoveDecoration(callback) {
    return this.emitter.on('did-remove-decoration', callback);
  }
  onDidUpdateDecorations(callback) {
    return this.emitter.on('did-update-decorations', callback);
  }
  getDecorations(propertyFilter) {
    let allDecorations = [];
    this.decorationsByMarker.forEach(decorations => {
      decorations.forEach(decoration => allDecorations.push(decoration));
    });
    if (propertyFilter != null) {
      allDecorations = allDecorations.filter(function(decoration) {
        for (let key in propertyFilter) {
          const value = propertyFilter[key];
          if (decoration.properties[key] !== value) return false;
        }
        return true;
      });
    }
    return allDecorations;
  }
  getLineDecorations(propertyFilter) {
    return this.getDecorations(propertyFilter).filter(decoration =>
      decoration.isType('line')
    );
  }
  getLineNumberDecorations(propertyFilter) {
    return this.getDecorations(propertyFilter).filter(decoration =>
      decoration.isType('line-number')
    );
  }
  getHighlightDecorations(propertyFilter) {
    return this.getDecorations(propertyFilter).filter(decoration =>
      decoration.isType('highlight')
    );
  }
  getOverlayDecorations(propertyFilter) {
    const result = [];
    result.push(...Array.from(this.overlayDecorations));
    if (propertyFilter != null) {
      return result.filter(function(decoration) {
        for (let key in propertyFilter) {
          const value = propertyFilter[key];
          if (decoration.properties[key] !== value) {
            return false;
          }
        }
        return true;
      });
    } else {
      return result;
    }
  }
  decorationPropertiesByMarkerForScreenRowRange(startScreenRow, endScreenRow) {
    const decorationPropertiesByMarker = new Map();
    this.decorationCountsByLayer.forEach((count, markerLayer) => {
      const markers = markerLayer.findMarkers({
        intersectsScreenRowRange: [startScreenRow, endScreenRow - 1]
      });
      const layerDecorations = this.layerDecorationsByMarkerLayer.get(
        markerLayer
      );
      const hasMarkerDecorations =
        this.markerDecorationCountsByLayer.get(markerLayer) > 0;
      for (let i = 0; i < markers.length; i++) {
        const marker = markers[i];
        if (!marker.isValid()) continue;
        let decorationPropertiesForMarker = decorationPropertiesByMarker.get(
          marker
        );
        if (decorationPropertiesForMarker == null) {
          decorationPropertiesForMarker = [];
          decorationPropertiesByMarker.set(
            marker,
            decorationPropertiesForMarker
          );
        }
        if (layerDecorations) {
          layerDecorations.forEach(layerDecoration => {
            const properties =
              layerDecoration.getPropertiesForMarker(marker) ||
              layerDecoration.getProperties();
            decorationPropertiesForMarker.push(properties);
          });
        }
        if (hasMarkerDecorations) {
          const decorationsForMarker = this.decorationsByMarker.get(marker);
          if (decorationsForMarker) {
            decorationsForMarker.forEach(decoration => {
              decorationPropertiesForMarker.push(decoration.getProperties());
            });
          }
        }
      }
    });
    return decorationPropertiesByMarker;
  }
  decorationsForScreenRowRange(startScreenRow, endScreenRow) {
    const decorationsByMarkerId = {};
    for (const layer of this.decorationCountsByLayer.keys()) {
      for (const marker of layer.findMarkers({
        intersectsScreenRowRange: [startScreenRow, endScreenRow]
      })) {
        const decorations = this.decorationsByMarker.get(marker);
        if (decorations) {
          decorationsByMarkerId[marker.id] = Array.from(decorations);
        }
      }
    }
    return decorationsByMarkerId;
  }
  decorationsStateForScreenRowRange(startScreenRow, endScreenRow) {
    const decorationsState = {};
    for (const layer of this.decorationCountsByLayer.keys()) {
      for (const marker of layer.findMarkers({
        intersectsScreenRowRange: [startScreenRow, endScreenRow]
      })) {
        if (marker.isValid()) {
          const screenRange = marker.getScreenRange();
          const bufferRange = marker.getBufferRange();
          const rangeIsReversed = marker.isReversed();
          const decorations = this.decorationsByMarker.get(marker);
          if (decorations) {
            decorations.forEach(decoration => {
              decorationsState[decoration.id] = {
                properties: decoration.properties,
                screenRange,
                bufferRange,
                rangeIsReversed
              };
            });
          }
          const layerDecorations = this.layerDecorationsByMarkerLayer.get(
            layer
          );
          if (layerDecorations) {
            layerDecorations.forEach(layerDecoration => {
              const properties =
                layerDecoration.getPropertiesForMarker(marker) ||
                layerDecoration.getProperties();
              decorationsState[`${layerDecoration.id}-${marker.id}`] = {
                properties,
                screenRange,
                bufferRange,
                rangeIsReversed
              };
            });
          }
        }
      }
    }
    return decorationsState;
  }
  decorateMarker(marker, decorationParams) {
    if (marker.isDestroyed()) {
      const error = new Error('Cannot decorate a destroyed marker');
      error.metadata = { markerLayerIsDestroyed: marker.layer.isDestroyed() };
      if (marker.destroyStackTrace != null) {
        error.metadata.destroyStackTrace = marker.destroyStackTrace;
      }
      if (
        marker.bufferMarker != null &&
        marker.bufferMarker.destroyStackTrace != null
      ) {
        error.metadata.destroyStackTrace =
          marker.bufferMarker.destroyStackTrace;
      }
      throw error;
    }
    marker = this.displayLayer
      .getMarkerLayer(marker.layer.id)
      .getMarker(marker.id);
    const decoration = new Decoration(marker, this, decorationParams);
    let decorationsForMarker = this.decorationsByMarker.get(marker);
    if (!decorationsForMarker) {
      decorationsForMarker = new Set();
      this.decorationsByMarker.set(marker, decorationsForMarker);
    }
    decorationsForMarker.add(decoration);
    if (decoration.isType('overlay')) this.overlayDecorations.add(decoration);
    this.observeDecoratedLayer(marker.layer, true);
    this.editor.didAddDecoration(decoration);
    this.emitDidUpdateDecorations();
    this.emitter.emit('did-add-decoration', decoration);
    return decoration;
  }
  decorateMarkerLayer(markerLayer, decorationParams) {
    if (markerLayer.isDestroyed()) {
      throw new Error('Cannot decorate a destroyed marker layer');
    }
    markerLayer = this.displayLayer.getMarkerLayer(markerLayer.id);
    const decoration = new LayerDecoration(markerLayer, this, decorationParams);
    let layerDecorations = this.layerDecorationsByMarkerLayer.get(markerLayer);
    if (layerDecorations == null) {
      layerDecorations = new Set();
      this.layerDecorationsByMarkerLayer.set(markerLayer, layerDecorations);
    }
    layerDecorations.add(decoration);
    this.observeDecoratedLayer(markerLayer, false);
    this.emitDidUpdateDecorations();
    return decoration;
  }
  emitDidUpdateDecorations() {
    this.editor.scheduleComponentUpdate();
    this.emitter.emit('did-update-decorations');
  }
  decorationDidChangeType(decoration) {
    if (decoration.isType('overlay')) {
      this.overlayDecorations.add(decoration);
    } else {
      this.overlayDecorations.delete(decoration);
    }
  }
  didDestroyMarkerDecoration(decoration) {
    const { marker } = decoration;
    const decorations = this.decorationsByMarker.get(marker);
    if (decorations && decorations.has(decoration)) {
      decorations.delete(decoration);
      if (decorations.size === 0) this.decorationsByMarker.delete(marker);
      this.overlayDecorations.delete(decoration);
      this.unobserveDecoratedLayer(marker.layer, true);
      this.emitter.emit('did-remove-decoration', decoration);
      this.emitDidUpdateDecorations();
    }
  }
  didDestroyLayerDecoration(decoration) {
    const { markerLayer } = decoration;
    const decorations = this.layerDecorationsByMarkerLayer.get(markerLayer);
    if (decorations && decorations.has(decoration)) {
      decorations.delete(decoration);
      if (decorations.size === 0) {
        this.layerDecorationsByMarkerLayer.delete(markerLayer);
      }
      this.unobserveDecoratedLayer(markerLayer, true);
      this.emitDidUpdateDecorations();
    }
  }
  observeDecoratedLayer(layer, isMarkerDecoration) {
    const newCount = (this.decorationCountsByLayer.get(layer) || 0) + 1;
    this.decorationCountsByLayer.set(layer, newCount);
    if (newCount === 1) {
      this.layerUpdateDisposablesByLayer.set(
        layer,
        layer.onDidUpdate(this.emitDidUpdateDecorations.bind(this))
      );
    }
    if (isMarkerDecoration) {
      this.markerDecorationCountsByLayer.set(
        layer,
        (this.markerDecorationCountsByLayer.get(layer) || 0) + 1
      );
    }
  }
  unobserveDecoratedLayer(layer, isMarkerDecoration) {
    const newCount = this.decorationCountsByLayer.get(layer) - 1;
    if (newCount === 0) {
      this.layerUpdateDisposablesByLayer.get(layer).dispose();
      this.decorationCountsByLayer.delete(layer);
    } else {
      this.decorationCountsByLayer.set(layer, newCount);
    }
    if (isMarkerDecoration) {
      this.markerDecorationCountsByLayer.set(
        this.markerDecorationCountsByLayer.get(layer) - 1
      );
    }
  }
};

================
File: src/decoration.js
================
const { Emitter } = require('event-kit');
let idCounter = 0;
const nextId = () => idCounter++;
const normalizeDecorationProperties = function (decoration, decorationParams) {
  decorationParams.id = decoration.id;
  if (
    decorationParams.type === 'line-number' &&
    decorationParams.gutterName == null
  ) {
    decorationParams.gutterName = 'line-number';
  }
  if (decorationParams.order == null) {
    decorationParams.order = Infinity;
  }
  return decorationParams;
};
module.exports = class Decoration {
  static isType(decorationProperties, type) {
    if (Array.isArray(decorationProperties.type)) {
      if (decorationProperties.type.includes(type)) {
        return true;
      }
      if (
        type === 'gutter' &&
        decorationProperties.type.includes('line-number')
      ) {
        return true;
      }
      return false;
    } else {
      if (type === 'gutter') {
        return ['gutter', 'line-number'].includes(decorationProperties.type);
      } else {
        return type === decorationProperties.type;
      }
    }
  }
  constructor(marker, decorationManager, properties) {
    this.marker = marker;
    this.decorationManager = decorationManager;
    this.emitter = new Emitter();
    this.id = nextId();
    this.setProperties(properties);
    this.destroyed = false;
    this.markerDestroyDisposable = this.marker.onDidDestroy(() =>
      this.destroy()
    );
  }
  destroy() {
    if (this.destroyed) {
      return;
    }
    this.markerDestroyDisposable.dispose();
    this.markerDestroyDisposable = null;
    this.destroyed = true;
    this.decorationManager.didDestroyMarkerDecoration(this);
    this.emitter.emit('did-destroy');
    return this.emitter.dispose();
  }
  isDestroyed() {
    return this.destroyed;
  }
  onDidChangeProperties(callback) {
    return this.emitter.on('did-change-properties', callback);
  }
  onDidDestroy(callback) {
    return this.emitter.once('did-destroy', callback);
  }
  getId() {
    return this.id;
  }
  getMarker() {
    return this.marker;
  }
  isType(type) {
    return Decoration.isType(this.properties, type);
  }
  getProperties() {
    return this.properties;
  }
  setProperties(newProperties) {
    if (this.destroyed) {
      return;
    }
    const oldProperties = this.properties;
    this.properties = normalizeDecorationProperties(this, newProperties);
    if (newProperties.type != null) {
      this.decorationManager.decorationDidChangeType(this);
    }
    this.decorationManager.emitDidUpdateDecorations();
    return this.emitter.emit('did-change-properties', {
      oldProperties,
      newProperties
    });
  }
  inspect() {
    return `<Decoration ${this.id}>`;
  }
  matchesPattern(decorationPattern) {
    if (decorationPattern == null) {
      return false;
    }
    for (let key in decorationPattern) {
      const value = decorationPattern[key];
      if (this.properties[key] !== value) {
        return false;
      }
    }
    return true;
  }
  flash(klass, duration) {
    if (duration == null) {
      duration = 500;
    }
    this.properties.flashRequested = true;
    this.properties.flashClass = klass;
    this.properties.flashDuration = duration;
    this.decorationManager.emitDidUpdateDecorations();
    return this.emitter.emit('did-flash');
  }
};

================
File: src/default-directory-provider.js
================
const {Directory} = require('pathwatcher');
const fs = require('fs-plus');
const path = require('path');
const url = require('url');
module.exports = class DefaultDirectoryProvider {
  directoryForURISync(uri) {
    const normalizedPath = this.normalizePath(uri);
    const {host} = url.parse(uri);
    let directoryPath;
    if (host) {
       directoryPath = uri;
    }
    else if (!fs.isDirectorySync(normalizedPath) && fs.isDirectorySync(path.dirname(normalizedPath))) {
      directoryPath = path.dirname(normalizedPath);
    }
    else {
      directoryPath = normalizedPath;
    }
    const directory = new Directory(directoryPath);
    if (host) {
      directory.path = directoryPath;
      if (fs.isCaseInsensitive()) {
        directory.lowerCasePath = directoryPath.toLowerCase();
      }
    }
    return directory;
  }
  directoryForURI(uri) {
    return Promise.resolve(this.directoryForURISync(uri));
  }
  normalizePath(uri) {
    let matchData, pathWithNormalizedDiskDriveLetter;
    pathWithNormalizedDiskDriveLetter = uri;
    if (process.platform === 'win32' && (matchData = uri.match(/^([a-z]):/))) {
      pathWithNormalizedDiskDriveLetter = `${matchData[1].toUpperCase()}${uri.slice(1)}`;
    }
    return path.normalize(pathWithNormalizedDiskDriveLetter);
  }
};

================
File: src/default-directory-searcher.js
================
const Task = require('./task');
class DirectorySearch {
  constructor(rootPaths, regex, options) {
    const scanHandlerOptions = {
      ignoreCase: regex.ignoreCase,
      inclusions: options.inclusions,
      includeHidden: options.includeHidden,
      excludeVcsIgnores: options.excludeVcsIgnores,
      globalExclusions: options.exclusions,
      follow: options.follow
    };
    const searchOptions = {
      leadingContextLineCount: options.leadingContextLineCount,
      trailingContextLineCount: options.trailingContextLineCount
    };
    this.task = new Task(require.resolve('./scan-handler'));
    this.task.on('scan:result-found', options.didMatch);
    this.task.on('scan:file-error', options.didError);
    this.task.on('scan:paths-searched', options.didSearchPaths);
    this.promise = new Promise((resolve, reject) => {
      this.task.on('task:cancelled', reject);
      this.task.start(
        rootPaths,
        regex.source,
        scanHandlerOptions,
        searchOptions,
        () => {
          this.task.terminate();
          resolve();
        }
      );
    });
  }
  then(...args) {
    return this.promise.then.apply(this.promise, args);
  }
  cancel() {
    this.task.cancel();
  }
}
module.exports = class DefaultDirectorySearcher {
  canSearchDirectory(directory) {
    return true;
  }
  search(directories, regex, options) {
    const rootPaths = directories.map(directory => directory.getPath());
    let isCancelled = false;
    const directorySearch = new DirectorySearch(rootPaths, regex, options);
    const promise = new Promise(function(resolve, reject) {
      directorySearch.then(resolve, function() {
        if (isCancelled) {
          resolve();
        } else {
          reject();
        }
      });
    });
    return {
      then: promise.then.bind(promise),
      catch: promise.catch.bind(promise),
      cancel() {
        isCancelled = true;
        directorySearch.cancel();
      }
    };
  }
};

================
File: src/delegated-listener.js
================
const EventKit = require('event-kit');
module.exports = function listen(element, eventName, selector, handler) {
  const innerHandler = function(event) {
    if (selector) {
      var currentTarget = event.target;
      while (currentTarget) {
        if (currentTarget.matches && currentTarget.matches(selector)) {
          handler({
            type: event.type,
            currentTarget: currentTarget,
            target: event.target,
            preventDefault: function() {
              event.preventDefault();
            },
            originalEvent: event
          });
        }
        if (currentTarget === element) break;
        currentTarget = currentTarget.parentNode;
      }
    } else {
      handler({
        type: event.type,
        currentTarget: event.currentTarget,
        target: event.target,
        preventDefault: function() {
          event.preventDefault();
        },
        originalEvent: event
      });
    }
  };
  element.addEventListener(eventName, innerHandler);
  return new EventKit.Disposable(function() {
    element.removeEventListener(eventName, innerHandler);
  });
};

================
File: src/deprecated-syntax-selectors.js
================
module.exports = new Set([
  'AFDKO',
  'AFKDO',
  'ASS',
  'AVX',
  'AVX2',
  'AVX512',
  'AVX512BW',
  'AVX512DQ',
  'Alignment',
  'Alpha',
  'AlphaLevel',
  'Angle',
  'Animation',
  'AnimationGroup',
  'ArchaeologyDigSiteFrame',
  'Arrow__',
  'AtLilyPond',
  'AttrBaseType',
  'AttrSetVal__',
  'BackColour',
  'Banner',
  'Bold',
  'Bonlang',
  'BorderStyle',
  'Browser',
  'Button',
  'C99',
  'CALCULATE',
  'CharacterSet',
  'ChatScript',
  'Chatscript',
  'CheckButton',
  'ClipboardFormat',
  'ClipboardType',
  'Clipboard__',
  'CodePage',
  'Codepages__',
  'Collisions',
  'ColorSelect',
  'ColourActual',
  'ColourLogical',
  'ColourReal',
  'ColourScheme',
  'ColourSize',
  'Column',
  'Comment',
  'ConfCachePolicy',
  'ControlPoint',
  'Cooldown',
  'DBE',
  'DDL',
  'DML',
  'DSC',
  'Database__',
  'DdcMode',
  'Dialogue',
  'DiscussionFilterType',
  'DiscussionStatus',
  'DisplaySchemes',
  'Document-Structuring-Comment',
  'DressUpModel',
  'Edit',
  'EditBox',
  'Effect',
  'Encoding',
  'End',
  'ExternalLinkBehaviour',
  'ExternalLinkDirection',
  'F16c',
  'FMA',
  'FilterType',
  'Font',
  'FontInstance',
  'FontString',
  'Fontname',
  'Fonts__',
  'Fontsize',
  'Format',
  'Frame',
  'GameTooltip',
  'GroupList',
  'HLE',
  'HeaderEvent',
  'HistoryType',
  'HttpVerb',
  'II',
  'IO',
  'Icon',
  'IconID',
  'InPlaceBox__',
  'InPlaceEditEvent',
  'Info',
  'Italic',
  'JSXEndTagStart',
  'JSXStartTagEnd',
  'KNC',
  'KeyModifier',
  'Kotlin',
  'LUW',
  'Language',
  'Layer',
  'LayeredRegion',
  'LdapItemList',
  'LineSpacing',
  'LinkFilter',
  'LinkLimit',
  'ListView',
  'Locales__',
  'Lock',
  'LoginPolicy',
  'MA_End__',
  'MA_StdCombo__',
  'MA_StdItem__',
  'MA_StdMenu__',
  'MISSING',
  'Mapping',
  'MarginL',
  'MarginR',
  'MarginV',
  'Marked',
  'MessageFrame',
  'Minimap',
  'MovieFrame',
  'Name',
  'Outline',
  'OutlineColour',
  'ParentedObject',
  'Path',
  'Permission',
  'PlayRes',
  'PlayerModel',
  'PrimaryColour',
  'Proof',
  'QuestPOIFrame',
  'RTM',
  'RecentModule__',
  'Regexp',
  'Region',
  'Rotation',
  'SCADABasic',
  'SSA',
  'Scale',
  'ScaleX',
  'ScaleY',
  'ScaledBorderAndShadow',
  'ScenarioPOIFrame',
  'ScriptObject',
  'Script__',
  'Scroll',
  'ScrollEvent',
  'ScrollFrame',
  'ScrollSide',
  'ScrollingMessageFrame',
  'SecondaryColour',
  'Sensitivity',
  'Shadow',
  'SimpleHTML',
  'Slider',
  'Spacing',
  'Start',
  'StatusBar',
  'Stream',
  'StrikeOut',
  'Style',
  'TIS',
  'TODO',
  'TabardModel',
  'Text',
  'Texture',
  'Timer',
  'ToolType',
  'Translation',
  'TreeView',
  'TriggerStatus',
  'UIObject',
  'Underline',
  'UserClass',
  'UserList',
  'UserNotifyList',
  'VisibleRegion',
  'Vplus',
  'WrapStyle',
  'XHPEndTagStart',
  'XHPStartTagEnd',
  'ZipType',
  '__package-name__',
  '_c',
  '_function',
  'a',
  'a10networks',
  'aaa',
  'abaqus',
  'abbrev',
  'abbreviated',
  'abbreviation',
  'abcnotation',
  'abl',
  'abnf',
  'abp',
  'absolute',
  'abstract',
  'academic',
  'access',
  'access-control',
  'access-qualifiers',
  'accessed',
  'accessor',
  'account',
  'accumulator',
  'ace',
  'ace3',
  'acl',
  'acos',
  'act',
  'action',
  'action-map',
  'actionhandler',
  'actionpack',
  'actions',
  'actionscript',
  'activerecord',
  'activesupport',
  'actual',
  'acute-accent',
  'ada',
  'add',
  'adddon',
  'added',
  'addition',
  'additional-character',
  'additive',
  'addon',
  'address',
  'address-of',
  'address-space',
  'addrfam',
  'adjustment',
  'admonition',
  'adr',
  'adverb',
  'adx',
  'ael',
  'aem',
  'aerospace',
  'aes',
  'aes_functions',
  'aesni',
  'aexLightGreen',
  'af',
  'afii',
  'aflex',
  'after',
  'after-expression',
  'agc',
  'agda',
  'agentspeak',
  'aggregate',
  'aggregation',
  'ahk',
  'ai-connection',
  'ai-player',
  'ai-wheeled-vehicle',
  'aif',
  'alabel',
  'alarms',
  'alda',
  'alert',
  'algebraic-type',
  'alias',
  'aliases',
  'align',
  'align-attribute',
  'alignment',
  'alignment-cue-setting',
  'alignment-mode',
  'all',
  'all-once',
  'all-solutions',
  'allocate',
  'alloy',
  'alloyglobals',
  'alloyxml',
  'alog',
  'alpha',
  'alphabeticalllt',
  'alphabeticallyge',
  'alphabeticallygt',
  'alphabeticallyle',
  'alt',
  'alter',
  'alternate-wysiwyg-string',
  'alternates',
  'alternation',
  'alternatives',
  'am',
  'ambient-audio-manager',
  'ambient-reflectivity',
  'amd',
  'amd3DNow',
  'amdnops',
  'ameter',
  'amount',
  'amp',
  'ampersand',
  'ampl',
  'ampscript',
  'an',
  'analysis',
  'analytics',
  'anb',
  'anchor',
  'and',
  'andop',
  'angelscript',
  'angle',
  'angle-brackets',
  'angular',
  'animation',
  'annot',
  'annotated',
  'annotation',
  'annotation-arguments',
  'anon',
  'anonymous',
  'another',
  'ansi',
  'ansi-c',
  'ansi-colored',
  'ansi-escape-code',
  'ansi-formatted',
  'ansi2',
  'ansible',
  'answer',
  'antialiasing',
  'antl',
  'antlr',
  'antlr4',
  'anubis',
  'any',
  'any-method',
  'anyclass',
  'aolserver',
  'apa',
  'apache',
  'apache-config',
  'apc',
  'apdl',
  'apex',
  'api',
  'api-notation',
  'apiary',
  'apib',
  'apl',
  'apostrophe',
  'appcache',
  'applescript',
  'application',
  'application-name',
  'application-process',
  'approx-equal',
  'aql',
  'aqua',
  'ar',
  'arbitrary-radix',
  'arbitrary-repetition',
  'arbitrary-repitition',
  'arch',
  'arch_specification',
  'architecture',
  'archive',
  'archives',
  'arduino',
  'area-code',
  'arendelle',
  'argcount',
  'args',
  'argument',
  'argument-label',
  'argument-separator',
  'argument-seperator',
  'argument-type',
  'arguments',
  'arith',
  'arithmetic',
  'arithmetical',
  'arithmeticcql',
  'ark',
  'arm',
  'arma',
  'armaConfig',
  'arnoldc',
  'arp',
  'arpop',
  'arr',
  'array',
  'array-expression',
  'array-literal',
  'arrays',
  'arrow',
  'articulation',
  'artihmetic',
  'arvo',
  'aryop',
  'as',
  'as4',
  'ascii',
  'asciidoc',
  'asdoc',
  'ash',
  'ashx',
  'asl',
  'asm',
  'asm-instruction',
  'asm-type-prefix',
  'asn',
  'asp',
  'asp-core-2',
  'aspx',
  'ass',
  'assembly',
  'assert',
  'assertion',
  'assigment',
  'assign',
  'assign-class',
  'assigned',
  'assigned-class',
  'assigned-value',
  'assignee',
  'assignement',
  'assignment',
  'assignmentforge-config',
  'associate',
  'association',
  'associativity',
  'assocs',
  'asterisk',
  'async',
  'at-marker',
  'at-root',
  'at-rule',
  'at-sign',
  'atmark',
  'atml3',
  'atoemp',
  'atom',
  'atom-term-processing',
  'atomic',
  'atomscript',
  'att',
  'attachment',
  'attr',
  'attribute',
  'attribute-entry',
  'attribute-expression',
  'attribute-key-value',
  'attribute-list',
  'attribute-lookup',
  'attribute-name',
  'attribute-reference',
  'attribute-selector',
  'attribute-value',
  'attribute-values',
  'attribute-with-value',
  'attribute_list',
  'attribute_value',
  'attribute_value2',
  'attributelist',
  'attributes',
  'attrset',
  'attrset-or-function',
  'audio',
  'audio-file',
  'auditor',
  'augmented',
  'auth',
  'auth_basic',
  'author',
  'author-names',
  'authorization',
  'auto',
  'auto-event',
  'autoconf',
  'autoindex',
  'autoit',
  'automake',
  'automatic',
  'autotools',
  'autovar',
  'aux',
  'auxiliary',
  'avdl',
  'avra',
  'avrasm',
  'avrdisasm',
  'avs',
  'avx',
  'avx2',
  'avx512',
  'awk',
  'axes_group',
  'axis',
  'axl',
  'b',
  'b-spline-patch',
  'babel',
  'back',
  'back-from',
  'back-reference',
  'back-slash',
  'backend',
  'background',
  'backreference',
  'backslash',
  'backslash-bar',
  'backslash-g',
  'backspace',
  'backtick',
  'bad-ampersand',
  'bad-angle-bracket',
  'bad-assignment',
  'bad-comments-or-CDATA',
  'bad-escape',
  'bad-octal',
  'bad-var',
  'bang',
  'banner',
  'bar',
  'bareword',
  'barline',
  'base',
  'base-11',
  'base-12',
  'base-13',
  'base-14',
  'base-15',
  'base-16',
  'base-17',
  'base-18',
  'base-19',
  'base-20',
  'base-21',
  'base-22',
  'base-23',
  'base-24',
  'base-25',
  'base-26',
  'base-27',
  'base-28',
  'base-29',
  'base-3',
  'base-30',
  'base-31',
  'base-32',
  'base-33',
  'base-34',
  'base-35',
  'base-36',
  'base-4',
  'base-5',
  'base-6',
  'base-7',
  'base-9',
  'base-call',
  'base-integer',
  'base64',
  'base85',
  'base_pound_number_pound',
  'basetype',
  'basic',
  'basic-arithmetic',
  'basic-type',
  'basic_functions',
  'basicblock',
  'basis-matrix',
  'bat',
  'batch',
  'batchfile',
  'battlesim',
  'bb',
  'bbcode',
  'bcmath',
  'be',
  'beam',
  'beamer',
  'beancount',
  'before',
  'begin',
  'begin-document',
  'begin-emphasis',
  'begin-end',
  'begin-end-group',
  'begin-literal',
  'begin-symbolic',
  'begintimeblock',
  'behaviour',
  'bem',
  'between-tag-pair',
  'bevel',
  'bezier-patch',
  'bfeac',
  'bff',
  'bg',
  'bg-black',
  'bg-blue',
  'bg-cyan',
  'bg-green',
  'bg-normal',
  'bg-purple',
  'bg-red',
  'bg-white',
  'bg-yellow',
  'bhtml',
  'bhv',
  'bibitem',
  'bibliography-anchor',
  'biblioref',
  'bibpaper',
  'bibtex',
  'bif',
  'big-arrow',
  'big-arrow-left',
  'bigdecimal',
  'bigint',
  'biicode',
  'biiconf',
  'bin',
  'binOp',
  'binary',
  'binary-arithmetic',
  'bind',
  'binder',
  'binding',
  'binding-prefix',
  'bindings',
  'binop',
  'bioinformatics',
  'biosphere',
  'bird-track',
  'bis',
  'bison',
  'bit',
  'bit-and-byte',
  'bit-range',
  'bit-wise',
  'bitarray',
  'bitop',
  'bits-mov',
  'bitvector',
  'bitwise',
  'black',
  'blade',
  'blanks',
  'blaze',
  'blenc',
  'blend',
  'blending',
  'blendtype',
  'blendu',
  'blendv',
  'blip',
  'block',
  'block-attribute',
  'block-dartdoc',
  'block-data',
  'block-level',
  'blockid',
  'blockname',
  'blockquote',
  'blocktitle',
  'blue',
  'blueprint',
  'bluespec',
  'blur',
  'bm',
  'bmi',
  'bmi1',
  'bmi2',
  'bnd',
  'bnf',
  'body',
  'body-statement',
  'bold',
  'bold-italic-text',
  'bold-text',
  'bolt',
  'bond',
  'bonlang',
  'boo',
  'boogie',
  'bool',
  'boolean',
  'boolean-test',
  'boost',
  'boot',
  'bord',
  'border',
  'botml',
  'bottom',
  'boundary',
  'bounded',
  'bounds',
  'bow',
  'box',
  'bpl',
  'bpr',
  'bqparam',
  'brace',
  'braced',
  'braces',
  'bracket',
  'bracketed',
  'brackets',
  'brainfuck',
  'branch',
  'branch-point',
  'break',
  'breakpoint',
  'breakpoints',
  'breaks',
  'bridle',
  'brightscript',
  'bro',
  'broken',
  'browser',
  'browsers',
  'bs',
  'bsl',
  'btw',
  'buffered',
  'buffers',
  'bugzilla-number',
  'build',
  'buildin',
  'buildout',
  'built-in',
  'built-in-variable',
  'built-ins',
  'builtin',
  'builtin-comparison',
  'builtins',
  'bullet',
  'bullet-point',
  'bump',
  'bump-multiplier',
  'bundle',
  'but',
  'button',
  'buttons',
  'by',
  'by-name',
  'by-number',
  'byref',
  'byte',
  'bytearray',
  'bz2',
  'bzl',
  'c',
  'c-style',
  'c0',
  'c1',
  'c2hs',
  'ca',
  'cabal',
  'cabal-keyword',
  'cache',
  'cache-management',
  'cacheability-control',
  'cake',
  'calc',
  'calca',
  'calendar',
  'call',
  'callable',
  'callback',
  'caller',
  'calling',
  'callmethod',
  'callout',
  'callparent',
  'camera',
  'camlp4',
  'camlp4-stream',
  'canonicalized-program-name',
  'canopen',
  'capability',
  'capnp',
  'cappuccino',
  'caps',
  'caption',
  'capture',
  'capturename',
  'cardinal-curve',
  'cardinal-patch',
  'cascade',
  'case',
  'case-block',
  'case-body',
  'case-class',
  'case-clause',
  'case-clause-body',
  'case-expression',
  'case-modifier',
  'case-pattern',
  'case-statement',
  'case-terminator',
  'case-value',
  'cassius',
  'cast',
  'catch',
  'catch-exception',
  'catcode',
  'categories',
  'categort',
  'category',
  'cba',
  'cbmbasic',
  'cbot',
  'cbs',
  'cc',
  'cc65',
  'ccml',
  'cdata',
  'cdef',
  'cdtor',
  'ceiling',
  'cell',
  'cellcontents',
  'cellwall',
  'ceq',
  'ces',
  'cet',
  'cexpr',
  'cextern',
  'ceylon',
  'ceylondoc',
  'cf',
  'cfdg',
  'cfengine',
  'cfg',
  'cfml',
  'cfscript',
  'cfunction',
  'cg',
  'cgi',
  'cgx',
  'chain',
  'chained',
  'chaining',
  'chainname',
  'changed',
  'changelogs',
  'changes',
  'channel',
  'chapel',
  'chapter',
  'char',
  'characater',
  'character',
  'character-class',
  'character-data-not-allowed-here',
  'character-literal',
  'character-literal-too-long',
  'character-not-allowed-here',
  'character-range',
  'character-reference',
  'character-token',
  'character_not_allowed',
  'character_not_allowed_here',
  'characters',
  'chars',
  'chars-and-bytes-io',
  'charset',
  'check',
  'check-identifier',
  'checkboxes',
  'checker',
  'chef',
  'chem',
  'chemical',
  'children',
  'choice',
  'choicescript',
  'chord',
  'chorus',
  'chuck',
  'chunk',
  'ciexyz',
  'circle',
  'circle-jot',
  'cirru',
  'cisco',
  'cisco-ios-config',
  'citation',
  'cite',
  'citrine',
  'cjam',
  'cjson',
  'clamp',
  'clamping',
  'class',
  'class-constraint',
  'class-constraints',
  'class-declaration',
  'class-definition',
  'class-fns',
  'class-instance',
  'class-list',
  'class-struct-block',
  'class-type',
  'class-type-definition',
  'classcode',
  'classes',
  'classic',
  'classicalb',
  'classmethods',
  'classobj',
  'classtree',
  'clause',
  'clause-head-body',
  'clauses',
  'clear',
  'clear-argument',
  'cleared',
  'clflushopt',
  'click',
  'client',
  'client-server',
  'clip',
  'clipboard',
  'clips',
  'clmul',
  'clock',
  'clojure',
  'cloned',
  'close',
  'closed',
  'closing',
  'closing-text',
  'closure',
  'clothes-body',
  'cm',
  'cmake',
  'cmb',
  'cmd',
  'cnet',
  'cns',
  'cobject',
  'cocoa',
  'cocor',
  'cod4mp',
  'code',
  'code-example',
  'codeblock',
  'codepoint',
  'codimension',
  'codstr',
  'coffee',
  'coffeescript',
  'coffeescript-preview',
  'coil',
  'collection',
  'collision',
  'colon',
  'colons',
  'color',
  'color-adjustment',
  'coloring',
  'colour',
  'colour-correction',
  'colour-interpolation',
  'colour-name',
  'colour-scheme',
  'colspan',
  'column',
  'column-divider',
  'column-specials',
  'com',
  'combinators',
  'comboboxes',
  'comma',
  'comma-bar',
  'comma-parenthesis',
  'command',
  'command-name',
  'command-synopsis',
  'commandline',
  'commands',
  'comment',
  'comment-ish',
  'comment-italic',
  'commented-out',
  'commit-command',
  'commit-message',
  'commodity',
  'common',
  'commonform',
  'communications',
  'community',
  'commute',
  'comnd',
  'compare',
  'compareOp',
  'comparison',
  'compile',
  'compile-only',
  'compiled',
  'compiled-papyrus',
  'compiler',
  'compiler-directive',
  'compiletime',
  'compiling-and-loading',
  'complement',
  'complete',
  'completed',
  'complex',
  'component',
  'component-separator',
  'component_instantiation',
  'compositor',
  'compound',
  'compound-assignment',
  'compress',
  'computer',
  'computercraft',
  'concat',
  'concatenated-arguments',
  'concatenation',
  'concatenator',
  'concatination',
  'concealed',
  'concise',
  'concrete',
  'condition',
  'conditional',
  'conditional-directive',
  'conditional-short',
  'conditionals',
  'conditions',
  'conf',
  'config',
  'configuration',
  'configure',
  'confluence',
  'conftype',
  'conjunction',
  'conky',
  'connect',
  'connection-state',
  'connectivity',
  'connstate',
  'cons',
  'consecutive-tags',
  'considering',
  'console',
  'const',
  'const-data',
  'constant',
  'constants',
  'constrained',
  'constraint',
  'constraints',
  'construct',
  'constructor',
  'constructor-list',
  'constructs',
  'consult',
  'contacts',
  'container',
  'containers-raycast',
  'contains',
  'content',
  'content-detective',
  'contentSupplying',
  'contentitem',
  'context',
  'context-free',
  'context-signature',
  'continuation',
  'continuations',
  'continue',
  'continued',
  'continuum',
  'contol',
  'contract',
  'contracts',
  'contrl',
  'control',
  'control-char',
  'control-handlers',
  'control-management',
  'control-systems',
  'control-transfer',
  'controller',
  'controlline',
  'controls',
  'contstant',
  'conventional',
  'conversion',
  'convert-type',
  'cookie',
  'cool',
  'coord1',
  'coord2',
  'coord3',
  'coordinates',
  'copy',
  'copying',
  'coq',
  'core',
  'core-parse',
  'coreutils',
  'correct',
  'cos',
  'counter',
  'counters',
  'cover',
  'cplkg',
  'cplusplus',
  'cpm',
  'cpp',
  'cpp-include',
  'cpp-type',
  'cpp_type',
  'cpu12',
  'cql',
  'cram',
  'crc32',
  'create',
  'creation',
  'critic',
  'crl',
  'crontab',
  'crypto',
  'crystal',
  'cs',
  'csharp',
  'cshtml',
  'csi',
  'csjs',
  'csound',
  'csound-document',
  'csound-score',
  'cspm',
  'css',
  'csv',
  'csx',
  'ct',
  'ctkey',
  'ctor',
  'ctxvar',
  'ctxvarbracket',
  'ctype',
  'cubic-bezier',
  'cucumber',
  'cuda',
  'cue-identifier',
  'cue-timings',
  'cuesheet',
  'cup',
  'cupsym',
  'curl',
  'curley',
  'curly',
  'currency',
  'current',
  'current-escape-char',
  'curve',
  'curve-2d',
  'curve-fitting',
  'curve-reference',
  'curve-technique',
  'custom',
  'customevent',
  'cut',
  'cve-number',
  'cvs',
  'cw',
  'cxx',
  'cy-GB',
  'cyan',
  'cyc',
  'cycle',
  'cypher',
  'cyrix',
  'cython',
  'd',
  'da',
  'daml',
  'dana',
  'danger',
  'danmakufu',
  'dark_aqua',
  'dark_blue',
  'dark_gray',
  'dark_green',
  'dark_purple',
  'dark_red',
  'dart',
  'dartdoc',
  'dash',
  'dasm',
  'data',
  'data-acquisition',
  'data-extension',
  'data-integrity',
  'data-item',
  'data-step',
  'data-transfer',
  'database',
  'database-name',
  'datablock',
  'datablocks',
  'datafeed',
  'datatype',
  'datatypes',
  'date',
  'date-time',
  'datetime',
  'dav',
  'day',
  'dayofmonth',
  'dayofweek',
  'db',
  'dba',
  'dbx',
  'dc',
  'dcon',
  'dd',
  'ddp',
  'de',
  'dealii',
  'deallocate',
  'deb-control',
  'debian',
  'debris',
  'debug',
  'debug-specification',
  'debugger',
  'debugging',
  'debugging-comment',
  'dec',
  'decal',
  'decimal',
  'decimal-arithmetic',
  'decision',
  'decl',
  'declaration',
  'declaration-expr',
  'declaration-prod',
  'declarations',
  'declarator',
  'declaratyion',
  'declare',
  'decode',
  'decoration',
  'decorator',
  'decreasing',
  'decrement',
  'def',
  'default',
  'define',
  'define-colour',
  'defined',
  'definedness',
  'definingobj',
  'definition',
  'definitions',
  'defintions',
  'deflate',
  'delay',
  'delegated',
  'delete',
  'deleted',
  'deletion',
  'delimeter',
  'delimited',
  'delimiter',
  'delimiter-too-long',
  'delimiters',
  'dense',
  'deprecated',
  'depricated',
  'dereference',
  'derived-type',
  'deriving',
  'desc',
  'describe',
  'description',
  'descriptors',
  'design',
  'desktop',
  'destination',
  'destructor',
  'destructured',
  'determ',
  'developer',
  'device',
  'device-io',
  'dformat',
  'dg',
  'dhcp',
  'diagnostic',
  'dialogue',
  'diamond',
  'dict',
  'dictionary',
  'dictionaryname',
  'diff',
  'difference',
  'different',
  'diffuse-reflectivity',
  'digdag',
  'digit-width',
  'dim',
  'dimension',
  'dip',
  'dir',
  'dir-target',
  'dircolors',
  'direct',
  'direction',
  'directive',
  'directive-option',
  'directives',
  'directory',
  'dirjs',
  'dirtyblue',
  'dirtygreen',
  'disable',
  'disable-markdown',
  'disable-todo',
  'discarded',
  'discusson',
  'disjunction',
  'disk',
  'disk-folder-file',
  'dism',
  'displacement',
  'display',
  'dissolve',
  'dissolve-interpolation',
  'distribution',
  'diverging-function',
  'divert',
  'divide',
  'divider',
  'django',
  'dl',
  'dlv',
  'dm',
  'dmf',
  'dml',
  'do',
  'dobody',
  'doc',
  'doc-comment',
  'docRoot',
  'dockerfile',
  'dockerignore',
  'doconce',
  'docstring',
  'doctest',
  'doctree-option',
  'doctype',
  'document',
  'documentation',
  'documentroot',
  'does',
  'dogescript',
  'doki',
  'dollar',
  'dollar-quote',
  'dollar_variable',
  'dom',
  'domain',
  'dontcollect',
  'doors',
  'dop',
  'dot',
  'dot-access',
  'dotenv',
  'dotfiles',
  'dothandout',
  'dotnet',
  'dotnote',
  'dots',
  'dotted',
  'dotted-circle',
  'dotted-del',
  'dotted-greater',
  'dotted-tack-up',
  'double',
  'double-arrow',
  'double-colon',
  'double-dash',
  'double-dash-not-allowed',
  'double-dot',
  'double-number-sign',
  'double-percentage',
  'double-qoute',
  'double-quote',
  'double-quoted',
  'double-quoted-string',
  'double-semicolon',
  'double-slash',
  'doublequote',
  'doubleslash',
  'dougle',
  'down',
  'download',
  'downwards',
  'doxyfile',
  'doxygen',
  'dragdrop',
  'drawing',
  'drive',
  'droiuby',
  'drop',
  'drop-shadow',
  'droplevel',
  'drummode',
  'drupal',
  'dsl',
  'dsv',
  'dt',
  'dtl',
  'due',
  'dummy',
  'dummy-variable',
  'dump',
  'duration',
  'dust',
  'dust_Conditional',
  'dust_end_section_tag',
  'dust_filter',
  'dust_partial',
  'dust_partial_not_self_closing',
  'dust_ref',
  'dust_ref_name',
  'dust_section_context',
  'dust_section_name',
  'dust_section_params',
  'dust_self_closing_section_tag',
  'dust_special',
  'dust_start_section_tag',
  'dustjs',
  'dut',
  'dwscript',
  'dxl',
  'dylan',
  'dynamic',
  'dyndoc',
  'dyon',
  'e',
  'e3globals',
  'each',
  'eachin',
  'earl-grey',
  'ebnf',
  'ebuild',
  'echo',
  'eclass',
  'ecmascript',
  'eco',
  'ecr',
  'ect',
  'ect2',
  'ect3',
  'ect4',
  'edasm',
  'edge',
  'edit-manager',
  'editfields',
  'editors',
  'ee',
  'eex',
  'effect',
  'effectgroup',
  'effective_routine_body',
  'effects',
  'eiffel',
  'eight',
  'eio',
  'eiz',
  'ejectors',
  'el',
  'elasticsearch',
  'elasticsearch2',
  'element',
  'elements',
  'elemnt',
  'elif',
  'elipse',
  'elision',
  'elixir',
  'ellipsis',
  'elm',
  'elmx',
  'else',
  'else-condition',
  'else-if',
  'elseif',
  'elseif-condition',
  'elsewhere',
  'eltype',
  'elvis',
  'em',
  'email',
  'embed',
  'embed-diversion',
  'embedded',
  'embedded-c',
  'embedded-ruby',
  'embedded2',
  'embeded',
  'ember',
  'emberscript',
  'emblem',
  'embperl',
  'emissive-colour',
  'eml',
  'emlist',
  'emoji',
  'emojicode',
  'emp',
  'emph',
  'emphasis',
  'empty',
  'empty-dictionary',
  'empty-list',
  'empty-parenthesis',
  'empty-start',
  'empty-string',
  'empty-tag',
  'empty-tuple',
  'empty-typing-pair',
  'empty_gif',
  'emptyelement',
  'en',
  'en-Scouse',
  'en-au',
  'en-lol',
  'en-old',
  'en-pirate',
  'enable',
  'enc',
  'enchant',
  'enclose',
  'encode',
  'encoding',
  'encryption',
  'end',
  'end-block-data',
  'end-definition',
  'end-document',
  'end-enum',
  'end-footnote',
  'end-of-line',
  'end-statement',
  'end-value',
  'endassociate',
  'endcode',
  'enddo',
  'endfile',
  'endforall',
  'endfunction',
  'endian',
  'endianness',
  'endif',
  'endinfo',
  'ending',
  'ending-space',
  'endinterface',
  'endlocaltable',
  'endmodule',
  'endobject',
  'endobjecttable',
  'endparamtable',
  'endprogram',
  'endproperty',
  'endpropertygroup',
  'endpropertygrouptable',
  'endpropertytable',
  'endselect',
  'endstate',
  'endstatetable',
  'endstruct',
  'endstructtable',
  'endsubmodule',
  'endsubroutine',
  'endtimeblock',
  'endtype',
  'enduserflagsref',
  'endvariable',
  'endvariabletable',
  'endwhere',
  'engine',
  'enterprise',
  'entity',
  'entity-creation-and-abolishing',
  'entity_instantiation',
  'entry',
  'entry-definition',
  'entry-key',
  'entry-type',
  'entrypoint',
  'enum',
  'enum-block',
  'enum-declaration',
  'enumeration',
  'enumerator',
  'enumerator-specification',
  'env',
  'environment',
  'environment-variable',
  'eo',
  'eof',
  'epatch',
  'eq',
  'eqn',
  'eqnarray',
  'equal',
  'equal-or-greater',
  'equal-or-less',
  'equalexpr',
  'equality',
  'equals',
  'equals-sign',
  'equation',
  'equation-label',
  'erb',
  'ereg',
  'erlang',
  'error',
  'error-control',
  'errorfunc',
  'errorstop',
  'es',
  'es6',
  'es6import',
  'esc',
  'escape',
  'escape-char',
  'escape-code',
  'escape-sequence',
  'escape-unicode',
  'escaped',
  'escapes',
  'escript',
  'eso-lua',
  'eso-txt',
  'essence',
  'et',
  'eth',
  'ethaddr',
  'etml',
  'etpl',
  'eudoc',
  'euler',
  'euphoria',
  'european',
  'evaled',
  'evaluable',
  'evaluation',
  'even-tab',
  'event',
  'event-call',
  'event-handler',
  'event-handling',
  'event-schedulling',
  'eventType',
  'eventb',
  'eventend',
  'events',
  'evnd',
  'exactly',
  'example',
  'exampleText',
  'examples',
  'exceeding-sections',
  'excel-link',
  'exception',
  'exceptions',
  'exclaimation-point',
  'exclamation',
  'exec',
  'exec-command',
  'execution-context',
  'exif',
  'existential',
  'exit',
  'exp',
  'expand-register',
  'expanded',
  'expansion',
  'expected-array-separator',
  'expected-dictionary-separator',
  'expected-extends',
  'expected-implements',
  'expected-range-separator',
  'experimental',
  'expires',
  'expl3',
  'explosion',
  'exponent',
  'exponential',
  'export',
  'exports',
  'expr',
  'expression',
  'expression-separator',
  'expression-seperator',
  'expressions',
  'expressions-and-types',
  'exprwrap',
  'ext',
  'extempore',
  'extend',
  'extended',
  'extends',
  'extension',
  'extension-specification',
  'extensions',
  'extern',
  'extern-block',
  'external',
  'external-call',
  'external-signature',
  'extersk',
  'extglob',
  'extra',
  'extra-characters',
  'extra-equals-sign',
  'extracted',
  'extras',
  'extrassk',
  'exxample',
  'eztpl',
  'f',
  'f5networks',
  'fa',
  'face',
  'fact',
  'factor',
  'factorial',
  'fadeawayheight',
  'fadeawaywidth',
  'fail',
  'fakeroot',
  'fallback',
  'fallout4',
  'false',
  'fandoc',
  'fann',
  'fantom',
  'fastcgi',
  'fbaccidental',
  'fbfigure',
  'fbgroupclose',
  'fbgroupopen',
  'fbp',
  'fctn',
  'fe',
  'feature',
  'features',
  'feedrate',
  'fenced',
  'fftwfn',
  'fhem',
  'fi',
  'field',
  'field-assignment',
  'field-completions',
  'field-id',
  'field-level-comment',
  'field-name',
  'field-tag',
  'fields',
  'figbassmode',
  'figure',
  'figuregroup',
  'filder-design-hdl-coder',
  'file',
  'file-i-o',
  'file-io',
  'file-name',
  'file-object',
  'file-path',
  'fileinfo',
  'filename',
  'filepath',
  'filetest',
  'filter',
  'filter-pipe',
  'filteredtranscludeblock',
  'filters',
  'final',
  'final-procedure',
  'finally',
  'financial',
  'financial-derivatives',
  'find',
  'find-in-files',
  'find-m',
  'finder',
  'finish',
  'finn',
  'fire',
  'firebug',
  'first',
  'first-class',
  'first-line',
  'fish',
  'fitnesse',
  'five',
  'fix_this_later',
  'fixed',
  'fixed-income',
  'fixed-point',
  'fixme',
  'fl',
  'flag',
  'flag-control',
  'flags',
  'flash',
  'flatbuffers',
  'flex-config',
  'fload',
  'float',
  'float-exponent',
  'float_exp',
  'floating-point',
  'floating_point',
  'floor',
  'flow',
  'flow-control',
  'flowcontrol',
  'flows',
  'flowtype',
  'flush',
  'fma',
  'fma4',
  'fmod',
  'fn',
  'fold',
  'folder',
  'folder-actions',
  'following',
  'font',
  'font-cache',
  'font-face',
  'font-name',
  'font-size',
  'fontface',
  'fontforge',
  'foobar',
  'footer',
  'footnote',
  'for',
  'for-in-loop',
  'for-loop',
  'for-quantity',
  'forall',
  'force',
  'foreach',
  'foreign',
  'forever',
  'forge-config',
  'forin',
  'form',
  'form-feed',
  'formal',
  'format',
  'format-register',
  'format-verb',
  'formatted',
  'formatter',
  'formatting',
  'forth',
  'fortran',
  'forward',
  'foundation',
  'fountain',
  'four',
  'fourd-command',
  'fourd-constant',
  'fourd-constant-hex',
  'fourd-constant-number',
  'fourd-constant-string',
  'fourd-control-begin',
  'fourd-control-end',
  'fourd-declaration',
  'fourd-declaration-array',
  'fourd-local-variable',
  'fourd-parameter',
  'fourd-table',
  'fourd-tag',
  'fourd-variable',
  'fpm',
  'fpu',
  'fpu_x87',
  'fr',
  'fragment',
  'frame',
  'frames',
  'frametitle',
  'framexml',
  'free',
  'free-form',
  'freebasic',
  'freefem',
  'freespace2',
  'from',
  'from-file',
  'front-matter',
  'fs',
  'fs2',
  'fsc',
  'fsgsbase',
  'fsharp',
  'fsi',
  'fsl',
  'fsm',
  'fsp',
  'fsx',
  'fth',
  'ftl',
  'ftl20n',
  'full-line',
  'full-stop',
  'fun',
  'funarg',
  'func-tag',
  'func_call',
  'funchand',
  'function',
  'function-arity',
  'function-attribute',
  'function-call',
  'function-definition',
  'function-literal',
  'function-parameter',
  'function-recursive',
  'function-return',
  'function-type',
  'functionDeclaration',
  'functionDefinition',
  'function_definition',
  'function_prototype',
  'functional_test',
  'functionend',
  'functions',
  'functionstart',
  'fundimental',
  'funk',
  'funtion-definition',
  'fus',
  'future',
  'futures',
  'fuzzy-logic',
  'fx',
  'fx-foliage-replicator',
  'fx-light',
  'fx-shape-replicator',
  'fx-sun-light',
  'g',
  'g-code',
  'ga',
  'gain',
  'galaxy',
  'gallery',
  'game-base',
  'game-connection',
  'game-server',
  'gamebusk',
  'gamescript',
  'gams',
  'gams-lst',
  'gap',
  'garch',
  'gather',
  'gcode',
  'gdb',
  'gdscript',
  'gdx',
  'ge',
  'geant4-macro',
  'geck',
  'geck-keyword',
  'general',
  'general-purpose',
  'generate',
  'generator',
  'generic',
  'generic-config',
  'generic-spec',
  'generic-type',
  'generic_list',
  'genericcall',
  'generics',
  'genetic-algorithms',
  'geo',
  'geometric',
  'geometry',
  'geometry-adjustment',
  'get',
  'getproperty',
  'getsec',
  'getset',
  'getter',
  'gettext',
  'getword',
  'gfm',
  'gfm-todotxt',
  'gfx',
  'gh-number',
  'gherkin',
  'gisdk',
  'git',
  'git-attributes',
  'git-commit',
  'git-config',
  'git-rebase',
  'gitignore',
  'given',
  'gj',
  'gl',
  'glob',
  'global',
  'global-functions',
  'globals',
  'globalsection',
  'glsl',
  'glue',
  'glyph_class_name',
  'glyphname-value',
  'gml',
  'gmp',
  'gmsh',
  'gmx',
  'gn',
  'gnu',
  'gnuplot',
  'go',
  'goal',
  'goatee',
  'godmode',
  'gohtml',
  'gold',
  'golo',
  'google',
  'gosub',
  'gotemplate',
  'goto',
  'goto-label',
  'gpd',
  'gpd_note',
  'gpp',
  'grace',
  'grade-down',
  'grade-up',
  'gradient',
  'gradle',
  'grails',
  'grammar',
  'grammar-rule',
  'grammar_production',
  'grap',
  'grapahql',
  'graph',
  'graphics',
  'graphql',
  'grave-accent',
  'gray',
  'greater',
  'greater-equal',
  'greater-or-equal',
  'greek',
  'greek-letter',
  'green',
  'gremlin',
  'grey',
  'grg',
  'grid-table',
  'gridlists',
  'grog',
  'groovy',
  'groovy-properties',
  'group',
  'group-level-comment',
  'group-name',
  'group-number',
  'group-reference',
  'group-title',
  'group1',
  'group10',
  'group11',
  'group2',
  'group3',
  'group4',
  'group5',
  'group6',
  'group7',
  'group8',
  'group9',
  'groupend',
  'groupflag',
  'grouping-statement',
  'groupname',
  'groupstart',
  'growl',
  'grr',
  'gs',
  'gsc',
  'gsp',
  'gt',
  'guard',
  'guards',
  'gui',
  'gui-bitmap-ctrl',
  'gui-button-base-ctrl',
  'gui-canvas',
  'gui-control',
  'gui-filter-ctrl',
  'gui-frameset-ctrl',
  'gui-menu-bar',
  'gui-message-vector-ctrl',
  'gui-ml-text-ctrl',
  'gui-popup-menu-ctrl',
  'gui-scroll-ctrl',
  'gui-slider-ctrl',
  'gui-text-ctrl',
  'gui-text-edit-ctrl',
  'gui-text-list-ctrl',
  'guid',
  'guillemot',
  'guis',
  'gzip',
  'gzip_static',
  'h',
  'h1',
  'hack',
  'hackfragment',
  'haddock',
  'hairpin',
  'ham',
  'haml',
  'hamlbars',
  'hamlc',
  'hamlet',
  'hamlpy',
  'handlebar',
  'handlebars',
  'handler',
  'hanging-paragraph',
  'haproxy-config',
  'harbou',
  'harbour',
  'hard-break',
  'hardlinebreaks',
  'hash',
  'hash-tick',
  'hashbang',
  'hashicorp',
  'hashkey',
  'haskell',
  'haxe',
  'hbs',
  'hcl',
  'hdl',
  'hdr',
  'he',
  'header',
  'header-continuation',
  'header-value',
  'headername',
  'headers',
  'heading',
  'heading-0',
  'heading-1',
  'heading-2',
  'heading-3',
  'heading-4',
  'heading-5',
  'heading-6',
  'height',
  'helen',
  'help',
  'helper',
  'helpers',
  'heredoc',
  'heredoc-token',
  'herestring',
  'heritage',
  'hex',
  'hex-ascii',
  'hex-byte',
  'hex-literal',
  'hex-old',
  'hex-string',
  'hex-value',
  'hex8',
  'hexadecimal',
  'hexidecimal',
  'hexprefix',
  'hg-commit',
  'hgignore',
  'hi',
  'hidden',
  'hide',
  'high-minus',
  'highlight-end',
  'highlight-group',
  'highlight-start',
  'hint',
  'history',
  'hive',
  'hive-name',
  'hjson',
  'hl7',
  'hlsl',
  'hn',
  'hoa',
  'hoc',
  'hocharacter',
  'hocomment',
  'hocon',
  'hoconstant',
  'hocontinuation',
  'hocontrol',
  'hombrew-formula',
  'homebrew',
  'homematic',
  'hook',
  'hoon',
  'horizontal-blending',
  'horizontal-packed-arithmetic',
  'horizontal-rule',
  'hostname',
  'hosts',
  'hour',
  'hours',
  'hps',
  'hql',
  'hr',
  'hrm',
  'hs',
  'hsc2hs',
  'ht',
  'htaccess',
  'htl',
  'html',
  'html_entity',
  'htmlbars',
  'http',
  'hu',
  'hungary',
  'hxml',
  'hy',
  'hydrant',
  'hydrogen',
  'hyperbolic',
  'hyperlink',
  'hyphen',
  'hyphenation',
  'hyphenation-char',
  'i',
  'i-beam',
  'i18n',
  'iRev',
  'ice',
  'icinga2',
  'icmc',
  'icmptype',
  'icmpv6type',
  'icmpxtype',
  'iconv',
  'id',
  'id-type',
  'id-with-protocol',
  'idd',
  'ideal',
  'identical',
  'identifer',
  'identified',
  'identifier',
  'identifier-type',
  'identifiers-and-DTDs',
  'identity',
  'idf',
  'idl',
  'idris',
  'ieee',
  'if',
  'if-block',
  'if-branch',
  'if-condition',
  'if-else',
  'if-then',
  'ifacespec',
  'ifdef',
  'ifname',
  'ifndef',
  'ignore',
  'ignore-eol',
  'ignore-errors',
  'ignorebii',
  'ignored',
  'ignored-binding',
  'ignoring',
  'iisfunc',
  'ijk',
  'ilasm',
  'illagal',
  'illeagal',
  'illegal',
  'illumination-model',
  'image',
  'image-acquisition',
  'image-alignment',
  'image-option',
  'image-processing',
  'images',
  'imap',
  'imba',
  'imfchan',
  'img',
  'immediate',
  'immediately-evaluated',
  'immutable',
  'impex',
  'implementation',
  'implementation-defined-hooks',
  'implemented',
  'implements',
  'implicit',
  'import',
  'import-all',
  'importall',
  'important',
  'in',
  'in-block',
  'in-module',
  'in-out',
  'inappropriate',
  'include',
  'include-statement',
  'includefile',
  'incomplete',
  'incomplete-variable-assignment',
  'inconsistent',
  'increment',
  'increment-decrement',
  'indent',
  'indented',
  'indented-paragraph',
  'indepimage',
  'index',
  'index-seperator',
  'indexed',
  'indexer',
  'indexes',
  'indicator',
  'indices',
  'indirect',
  'indirection',
  'individual-enum-definition',
  'individual-rpc-call',
  'inet',
  'inetprototype',
  'inferred',
  'infes',
  'infinity',
  'infix',
  'info',
  'inform',
  'inform6',
  'inform7',
  'infotype',
  'ingore-eol',
  'inherit',
  'inheritDoc',
  'inheritance',
  'inherited',
  'inherited-class',
  'inherited-struct',
  'inherits',
  'ini',
  'init',
  'initial-lowercase',
  'initial-uppercase',
  'initial-value',
  'initialization',
  'initialize',
  'initializer-list',
  'ink',
  'inline',
  'inline-data',
  'inlineConditionalBranchSeparator',
  'inlineConditionalClause',
  'inlineConditionalEnd',
  'inlineConditionalStart',
  'inlineLogicEnd',
  'inlineLogicStart',
  'inlineSequenceEnd',
  'inlineSequenceSeparator',
  'inlineSequenceStart',
  'inlineSequenceTypeChar',
  'inlineblock',
  'inlinecode',
  'inlinecomment',
  'inlinetag',
  'inner',
  'inner-class',
  'inno',
  'ino',
  'inout',
  'input',
  'inquire',
  'inserted',
  'insertion',
  'insertion-and-extraction',
  'inside',
  'install',
  'instance',
  'instancemethods',
  'instanceof',
  'instances',
  'instantiation',
  'instruction',
  'instruction-pointer',
  'instructions',
  'instrument',
  'instrument-block',
  'instrument-control',
  'instrument-declaration',
  'int',
  'int32',
  'int64',
  'integer',
  'integer-float',
  'intel',
  'intel-hex',
  'intent',
  'intepreted',
  'interaction',
  'interbase',
  'interface',
  'interface-block',
  'interface-or-protocol',
  'interfaces',
  'interior-instance',
  'interiors',
  'interlink',
  'internal',
  'internet',
  'interpolate-argument',
  'interpolate-string',
  'interpolate-variable',
  'interpolated',
  'interpolation',
  'interrupt',
  'intersection',
  'interval',
  'intervalOrList',
  'intl',
  'intrinsic',
  'intuicio4',
  'invalid',
  'invalid-character',
  'invalid-character-escape',
  'invalid-inequality',
  'invalid-quote',
  'invalid-variable-name',
  'invariant',
  'invocation',
  'invoke',
  'invokee',
  'io',
  'ior',
  'iota',
  'ip',
  'ip-port',
  'ip6',
  'ipkg',
  'ipsec',
  'ipv4',
  'ipv6',
  'ipynb',
  'irct',
  'irule',
  'is',
  'isa',
  'isc',
  'iscexport',
  'isclass',
  'isml',
  'issue',
  'it',
  'italic',
  'italic-text',
  'item',
  'item-access',
  'itemlevel',
  'items',
  'iteration',
  'itunes',
  'ivar',
  'ja',
  'jack',
  'jade',
  'jakefile',
  'jasmin',
  'java',
  'java-properties',
  'java-props',
  'javadoc',
  'javascript',
  'jbeam',
  'jekyll',
  'jflex',
  'jibo-rule',
  'jinja',
  'jison',
  'jisonlex',
  'jmp',
  'joint',
  'joker',
  'jolie',
  'jot',
  'journaling',
  'jpl',
  'jq',
  'jquery',
  'js',
  'js-label',
  'jsdoc',
  'jsduck',
  'jsim',
  'json',
  'json5',
  'jsoniq',
  'jsonnet',
  'jsont',
  'jsp',
  'jsx',
  'julia',
  'julius',
  'jump',
  'juniper',
  'juniper-junos-config',
  'junit-test-report',
  'junos',
  'juttle',
  'jv',
  'jxa',
  'k',
  'kag',
  'kagex',
  'kb',
  'kbd',
  'kconfig',
  'kerboscript',
  'kernel',
  'kevs',
  'kevscript',
  'kewyword',
  'key',
  'key-assignment',
  'key-letter',
  'key-pair',
  'key-path',
  'key-value',
  'keyboard',
  'keyframe',
  'keyframes',
  'keygroup',
  'keyname',
  'keyspace',
  'keyspace-name',
  'keyvalue',
  'keyword',
  'keyword-parameter',
  'keyword1',
  'keyword2',
  'keyword3',
  'keyword4',
  'keyword5',
  'keyword6',
  'keyword7',
  'keyword8',
  'keyword_arrays',
  'keyword_objects',
  'keyword_roots',
  'keyword_string',
  'keywords',
  'keywork',
  'kickstart',
  'kind',
  'kmd',
  'kn',
  'knitr',
  'knockout',
  'knot',
  'ko',
  'ko-virtual',
  'kos',
  'kotlin',
  'krl',
  'ksp-cfg',
  'kspcfg',
  'kurumin',
  'kv',
  'kxi',
  'kxigauge',
  'l',
  'l20n',
  'l4proto',
  'label',
  'label-expression',
  'labeled',
  'labeled-parameter',
  'labelled-thing',
  'lagda',
  'lambda',
  'lambda-function',
  'lammps',
  'langref',
  'language',
  'language-range',
  'languagebabel',
  'langversion',
  'largesk',
  'lasso',
  'last',
  'last-paren-match',
  'latex',
  'latex2',
  'latino',
  'latte',
  'launch',
  'layout',
  'layoutbii',
  'lbsearch',
  'lc',
  'lc-3',
  'lcb',
  'ldap',
  'ldif',
  'le',
  'leader-char',
  'leading',
  'leading-space',
  'leading-tabs',
  'leaf',
  'lean',
  'ledger',
  'left',
  'left-margin',
  'leftshift',
  'lefttoright',
  'legacy',
  'legacy-setting',
  'lemon',
  'len',
  'length',
  'leopard',
  'less',
  'less-equal',
  'less-or-equal',
  'let',
  'letter',
  'level',
  'level-of-detail',
  'level1',
  'level2',
  'level3',
  'level4',
  'level5',
  'level6',
  'levels',
  'lex',
  'lexc',
  'lexical',
  'lf-in-string',
  'lhs',
  'li',
  'lib',
  'libfile',
  'library',
  'libs',
  'libxml',
  'lid',
  'lifetime',
  'ligature',
  'light',
  'light_purple',
  'lighting',
  'lightning',
  'lilypond',
  'lilypond-drummode',
  'lilypond-figbassmode',
  'lilypond-figuregroup',
  'lilypond-internals',
  'lilypond-lyricsmode',
  'lilypond-markupmode',
  'lilypond-notedrum',
  'lilypond-notemode',
  'lilypond-notemode-explicit',
  'lilypond-notenames',
  'lilypond-schememode',
  'limit_zone',
  'line-block',
  'line-break',
  'line-continuation',
  'line-cue-setting',
  'line-statement',
  'line-too-long',
  'linebreak',
  'linenumber',
  'link',
  'link-label',
  'link-text',
  'link-url',
  'linkage',
  'linkage-type',
  'linkedin',
  'linkedsockets',
  'linkplain',
  'linkplain-label',
  'linq',
  'linuxcncgcode',
  'liquid',
  'liquidhaskell',
  'liquidsoap',
  'lisp',
  'lisp-repl',
  'list',
  'list-done',
  'list-separator',
  'list-style-type',
  'list-today',
  'list_item',
  'listing',
  'listnum',
  'listvalues',
  'litaco',
  'litcoffee',
  'literal',
  'literal-string',
  'literate',
  'litword',
  'livecodescript',
  'livescript',
  'livescriptscript',
  'll',
  'llvm',
  'load-constants',
  'load-hint',
  'loader',
  'local',
  'local-variables',
  'localhost',
  'localizable',
  'localized',
  'localname',
  'locals',
  'localtable',
  'location',
  'lock',
  'log',
  'log-debug',
  'log-error',
  'log-failed',
  'log-info',
  'log-patch',
  'log-success',
  'log-verbose',
  'log-warning',
  'logarithm',
  'logging',
  'logic',
  'logicBegin',
  'logical',
  'logical-expression',
  'logicblox',
  'logicode',
  'logo',
  'logstash',
  'logtalk',
  'lol',
  'long',
  'look-ahead',
  'look-behind',
  'lookahead',
  'lookaround',
  'lookbehind',
  'loop',
  'loop-control',
  'low-high',
  'lowercase',
  'lowercase_character_not_allowed_here',
  'lozenge',
  'lparen',
  'lsg',
  'lsl',
  'lst',
  'lst-cpu12',
  'lstdo',
  'lt',
  'lt-gt',
  'lterat',
  'lu',
  'lua',
  'lucee',
  'lucius',
  'lury',
  'lv',
  'lyricsmode',
  'm',
  'm4',
  'm4sh',
  'm65816',
  'm68k',
  'mac-classic',
  'mac-fsaa',
  'machine',
  'machineclause',
  'macro',
  'macro-usage',
  'macro11',
  'macrocallblock',
  'macrocallinline',
  'madoko',
  'magenta',
  'magic',
  'magik',
  'mail',
  'mailer',
  'mailto',
  'main',
  'makefile',
  'makefile2',
  'mako',
  'mamba',
  'man',
  'mantissa',
  'manualmelisma',
  'map',
  'map-library',
  'map-name',
  'mapfile',
  'mapkey',
  'mapping',
  'mapping-type',
  'maprange',
  'marasm',
  'margin',
  'marginpar',
  'mark',
  'mark-input',
  'markdown',
  'marker',
  'marko',
  'marko-attribute',
  'marko-tag',
  'markup',
  'markupmode',
  'mas2j',
  'mask',
  'mason',
  'mat',
  'mata',
  'match',
  'match-bind',
  'match-branch',
  'match-condition',
  'match-definition',
  'match-exception',
  'match-option',
  'match-pattern',
  'material',
  'material-library',
  'material-name',
  'math',
  'math-symbol',
  'math_complex',
  'math_real',
  'mathematic',
  'mathematica',
  'mathematical',
  'mathematical-symbols',
  'mathematics',
  'mathjax',
  'mathml',
  'matlab',
  'matrix',
  'maude',
  'maven',
  'max',
  'max-angle',
  'max-distance',
  'max-length',
  'maxscript',
  'maybe',
  'mb',
  'mbstring',
  'mc',
  'mcc',
  'mccolor',
  'mch',
  'mcn',
  'mcode',
  'mcq',
  'mcr',
  'mcrypt',
  'mcs',
  'md',
  'mdash',
  'mdoc',
  'mdx',
  'me',
  'measure',
  'media',
  'media-feature',
  'media-property',
  'media-type',
  'mediawiki',
  'mei',
  'mel',
  'memaddress',
  'member',
  'member-function-attribute',
  'member-of',
  'membership',
  'memcache',
  'memcached',
  'memoir',
  'memoir-alltt',
  'memoir-fbox',
  'memoir-verbatim',
  'memory',
  'memory-management',
  'memory-protection',
  'memos',
  'menhir',
  'mention',
  'menu',
  'mercury',
  'merge-group',
  'merge-key',
  'merlin',
  'mesgTrigger',
  'mesgType',
  'message',
  'message-declaration',
  'message-forwarding-handler',
  'message-sending',
  'message-vector',
  'messages',
  'meta',
  'meta-conditional',
  'meta-data',
  'meta-file',
  'meta-info',
  'metaclass',
  'metacommand',
  'metadata',
  'metakey',
  'metamodel',
  'metapost',
  'metascript',
  'meteor',
  'method',
  'method-call',
  'method-definition',
  'method-modification',
  'method-mofification',
  'method-parameter',
  'method-parameters',
  'method-restriction',
  'methodcalls',
  'methods',
  'metrics',
  'mhash',
  'microsites',
  'microsoft-dynamics',
  'middle',
  'midi_processing',
  'migration',
  'mime',
  'min',
  'minelua',
  'minetweaker',
  'minitemplate',
  'minitest',
  'minus',
  'minute',
  'mips',
  'mirah',
  'misc',
  'miscellaneous',
  'mismatched',
  'missing',
  'missing-asterisk',
  'missing-inheritance',
  'missing-parameters',
  'missing-section-begin',
  'missingend',
  'mission-area',
  'mixin',
  'mixin-name',
  'mjml',
  'ml',
  'mlab',
  'mls',
  'mm',
  'mml',
  'mmx',
  'mmx_instructions',
  'mn',
  'mnemonic',
  'mobile-messaging',
  'mochi',
  'mod',
  'mod-r',
  'mod_perl',
  'mod_perl_1',
  'modblock',
  'modbus',
  'mode',
  'model',
  'model-based-calibration',
  'model-predictive-control',
  'modelica',
  'modelicascript',
  'modeline',
  'models',
  'modern',
  'modified',
  'modifier',
  'modifiers',
  'modify',
  'modify-range',
  'modifytime',
  'modl',
  'modr',
  'modula-2',
  'module',
  'module-alias',
  'module-binding',
  'module-definition',
  'module-expression',
  'module-function',
  'module-reference',
  'module-rename',
  'module-sum',
  'module-type',
  'module-type-definition',
  'modules',
  'modulo',
  'modx',
  'mojolicious',
  'mojom',
  'moment',
  'mond',
  'money',
  'mongo',
  'mongodb',
  'monicelli',
  'monitor',
  'monkberry',
  'monkey',
  'monospace',
  'monospaced',
  'monte',
  'month',
  'moon',
  'moonscript',
  'moos',
  'moose',
  'moosecpp',
  'motion',
  'mouse',
  'mov',
  'movement',
  'movie',
  'movie-file',
  'mozu',
  'mpw',
  'mpx',
  'mqsc',
  'ms',
  'mscgen',
  'mscript',
  'msg',
  'msgctxt',
  'msgenny',
  'msgid',
  'msgstr',
  'mson',
  'mson-block',
  'mss',
  'mta',
  'mtl',
  'mucow',
  'mult',
  'multi',
  'multi-line',
  'multi-symbol',
  'multi-threading',
  'multiclet',
  'multids-file',
  'multiline',
  'multiline-cell',
  'multiline-text-reference',
  'multiline-tiddler-title',
  'multimethod',
  'multipart',
  'multiplication',
  'multiplicative',
  'multiply',
  'multiverse',
  'mumps',
  'mundosk',
  'music',
  'must_be',
  'mustache',
  'mut',
  'mutable',
  'mutator',
  'mx',
  'mxml',
  'mydsl1',
  'mylanguage',
  'mysql',
  'mysqli',
  'mysqlnd-memcache',
  'mysqlnd-ms',
  'mysqlnd-qc',
  'mysqlnd-uh',
  'mzn',
  'nabla',
  'nagios',
  'name',
  'name-list',
  'name-of-parameter',
  'named',
  'named-char',
  'named-key',
  'named-tuple',
  'nameless-typed',
  'namelist',
  'names',
  'namespace',
  'namespace-block',
  'namespace-definition',
  'namespace-language',
  'namespace-prefix',
  'namespace-reference',
  'namespace-statement',
  'namespaces',
  'nan',
  'nand',
  'nant',
  'nant-build',
  'narration',
  'nas',
  'nasal',
  'nasl',
  'nasm',
  'nastran',
  'nat',
  'native',
  'nativeint',
  'natural',
  'navigation',
  'nbtkey',
  'ncf',
  'ncl',
  'ndash',
  'ne',
  'nearley',
  'neg-ratio',
  'negatable',
  'negate',
  'negated',
  'negation',
  'negative',
  'negative-look-ahead',
  'negative-look-behind',
  'negativity',
  'nesc',
  'nessuskb',
  'nested',
  'nested_braces',
  'nested_brackets',
  'nested_ltgt',
  'nested_parens',
  'nesty',
  'net',
  'net-object',
  'netbios',
  'network',
  'network-value',
  'networking',
  'neural-network',
  'new',
  'new-line',
  'new-object',
  'newline',
  'newline-spacing',
  'newlinetext',
  'newlisp',
  'newobject',
  'nez',
  'nft',
  'ngdoc',
  'nginx',
  'nickname',
  'nil',
  'nim',
  'nine',
  'ninja',
  'ninjaforce',
  'nit',
  'nitro',
  'nix',
  'nl',
  'nlf',
  'nm',
  'nm7',
  'no',
  'no-capture',
  'no-completions',
  'no-content',
  'no-default',
  'no-indent',
  'no-leading-digits',
  'no-trailing-digits',
  'no-validate-params',
  'node',
  'nogc',
  'noindent',
  'nokia-sros-config',
  'non',
  'non-capturing',
  'non-immediate',
  'non-null-typehinted',
  'non-standard',
  'non-terminal',
  'nondir-target',
  'none',
  'none-parameter',
  'nonlocal',
  'nonterminal',
  'noon',
  'noop',
  'nop',
  'noparams',
  'nor',
  'normal',
  'normal_numeric',
  'normal_objects',
  'normal_text',
  'normalised',
  'not',
  'not-a-number',
  'not-equal',
  'not-identical',
  'notation',
  'note',
  'notechord',
  'notemode',
  'notequal',
  'notequalexpr',
  'notes',
  'notidentical',
  'notification',
  'nowdoc',
  'noweb',
  'nrtdrv',
  'nsapi',
  'nscript',
  'nse',
  'nsis',
  'nsl',
  'ntriples',
  'nul',
  'null',
  'nullify',
  'nullological',
  'nulltype',
  'num',
  'number',
  'number-sign',
  'number-sign-equals',
  'numbered',
  'numberic',
  'numbers',
  'numbersign',
  'numeric',
  'numeric_std',
  'numerical',
  'nunjucks',
  'nut',
  'nvatom',
  'nxc',
  'o',
  'obj',
  'objaggregation',
  'objc',
  'objcpp',
  'objdump',
  'object',
  'object-comments',
  'object-definition',
  'object-level-comment',
  'object-name',
  'objects',
  'objectset',
  'objecttable',
  'objectvalues',
  'objj',
  'obsolete',
  'ocaml',
  'ocamllex',
  'occam',
  'oci8',
  'ocmal',
  'oct',
  'octal',
  'octave',
  'octave-change',
  'octave-shift',
  'octet',
  'octo',
  'octobercms',
  'octothorpe',
  'odd-tab',
  'odedsl',
  'ods',
  'of',
  'off',
  'offset',
  'ofx',
  'ogre',
  'ok',
  'ol',
  'old',
  'old-style',
  'omap',
  'omitted',
  'on-background',
  'on-error',
  'once',
  'one',
  'one-sixth-em',
  'one-twelfth-em',
  'oniguruma',
  'oniguruma-comment',
  'only',
  'only-in',
  'onoff',
  'ooc',
  'oot',
  'op-domain',
  'op-range',
  'opa',
  'opaque',
  'opc',
  'opcache',
  'opcode',
  'opcode-argument-types',
  'opcode-declaration',
  'opcode-definition',
  'opcode-details',
  'open',
  'open-gl',
  'openal',
  'openbinding',
  'opencl',
  'opendss',
  'opening',
  'opening-text',
  'openmp',
  'openssl',
  'opentype',
  'operand',
  'operands',
  'operation',
  'operator',
  'operator2',
  'operator3',
  'operators',
  'opmask',
  'opmaskregs',
  'optical-density',
  'optimization',
  'option',
  'option-description',
  'option-toggle',
  'optional',
  'optional-parameter',
  'optional-parameter-assignment',
  'optionals',
  'optionname',
  'options',
  'optiontype',
  'or',
  'oracle',
  'orbbasic',
  'orcam',
  'orchestra',
  'order',
  'ordered',
  'ordered-block',
  'ordinal',
  'organized',
  'orgtype',
  'origin',
  'osiris',
  'other',
  'other-inherited-class',
  'other_buildins',
  'other_keywords',
  'others',
  'otherwise',
  'otherwise-expression',
  'out',
  'outer',
  'output',
  'overload',
  'override',
  'owner',
  'ownership',
  'oz',
  'p',
  'p4',
  'p5',
  'p8',
  'pa',
  'package',
  'package-definition',
  'package_body',
  'packages',
  'packed',
  'packed-arithmetic',
  'packed-blending',
  'packed-comparison',
  'packed-conversion',
  'packed-floating-point',
  'packed-integer',
  'packed-math',
  'packed-mov',
  'packed-other',
  'packed-shift',
  'packed-shuffle',
  'packed-test',
  'padlock',
  'page',
  'page-props',
  'pagebreak',
  'pair',
  'pair-programming',
  'paket',
  'pandoc',
  'papyrus',
  'papyrus-assembly',
  'paragraph',
  'parallel',
  'param',
  'param-list',
  'paramater',
  'paramerised-type',
  'parameter',
  'parameter-entity',
  'parameter-space',
  'parameterless',
  'parameters',
  'paramless',
  'params',
  'paramtable',
  'paramter',
  'paren',
  'paren-group',
  'parens',
  'parent',
  'parent-reference',
  'parent-selector',
  'parent-selector-suffix',
  'parenthases',
  'parentheses',
  'parenthesis',
  'parenthetical',
  'parenthetical_list',
  'parenthetical_pair',
  'parfor',
  'parfor-quantity',
  'parse',
  'parsed',
  'parser',
  'parser-function',
  'parser-token',
  'parser3',
  'part',
  'partial',
  'particle',
  'pascal',
  'pass',
  'pass-through',
  'passive',
  'passthrough',
  'password',
  'password-hash',
  'patch',
  'path',
  'path-camera',
  'path-pattern',
  'pathoperation',
  'paths',
  'pathspec',
  'patientId',
  'pattern',
  'pattern-argument',
  'pattern-binding',
  'pattern-definition',
  'pattern-match',
  'pattern-offset',
  'patterns',
  'pause',
  'payee',
  'payload',
  'pbo',
  'pbtxt',
  'pcdata',
  'pcntl',
  'pdd',
  'pddl',
  'ped',
  'pegcoffee',
  'pegjs',
  'pending',
  'percentage',
  'percentage-sign',
  'percussionnote',
  'period',
  'perl',
  'perl-section',
  'perl6',
  'perl6fe',
  'perlfe',
  'perlt6e',
  'perm',
  'permutations',
  'personalization',
  'pervasive',
  'pf',
  'pflotran',
  'pfm',
  'pfx',
  'pgn',
  'pgsql',
  'phone',
  'phone-number',
  'phonix',
  'php',
  'php-code-in-comment',
  'php_apache',
  'php_dom',
  'php_ftp',
  'php_imap',
  'php_mssql',
  'php_odbc',
  'php_pcre',
  'php_spl',
  'php_zip',
  'phpdoc',
  'phrasemodifiers',
  'phraslur',
  'physical-zone',
  'physics',
  'pi',
  'pic',
  'pick',
  'pickup',
  'picture',
  'pig',
  'pillar',
  'pipe',
  'pipe-sign',
  'pipeline',
  'piratesk',
  'pitch',
  'pixie',
  'pkgbuild',
  'pl',
  'placeholder',
  'placeholder-parts',
  'plain',
  'plainsimple-emphasize',
  'plainsimple-heading',
  'plainsimple-number',
  'plantuml',
  'player',
  'playerversion',
  'pld_modeling',
  'please-build',
  'please-build-defs',
  'plist',
  'plsql',
  'plugin',
  'plus',
  'plztarget',
  'pmc',
  'pml',
  'pmlPhysics-arrangecharacter',
  'pmlPhysics-emphasisequote',
  'pmlPhysics-graphic',
  'pmlPhysics-header',
  'pmlPhysics-htmlencoded',
  'pmlPhysics-links',
  'pmlPhysics-listtable',
  'pmlPhysics-physicalquantity',
  'pmlPhysics-relationships',
  'pmlPhysics-slides',
  'pmlPhysics-slidestacks',
  'pmlPhysics-speech',
  'pmlPhysics-structure',
  'pnt',
  'po',
  'pod',
  'poe',
  'pogoscript',
  'point',
  'point-size',
  'pointer',
  'pointer-arith',
  'pointer-following',
  'points',
  'polarcoord',
  'policiesbii',
  'policy',
  'polydelim',
  'polygonal',
  'polymer',
  'polymorphic',
  'polymorphic-variant',
  'polynomial-degree',
  'polysep',
  'pony',
  'port',
  'port_list',
  'pos-ratio',
  'position-cue-setting',
  'positional',
  'positive',
  'posix',
  'posix-reserved',
  'post-match',
  'postblit',
  'postcss',
  'postfix',
  'postpone',
  'postscript',
  'potigol',
  'potion',
  'pound',
  'pound-sign',
  'povray',
  'power',
  'power_set',
  'powershell',
  'pp',
  'ppc',
  'ppcasm',
  'ppd',
  'praat',
  'pragma',
  'pragma-all-once',
  'pragma-mark',
  'pragma-message',
  'pragma-newline-spacing',
  'pragma-newline-spacing-value',
  'pragma-once',
  'pragma-stg',
  'pragma-stg-value',
  'pre',
  'pre-defined',
  'pre-match',
  'preamble',
  'prec',
  'precedence',
  'precipitation',
  'precision',
  'precision-point',
  'pred',
  'predefined',
  'predicate',
  'prefetch',
  'prefetchwt',
  'prefix',
  'prefixed-uri',
  'prefixes',
  'preinst',
  'prelude',
  'prepare',
  'prepocessor',
  'preposition',
  'prepositional',
  'preprocessor',
  'prerequisites',
  'preset',
  'preview',
  'previous',
  'prg',
  'primary',
  'primitive',
  'primitive-datatypes',
  'primitive-field',
  'print',
  'print-argument',
  'priority',
  'prism',
  'private',
  'privileged',
  'pro',
  'probe',
  'proc',
  'procedure',
  'procedure_definition',
  'procedure_prototype',
  'process',
  'process-id',
  'process-substitution',
  'processes',
  'processing',
  'proctitle',
  'production',
  'profile',
  'profiling',
  'program',
  'program-block',
  'program-name',
  'progressbars',
  'proguard',
  'project',
  'projectile',
  'prolog',
  'prolog-flags',
  'prologue',
  'promoted',
  'prompt',
  'prompt-prefix',
  'prop',
  'properties',
  'properties_literal',
  'property',
  'property-flag',
  'property-list',
  'property-name',
  'property-value',
  'property-with-attributes',
  'propertydef',
  'propertyend',
  'propertygroup',
  'propertygrouptable',
  'propertyset',
  'propertytable',
  'proposition',
  'protection',
  'protections',
  'proto',
  'protobuf',
  'protobufs',
  'protocol',
  'protocol-specification',
  'prototype',
  'provision',
  'proxy',
  'psci',
  'pseudo',
  'pseudo-class',
  'pseudo-element',
  'pseudo-method',
  'pseudo-mnemonic',
  'pseudo-variable',
  'pshdl',
  'pspell',
  'psql',
  'pt',
  'ptc-config',
  'ptc-config-modelcheck',
  'pthread',
  'ptr',
  'ptx',
  'public',
  'pug',
  'punchcard',
  'punctual',
  'punctuation',
  'punctutation',
  'puncuation',
  'puncutation',
  'puntuation',
  'puppet',
  'purebasic',
  'purescript',
  'pweave',
  'pwisa',
  'pwn',
  'py2pml',
  'pyj',
  'pyjade',
  'pymol',
  'pyresttest',
  'python',
  'python-function',
  'q',
  'q-brace',
  'q-bracket',
  'q-ltgt',
  'q-paren',
  'qa',
  'qm',
  'qml',
  'qos',
  'qoute',
  'qq',
  'qq-brace',
  'qq-bracket',
  'qq-ltgt',
  'qq-paren',
  'qry',
  'qtpro',
  'quad',
  'quad-arrow-down',
  'quad-arrow-left',
  'quad-arrow-right',
  'quad-arrow-up',
  'quad-backslash',
  'quad-caret-down',
  'quad-caret-up',
  'quad-circle',
  'quad-colon',
  'quad-del-down',
  'quad-del-up',
  'quad-diamond',
  'quad-divide',
  'quad-equal',
  'quad-jot',
  'quad-less',
  'quad-not-equal',
  'quad-question',
  'quad-quote',
  'quad-slash',
  'quadrigraph',
  'qual',
  'qualified',
  'qualifier',
  'quality',
  'quant',
  'quantifier',
  'quantifiers',
  'quartz',
  'quasi',
  'quasiquote',
  'quasiquotes',
  'query',
  'query-dsl',
  'question',
  'questionmark',
  'quicel',
  'quicktemplate',
  'quicktime-file',
  'quotation',
  'quote',
  'quoted',
  'quoted-identifier',
  'quoted-object',
  'quoted-or-unquoted',
  'quotes',
  'qx',
  'qx-brace',
  'qx-bracket',
  'qx-ltgt',
  'qx-paren',
  'r',
  'r3',
  'rabl',
  'racket',
  'radar',
  'radar-area',
  'radiobuttons',
  'radix',
  'rails',
  'rainmeter',
  'raml',
  'random',
  'random_number',
  'randomsk',
  'range',
  'range-2',
  'rank',
  'rant',
  'rapid',
  'rarity',
  'ratio',
  'rational-form',
  'raw',
  'raw-regex',
  'raxe',
  'rb',
  'rd',
  'rdfs-type',
  'rdrand',
  'rdseed',
  'react',
  'read',
  'readline',
  'readonly',
  'readwrite',
  'real',
  'realip',
  'rebeca',
  'rebol',
  'rec',
  'receive',
  'receive-channel',
  'recipe',
  'recipient-subscriber-list',
  'recode',
  'record',
  'record-field',
  'record-usage',
  'recordfield',
  'recutils',
  'red',
  'redbook-audio',
  'redirect',
  'redirection',
  'redprl',
  'redundancy',
  'ref',
  'refer',
  'reference',
  'referer',
  'refinement',
  'reflection',
  'reg',
  'regex',
  'regexname',
  'regexp',
  'regexp-option',
  'region-anchor-setting',
  'region-cue-setting',
  'region-identifier-setting',
  'region-lines-setting',
  'region-scroll-setting',
  'region-viewport-anchor-setting',
  'region-width-setting',
  'register',
  'register-64',
  'registers',
  'regular',
  'reiny',
  'reject',
  'rejecttype',
  'rel',
  'related',
  'relation',
  'relational',
  'relations',
  'relationship',
  'relationship-name',
  'relationship-pattern',
  'relationship-pattern-end',
  'relationship-pattern-start',
  'relationship-type',
  'relationship-type-or',
  'relationship-type-ored',
  'relationship-type-start',
  'relative',
  'rem',
  'reminder',
  'remote',
  'removed',
  'rename',
  'renamed-from',
  'renamed-to',
  'renaming',
  'render',
  'renpy',
  'reocrd',
  'reparator',
  'repeat',
  'repl-prompt',
  'replace',
  'replaceXXX',
  'replaced',
  'replacement',
  'reply',
  'repo',
  'reporter',
  'reporting',
  'repository',
  'request',
  'request-type',
  'require',
  'required',
  'requiredness',
  'requirement',
  'requirements',
  'rescue',
  'reserved',
  'reset',
  'resolution',
  'resource',
  'resource-manager',
  'response',
  'response-type',
  'rest',
  'rest-args',
  'rester',
  'restriced',
  'restructuredtext',
  'result',
  'result-separator',
  'results',
  'retro',
  'return',
  'return-type',
  'return-value',
  'returns',
  'rev',
  'reverse',
  'reversed',
  'review',
  'rewrite',
  'rewrite-condition',
  'rewrite-operator',
  'rewrite-pattern',
  'rewrite-substitution',
  'rewrite-test',
  'rewritecond',
  'rewriterule',
  'rf',
  'rfc',
  'rgb',
  'rgb-percentage',
  'rgb-value',
  'rhap',
  'rho',
  'rhs',
  'rhtml',
  'richtext',
  'rid',
  'right',
  'ring',
  'riot',
  'rivescript',
  'rjs',
  'rl',
  'rmarkdown',
  'rnc',
  'rng',
  'ro',
  'roboconf',
  'robot',
  'robotc',
  'robust-control',
  'rockerfile',
  'roff',
  'role',
  'rollout-control',
  'root',
  'rotate',
  'rotate-first',
  'rotate-last',
  'round',
  'round-brackets',
  'router',
  'routeros',
  'routes',
  'routine',
  'row',
  'row2',
  'rowspan',
  'roxygen',
  'rparent',
  'rpc',
  'rpc-definition',
  'rpe',
  'rpm-spec',
  'rpmspec',
  'rpt',
  'rq',
  'rrd',
  'rsl',
  'rspec',
  'rtemplate',
  'ru',
  'ruby',
  'rubymotion',
  'rule',
  'rule-identifier',
  'rule-name',
  'rule-pattern',
  'rule-tag',
  'ruleDefinition',
  'rules',
  'run',
  'rune',
  'runoff',
  'runtime',
  'rust',
  'rviz',
  'rx',
  's',
  'safe-call',
  'safe-navigation',
  'safe-trap',
  'safer',
  'safety',
  'sage',
  'salesforce',
  'salt',
  'sampler',
  'sampler-comparison',
  'samplerarg',
  'sampling',
  'sas',
  'sass',
  'sass-script-maps',
  'satcom',
  'satisfies',
  'sblock',
  'scad',
  'scala',
  'scaladoc',
  'scalar',
  'scale',
  'scam',
  'scan',
  'scenario',
  'scenario_outline',
  'scene',
  'scene-object',
  'scheduled',
  'schelp',
  'schem',
  'schema',
  'scheme',
  'schememode',
  'scientific',
  'scilab',
  'sck',
  'scl',
  'scope',
  'scope-name',
  'scope-resolution',
  'scoping',
  'score',
  'screen',
  'scribble',
  'script',
  'script-flag',
  'script-metadata',
  'script-object',
  'script-tag',
  'scripting',
  'scriptlet',
  'scriptlocal',
  'scriptname',
  'scriptname-declaration',
  'scripts',
  'scroll',
  'scrollbars',
  'scrollpanes',
  'scss',
  'scumm',
  'sdbl',
  'sdl',
  'sdo',
  'sealed',
  'search',
  'seawolf',
  'second',
  'secondary',
  'section',
  'section-attribute',
  'sectionname',
  'sections',
  'see',
  'segment',
  'segment-registers',
  'segment-resolution',
  'select',
  'select-block',
  'selector',
  'self',
  'self-binding',
  'self-close',
  'sem',
  'semantic',
  'semanticmodel',
  'semi-colon',
  'semicolon',
  'semicoron',
  'semireserved',
  'send-channel',
  'sender',
  'senum',
  'sep',
  'separator',
  'separatory',
  'sepatator',
  'seperator',
  'sequence',
  'sequences',
  'serial',
  'serpent',
  'server',
  'service',
  'service-declaration',
  'service-rpc',
  'services',
  'session',
  'set',
  'set-colour',
  'set-size',
  'set-variable',
  'setbagmix',
  'setname',
  'setproperty',
  'sets',
  'setter',
  'setting',
  'settings',
  'settype',
  'setword',
  'seven',
  'severity',
  'sexpr',
  'sfd',
  'sfst',
  'sgml',
  'sgx1',
  'sgx2',
  'sha',
  'sha256',
  'sha512',
  'sha_functions',
  'shad',
  'shade',
  'shaderlab',
  'shadow-object',
  'shape',
  'shape-base',
  'shape-base-data',
  'shared',
  'shared-static',
  'sharp',
  'sharpequal',
  'sharpge',
  'sharpgt',
  'sharple',
  'sharplt',
  'sharpness',
  'shebang',
  'shell',
  'shell-function',
  'shell-session',
  'shift',
  'shift-and-rotate',
  'shift-left',
  'shift-right',
  'shine',
  'shinescript',
  'shipflow',
  'shmop',
  'short',
  'shortcut',
  'shortcuts',
  'shorthand',
  'shorthandpropertyname',
  'show',
  'show-argument',
  'shuffle-and-unpack',
  'shutdown',
  'shy',
  'sidebar',
  'sifu',
  'sigdec',
  'sigil',
  'sign-line',
  'signal',
  'signal-processing',
  'signature',
  'signed',
  'signed-int',
  'signedness',
  'signifier',
  'silent',
  'sim-group',
  'sim-object',
  'sim-set',
  'simd',
  'simd-horizontal',
  'simd-integer',
  'simple',
  'simple-delimiter',
  'simple-divider',
  'simple-element',
  'simple_delimiter',
  'simplexml',
  'simplez',
  'simulate',
  'since',
  'singe',
  'single',
  'single-line',
  'single-quote',
  'single-quoted',
  'single_quote',
  'singlequote',
  'singleton',
  'singleword',
  'sites',
  'six',
  'size',
  'size-cue-setting',
  'sized_integer',
  'sizeof',
  'sjs',
  'sjson',
  'sk',
  'skaction',
  'skdragon',
  'skeeland',
  'skellett',
  'sketchplugin',
  'skevolved',
  'skew',
  'skill',
  'skipped',
  'skmorkaz',
  'skquery',
  'skrambled',
  'skrayfall',
  'skript',
  'skrpg',
  'sksharp',
  'skstuff',
  'skutilities',
  'skvoice',
  'sky',
  'skyrim',
  'sl',
  'slash',
  'slash-bar',
  'slash-option',
  'slash-sign',
  'slashes',
  'sleet',
  'slice',
  'slim',
  'slm',
  'sln',
  'slot',
  'slugignore',
  'sma',
  'smali',
  'smalltalk',
  'smarty',
  'smb',
  'smbinternal',
  'smilebasic',
  'sml',
  'smoothing-group',
  'smpte',
  'smtlib',
  'smx',
  'snakeskin',
  'snapshot',
  'snlog',
  'snmp',
  'so',
  'soap',
  'social',
  'socketgroup',
  'sockets',
  'soft',
  'solidity',
  'solve',
  'soma',
  'somearg',
  'something',
  'soql',
  'sort',
  'sorting',
  'souce',
  'sound',
  'sound_processing',
  'sound_synthesys',
  'source',
  'source-constant',
  'soy',
  'sp',
  'space',
  'space-after-command',
  'spacebars',
  'spaces',
  'sparql',
  'spath',
  'spec',
  'special',
  'special-attributes',
  'special-character',
  'special-curve',
  'special-functions',
  'special-hook',
  'special-keyword',
  'special-method',
  'special-point',
  'special-token-sequence',
  'special-tokens',
  'special-type',
  'specification',
  'specifier',
  'spectral-curve',
  'specular-exponent',
  'specular-reflectivity',
  'sphinx',
  'sphinx-domain',
  'spice',
  'spider',
  'spindlespeed',
  'splat',
  'spline',
  'splunk',
  'splunk-conf',
  'splus',
  'spn',
  'spread',
  'spread-line',
  'spreadmap',
  'sprite',
  'sproto',
  'sproutcore',
  'sqf',
  'sql',
  'sqlbuiltin',
  'sqlite',
  'sqlsrv',
  'sqr',
  'sqsp',
  'squad',
  'square',
  'squart',
  'squirrel',
  'sr-Cyrl',
  'sr-Latn',
  'src',
  'srltext',
  'sros',
  'srt',
  'srv',
  'ss',
  'ssa',
  'sse',
  'sse2',
  'sse2_simd',
  'sse3',
  'sse4',
  'sse4_simd',
  'sse5',
  'sse_avx',
  'sse_simd',
  'ssh-config',
  'ssi',
  'ssl',
  'ssn',
  'sstemplate',
  'st',
  'stable',
  'stack',
  'stack-effect',
  'stackframe',
  'stage',
  'stan',
  'standard',
  'standard-key',
  'standard-links',
  'standard-suite',
  'standardadditions',
  'standoc',
  'star',
  'starline',
  'start',
  'start-block',
  'start-condition',
  'start-symbol',
  'start-value',
  'starting-function-params',
  'starting-functions',
  'starting-functions-point',
  'startshape',
  'stata',
  'statamic',
  'state',
  'state-flag',
  'state-management',
  'stateend',
  'stategrouparg',
  'stategroupval',
  'statement',
  'statement-separator',
  'states',
  'statestart',
  'statetable',
  'static',
  'static-assert',
  'static-classes',
  'static-if',
  'static-shape',
  'staticimages',
  'statistics',
  'stats',
  'std',
  'stdWrap',
  'std_logic',
  'std_logic_1164',
  'stderr-write-file',
  'stdint',
  'stdlib',
  'stdlibcall',
  'stdplugin',
  'stem',
  'step',
  'step-size',
  'steps',
  'stg',
  'stile-shoe-left',
  'stile-shoe-up',
  'stile-tilde',
  'stitch',
  'stk',
  'stmt',
  'stochastic',
  'stop',
  'stopping',
  'storage',
  'story',
  'stp',
  'straight-quote',
  'stray',
  'stray-comment-end',
  'stream',
  'stream-selection-and-control',
  'streamsfuncs',
  'streem',
  'strict',
  'strictness',
  'strike',
  'strikethrough',
  'string',
  'string-constant',
  'string-format',
  'string-interpolation',
  'string-long-quote',
  'string-long-single-quote',
  'string-single-quote',
  'stringchar',
  'stringize',
  'strings',
  'strong',
  'struc',
  'struct',
  'struct-union-block',
  'structdef',
  'structend',
  'structs',
  'structstart',
  'structtable',
  'structure',
  'stuff',
  'stupid-goddamn-hack',
  'style',
  'styleblock',
  'styles',
  'stylus',
  'sub',
  'sub-pattern',
  'subchord',
  'subckt',
  'subcmd',
  'subexp',
  'subexpression',
  'subkey',
  'subkeys',
  'subl',
  'submodule',
  'subnet',
  'subnet6',
  'subpattern',
  'subprogram',
  'subroutine',
  'subscript',
  'subsection',
  'subsections',
  'subset',
  'subshell',
  'subsort',
  'substituted',
  'substitution',
  'substitution-definition',
  'subtitle',
  'subtlegradient',
  'subtlegray',
  'subtract',
  'subtraction',
  'subtype',
  'suffix',
  'sugarml',
  'sugarss',
  'sugly',
  'sugly-comparison-operators',
  'sugly-control-keywords',
  'sugly-declare-function',
  'sugly-delcare-operator',
  'sugly-delcare-variable',
  'sugly-else-in-invalid-position',
  'sugly-encode-clause',
  'sugly-function-groups',
  'sugly-function-recursion',
  'sugly-function-variables',
  'sugly-general-functions',
  'sugly-general-operators',
  'sugly-generic-classes',
  'sugly-generic-types',
  'sugly-global-function',
  'sugly-int-constants',
  'sugly-invoke-function',
  'sugly-json-clause',
  'sugly-language-constants',
  'sugly-math-clause',
  'sugly-math-constants',
  'sugly-multiple-parameter-function',
  'sugly-number-constants',
  'sugly-operator-operands',
  'sugly-print-clause',
  'sugly-single-parameter-function',
  'sugly-subject-or-predicate',
  'sugly-type-function',
  'sugly-uri-clause',
  'summary',
  'super',
  'superclass',
  'supercollider',
  'superscript',
  'superset',
  'supervisor',
  'supervisord',
  'supplemental',
  'supplimental',
  'support',
  'suppress-image-or-category',
  'suppressed',
  'surface',
  'surface-technique',
  'sv',
  'svg',
  'svm',
  'svn',
  'swift',
  'swig',
  'switch',
  'switch-block',
  'switch-expression',
  'switch-statement',
  'switchEnd',
  'switchStart',
  'swizzle',
  'sybase',
  'syllableseparator',
  'symbol',
  'symbol-definition',
  'symbol-type',
  'symbolic',
  'symbolic-math',
  'symbols',
  'symmetry',
  'sync-match',
  'sync-mode',
  'sync-mode-location',
  'synchronization',
  'synchronize',
  'synchronized',
  'synergy',
  'synopsis',
  'syntax',
  'syntax-case',
  'syntax-cluster',
  'syntax-conceal',
  'syntax-error',
  'syntax-include',
  'syntax-item',
  'syntax-keywords',
  'syntax-match',
  'syntax-option',
  'syntax-region',
  'syntax-rule',
  'syntax-spellcheck',
  'syntax-sync',
  'sys-types',
  'sysj',
  'syslink',
  'syslog-ng',
  'system',
  'system-events',
  'system-identification',
  'system-table-pointer',
  'systemreference',
  'sytem-events',
  't',
  't3datastructure',
  't4',
  't5',
  't7',
  'ta',
  'tab',
  'table',
  'table-name',
  'tablename',
  'tabpanels',
  'tabs',
  'tabular',
  'tacacs',
  'tack-down',
  'tack-up',
  'taco',
  'tads3',
  'tag',
  'tag-string',
  'tag-value',
  'tagbraces',
  'tagdef',
  'tagged',
  'tagger_script',
  'taglib',
  'tagname',
  'tagnamedjango',
  'tags',
  'taint',
  'take',
  'target',
  'targetobj',
  'targetprop',
  'task',
  'tasks',
  'tbdfile',
  'tbl',
  'tbody',
  'tcl',
  'tcoffee',
  'tcp-object',
  'td',
  'tdl',
  'tea',
  'team',
  'telegram',
  'tell',
  'telnet',
  'temp',
  'template',
  'template-call',
  'template-parameter',
  'templatetag',
  'tempo',
  'temporal',
  'term',
  'term-comparison',
  'term-creation-and-decomposition',
  'term-io',
  'term-testing',
  'term-unification',
  'terminal',
  'terminate',
  'termination',
  'terminator',
  'terms',
  'ternary',
  'ternary-if',
  'terra',
  'terraform',
  'terrain-block',
  'test',
  'testcase',
  'testing',
  'tests',
  'testsuite',
  'testx',
  'tex',
  'texres',
  'texshop',
  'text',
  'text-reference',
  'text-suite',
  'textbf',
  'textcolor',
  'textile',
  'textio',
  'textit',
  'textlabels',
  'textmate',
  'texttt',
  'textual',
  'texture',
  'texture-map',
  'texture-option',
  'tfoot',
  'th',
  'thead',
  'then',
  'therefore',
  'thin',
  'thing1',
  'third',
  'this',
  'thorn',
  'thread',
  'three',
  'thrift',
  'throughput',
  'throw',
  'throwables',
  'throws',
  'tick',
  'ticket-num',
  'ticket-psa',
  'tid-file',
  'tidal',
  'tidalcycles',
  'tiddler',
  'tiddler-field',
  'tiddler-fields',
  'tidy',
  'tier',
  'tieslur',
  'tikz',
  'tilde',
  'time',
  'timeblock',
  'timehrap',
  'timeout',
  'timer',
  'times',
  'timesig',
  'timespan',
  'timespec',
  'timestamp',
  'timing',
  'titanium',
  'title',
  'title-page',
  'title-text',
  'titled-paragraph',
  'tjs',
  'tl',
  'tla',
  'tlh',
  'tmpl',
  'tmsim',
  'tmux',
  'tnote',
  'tnsaudit',
  'to',
  'to-file',
  'to-type',
  'toc',
  'toc-list',
  'todo',
  'todo_extra',
  'todotxt',
  'token',
  'token-def',
  'token-paste',
  'token-type',
  'tokenised',
  'tokenizer',
  'toml',
  'too-many-tildes',
  'tool',
  'toolbox',
  'tooltip',
  'top',
  'top-level',
  'top_level',
  'topas',
  'topic',
  'topic-decoration',
  'topic-title',
  'tornado',
  'torque',
  'torquescript',
  'tosca',
  'total-config',
  'totaljs',
  'tpye',
  'tr',
  'trace',
  'trace-argument',
  'trace-object',
  'traceback',
  'tracing',
  'track_processing',
  'trader',
  'tradersk',
  'trail',
  'trailing',
  'trailing-array-separator',
  'trailing-dictionary-separator',
  'trailing-match',
  'trait',
  'traits',
  'traits-keyword',
  'transaction',
  'transcendental',
  'transcludeblock',
  'transcludeinline',
  'transclusion',
  'transform',
  'transformation',
  'transient',
  'transition',
  'transitionable-property-value',
  'translation',
  'transmission-filter',
  'transparency',
  'transparent-line',
  'transpose',
  'transposed-func',
  'transposed-matrix',
  'transposed-parens',
  'transposed-variable',
  'trap',
  'tree',
  'treetop',
  'trenni',
  'trigEvent_',
  'trigLevelMod_',
  'trigLevel_',
  'trigger',
  'trigger-words',
  'triggermodifier',
  'trigonometry',
  'trimming-loop',
  'triple',
  'triple-dash',
  'triple-slash',
  'triple-star',
  'true',
  'truncate',
  'truncation',
  'truthgreen',
  'try',
  'try-catch',
  'trycatch',
  'ts',
  'tsql',
  'tss',
  'tst',
  'tsv',
  'tsx',
  'tt',
  'ttcn3',
  'ttlextension',
  'ttpmacro',
  'tts',
  'tubaina',
  'tubaina2',
  'tul',
  'tup',
  'tuple',
  'turbulence',
  'turing',
  'turquoise',
  'turtle',
  'tutch',
  'tvml',
  'tw5',
  'twig',
  'twigil',
  'twiki',
  'two',
  'txl',
  'txt',
  'txt2tags',
  'type',
  'type-annotation',
  'type-cast',
  'type-cheat',
  'type-checking',
  'type-constrained',
  'type-constraint',
  'type-declaration',
  'type-def',
  'type-definition',
  'type-definition-group',
  'type-definitions',
  'type-descriptor',
  'type-of',
  'type-or',
  'type-parameter',
  'type-parameters',
  'type-signature',
  'type-spec',
  'type-specialization',
  'type-specifiers',
  'type_2',
  'type_trait',
  'typeabbrev',
  'typeclass',
  'typed',
  'typed-hole',
  'typedblock',
  'typedcoffeescript',
  'typedecl',
  'typedef',
  'typeexp',
  'typehint',
  'typehinted',
  'typeid',
  'typename',
  'types',
  'typesbii',
  'typescriptish',
  'typographic-quotes',
  'typoscript',
  'typoscript2',
  'u',
  'u-degree',
  'u-end',
  'u-offset',
  'u-resolution',
  'u-scale',
  'u-segments',
  'u-size',
  'u-start',
  'u-value',
  'uc',
  'ucicfg',
  'ucicmd',
  'udaf',
  'udf',
  'udl',
  'udp',
  'udtf',
  'ui',
  'ui-block',
  'ui-group',
  'ui-state',
  'ui-subgroup',
  'uintptr',
  'ujm',
  'uk',
  'ul',
  'umbaska',
  'unOp',
  'unary',
  'unbuffered',
  'unchecked',
  'uncleared',
  'unclosed',
  'unclosed-string',
  'unconstrained',
  'undef',
  'undefined',
  'underbar-circle',
  'underbar-diamond',
  'underbar-iota',
  'underbar-jot',
  'underbar-quote',
  'underbar-semicolon',
  'underline',
  'underline-text',
  'underlined',
  'underscore',
  'undocumented',
  'unescaped-quote',
  'unexpected',
  'unexpected-characters',
  'unexpected-extends',
  'unexpected-extends-character',
  'unfiled',
  'unformatted',
  'unicode',
  'unicode-16-bit',
  'unicode-32-bit',
  'unicode-escape',
  'unicode-raw',
  'unicode-raw-regex',
  'unified',
  'unify',
  'unimplemented',
  'unimportant',
  'union',
  'union-declaration',
  'unique-id',
  'unit',
  'unit-checking',
  'unit-test',
  'unit_test',
  'unittest',
  'unity',
  'unityscript',
  'universal-match',
  'unix',
  'unknown',
  'unknown-escape',
  'unknown-method',
  'unknown-property-name',
  'unknown-rune',
  'unlabeled',
  'unless',
  'unnecessary',
  'unnumbered',
  'uno',
  'unoconfig',
  'unop',
  'unoproj',
  'unordered',
  'unordered-block',
  'unosln',
  'unpack',
  'unpacking',
  'unparsed',
  'unqualified',
  'unquoted',
  'unrecognized',
  'unrecognized-character',
  'unrecognized-character-escape',
  'unrecognized-string-escape',
  'unsafe',
  'unsigned',
  'unsigned-int',
  'unsized_integer',
  'unsupplied',
  'until',
  'untitled',
  'untyped',
  'unused',
  'uopz',
  'update',
  'uppercase',
  'upstream',
  'upwards',
  'ur',
  'uri',
  'url',
  'usable',
  'usage',
  'use',
  'use-as',
  'use-map',
  'use-material',
  'usebean',
  'usecase',
  'usecase-block',
  'user',
  'user-defined',
  'user-defined-property',
  'user-defined-type',
  'user-interaction',
  'userflagsref',
  'userid',
  'username',
  'users',
  'using',
  'using-namespace-declaration',
  'using_animtree',
  'util',
  'utilities',
  'utility',
  'utxt',
  'uv-resolution',
  'uvu',
  'uvw',
  'ux',
  'uxc',
  'uxl',
  'uz',
  'v',
  'v-degree',
  'v-end',
  'v-offset',
  'v-resolution',
  'v-scale',
  'v-segments',
  'v-size',
  'v-start',
  'v-value',
  'val',
  'vala',
  'valgrind',
  'valid',
  'valid-ampersand',
  'valid-bracket',
  'valign',
  'value',
  'value-pair',
  'value-signature',
  'value-size',
  'value-type',
  'valuepair',
  'vamos',
  'vamp',
  'vane-down',
  'vane-left',
  'vane-right',
  'vane-up',
  'var',
  'var-single-variable',
  'var1',
  'var2',
  'variable',
  'variable-access',
  'variable-assignment',
  'variable-declaration',
  'variable-definition',
  'variable-modifier',
  'variable-parameter',
  'variable-reference',
  'variable-usage',
  'variables',
  'variabletable',
  'variant',
  'variant-definition',
  'varname',
  'varnish',
  'vars',
  'vb',
  'vbnet',
  'vbs',
  'vc',
  'vcard',
  'vcd',
  'vcl',
  'vcs',
  'vector',
  'vector-load',
  'vectors',
  'vehicle',
  'velocity',
  'vendor-prefix',
  'verb',
  'verbatim',
  'verdict',
  'verilog',
  'version',
  'version-number',
  'version-specification',
  'vertex',
  'vertex-reference',
  'vertical-blending',
  'vertical-span',
  'vertical-text-cue-setting',
  'vex',
  'vhdl',
  'vhost',
  'vi',
  'via',
  'video-texturing',
  'video_processing',
  'view',
  'viewhelpers',
  'vimAugroupKey',
  'vimBehaveModel',
  'vimFTCmd',
  'vimFTOption',
  'vimFuncKey',
  'vimGroupSpecial',
  'vimHiAttrib',
  'vimHiClear',
  'vimMapModKey',
  'vimPattern',
  'vimSynCase',
  'vimSynType',
  'vimSyncC',
  'vimSyncLinecont',
  'vimSyncMatch',
  'vimSyncNone',
  'vimSyncRegion',
  'vimUserAttrbCmplt',
  'vimUserAttrbKey',
  'vimUserCommand',
  'viml',
  'virtual',
  'virtual-host',
  'virtual-reality',
  'visibility',
  'visualforce',
  'visualization',
  'vlanhdr',
  'vle',
  'vmap',
  'vmx',
  'voice',
  'void',
  'volatile',
  'volt',
  'volume',
  'vpath',
  'vplus',
  'vrf',
  'vtt',
  'vue',
  'vue-jade',
  'vue-stylus',
  'w-offset',
  'w-scale',
  'w-value',
  'w3c-extended-color-name',
  'w3c-non-standard-color-name',
  'w3c-standard-color-name',
  'wait',
  'waitress',
  'waitress-config',
  'waitress-rb',
  'warn',
  'warning',
  'warnings',
  'wast',
  'water',
  'watson-todo',
  'wavefront',
  'wavelet',
  'wddx',
  'wdiff',
  'weapon',
  'weave',
  'weaveBracket',
  'weaveBullet',
  'webidl',
  'webspeed',
  'webvtt',
  'weekday',
  'weirdland',
  'wf',
  'wh',
  'whatever',
  'wheeled-vehicle',
  'when',
  'where',
  'while',
  'while-condition',
  'while-loop',
  'whiskey',
  'white',
  'whitespace',
  'widget',
  'width',
  'wiki',
  'wiki-link',
  'wildcard',
  'wildsk',
  'win',
  'window',
  'window-classes',
  'windows',
  'winered',
  'with',
  'with-arg',
  'with-args',
  'with-arguments',
  'with-params',
  'with-prefix',
  'with-side-effects',
  'with-suffix',
  'with-terminator',
  'with-value',
  'with_colon',
  'without-args',
  'without-arguments',
  'wla-dx',
  'word',
  'word-op',
  'wordnet',
  'wordpress',
  'words',
  'workitem',
  'world',
  'wow',
  'wp',
  'write',
  'wrong',
  'wrong-access-type',
  'wrong-division',
  'wrong-division-assignment',
  'ws',
  'www',
  'wxml',
  'wysiwyg-string',
  'x10',
  'x86',
  'x86_64',
  'x86asm',
  'xacro',
  'xbase',
  'xchg',
  'xhp',
  'xhprof',
  'xikij',
  'xml',
  'xml-attr',
  'xmlrpc',
  'xmlwriter',
  'xop',
  'xor',
  'xparse',
  'xq',
  'xquery',
  'xref',
  'xsave',
  'xsd-all',
  'xsd_nillable',
  'xsd_optional',
  'xsl',
  'xslt',
  'xsse3_simd',
  'xst',
  'xtend',
  'xtoy',
  'xtpl',
  'xu',
  'xvc',
  'xve',
  'xyzw',
  'y',
  'y1',
  'y2',
  'yabb',
  'yaml',
  'yaml-ext',
  'yang',
  'yara',
  'yate',
  'yaws',
  'year',
  'yellow',
  'yield',
  'ykk',
  'yorick',
  'you-forgot-semicolon',
  'z',
  'z80',
  'zap',
  'zapper',
  'zep',
  'zepon',
  'zepto',
  'zero',
  'zero-width-marker',
  'zero-width-print',
  'zeroop',
  'zh-CN',
  'zh-TW',
  'zig',
  'zilde',
  'zlib',
  'zoomfilter',
  'zzz'
]);

================
File: src/deserializer-manager.js
================
const { Disposable } = require('event-kit');
module.exports = class DeserializerManager {
  constructor(atomEnvironment) {
    this.atomEnvironment = atomEnvironment;
    this.deserializers = {};
  }
  add(...deserializers) {
    for (let i = 0; i < deserializers.length; i++) {
      let deserializer = deserializers[i];
      this.deserializers[deserializer.name] = deserializer;
    }
    return new Disposable(() => {
      for (let j = 0; j < deserializers.length; j++) {
        let deserializer = deserializers[j];
        delete this.deserializers[deserializer.name];
      }
    });
  }
  getDeserializerCount() {
    return Object.keys(this.deserializers).length;
  }
  deserialize(state) {
    if (state == null) {
      return;
    }
    const deserializer = this.get(state);
    if (deserializer) {
      let stateVersion =
        (typeof state.get === 'function' && state.get('version')) ||
        state.version;
      if (
        deserializer.version != null &&
        deserializer.version !== stateVersion
      ) {
        return;
      }
      return deserializer.deserialize(state, this.atomEnvironment);
    } else {
      return console.warn('No deserializer found for', state);
    }
  }
  get(state) {
    if (state == null) {
      return;
    }
    let stateDeserializer =
      (typeof state.get === 'function' && state.get('deserializer')) ||
      state.deserializer;
    return this.deserializers[stateDeserializer];
  }
  clear() {
    this.deserializers = {};
  }
};

================
File: src/dock.js
================
const etch = require('etch');
const _ = require('underscore-plus');
const { CompositeDisposable, Emitter } = require('event-kit');
const PaneContainer = require('./pane-container');
const TextEditor = require('./text-editor');
const Grim = require('grim');
const $ = etch.dom;
const MINIMUM_SIZE = 100;
const DEFAULT_INITIAL_SIZE = 300;
const SHOULD_ANIMATE_CLASS = 'atom-dock-should-animate';
const VISIBLE_CLASS = 'atom-dock-open';
const RESIZE_HANDLE_RESIZABLE_CLASS = 'atom-dock-resize-handle-resizable';
const TOGGLE_BUTTON_VISIBLE_CLASS = 'atom-dock-toggle-button-visible';
const CURSOR_OVERLAY_VISIBLE_CLASS = 'atom-dock-cursor-overlay-visible';
module.exports = class Dock {
  constructor(params) {
    this.handleResizeHandleDragStart = this.handleResizeHandleDragStart.bind(
      this
    );
    this.handleResizeToFit = this.handleResizeToFit.bind(this);
    this.handleMouseMove = this.handleMouseMove.bind(this);
    this.handleMouseUp = this.handleMouseUp.bind(this);
    this.handleDrag = _.throttle(this.handleDrag.bind(this), 30);
    this.handleDragEnd = this.handleDragEnd.bind(this);
    this.handleToggleButtonDragEnter = this.handleToggleButtonDragEnter.bind(
      this
    );
    this.toggle = this.toggle.bind(this);
    this.location = params.location;
    this.widthOrHeight = getWidthOrHeight(this.location);
    this.config = params.config;
    this.applicationDelegate = params.applicationDelegate;
    this.deserializerManager = params.deserializerManager;
    this.notificationManager = params.notificationManager;
    this.viewRegistry = params.viewRegistry;
    this.didActivate = params.didActivate;
    this.emitter = new Emitter();
    this.paneContainer = new PaneContainer({
      location: this.location,
      config: this.config,
      applicationDelegate: this.applicationDelegate,
      deserializerManager: this.deserializerManager,
      notificationManager: this.notificationManager,
      viewRegistry: this.viewRegistry
    });
    this.state = {
      size: null,
      visible: false,
      shouldAnimate: false
    };
    this.subscriptions = new CompositeDisposable(
      this.emitter,
      this.paneContainer.onDidActivatePane(() => {
        this.show();
        this.didActivate(this);
      }),
      this.paneContainer.observePanes(pane => {
        pane.onDidAddItem(this.handleDidAddPaneItem.bind(this));
        pane.onDidRemoveItem(this.handleDidRemovePaneItem.bind(this));
      }),
      this.paneContainer.onDidChangeActivePane(item =>
        params.didChangeActivePane(this, item)
      ),
      this.paneContainer.onDidChangeActivePaneItem(item =>
        params.didChangeActivePaneItem(this, item)
      ),
      this.paneContainer.onDidDestroyPaneItem(item =>
        params.didDestroyPaneItem(item)
      )
    );
  }
  elementAttached() {
    etch.updateSync(this);
  }
  getElement() {
    if (this.element == null) {
      etch.initialize(this);
    }
    return this.element;
  }
  getLocation() {
    return this.location;
  }
  destroy() {
    this.subscriptions.dispose();
    this.paneContainer.destroy();
    window.removeEventListener('mousemove', this.handleMouseMove);
    window.removeEventListener('mouseup', this.handleMouseUp);
    window.removeEventListener('drag', this.handleDrag);
    window.removeEventListener('dragend', this.handleDragEnd);
  }
  setHovered(hovered) {
    if (hovered === this.state.hovered) return;
    this.setState({ hovered });
  }
  setDraggingItem(draggingItem) {
    if (draggingItem === this.state.draggingItem) return;
    this.setState({ draggingItem });
  }
  activate() {
    this.getActivePane().activate();
  }
  show() {
    this.setState({ visible: true });
  }
  hide() {
    this.setState({ visible: false });
  }
  toggle() {
    const state = { visible: !this.state.visible };
    if (!state.visible) state.hovered = false;
    this.setState(state);
  }
  isVisible() {
    return this.state.visible;
  }
  setState(newState) {
    const prevState = this.state;
    const nextState = Object.assign({}, prevState, newState);
    if (nextState.visible !== prevState.visible) {
      nextState.shouldAnimate = false;
    } else if (
      !nextState.visible &&
      nextState.draggingItem &&
      !prevState.draggingItem
    ) {
      nextState.shouldAnimate = true;
    }
    this.state = nextState;
    const { hovered, visible } = this.state;
    if (this.element != null) {
      if ((visible && !prevState.visible) || this.state.size !== prevState.size)
        etch.updateSync(this);
      else etch.update(this);
    }
    if (hovered !== prevState.hovered) {
      this.emitter.emit('did-change-hovered', hovered);
    }
    if (visible !== prevState.visible) {
      this.emitter.emit('did-change-visible', visible);
    }
  }
  render() {
    const innerElementClassList = ['atom-dock-inner', this.location];
    if (this.state.visible) innerElementClassList.push(VISIBLE_CLASS);
    const maskElementClassList = ['atom-dock-mask'];
    if (this.state.shouldAnimate)
      maskElementClassList.push(SHOULD_ANIMATE_CLASS);
    const cursorOverlayElementClassList = [
      'atom-dock-cursor-overlay',
      this.location
    ];
    if (this.state.resizing)
      cursorOverlayElementClassList.push(CURSOR_OVERLAY_VISIBLE_CLASS);
    const shouldBeVisible = this.state.visible || this.state.showDropTarget;
    const size = Math.max(
      MINIMUM_SIZE,
      this.state.size ||
        (this.state.draggingItem &&
          getPreferredSize(this.state.draggingItem, this.location)) ||
        DEFAULT_INITIAL_SIZE
    );
    const maskStyle = {
      [this.widthOrHeight]: `${shouldBeVisible ? size : 0}px`
    };
    const wrapperStyle = { [this.widthOrHeight]: `${size}px` };
    return $(
      'atom-dock',
      { className: this.location },
      $.div(
        { ref: 'innerElement', className: innerElementClassList.join(' ') },
        $.div(
          {
            className: maskElementClassList.join(' '),
            style: maskStyle
          },
          $.div(
            {
              ref: 'wrapperElement',
              className: `atom-dock-content-wrapper ${this.location}`,
              style: wrapperStyle
            },
            $(DockResizeHandle, {
              location: this.location,
              onResizeStart: this.handleResizeHandleDragStart,
              onResizeToFit: this.handleResizeToFit,
              dockIsVisible: this.state.visible
            }),
            $(ElementComponent, { element: this.paneContainer.getElement() }),
            $.div({ className: cursorOverlayElementClassList.join(' ') })
          )
        ),
        $(DockToggleButton, {
          ref: 'toggleButton',
          onDragEnter: this.state.draggingItem
            ? this.handleToggleButtonDragEnter
            : null,
          location: this.location,
          toggle: this.toggle,
          dockIsVisible: shouldBeVisible,
          visible:
            (this.state.hovered &&
              (this.state.visible || this.getPaneItems().length > 0)) ||
            (!shouldBeVisible &&
              this.state.draggingItem &&
              isItemAllowed(this.state.draggingItem, this.location))
        })
      )
    );
  }
  update(props) {
    return etch.update(this);
  }
  handleDidAddPaneItem() {
    if (this.state.size == null) {
      this.setState({ size: this.getInitialSize() });
    }
  }
  handleDidRemovePaneItem() {
    if (this.paneContainer.getPaneItems().length === 0) {
      this.setState({ visible: false, hovered: false, size: null });
    }
  }
  handleResizeHandleDragStart() {
    window.addEventListener('mousemove', this.handleMouseMove);
    window.addEventListener('mouseup', this.handleMouseUp);
    this.setState({ resizing: true });
  }
  handleResizeToFit() {
    const item = this.getActivePaneItem();
    if (item) {
      const size = getPreferredSize(item, this.getLocation());
      if (size != null) this.setState({ size });
    }
  }
  handleMouseMove(event) {
    if (event.buttons === 0) {
      this.handleMouseUp(event);
      return;
    }
    let size = 0;
    switch (this.location) {
      case 'left':
        size = event.pageX - this.element.getBoundingClientRect().left;
        break;
      case 'bottom':
        size = this.element.getBoundingClientRect().bottom - event.pageY;
        break;
      case 'right':
        size = this.element.getBoundingClientRect().right - event.pageX;
        break;
    }
    this.setState({ size });
  }
  handleMouseUp(event) {
    window.removeEventListener('mousemove', this.handleMouseMove);
    window.removeEventListener('mouseup', this.handleMouseUp);
    this.setState({ resizing: false });
  }
  handleToggleButtonDragEnter() {
    this.setState({ showDropTarget: true });
    window.addEventListener('drag', this.handleDrag);
    window.addEventListener('dragend', this.handleDragEnd);
  }
  handleDrag(event) {
    if (!this.pointWithinHoverArea({ x: event.pageX, y: event.pageY }, true)) {
      this.draggedOut();
    }
  }
  handleDragEnd() {
    this.draggedOut();
  }
  draggedOut() {
    this.setState({ showDropTarget: false });
    window.removeEventListener('drag', this.handleDrag);
    window.removeEventListener('dragend', this.handleDragEnd);
  }
  pointWithinHoverArea(point, detectingExit) {
    const dockBounds = this.refs.innerElement.getBoundingClientRect();
    const bounds = {
      top: dockBounds.top,
      right: dockBounds.right,
      bottom: dockBounds.bottom,
      left: dockBounds.left
    };
    switch (this.location) {
      case 'right':
        bounds.left = Math.min(bounds.left, bounds.right - 2);
        break;
      case 'bottom':
        bounds.top = Math.min(bounds.top, bounds.bottom - 1);
        break;
      case 'left':
        bounds.right = Math.max(bounds.right, bounds.left + 2);
        break;
    }
    switch (this.location) {
      case 'right':
        bounds.right = Number.POSITIVE_INFINITY;
        break;
      case 'bottom':
        bounds.bottom = Number.POSITIVE_INFINITY;
        break;
      case 'left':
        bounds.left = Number.NEGATIVE_INFINITY;
        break;
    }
    if (rectContainsPoint(bounds, point)) return true;
    const toggleButtonBounds = this.refs.toggleButton.getBounds();
    if (rectContainsPoint(toggleButtonBounds, point)) return true;
    if (detectingExit) {
      const hoverMargin = 20;
      switch (this.location) {
        case 'right':
          bounds.left =
            Math.min(bounds.left, toggleButtonBounds.left) - hoverMargin;
          break;
        case 'bottom':
          bounds.top =
            Math.min(bounds.top, toggleButtonBounds.top) - hoverMargin;
          break;
        case 'left':
          bounds.right =
            Math.max(bounds.right, toggleButtonBounds.right) + hoverMargin;
          break;
      }
      if (rectContainsPoint(bounds, point)) return true;
    }
    return false;
  }
  getInitialSize() {
    const activePaneItem =
      this.paneContainer.getActivePaneItem() ||
      this.paneContainer.getPaneItems()[0];
    return activePaneItem
      ? getPreferredSize(activePaneItem, this.location) || DEFAULT_INITIAL_SIZE
      : null;
  }
  serialize() {
    return {
      deserializer: 'Dock',
      size: this.state.size,
      paneContainer: this.paneContainer.serialize(),
      visible: this.state.visible
    };
  }
  deserialize(serialized, deserializerManager) {
    this.paneContainer.deserialize(
      serialized.paneContainer,
      deserializerManager
    );
    this.setState({
      size: serialized.size || this.getInitialSize(),
      visible:
        serialized.visible && this.paneContainer.getPaneItems().length > 0
    });
  }
  onDidChangeVisible(callback) {
    return this.emitter.on('did-change-visible', callback);
  }
  observeVisible(callback) {
    callback(this.isVisible());
    return this.onDidChangeVisible(callback);
  }
  observePaneItems(callback) {
    return this.paneContainer.observePaneItems(callback);
  }
  onDidChangeActivePaneItem(callback) {
    return this.paneContainer.onDidChangeActivePaneItem(callback);
  }
  onDidStopChangingActivePaneItem(callback) {
    return this.paneContainer.onDidStopChangingActivePaneItem(callback);
  }
  observeActivePaneItem(callback) {
    return this.paneContainer.observeActivePaneItem(callback);
  }
  onDidAddPane(callback) {
    return this.paneContainer.onDidAddPane(callback);
  }
  onWillDestroyPane(callback) {
    return this.paneContainer.onWillDestroyPane(callback);
  }
  onDidDestroyPane(callback) {
    return this.paneContainer.onDidDestroyPane(callback);
  }
  observePanes(callback) {
    return this.paneContainer.observePanes(callback);
  }
  onDidChangeActivePane(callback) {
    return this.paneContainer.onDidChangeActivePane(callback);
  }
  observeActivePane(callback) {
    return this.paneContainer.observeActivePane(callback);
  }
  onDidAddPaneItem(callback) {
    return this.paneContainer.onDidAddPaneItem(callback);
  }
  onWillDestroyPaneItem(callback) {
    return this.paneContainer.onWillDestroyPaneItem(callback);
  }
  onDidDestroyPaneItem(callback) {
    return this.paneContainer.onDidDestroyPaneItem(callback);
  }
  onDidChangeHovered(callback) {
    return this.emitter.on('did-change-hovered', callback);
  }
  getPaneItems() {
    return this.paneContainer.getPaneItems();
  }
  getActivePaneItem() {
    return this.paneContainer.getActivePaneItem();
  }
  getActiveTextEditor() {
    Grim.deprecate(
      'Text editors are not allowed in docks. Use atom.workspace.getActiveTextEditor() instead.'
    );
    const activeItem = this.getActivePaneItem();
    if (activeItem instanceof TextEditor) {
      return activeItem;
    }
  }
  saveAll() {
    this.paneContainer.saveAll();
  }
  confirmClose(options) {
    return this.paneContainer.confirmClose(options);
  }
  getPanes() {
    return this.paneContainer.getPanes();
  }
  getActivePane() {
    return this.paneContainer.getActivePane();
  }
  activateNextPane() {
    return this.paneContainer.activateNextPane();
  }
  activatePreviousPane() {
    return this.paneContainer.activatePreviousPane();
  }
  paneForURI(uri) {
    return this.paneContainer.paneForURI(uri);
  }
  paneForItem(item) {
    return this.paneContainer.paneForItem(item);
  }
  destroyActivePane() {
    const activePane = this.getActivePane();
    if (activePane != null) {
      activePane.destroy();
    }
  }
};
class DockResizeHandle {
  constructor(props) {
    this.props = props;
    etch.initialize(this);
  }
  render() {
    const classList = ['atom-dock-resize-handle', this.props.location];
    if (this.props.dockIsVisible) classList.push(RESIZE_HANDLE_RESIZABLE_CLASS);
    return $.div({
      className: classList.join(' '),
      on: { mousedown: this.handleMouseDown }
    });
  }
  getElement() {
    return this.element;
  }
  getSize() {
    if (!this.size) {
      this.size = this.element.getBoundingClientRect()[
        getWidthOrHeight(this.props.location)
      ];
    }
    return this.size;
  }
  update(newProps) {
    this.props = Object.assign({}, this.props, newProps);
    return etch.update(this);
  }
  handleMouseDown(event) {
    if (event.detail === 2) {
      this.props.onResizeToFit();
    } else if (this.props.dockIsVisible) {
      this.props.onResizeStart();
    }
  }
}
class DockToggleButton {
  constructor(props) {
    this.props = props;
    etch.initialize(this);
  }
  render() {
    const classList = ['atom-dock-toggle-button', this.props.location];
    if (this.props.visible) classList.push(TOGGLE_BUTTON_VISIBLE_CLASS);
    return $.div(
      { className: classList.join(' ') },
      $.div(
        {
          ref: 'innerElement',
          className: `atom-dock-toggle-button-inner ${this.props.location}`,
          on: {
            click: this.handleClick,
            dragenter: this.props.onDragEnter
          }
        },
        $.span({
          ref: 'iconElement',
          className: `icon ${getIconName(
            this.props.location,
            this.props.dockIsVisible
          )}`
        })
      )
    );
  }
  getElement() {
    return this.element;
  }
  getBounds() {
    return this.refs.innerElement.getBoundingClientRect();
  }
  update(newProps) {
    this.props = Object.assign({}, this.props, newProps);
    return etch.update(this);
  }
  handleClick() {
    this.props.toggle();
  }
}
class ElementComponent {
  constructor(props) {
    this.element = props.element;
  }
  update(props) {
    this.element = props.element;
  }
}
function getWidthOrHeight(location) {
  return location === 'left' || location === 'right' ? 'width' : 'height';
}
function getPreferredSize(item, location) {
  switch (location) {
    case 'left':
    case 'right':
      return typeof item.getPreferredWidth === 'function'
        ? item.getPreferredWidth()
        : null;
    default:
      return typeof item.getPreferredHeight === 'function'
        ? item.getPreferredHeight()
        : null;
  }
}
function getIconName(location, visible) {
  switch (location) {
    case 'right':
      return visible ? 'icon-chevron-right' : 'icon-chevron-left';
    case 'bottom':
      return visible ? 'icon-chevron-down' : 'icon-chevron-up';
    case 'left':
      return visible ? 'icon-chevron-left' : 'icon-chevron-right';
    default:
      throw new Error(`Invalid location: ${location}`);
  }
}
function rectContainsPoint(rect, point) {
  return (
    point.x >= rect.left &&
    point.y >= rect.top &&
    point.x <= rect.right &&
    point.y <= rect.bottom
  );
}
function isItemAllowed(item, location) {
  if (typeof item.getAllowedLocations !== 'function') return true;
  return item.getAllowedLocations().includes(location);
}

================
File: src/electron-shims.js
================
const path = require('path');
const electron = require('electron');
const dirname = path.dirname;
path.dirname = function(path) {
  if (typeof path !== 'string') {
    path = '' + path;
    const Grim = require('grim');
    Grim.deprecate('Argument to `path.dirname` must be a string');
  }
  return dirname(path);
};
const extname = path.extname;
path.extname = function(path) {
  if (typeof path !== 'string') {
    path = '' + path;
    const Grim = require('grim');
    Grim.deprecate('Argument to `path.extname` must be a string');
  }
  return extname(path);
};
const basename = path.basename;
path.basename = function(path, ext) {
  if (
    typeof path !== 'string' ||
    (ext !== undefined && typeof ext !== 'string')
  ) {
    path = '' + path;
    const Grim = require('grim');
    Grim.deprecate('Arguments to `path.basename` must be strings');
  }
  return basename(path, ext);
};
electron.ipcRenderer.sendChannel = function() {
  const Grim = require('grim');
  Grim.deprecate('Use `ipcRenderer.send` instead of `ipcRenderer.sendChannel`');
  return this.send.apply(this, arguments);
};
const remoteRequire = electron.remote.require;
electron.remote.require = function(moduleName) {
  const Grim = require('grim');
  switch (moduleName) {
    case 'menu':
      Grim.deprecate('Use `remote.Menu` instead of `remote.require("menu")`');
      return this.Menu;
    case 'menu-item':
      Grim.deprecate(
        'Use `remote.MenuItem` instead of `remote.require("menu-item")`'
      );
      return this.MenuItem;
    case 'browser-window':
      Grim.deprecate(
        'Use `remote.BrowserWindow` instead of `remote.require("browser-window")`'
      );
      return this.BrowserWindow;
    case 'dialog':
      Grim.deprecate(
        'Use `remote.Dialog` instead of `remote.require("dialog")`'
      );
      return this.Dialog;
    case 'app':
      Grim.deprecate('Use `remote.app` instead of `remote.require("app")`');
      return this.app;
    case 'crash-reporter':
      Grim.deprecate(
        'Use `remote.crashReporter` instead of `remote.require("crashReporter")`'
      );
      return this.crashReporter;
    case 'global-shortcut':
      Grim.deprecate(
        'Use `remote.globalShortcut` instead of `remote.require("global-shortcut")`'
      );
      return this.globalShortcut;
    case 'clipboard':
      Grim.deprecate(
        'Use `remote.clipboard` instead of `remote.require("clipboard")`'
      );
      return this.clipboard;
    case 'native-image':
      Grim.deprecate(
        'Use `remote.nativeImage` instead of `remote.require("native-image")`'
      );
      return this.nativeImage;
    case 'tray':
      Grim.deprecate('Use `remote.Tray` instead of `remote.require("tray")`');
      return this.Tray;
    default:
      return remoteRequire.call(this, moduleName);
  }
};

================
File: src/file-system-blob-store.js
================
'use strict';
const fs = require('fs-plus');
const path = require('path');
module.exports = class FileSystemBlobStore {
  static load(directory) {
    let instance = new FileSystemBlobStore(directory);
    instance.load();
    return instance;
  }
  constructor(directory) {
    this.blobFilename = path.join(directory, 'BLOB');
    this.blobMapFilename = path.join(directory, 'MAP');
    this.lockFilename = path.join(directory, 'LOCK');
    this.reset();
  }
  reset() {
    this.inMemoryBlobs = new Map();
    this.storedBlob = Buffer.alloc(0);
    this.storedBlobMap = {};
    this.usedKeys = new Set();
  }
  load() {
    if (!fs.existsSync(this.blobMapFilename)) {
      return;
    }
    if (!fs.existsSync(this.blobFilename)) {
      return;
    }
    try {
      this.storedBlob = fs.readFileSync(this.blobFilename);
      this.storedBlobMap = JSON.parse(fs.readFileSync(this.blobMapFilename));
    } catch (e) {
      this.reset();
    }
  }
  save() {
    let dump = this.getDump();
    let blobToStore = Buffer.concat(dump[0]);
    let mapToStore = JSON.stringify(dump[1]);
    let acquiredLock = false;
    try {
      fs.writeFileSync(this.lockFilename, 'LOCK', { flag: 'wx' });
      acquiredLock = true;
      fs.writeFileSync(this.blobFilename, blobToStore);
      fs.writeFileSync(this.blobMapFilename, mapToStore);
    } catch (error) {
      if (error.code !== 'EEXIST') {
        throw error;
      }
    } finally {
      if (acquiredLock) {
        fs.unlinkSync(this.lockFilename);
      }
    }
  }
  has(key) {
    return (
      this.inMemoryBlobs.has(key) || this.storedBlobMap.hasOwnProperty(key)
    );
  }
  get(key) {
    if (this.has(key)) {
      this.usedKeys.add(key);
      return this.getFromMemory(key) || this.getFromStorage(key);
    }
  }
  set(key, buffer) {
    this.usedKeys.add(key);
    return this.inMemoryBlobs.set(key, buffer);
  }
  delete(key) {
    this.inMemoryBlobs.delete(key);
    delete this.storedBlobMap[key];
  }
  getFromMemory(key) {
    return this.inMemoryBlobs.get(key);
  }
  getFromStorage(key) {
    if (!this.storedBlobMap[key]) {
      return;
    }
    return this.storedBlob.slice.apply(
      this.storedBlob,
      this.storedBlobMap[key]
    );
  }
  getDump() {
    let buffers = [];
    let blobMap = {};
    let currentBufferStart = 0;
    function dump(key, getBufferByKey) {
      let buffer = getBufferByKey(key);
      buffers.push(buffer);
      blobMap[key] = [currentBufferStart, currentBufferStart + buffer.length];
      currentBufferStart += buffer.length;
    }
    for (let key of this.inMemoryBlobs.keys()) {
      if (this.usedKeys.has(key)) {
        dump(key, this.getFromMemory.bind(this));
      }
    }
    for (let key of Object.keys(this.storedBlobMap)) {
      if (!blobMap[key] && this.usedKeys.has(key)) {
        dump(key, this.getFromStorage.bind(this));
      }
    }
    return [buffers, blobMap];
  }
};

================
File: src/first-mate-helpers.js
================
module.exports = {
  fromFirstMateScopeId(firstMateScopeId) {
    let atomScopeId = -firstMateScopeId;
    if ((atomScopeId & 1) === 0) atomScopeId--;
    return atomScopeId + 256;
  },
  toFirstMateScopeId(atomScopeId) {
    return -(atomScopeId - 256);
  }
};

================
File: src/get-app-details.js
================
function getReleaseChannel(version) {
  const match = version.match(/\d+\.\d+\.\d+(-([a-z]+)(\d+|-\w{4,})?)?$/);
  if (!match) {
    return "unrecognized";
  } else if (match[2]) {
    return match[2];
  }
  return "stable";
}
function getAppName() {
  const { app } = require("electron");
  if (process.type === "renderer") {
    return atom.getAppName();
  }
  const releaseChannel = getReleaseChannel(app.getVersion());
  const appNameParts = [app.getName()];
  if (releaseChannel !== "stable") {
    appNameParts.push(
      releaseChannel.charAt(0).toUpperCase() + releaseChannel.slice(1)
    );
  }
  return appNameParts.join(" ");
}
function getConfigFilePath(opts = {}) {
  const fs = require("fs");
  const path = require("path");
  let configFilePath = [ "config.json", "config.cson" ].map(file =>
    path.join(process.env.ATOM_HOME, file)
  ).find(f => fs.existsSync(f));
  if (configFilePath) {
    return configFilePath;
  } else {
    if (opts.returnPlaceholder) {
      return path.join(process.env.ATOM_HOME, "config.cson");
    } else {
      return null;
    }
  }
}
module.exports = {
  getReleaseChannel,
  getAppName,
  getConfigFilePath,
};

================
File: src/get-window-load-settings.js
================
const { remote } = require('electron');
let windowLoadSettings = null;
module.exports = () => {
  if (!windowLoadSettings) {
    windowLoadSettings = JSON.parse(remote.getCurrentWindow().loadSettingsJSON);
  }
  return windowLoadSettings;
};

================
File: src/git-repository-provider.js
================
const fs = require('fs');
const { Directory } = require('pathwatcher');
const GitRepository = require('./git-repository');
const GIT_FILE_REGEX = RegExp('^gitdir: (.+)');
function pathFromGitFileSync(gitFile) {
  try {
    const gitFileBuff = fs.readFileSync(gitFile, 'utf8');
    return gitFileBuff != null ? gitFileBuff.match(GIT_FILE_REGEX)[1] : null;
  } catch (error) {}
}
function pathFromGitFile(gitFile) {
  return new Promise(resolve => {
    fs.readFile(gitFile, 'utf8', (err, gitFileBuff) => {
      if (err == null && gitFileBuff != null) {
        const result = gitFileBuff.toString().match(GIT_FILE_REGEX);
        resolve(result != null ? result[1] : null);
      } else {
        resolve(null);
      }
    });
  });
}
function findGitDirectorySync(directory) {
  let gitDir = directory.getSubdirectory('.git');
  if (typeof gitDir.getPath === 'function') {
    const gitDirPath = pathFromGitFileSync(gitDir.getPath());
    if (gitDirPath) {
      gitDir = new Directory(directory.resolve(gitDirPath));
    }
  }
  if (
    typeof gitDir.existsSync === 'function' &&
    gitDir.existsSync() &&
    isValidGitDirectorySync(gitDir)
  ) {
    return gitDir;
  } else if (directory.isRoot()) {
    return null;
  } else {
    return findGitDirectorySync(directory.getParent());
  }
}
async function findGitDirectory(directory) {
  let gitDir = directory.getSubdirectory('.git');
  if (typeof gitDir.getPath === 'function') {
    const gitDirPath = await pathFromGitFile(gitDir.getPath());
    if (gitDirPath) {
      gitDir = new Directory(directory.resolve(gitDirPath));
    }
  }
  if (
    typeof gitDir.exists === 'function' &&
    (await gitDir.exists()) &&
    (await isValidGitDirectory(gitDir))
  ) {
    return gitDir;
  } else if (directory.isRoot()) {
    return null;
  } else {
    return findGitDirectory(directory.getParent());
  }
}
function isValidGitDirectorySync(directory) {
  const commonDirFile = directory.getSubdirectory('commondir');
  let commonDir;
  if (commonDirFile.existsSync()) {
    const commonDirPathBuff = fs.readFileSync(commonDirFile.getPath());
    const commonDirPathString = commonDirPathBuff.toString().trim();
    commonDir = new Directory(directory.resolve(commonDirPathString));
    if (!commonDir.existsSync()) {
      return false;
    }
  } else {
    commonDir = directory;
  }
  return (
    directory.getFile('HEAD').existsSync() &&
    commonDir.getSubdirectory('objects').existsSync() &&
    commonDir.getSubdirectory('refs').existsSync()
  );
}
async function isValidGitDirectory(directory) {
  const commonDirFile = directory.getSubdirectory('commondir');
  let commonDir;
  if (await commonDirFile.exists()) {
    const commonDirPathBuff = await fs.readFile(commonDirFile.getPath());
    const commonDirPathString = commonDirPathBuff.toString().trim();
    commonDir = new Directory(directory.resolve(commonDirPathString));
    if (!(await commonDir.exists())) {
      return false;
    }
  } else {
    commonDir = directory;
  }
  return (
    (await directory.getFile('HEAD').exists()) &&
    (await commonDir.getSubdirectory('objects').exists()) &&
    commonDir.getSubdirectory('refs').exists()
  );
}
class GitRepositoryProvider {
  constructor(project, config) {
    this.project = project;
    this.config = config;
    this.pathToRepository = {};
  }
  async repositoryForDirectory(directory) {
    const gitDir = await findGitDirectory(directory);
    return this.repositoryForGitDirectory(gitDir);
  }
  repositoryForDirectorySync(directory) {
    const gitDir = findGitDirectorySync(directory);
    return this.repositoryForGitDirectory(gitDir);
  }
  repositoryForGitDirectory(gitDir) {
    if (!gitDir) {
      return null;
    }
    const gitDirPath = gitDir.getPath();
    let repo = this.pathToRepository[gitDirPath];
    if (!repo) {
      repo = GitRepository.open(gitDirPath, {
        project: this.project,
        config: this.config
      });
      if (!repo) {
        return null;
      }
      repo.onDidDestroy(() => delete this.pathToRepository[gitDirPath]);
      this.pathToRepository[gitDirPath] = repo;
      repo.refreshIndex();
      repo.refreshStatus();
    }
    return repo;
  }
}
module.exports = GitRepositoryProvider;

================
File: src/git-repository.js
================
const path = require('path');
const fs = require('fs-plus');
const _ = require('underscore-plus');
const { Emitter, Disposable, CompositeDisposable } = require('event-kit');
const GitUtils = require('git-utils');
let nextId = 0;
module.exports = class GitRepository {
  static exists(path) {
    const git = this.open(path);
    if (git) {
      git.destroy();
      return true;
    } else {
      return false;
    }
  }
  static open(path, options) {
    if (!path) {
      return null;
    }
    try {
      return new GitRepository(path, options);
    } catch (error) {
      return null;
    }
  }
  constructor(path, options = {}) {
    this.id = nextId++;
    this.emitter = new Emitter();
    this.subscriptions = new CompositeDisposable();
    this.repo = GitUtils.open(path);
    if (this.repo == null) {
      throw new Error(`No Git repository found searching path: ${path}`);
    }
    this.statusRefreshCount = 0;
    this.statuses = {};
    this.upstream = { ahead: 0, behind: 0 };
    for (let submodulePath in this.repo.submodules) {
      const submoduleRepo = this.repo.submodules[submodulePath];
      submoduleRepo.upstream = { ahead: 0, behind: 0 };
    }
    this.project = options.project;
    this.config = options.config;
    if (options.refreshOnWindowFocus || options.refreshOnWindowFocus == null) {
      const onWindowFocus = () => {
        this.refreshIndex();
        this.refreshStatus();
      };
      window.addEventListener('focus', onWindowFocus);
      this.subscriptions.add(
        new Disposable(() => window.removeEventListener('focus', onWindowFocus))
      );
    }
    if (this.project != null) {
      this.project
        .getBuffers()
        .forEach(buffer => this.subscribeToBuffer(buffer));
      this.subscriptions.add(
        this.project.onDidAddBuffer(buffer => this.subscribeToBuffer(buffer))
      );
    }
  }
  destroy() {
    this.repo = null;
    if (this.emitter) {
      this.emitter.emit('did-destroy');
      this.emitter.dispose();
      this.emitter = null;
    }
    if (this.subscriptions) {
      this.subscriptions.dispose();
      this.subscriptions = null;
    }
  }
  isDestroyed() {
    return this.repo == null;
  }
  onDidDestroy(callback) {
    return this.emitter.once('did-destroy', callback);
  }
  onDidChangeStatus(callback) {
    return this.emitter.on('did-change-status', callback);
  }
  onDidChangeStatuses(callback) {
    return this.emitter.on('did-change-statuses', callback);
  }
  getType() {
    return 'git';
  }
  getPath() {
    if (this.path == null) {
      this.path = fs.absolute(this.getRepo().getPath());
    }
    return this.path;
  }
  getWorkingDirectory() {
    return this.getRepo().getWorkingDirectory();
  }
  isProjectAtRoot() {
    if (this.projectAtRoot == null) {
      this.projectAtRoot =
        this.project &&
        this.project.relativize(this.getWorkingDirectory()) === '';
    }
    return this.projectAtRoot;
  }
  // Public: Makes a path relative to the repository's working directory.
  relativize(path) {
    return this.getRepo().relativize(path);
  }
  hasBranch(branch) {
    return this.getReferenceTarget(`refs/heads/${branch}`) != null;
  }
  getShortHead(path) {
    return this.getRepo(path).getShortHead();
  }
  isSubmodule(filePath) {
    if (!filePath) return false;
    const repo = this.getRepo(filePath);
    if (repo.isSubmodule(repo.relativize(filePath))) {
      return true;
    } else {
      return (
        repo !== this.getRepo() &&
        repo.relativize(path.join(filePath, 'dir')) === 'dir'
      );
    }
  }
  getAheadBehindCount(reference, path) {
    return this.getRepo(path).getAheadBehindCount(reference);
  }
  getCachedUpstreamAheadBehindCount(path) {
    return this.getRepo(path).upstream || this.upstream;
  }
  getConfigValue(key, path) {
    return this.getRepo(path).getConfigValue(key);
  }
  getOriginURL(path) {
    return this.getConfigValue('remote.origin.url', path);
  }
  getUpstreamBranch(path) {
    return this.getRepo(path).getUpstreamBranch();
  }
  getReferences(path) {
    return this.getRepo(path).getReferences();
  }
  getReferenceTarget(reference, path) {
    return this.getRepo(path).getReferenceTarget(reference);
  }
  isPathModified(path) {
    return this.isStatusModified(this.getPathStatus(path));
  }
  isPathNew(path) {
    return this.isStatusNew(this.getPathStatus(path));
  }
  isPathIgnored(path) {
    return this.getRepo().isIgnored(this.relativize(path));
  }
  getDirectoryStatus(directoryPath) {
    directoryPath = `${this.relativize(directoryPath)}/`;
    let directoryStatus = 0;
    for (let statusPath in this.statuses) {
      const status = this.statuses[statusPath];
      if (statusPath.startsWith(directoryPath)) directoryStatus |= status;
    }
    return directoryStatus;
  }
  getPathStatus(path) {
    const repo = this.getRepo(path);
    const relativePath = this.relativize(path);
    const currentPathStatus = this.statuses[relativePath] || 0;
    let pathStatus = repo.getStatus(repo.relativize(path)) || 0;
    if (repo.isStatusIgnored(pathStatus)) pathStatus = 0;
    if (pathStatus > 0) {
      this.statuses[relativePath] = pathStatus;
    } else {
      delete this.statuses[relativePath];
    }
    if (currentPathStatus !== pathStatus) {
      this.emitter.emit('did-change-status', { path, pathStatus });
    }
    return pathStatus;
  }
  getCachedPathStatus(path) {
    return this.statuses[this.relativize(path)];
  }
  isStatusModified(status) {
    return this.getRepo().isStatusModified(status);
  }
  isStatusNew(status) {
    return this.getRepo().isStatusNew(status);
  }
  getDiffStats(path) {
    const repo = this.getRepo(path);
    return repo.getDiffStats(repo.relativize(path));
  }
  getLineDiffs(path, text) {
    const options = { ignoreEolWhitespace: process.platform === 'win32' };
    const repo = this.getRepo(path);
    return repo.getLineDiffs(repo.relativize(path), text, options);
  }
  checkoutHead(path) {
    const repo = this.getRepo(path);
    const headCheckedOut = repo.checkoutHead(repo.relativize(path));
    if (headCheckedOut) this.getPathStatus(path);
    return headCheckedOut;
  }
  checkoutReference(reference, create) {
    return this.getRepo().checkoutReference(reference, create);
  }
  subscribeToBuffer(buffer) {
    const getBufferPathStatus = () => {
      const bufferPath = buffer.getPath();
      if (bufferPath) this.getPathStatus(bufferPath);
    };
    getBufferPathStatus();
    const bufferSubscriptions = new CompositeDisposable();
    bufferSubscriptions.add(buffer.onDidSave(getBufferPathStatus));
    bufferSubscriptions.add(buffer.onDidReload(getBufferPathStatus));
    bufferSubscriptions.add(buffer.onDidChangePath(getBufferPathStatus));
    bufferSubscriptions.add(
      buffer.onDidDestroy(() => {
        bufferSubscriptions.dispose();
        return this.subscriptions.remove(bufferSubscriptions);
      })
    );
    this.subscriptions.add(bufferSubscriptions);
  }
  checkoutHeadForEditor(editor) {
    const buffer = editor.getBuffer();
    const bufferPath = buffer.getPath();
    if (bufferPath) {
      this.checkoutHead(bufferPath);
      return buffer.reload();
    }
  }
  getRepo(path) {
    if (this.repo) {
      return this.repo.submoduleForPath(path) || this.repo;
    } else {
      throw new Error('Repository has been destroyed');
    }
  }
  refreshIndex() {
    return this.getRepo().refreshIndex();
  }
  async refreshStatus() {
    const statusRefreshCount = ++this.statusRefreshCount;
    const repo = this.getRepo();
    const relativeProjectPaths =
      this.project &&
      this.project
        .getPaths()
        .map(projectPath => this.relativize(projectPath))
        .filter(
          projectPath => projectPath.length > 0 && !path.isAbsolute(projectPath)
        );
    const branch = await repo.getHeadAsync();
    const upstream = await repo.getAheadBehindCountAsync();
    const statuses = {};
    const repoStatus =
      relativeProjectPaths.length > 0
        ? await repo.getStatusAsync(relativeProjectPaths)
        : await repo.getStatusAsync();
    for (let filePath in repoStatus) {
      statuses[filePath] = repoStatus[filePath];
    }
    const submodules = {};
    for (let submodulePath in repo.submodules) {
      const submoduleRepo = repo.submodules[submodulePath];
      submodules[submodulePath] = {
        branch: await submoduleRepo.getHeadAsync(),
        upstream: await submoduleRepo.getAheadBehindCountAsync()
      };
      const workingDirectoryPath = submoduleRepo.getWorkingDirectory();
      const submoduleStatus = await submoduleRepo.getStatusAsync();
      for (let filePath in submoduleStatus) {
        const absolutePath = path.join(workingDirectoryPath, filePath);
        const relativizePath = repo.relativize(absolutePath);
        statuses[relativizePath] = submoduleStatus[filePath];
      }
    }
    if (this.statusRefreshCount !== statusRefreshCount || this.isDestroyed())
      return;
    const statusesUnchanged =
      _.isEqual(branch, this.branch) &&
      _.isEqual(statuses, this.statuses) &&
      _.isEqual(upstream, this.upstream) &&
      _.isEqual(submodules, this.submodules);
    this.branch = branch;
    this.statuses = statuses;
    this.upstream = upstream;
    this.submodules = submodules;
    for (let submodulePath in repo.submodules) {
      repo.submodules[submodulePath].upstream =
        submodules[submodulePath].upstream;
    }
    if (!statusesUnchanged) this.emitter.emit('did-change-statuses');
  }
};

================
File: src/grammar-registry.js
================
const _ = require('underscore-plus');
const Grim = require('grim');
const CSON = require('season');
const SecondMate = require('second-mate');
const { Disposable, CompositeDisposable, Emitter } = require('event-kit');
const TextMateLanguageMode = require('./text-mate-language-mode');
const NodeTreeSitterLanguageMode = require('./tree-sitter-language-mode');
const WASMTreeSitterLanguageMode = require('./wasm-tree-sitter-language-mode');
const TreeSitterGrammar = require('./tree-sitter-grammar');
const WASMTreeSitterGrammar = require('./wasm-tree-sitter-grammar');
const ScopeDescriptor = require('./scope-descriptor');
const Token = require('./token');
const fs = require('fs-plus');
const { Point, Range } = require('text-buffer');
const PATH_SPLIT_REGEX = new RegExp('[/.]');
module.exports = class GrammarRegistry {
  constructor({ config } = {}) {
    this.config = config;
    this.subscriptions = new CompositeDisposable();
    this.textmateRegistry = new SecondMate.GrammarRegistry({
      maxTokensPerLine: 100,
      maxLineLength: 1000
    });
    this.emitter = new Emitter();
    this.clear();
  }
  clear() {
    this.textmateRegistry.clear();
    this.wasmTreeSitterGrammarsById = {};
    this.treeSitterGrammarsById = {};
    if (this.subscriptions) this.subscriptions.dispose();
    this.subscriptions = new CompositeDisposable();
    this.languageOverridesByBufferId = new Map();
    this.grammarScoresByBuffer = new Map();
    this.textMateScopeNamesByTreeSitterLanguageId = new Map();
    this.treeSitterLanguageIdsByTextMateScopeName = new Map();
    const grammarAddedOrUpdated = this.grammarAddedOrUpdated.bind(this);
    this.textmateRegistry.onDidAddGrammar(grammarAddedOrUpdated);
    this.textmateRegistry.onDidUpdateGrammar(grammarAddedOrUpdated);
    let onLanguageModeChange = () => {
      this.grammarScoresByBuffer.forEach((_score, buffer) => {
        if (!this.languageOverridesByBufferId.has(buffer.id)) {
          this.autoAssignLanguageMode(buffer);
        }
      });
    };
    this.subscriptions.add(
      this.config.onDidChange('core.useTreeSitterParsers', onLanguageModeChange),
      this.config.onDidChange('core.useLegacyTreeSitter', onLanguageModeChange)
    );
  }
  serialize() {
    const languageOverridesByBufferId = {};
    this.languageOverridesByBufferId.forEach((languageId, bufferId) => {
      languageOverridesByBufferId[bufferId] = languageId;
    });
    return { languageOverridesByBufferId };
  }
  deserialize(params) {
    for (const bufferId in params.languageOverridesByBufferId || {}) {
      this.languageOverridesByBufferId.set(
        bufferId,
        params.languageOverridesByBufferId[bufferId]
      );
    }
  }
  createToken(value, scopes) {
    return new Token({ value, scopes });
  }
  maintainLanguageMode(buffer) {
    this.grammarScoresByBuffer.set(buffer, null);
    const languageOverride = this.languageOverridesByBufferId.get(buffer.id);
    if (languageOverride) {
      this.assignLanguageMode(buffer, languageOverride);
    } else {
      this.autoAssignLanguageMode(buffer);
    }
    const pathChangeSubscription = buffer.onDidChangePath(() => {
      this.grammarScoresByBuffer.delete(buffer);
      if (!this.languageOverridesByBufferId.has(buffer.id)) {
        this.autoAssignLanguageMode(buffer);
      }
    });
    const destroySubscription = buffer.onDidDestroy(() => {
      this.grammarScoresByBuffer.delete(buffer);
      this.languageOverridesByBufferId.delete(buffer.id);
      this.subscriptions.remove(destroySubscription);
      this.subscriptions.remove(pathChangeSubscription);
    });
    this.subscriptions.add(pathChangeSubscription, destroySubscription);
    return new Disposable(() => {
      destroySubscription.dispose();
      pathChangeSubscription.dispose();
      this.subscriptions.remove(pathChangeSubscription);
      this.subscriptions.remove(destroySubscription);
      this.grammarScoresByBuffer.delete(buffer);
      this.languageOverridesByBufferId.delete(buffer.id);
    });
  }
  assignLanguageMode(buffer, languageId) {
    if (buffer.getBuffer) buffer = buffer.getBuffer();
    let grammar = null;
    if (languageId != null) {
      grammar = this.grammarForId(languageId);
      if (!grammar || !grammar.scopeName) return false;
      this.languageOverridesByBufferId.set(buffer.id, languageId);
    } else {
      this.languageOverridesByBufferId.set(buffer.id, null);
      grammar = this.textmateRegistry.nullGrammar;
    }
    this.grammarScoresByBuffer.set(buffer, null);
    if (grammar !== buffer.getLanguageMode().grammar) {
      buffer.setLanguageMode(
        this.languageModeForGrammarAndBuffer(grammar, buffer)
      );
    }
    return true;
  }
  assignGrammar(buffer, grammar) {
    if (!grammar) return false;
    if (buffer.getBuffer) buffer = buffer.getBuffer();
    this.languageOverridesByBufferId.set(buffer.id, grammar.scopeName || null);
    this.grammarScoresByBuffer.set(buffer, null);
    if (grammar !== buffer.getLanguageMode().grammar) {
      buffer.setLanguageMode(
        this.languageModeForGrammarAndBuffer(grammar, buffer)
      );
    }
    return true;
  }
  getAssignedLanguageId(buffer) {
    return this.languageOverridesByBufferId.get(buffer.id);
  }
  autoAssignLanguageMode(buffer) {
    const result = this.selectGrammarWithScore(
      buffer.getPath(),
      getGrammarSelectionContent(buffer)
    );
    this.languageOverridesByBufferId.delete(buffer.id);
    this.grammarScoresByBuffer.set(buffer, result.score);
    if (result.grammar !== buffer.getLanguageMode().grammar) {
      buffer.setLanguageMode(
        this.languageModeForGrammarAndBuffer(result.grammar, buffer)
      );
    }
  }
  languageModeForGrammarAndBuffer(grammar, buffer) {
    if (grammar instanceof WASMTreeSitterGrammar) {
      return new WASMTreeSitterLanguageMode({
        grammar,
        buffer,
        config: this.config,
        grammars: this
      });
    } else if (grammar instanceof TreeSitterGrammar) {
      return new NodeTreeSitterLanguageMode({
        grammar,
        buffer,
        config: this.config,
        grammars: this
      });
    } else {
      return new TextMateLanguageMode({ grammar, buffer, config: this.config });
    }
  }
  selectGrammar(filePath, fileContents) {
    return this.selectGrammarWithScore(filePath, fileContents).grammar;
  }
  selectGrammarWithScore(filePath, fileContents) {
    let bestMatch = null;
    let highestScore = -Infinity;
    this.forEachGrammar(grammar => {
      const score = this.getGrammarScore(grammar, filePath, fileContents);
      if (score > highestScore || bestMatch == null) {
        bestMatch = grammar;
        highestScore = score;
      }
    });
    return { grammar: bestMatch, score: highestScore };
  }
  getLanguageParserForScope(scope) {
    if (typeof scope === 'string') {
      scope = new ScopeDescriptor({ scopes: [scope] })
    }
    let useTreeSitterParsers = this.config.get('core.useTreeSitterParsers', { scope });
    let useLegacyTreeSitter = this.config.get('core.useLegacyTreeSitter', { scope });
    if (!useTreeSitterParsers) return 'textmate';
    return useLegacyTreeSitter ? 'node-tree-sitter' : 'wasm-tree-sitter';
  }
  getGrammarScore(grammar, filePath, contents) {
    if (contents == null && fs.isFileSync(filePath)) {
      contents = fs.readFileSync(filePath, 'utf8');
    }
    let score = this.getGrammarPathScore(grammar, filePath);
    if (this.grammarMatchesPrefix(grammar, contents)) score += 0.5;
    if (score > 0) {
      const isNewTreeSitter = grammar instanceof WASMTreeSitterGrammar;
      const isOldTreeSitter = grammar instanceof TreeSitterGrammar;
      const isTreeSitter = isNewTreeSitter || isOldTreeSitter;
      let scope = new ScopeDescriptor({ scopes: [grammar.scopeName] });
      let parserConfig = this.getLanguageParserForScope(scope);
      if (isNewTreeSitter) {
        if (parserConfig === 'wasm-tree-sitter') {
          score += 0.1;
        } else if (parserConfig === 'textmate') {
          score = -1;
        }
      } else if (isOldTreeSitter) {
        if (parserConfig === 'node-tree-sitter') {
          score += 0.1;
        } else if (parserConfig === 'wasm-tree-sitter') {
          score += 0.09;
        } else if (parserConfig === 'textmate') {
          score = -1;
        }
      }
      if (grammar.contentRegex) {
        const contentMatch = isTreeSitter
          ? grammar.contentRegex.test(contents)
          : grammar.contentRegex.findNextMatchSync(contents);
        if (contentMatch) {
          score += 0.05;
        } else {
          score -= 0.05;
        }
      }
      if (!grammar.bundledPackage) score += 0.01;
    }
    return score;
  }
  getGrammarPathScore(grammar, filePath) {
    if (!filePath) return -1;
    if (process.platform === 'win32') {
      filePath = filePath.replace(/\\/g, '/');
    }
    const pathComponents = filePath.toLowerCase().split(PATH_SPLIT_REGEX);
    let pathScore = 0;
    let customFileTypes;
    if (this.config.get('core.customFileTypes')) {
      customFileTypes = this.config.get('core.customFileTypes')[
        grammar.scopeName
      ];
    }
    let { fileTypes } = grammar;
    if (customFileTypes) {
      fileTypes = fileTypes.concat(customFileTypes);
    }
    for (let i = 0; i < fileTypes.length; i++) {
      const fileType = fileTypes[i];
      const fileTypeComponents = fileType.toLowerCase().split(PATH_SPLIT_REGEX);
      const pathSuffix = pathComponents.slice(-fileTypeComponents.length);
      if (_.isEqual(pathSuffix, fileTypeComponents)) {
        pathScore = Math.max(pathScore, fileType.length);
        if (i >= grammar.fileTypes.length) {
          pathScore += 0.5;
        }
      }
    }
    return pathScore;
  }
  grammarMatchesPrefix(grammar, contents) {
    if (contents && grammar.firstLineRegex) {
      let escaped = false;
      let numberOfNewlinesInRegex = 0;
      for (let character of grammar.firstLineRegex.source) {
        switch (character) {
          case '\\':
            escaped = !escaped;
            break;
          case 'n':
            if (escaped) {
              numberOfNewlinesInRegex++;
            }
            escaped = false;
            break;
          default:
            escaped = false;
        }
      }
      const prefix = contents
        .split('\n')
        .slice(0, numberOfNewlinesInRegex + 1)
        .join('\n');
      if (grammar.firstLineRegex.findNextMatchSync) {
        return grammar.firstLineRegex.findNextMatchSync(prefix);
      } else {
        return grammar.firstLineRegex.test(prefix);
      }
    } else {
      return false;
    }
  }
  forEachGrammar(callback) {
    this.getGrammars({ includeTreeSitter: true }).forEach(callback);
  }
  grammarForId(languageId) {
    if (!languageId) return null;
    const config = this.getLanguageParserForScope(
      new ScopeDescriptor({ scopes: [languageId] })
    );
    let getTreeSitterGrammar = (table, languageId) => {
      let grammar = table[languageId];
      if (grammar?.scopeName) {
        return grammar;
      }
      return null;
    };
    if (config === 'wasm-tree-sitter') {
      return (
        getTreeSitterGrammar(
          this.wasmTreeSitterGrammarsById,
          languageId
        ) ||
        this.textmateRegistry.grammarForScopeName(languageId)
      );
    } else if (config === 'node-tree-sitter') {
      return (
        getTreeSitterGrammar(
          this.treeSitterGrammarsById,
          languageId
        ) ||
        this.textmateRegistry.grammarForScopeName(languageId)
      );
    } else {
      return (
        this.textmateRegistry.grammarForScopeName(languageId) ||
        this.wasmTreeSitterGrammarsById[languageId] ||
        this.treeSitterGrammarsById[languageId]
      );
    }
  }
  grammarOverrideForPath(filePath) {
    Grim.deprecate('Use buffer.getLanguageMode().getLanguageId() instead');
    const buffer = atom.project.findBufferForPath(filePath);
    if (buffer) return this.getAssignedLanguageId(buffer);
  }
  setGrammarOverrideForPath(filePath, languageId) {
    Grim.deprecate(
      'Use atom.grammars.assignLanguageMode(buffer, languageId) instead'
    );
    const buffer = atom.project.findBufferForPath(filePath);
    if (buffer) {
      const grammar = this.grammarForScopeName(languageId);
      if (grammar)
        this.languageOverridesByBufferId.set(buffer.id, grammar.name);
    }
  }
  clearGrammarOverrideForPath(filePath) {
    Grim.deprecate('Use atom.grammars.autoAssignLanguageMode(buffer) instead');
    const buffer = atom.project.findBufferForPath(filePath);
    if (buffer) this.languageOverridesByBufferId.delete(buffer.id);
  }
  grammarAddedOrUpdated(grammar) {
    if (grammar.scopeName && !grammar.id) grammar.id = grammar.scopeName;
    this.grammarScoresByBuffer.forEach((score, buffer) => {
      const languageMode = buffer.getLanguageMode();
      const languageOverride = this.languageOverridesByBufferId.get(buffer.id);
      if (
        grammar === buffer.getLanguageMode().grammar ||
        grammar === this.grammarForId(languageOverride)
      ) {
        buffer.setLanguageMode(
          this.languageModeForGrammarAndBuffer(grammar, buffer)
        );
        return;
      } else if (!languageOverride) {
        const score = this.getGrammarScore(
          grammar,
          buffer.getPath(),
          getGrammarSelectionContent(buffer)
        );
        const currentScore = this.grammarScoresByBuffer.get(buffer);
        if (currentScore == null || score > currentScore) {
          buffer.setLanguageMode(
            this.languageModeForGrammarAndBuffer(grammar, buffer)
          );
          this.grammarScoresByBuffer.set(buffer, score);
          return;
        }
      }
      languageMode.updateForInjection(grammar);
    });
  }
  onDidAddGrammar(callback) {
    let disposable = new CompositeDisposable();
    disposable.add(
      this.textmateRegistry.onDidAddGrammar(callback),
      this.emitter.on('did-add-grammar', callback)
    );
    return disposable;
  }
  onDidUpdateGrammar(callback) {
    let disposable = new CompositeDisposable();
    disposable.add(
      this.textmateRegistry.onDidUpdateGrammar(callback),
      this.emitter.on('did-update-grammar', callback)
    );
    return disposable;
  }
  addInjectionPoint(grammarId, injectionPoint, { only = null } = {}) {
    let grammarsToDispose = [];
    const addOrCreateInjectionPoint = (table, grammarId) => {
      let grammar = table[grammarId];
      if (grammar) {
        if (grammar.addInjectionPoint) {
          grammar.addInjectionPoint(injectionPoint);
          this.emitter.emit('did-update-grammar', grammar);
        } else {
          grammar.injectionPoints.push(injectionPoint);
        }
        grammarsToDispose.push(grammar);
      } else {
        table[grammarId] = { injectionPoints: [injectionPoint] }
      }
    };
    if (!only || only === 'legacy') {
      addOrCreateInjectionPoint(this.treeSitterGrammarsById, grammarId);
    }
    if (!only || only === 'modern') {
      addOrCreateInjectionPoint(this.wasmTreeSitterGrammarsById, grammarId);
    }
    return new Disposable(() => {
      for (let grammar of grammarsToDispose) {
        grammar.removeInjectionPoint(injectionPoint);
      }
    });
  }
  get nullGrammar() {
    return this.textmateRegistry.nullGrammar;
  }
  get grammars() {
    return this.getGrammars();
  }
  decodeTokens() {
    return this.textmateRegistry.decodeTokens.apply(
      this.textmateRegistry,
      arguments
    );
  }
  grammarForScopeName(scopeName) {
    return this.grammarForId(scopeName);
  }
  addGrammar(grammar) {
    if (grammar instanceof WASMTreeSitterGrammar) {
      const existingParams =
        this.wasmTreeSitterGrammarsById[grammar.scopeName] || {};
      if (grammar.scopeName)
        this.wasmTreeSitterGrammarsById[grammar.scopeName] = grammar;
      if (existingParams.injectionPoints) {
        for (const injectionPoint of existingParams.injectionPoints) {
          grammar.addInjectionPoint(injectionPoint);
        }
      }
      this.grammarAddedOrUpdated(grammar);
      this.emitter.emit('did-add-grammar', grammar);
      return new Disposable(() => this.removeGrammar(grammar));
    } else if (grammar instanceof TreeSitterGrammar) {
      const existingParams =
        this.treeSitterGrammarsById[grammar.scopeName] || {};
      if (grammar.scopeName)
        this.treeSitterGrammarsById[grammar.scopeName] = grammar;
      if (existingParams.injectionPoints) {
        for (const injectionPoint of existingParams.injectionPoints) {
          grammar.addInjectionPoint(injectionPoint);
        }
      }
      this.grammarAddedOrUpdated(grammar);
      this.emitter.emit('did-add-grammar', grammar);
      return new Disposable(() => this.removeGrammar(grammar));
    } else {
      return this.textmateRegistry.addGrammar(grammar);
    }
  }
  removeGrammar(grammar) {
    if (grammar instanceof WASMTreeSitterGrammar) {
      delete this.wasmTreeSitterGrammarsById[grammar.scopeName];
    } else if (grammar instanceof TreeSitterGrammar) {
      delete this.treeSitterGrammarsById[grammar.scopeName];
    } else {
      return this.textmateRegistry.removeGrammar(grammar);
    }
  }
  removeGrammarForScopeName(scopeName) {
    return this.textmateRegistry.removeGrammarForScopeName(scopeName);
  }
  loadGrammar(grammarPath, callback) {
    this.readGrammar(grammarPath, (error, grammar) => {
      if (error) return callback(error);
      this.addGrammar(grammar);
      callback(null, grammar);
    });
  }
  loadGrammarSync(grammarPath) {
    const grammar = this.readGrammarSync(grammarPath);
    this.addGrammar(grammar);
    return grammar;
  }
  readGrammar(grammarPath, callback) {
    if (!callback) callback = () => {};
    CSON.readFile(grammarPath, (error, params = {}) => {
      if (error) return callback(error);
      try {
        callback(null, this.createGrammar(grammarPath, params));
      } catch (error) {
        callback(error);
      }
    });
  }
  readGrammarSync(grammarPath) {
    return this.createGrammar(
      grammarPath,
      CSON.readFileSync(grammarPath) || {}
    );
  }
  createGrammar(grammarPath, params) {
    if (params.type === 'modern-tree-sitter') {
      return new WASMTreeSitterGrammar(this, grammarPath, params)
    } else if (params.type === 'tree-sitter') {
      return new TreeSitterGrammar(this, grammarPath, params);
    } else {
      if (
        typeof params.scopeName !== 'string' ||
        params.scopeName.length === 0
      ) {
        throw new Error(
          `Grammar missing required scopeName property: ${grammarPath}`
        );
      }
      return this.textmateRegistry.createGrammar(grammarPath, params);
    }
  }
  getGrammars(params) {
    let result = this.textmateRegistry.getGrammars();
    if (!(params && params.includeTreeSitter)) return result;
    let modernTsGrammars = Object.values(this.wasmTreeSitterGrammarsById)
      .filter(g => g.scopeName);
    result = result.concat(modernTsGrammars);
    const legacyTsGrammars = Object.values(this.treeSitterGrammarsById)
      .filter(g => g.scopeName);
    result = result.concat(legacyTsGrammars);
    return result;
  }
  scopeForId(id) {
    return this.textmateRegistry.scopeForId(id);
  }
  treeSitterGrammarForLanguageString(languageString, type = 'wasm') {
    let longestMatchLength = 0;
    let grammarWithLongestMatch = null;
    let table = type === 'original' ? this.treeSitterGrammarsById : this.wasmTreeSitterGrammarsById;
    for (const id in table) {
      const grammar = table[id];
      if (grammar.injectionRegex) {
        const match = languageString.match(grammar.injectionRegex);
        if (match) {
          const { length } = match[0];
          if (length > longestMatchLength) {
            grammarWithLongestMatch = grammar;
            longestMatchLength = length;
          }
        }
      }
    }
    return grammarWithLongestMatch;
  }
};
function getGrammarSelectionContent(buffer) {
  return buffer.getTextInRange(
    Range(Point(0, 0), buffer.positionForCharacterIndex(1024))
  );
}

================
File: src/gutter-container.js
================
const { Emitter } = require('event-kit');
const Gutter = require('./gutter');
module.exports = class GutterContainer {
  constructor(textEditor) {
    this.gutters = [];
    this.textEditor = textEditor;
    this.emitter = new Emitter();
  }
  scheduleComponentUpdate() {
    this.textEditor.scheduleComponentUpdate();
  }
  destroy() {
    const guttersToDestroy = this.gutters.slice(0);
    for (let gutter of guttersToDestroy) {
      if (gutter.name !== 'line-number') {
        gutter.destroy();
      }
    }
    this.gutters = [];
    this.emitter.dispose();
  }
  addGutter(options) {
    options = options || {};
    const gutterName = options.name;
    if (gutterName === null) {
      throw new Error('A name is required to create a gutter.');
    }
    if (this.gutterWithName(gutterName)) {
      throw new Error(
        'Tried to create a gutter with a name that is already in use.'
      );
    }
    const newGutter = new Gutter(this, options);
    let inserted = false;
    for (let i = 0; i < this.gutters.length; i++) {
      if (this.gutters[i].priority >= newGutter.priority) {
        this.gutters.splice(i, 0, newGutter);
        inserted = true;
        break;
      }
    }
    if (!inserted) {
      this.gutters.push(newGutter);
    }
    this.scheduleComponentUpdate();
    this.emitter.emit('did-add-gutter', newGutter);
    return newGutter;
  }
  getGutters() {
    return this.gutters.slice();
  }
  gutterWithName(name) {
    for (let gutter of this.gutters) {
      if (gutter.name === name) {
        return gutter;
      }
    }
    return null;
  }
  observeGutters(callback) {
    for (let gutter of this.getGutters()) {
      callback(gutter);
    }
    return this.onDidAddGutter(callback);
  }
  onDidAddGutter(callback) {
    return this.emitter.on('did-add-gutter', callback);
  }
  onDidRemoveGutter(callback) {
    return this.emitter.on('did-remove-gutter', callback);
  }
  removeGutter(gutter) {
    const index = this.gutters.indexOf(gutter);
    if (index > -1) {
      this.gutters.splice(index, 1);
      this.scheduleComponentUpdate();
      this.emitter.emit('did-remove-gutter', gutter.name);
    } else {
      throw new Error(
        'The given gutter cannot be removed because it is not ' +
          'within this GutterContainer.'
      );
    }
  }
  addGutterDecoration(gutter, marker, options) {
    if (gutter.type === 'line-number') {
      options.type = 'line-number';
    } else {
      options.type = 'gutter';
    }
    options.gutterName = gutter.name;
    return this.textEditor.decorateMarker(marker, options);
  }
};

================
File: src/gutter.js
================
const { Emitter } = require('event-kit');
const DefaultPriority = -100;
module.exports = class Gutter {
  constructor(gutterContainer, options) {
    this.gutterContainer = gutterContainer;
    this.name = options && options.name;
    this.priority =
      options && options.priority != null ? options.priority : DefaultPriority;
    this.visible = options && options.visible != null ? options.visible : true;
    this.type = options && options.type != null ? options.type : 'decorated';
    this.labelFn = options && options.labelFn;
    this.className = options && options.class;
    this.onMouseDown = options && options.onMouseDown;
    this.onMouseMove = options && options.onMouseMove;
    this.emitter = new Emitter();
  }
  destroy() {
    if (this.name === 'line-number') {
      throw new Error('The line-number gutter cannot be destroyed.');
    } else {
      this.gutterContainer.removeGutter(this);
      this.emitter.emit('did-destroy');
      this.emitter.dispose();
    }
  }
  onDidChangeVisible(callback) {
    return this.emitter.on('did-change-visible', callback);
  }
  onDidDestroy(callback) {
    return this.emitter.once('did-destroy', callback);
  }
  hide() {
    if (this.visible) {
      this.visible = false;
      this.gutterContainer.scheduleComponentUpdate();
      this.emitter.emit('did-change-visible', this);
    }
  }
  show() {
    if (!this.visible) {
      this.visible = true;
      this.gutterContainer.scheduleComponentUpdate();
      this.emitter.emit('did-change-visible', this);
    }
  }
  isVisible() {
    return this.visible;
  }
  decorateMarker(marker, options) {
    return this.gutterContainer.addGutterDecoration(this, marker, options);
  }
  getElement() {
    if (this.element == null) this.element = document.createElement('div');
    return this.element;
  }
};

================
File: src/history-manager.js
================
const { Emitter, CompositeDisposable } = require('event-kit');
class HistoryManager {
  constructor({ project, commands, stateStore }) {
    this.stateStore = stateStore;
    this.emitter = new Emitter();
    this.projects = [];
    this.disposables = new CompositeDisposable();
    this.disposables.add(
      commands.add(
        'atom-workspace',
        { 'application:clear-project-history': this.clearProjects.bind(this) },
        false
      )
    );
    this.disposables.add(
      project.onDidChangePaths(projectPaths => this.addProject(projectPaths))
    );
  }
  destroy() {
    this.disposables.dispose();
  }
  getProjects() {
    return this.projects.map(p => new HistoryProject(p.paths, p.lastOpened));
  }
  async clearProjects() {
    this.projects = [];
    await this.saveState();
    this.didChangeProjects();
  }
  onDidChangeProjects(callback) {
    return this.emitter.on('did-change-projects', callback);
  }
  didChangeProjects(args = { reloaded: false }) {
    this.emitter.emit('did-change-projects', args);
  }
  async addProject(paths, lastOpened) {
    if (paths.length === 0) return;
    let project = this.getProject(paths);
    if (!project) {
      project = new HistoryProject(paths);
      this.projects.push(project);
    }
    project.lastOpened = lastOpened || new Date();
    this.projects.sort((a, b) => b.lastOpened - a.lastOpened);
    await this.saveState();
    this.didChangeProjects();
  }
  async removeProject(paths) {
    if (paths.length === 0) return;
    let project = this.getProject(paths);
    if (!project) return;
    let index = this.projects.indexOf(project);
    this.projects.splice(index, 1);
    await this.saveState();
    this.didChangeProjects();
  }
  getProject(paths) {
    for (let i = 0; i < this.projects.length; i++) {
      if (arrayEquivalent(paths, this.projects[i].paths)) {
        return this.projects[i];
      }
    }
    return null;
  }
  async loadState() {
    const history = await this.stateStore.load('history-manager');
    if (history && history.projects) {
      this.projects = history.projects
        .filter(p => Array.isArray(p.paths) && p.paths.length > 0)
        .map(p => new HistoryProject(p.paths, new Date(p.lastOpened)));
      this.didChangeProjects({ reloaded: true });
    } else {
      this.projects = [];
    }
  }
  async saveState() {
    const projects = this.projects.map(p => ({
      paths: p.paths,
      lastOpened: p.lastOpened
    }));
    await this.stateStore.save('history-manager', { projects });
  }
}
function arrayEquivalent(a, b) {
  if (a.length !== b.length) return false;
  for (let i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) return false;
  }
  return true;
}
class HistoryProject {
  constructor(paths, lastOpened) {
    this.paths = paths;
    this.lastOpened = lastOpened || new Date();
  }
  set paths(paths) {
    this._paths = paths;
  }
  get paths() {
    return this._paths;
  }
  set lastOpened(lastOpened) {
    this._lastOpened = lastOpened;
  }
  get lastOpened() {
    return this._lastOpened;
  }
}
module.exports = { HistoryManager, HistoryProject };

================
File: src/initialize-application-window.js
================
const AtomEnvironment = require('./atom-environment');
const ApplicationDelegate = require('./application-delegate');
const Clipboard = require('./clipboard');
const TextEditor = require('./text-editor');
require('./text-editor-component');
require('./file-system-blob-store');
require('./native-compile-cache');
require('./compile-cache');
require('./module-cache');
const clipboard = new Clipboard();
TextEditor.setClipboard(clipboard);
TextEditor.viewForItem = item => atom.views.getView(item);
global.atom = new AtomEnvironment({
  clipboard,
  applicationDelegate: new ApplicationDelegate(),
  enablePersistence: true
});
TextEditor.setScheduler(global.atom.views);
global.atom.preloadPackages();
module.exports = function({ blobStore }) {
  const { updateProcessEnv } = require('./update-process-env');
  const path = require('path');
  require('./window');
  const getWindowLoadSettings = require('./get-window-load-settings');
  const { ipcRenderer } = require('electron');
  const { resourcePath, devMode } = getWindowLoadSettings();
  require('./electron-shims');
  const exportsPath = path.join(resourcePath, 'exports');
  require('module').globalPaths.push(exportsPath);
  process.env.NODE_PATH = exportsPath;
  if (!devMode && process.env.NODE_ENV == null) {
    process.env.NODE_ENV = 'production';
  }
  global.atom.initialize({
    window,
    document,
    blobStore,
    configDirPath: process.env.ATOM_HOME,
    env: process.env
  });
  return global.atom.startEditorWindow().then(function() {
    const windowFocused = function() {
      window.removeEventListener('focus', windowFocused);
      setTimeout(() => document.querySelector('atom-workspace').focus(), 0);
    };
    window.addEventListener('focus', windowFocused);
    ipcRenderer.on('environment', (event, env) => updateProcessEnv(env));
  });
};

================
File: src/initialize-test-window.js
================
const ipcHelpers = require('./ipc-helpers');
const { requireModule } = require('./module-utils');
function cloneObject(object) {
  const clone = {};
  for (const key in object) {
    clone[key] = object[key];
  }
  return clone;
}
module.exports = async function({ blobStore }) {
  const { remote } = require('electron');
  const getWindowLoadSettings = require('./get-window-load-settings');
  const exitWithStatusCode = function(status) {
    remote.app.emit('will-quit');
    remote.process.exit(status);
  };
  try {
    const path = require('path');
    const { ipcRenderer } = require('electron');
    const CompileCache = require('./compile-cache');
    const AtomEnvironment = require('../src/atom-environment');
    const ApplicationDelegate = require('../src/application-delegate');
    const Clipboard = require('../src/clipboard');
    const TextEditor = require('../src/text-editor');
    const { updateProcessEnv } = require('./update-process-env');
    require('./electron-shims');
    ipcRenderer.on('environment', (event, env) => updateProcessEnv(env));
    const {
      testRunnerPath,
      legacyTestRunnerPath,
      headless,
      logFile,
      testPaths,
      env
    } = getWindowLoadSettings();
    if (headless) {
      const util = require('util');
      Object.defineProperties(process, {
        stdout: { value: remote.process.stdout },
        stderr: { value: remote.process.stderr }
      });
      console.log = (...args) =>
        process.stdout.write(`${util.format(...args)}\n`);
      console.error = (...args) =>
        process.stderr.write(`${util.format(...args)}\n`);
    } else {
      remote.getCurrentWindow().show();
    }
    const handleKeydown = function(event) {
      if ((event.metaKey || event.ctrlKey) && event.keyCode === 82) {
        ipcHelpers.call('window-method', 'reload');
      }
      if (
        event.keyCode === 73 &&
        ((process.platform === 'darwin' && event.metaKey && event.altKey) ||
          (process.platform !== 'darwin' && event.ctrlKey && event.shiftKey))
      ) {
        ipcHelpers.call('window-method', 'toggleDevTools');
      }
      if ((event.metaKey || event.ctrlKey) && event.keyCode === 87) {
        ipcHelpers.call('window-method', 'close');
      }
      if ((event.metaKey || event.ctrlKey) && event.keyCode === 67) {
        atom.clipboard.write(window.getSelection().toString());
      }
    };
    window.addEventListener('keydown', handleKeydown, { capture: true });
    const exportsPath = path.join(
      getWindowLoadSettings().resourcePath,
      'exports'
    );
    require('module').globalPaths.push(exportsPath);
    process.env.NODE_PATH = exportsPath;
    updateProcessEnv(env);
    const FindParentDir = require('find-parent-dir');
    const packageRoot = FindParentDir.sync(testPaths[0], 'package.json');
    if (packageRoot) {
      const packageMetadata = require(path.join(packageRoot, 'package.json'));
      if (packageMetadata.atomTranspilers) {
        CompileCache.addTranspilerConfigForPath(
          packageRoot,
          packageMetadata.name,
          packageMetadata,
          packageMetadata.atomTranspilers
        );
      }
    }
    document.title = 'Spec Suite';
    const clipboard = new Clipboard();
    TextEditor.setClipboard(clipboard);
    TextEditor.viewForItem = item => atom.views.getView(item);
    const testRunner = requireModule(testRunnerPath);
    const legacyTestRunner = require(legacyTestRunnerPath);
    const buildDefaultApplicationDelegate = () => new ApplicationDelegate();
    const buildAtomEnvironment = function(params) {
      params = cloneObject(params);
      if (!params.hasOwnProperty('clipboard')) {
        params.clipboard = clipboard;
      }
      if (!params.hasOwnProperty('blobStore')) {
        params.blobStore = blobStore;
      }
      if (!params.hasOwnProperty('onlyLoadBaseStyleSheets')) {
        params.onlyLoadBaseStyleSheets = true;
      }
      const atomEnvironment = new AtomEnvironment(params);
      atomEnvironment.initialize(params);
      TextEditor.setScheduler(atomEnvironment.views);
      return atomEnvironment;
    };
    const statusCode = await testRunner({
      logFile,
      headless,
      testPaths,
      buildAtomEnvironment,
      buildDefaultApplicationDelegate,
      legacyTestRunner
    });
    if (getWindowLoadSettings().headless) {
      exitWithStatusCode(statusCode);
    }
  } catch (error) {
    if (getWindowLoadSettings().headless) {
      console.error(error.stack || error);
      exitWithStatusCode(1);
    } else {
      throw error;
    }
  }
};

================
File: src/ipc-helpers.js
================
const Disposable = require('event-kit').Disposable;
let ipcRenderer = null;
let ipcMain = null;
let BrowserWindow = null;
let nextResponseChannelId = 0;
exports.on = function(emitter, eventName, callback) {
  emitter.on(eventName, callback);
  return new Disposable(() => emitter.removeListener(eventName, callback));
};
exports.call = function(channel, ...args) {
  if (!ipcRenderer) {
    ipcRenderer = require('electron').ipcRenderer;
    ipcRenderer.setMaxListeners(20);
  }
  const responseChannel = `ipc-helpers-response-${nextResponseChannelId++}`;
  return new Promise(resolve => {
    ipcRenderer.on(responseChannel, (event, result) => {
      ipcRenderer.removeAllListeners(responseChannel);
      resolve(result);
    });
    ipcRenderer.send(channel, responseChannel, ...args);
  });
};
exports.respondTo = function(channel, callback) {
  if (!ipcMain) {
    const electron = require('electron');
    ipcMain = electron.ipcMain;
    BrowserWindow = electron.BrowserWindow;
  }
  return exports.on(
    ipcMain,
    channel,
    async (event, responseChannel, ...args) => {
      const browserWindow = BrowserWindow.fromWebContents(event.sender);
      const result = await callback(browserWindow, ...args);
      if (!event.sender.isDestroyed()) {
        event.sender.send(responseChannel, result);
      }
    }
  );
};

================
File: src/item-registry.js
================
module.exports = class ItemRegistry {
  constructor() {
    this.items = new WeakSet();
  }
  addItem(item) {
    if (this.hasItem(item)) {
      throw new Error(
        `The workspace can only contain one instance of item ${item}`
      );
    }
    return this.items.add(item);
  }
  removeItem(item) {
    return this.items.delete(item);
  }
  hasItem(item) {
    return this.items.has(item);
  }
};

================
File: src/keymap-extensions.js
================
const fs = require('fs-plus');
const path = require('path');
const KeymapManager = require('atom-keymap');
const CSON = require('season');
const buildMetadata = require('../package.json');
var bundledKeymaps;
if (buildMetadata != null) {
  bundledKeymaps = buildMetadata._atomKeymaps;
}
KeymapManager.prototype.onDidLoadBundledKeymaps = function(callback) {
  return this.emitter.on('did-load-bundled-keymaps', callback);
};
KeymapManager.prototype.onDidLoadUserKeymap = function(callback) {
  return this.emitter.on('did-load-user-keymap', callback);
};
KeymapManager.prototype.canLoadBundledKeymapsFromMemory = function() {
  return bundledKeymaps != null;
};
KeymapManager.prototype.loadBundledKeymaps = function() {
  if (bundledKeymaps != null) {
    for (let keymapName in bundledKeymaps) {
      const keymap = bundledKeymaps[keymapName];
      const keymapPath = `core:${keymapName}`;
      this.add(keymapPath, keymap, 0, this.devMode != null ? this.devMode : false);
    }
  } else {
    const keymapsPath = path.join(this.resourcePath, 'keymaps');
    this.loadKeymap(keymapsPath);
  }
  return this.emitter.emit('did-load-bundled-keymaps');
};
KeymapManager.prototype.getUserKeymapPath = function() {
  if (this.configDirPath == null) {
    return "";
  }
  let userKeymapPath = CSON.resolve(path.join(this.configDirPath, 'keymap'));
  if (userKeymapPath) {
    return userKeymapPath;
  }
  return path.join(this.configDirPath, 'keymap.cson');
};
KeymapManager.prototype.loadUserKeymap = function() {
  const userKeymapPath = this.getUserKeymapPath();
  if (!fs.isFileSync(userKeymapPath)) {
    return;
  }
  try {
    this.loadKeymap(userKeymapPath, {watch: true, suppressErrors: true, priority: 100});
  }
  catch (error) {
    if (error.message.indexOf('Unable to watch path') > -1) {
      const message = `Unable to watch path: \`${path.basename(userKeymapPath)}\`. Make sure you \
        have permission to read \`${userKeymapPath}\`.
        On linux there are currently problems with watch sizes. See \
        [this document][watches] for more info. \
        [watches]:https://pulsar-edit.dev/docs/atom-archive/hacking-atom/#typeerror-unable-to-watch-path`;
      this.notificationManager.addError(message, {dismissable: true});
    }
    else {
      const detail = error.path;
      const stack = error.stack;
      this.notificationManager.addFatalError(error.message, {detail,stack,dismissable: true});
    }
  }
  return this.emitter.emit('did-load-user-keymap');
};
KeymapManager.prototype.subscribeToFileReadFailure = function() {
  return this.onDidFailToReadFile((error) => {
    const userKeymapPath = this.getUserKeymapPath();
    const message = `Failed to load \`${userKeymapPath}\``;
    const detail = error.location != null ? error.stack : error.message;
    this.notificationManager.addError(message, {detail, dismissable: true});
  });
};
module.exports = KeymapManager;

================
File: src/layer-decoration.js
================
var idCounter = 0;
var nextId = function() {
  return idCounter++;
};
module.exports = class LayerDecoration {
  constructor(markerLayer, decorationManager, properties1) {
    this.markerLayer = markerLayer;
    this.decorationManager = decorationManager;
    this.properties = properties1;
    this.id = nextId();
    this.destroyed = false;
    this.markerLayerDestroyedDisposable = this.markerLayer.onDidDestroy(() => this.destroy());
    this.overridePropertiesByMarker = null;
  }
  destroy() {
    if (this.destroyed) {
      return;
    }
    this.markerLayerDestroyedDisposable.dispose();
    this.markerLayerDestroyedDisposable = null;
    this.destroyed = true;
    this.decorationManager.didDestroyLayerDecoration(this);
  }
  isDestroyed() {
    return this.destroyed;
  }
  getId() {
    return this.id;
  }
  getMarkerLayer() {
    return this.markerLayer;
  }
  getProperties() {
    return this.properties;
  }
  setProperties(newProperties) {
    if (this.destroyed) {
      return;
    }
    this.properties = newProperties;
    this.decorationManager.emitDidUpdateDecorations();
  }
  setPropertiesForMarker(marker, properties) {
    if (this.destroyed) {
      return;
    }
    if (this.overridePropertiesByMarker == null) {
      this.overridePropertiesByMarker = new Map();
    }
    marker = this.markerLayer.getMarker(marker.id);
    if (properties != null) {
      this.overridePropertiesByMarker.set(marker, properties);
    } else {
      this.overridePropertiesByMarker.delete(marker);
    }
    this.decorationManager.emitDidUpdateDecorations();
  }
  getPropertiesForMarker(marker) {
    if (!this.overridePropertiesByMarker) {
      return undefined;
    }
    return this.overridePropertiesByMarker.get(marker);
  }
};

================
File: src/less-compile-cache.js
================
const path = require('path');
const LessCache = require('less-cache');
module.exports = class LessCompileCache {
  constructor({resourcePath, importPaths, lessSourcesByRelativeFilePath, importedFilePathsByRelativeImportPath}) {
    const cacheDir = path.join(process.env.ATOM_HOME, 'compile-cache', 'less');
    this.lessSearchPaths = [path.join(resourcePath, 'static', 'variables'), path.join(resourcePath, 'static')];
    if (importPaths != null) {
      importPaths = importPaths.concat(this.lessSearchPaths);
    } else {
      importPaths = this.lessSearchPaths;
    }
    this.cache = new LessCache({
      importPaths,
      resourcePath,
      lessSourcesByRelativeFilePath,
      importedFilePathsByRelativeImportPath,
      cacheDir,
      fallbackDir: path.join(resourcePath, 'less-compile-cache')
    });
  }
  setImportPaths(importPaths = []) {
    this.cache.setImportPaths(importPaths.concat(this.lessSearchPaths));
  }
  read(stylesheetPath) {
    return this.cache.readFileSync(stylesheetPath);
  }
  cssForFile(stylesheetPath, lessContent, digest) {
    return this.cache.cssForFile(stylesheetPath, lessContent, digest);
  }
};

================
File: src/menu-helpers.js
================
const _ = require('underscore-plus');
const ItemSpecificities = new WeakMap();
function addItemToMenu(item, menu) {
  const lastMenuItem = _.last(menu);
  const lastMenuItemIsSpearator =
    lastMenuItem && lastMenuItem.type === 'separator';
  if (!(item.type === 'separator' && lastMenuItemIsSpearator)) {
    menu.push(item);
  }
}
function merge(menu, item, itemSpecificity = Infinity) {
  item = cloneMenuItem(item);
  ItemSpecificities.set(item, itemSpecificity);
  const matchingItemIndex = findMatchingItemIndex(menu, item);
  if (matchingItemIndex === -1) {
    addItemToMenu(item, menu);
    return;
  }
  const matchingItem = menu[matchingItemIndex];
  if (item.submenu != null) {
    for (let submenuItem of item.submenu) {
      merge(matchingItem.submenu, submenuItem, itemSpecificity);
    }
  } else if (
    itemSpecificity &&
    itemSpecificity >= ItemSpecificities.get(matchingItem)
  ) {
    menu[matchingItemIndex] = item;
  }
}
function unmerge(menu, item) {
  item = cloneMenuItem(item);
  const matchingItemIndex = findMatchingItemIndex(menu, item);
  if (matchingItemIndex === -1) {
    return;
  }
  const matchingItem = menu[matchingItemIndex];
  if (item.submenu != null) {
    for (let submenuItem of item.submenu) {
      unmerge(matchingItem.submenu, submenuItem);
    }
  }
  if (matchingItem.submenu == null || matchingItem.submenu.filter( ({type}) => type !== 'separator' ).length === 0) {
    menu.splice(matchingItemIndex, 1);
  }
}
function findMatchingItemIndex(menu, { type, id, submenu }) {
  if (type === 'separator') {
    return -1;
  }
  for (let index = 0; index < menu.length; index++) {
    const item = menu[index];
    if (item.id === id && (item.submenu != null) === (submenu != null)) {
      return index;
    }
  }
  return -1;
}
function normalizeLabel(label) {
  if (label == null) {
    return;
  }
  return process.platform === 'darwin' ? label : label.replace(/&/g, '');
}
function cloneMenuItem(item) {
  item = _.pick(
    item,
    'type',
    'label',
    'id',
    'enabled',
    'visible',
    'command',
    'submenu',
    'commandDetail',
    'role',
    'accelerator',
    'before',
    'after',
    'beforeGroupContaining',
    'afterGroupContaining'
  );
  if (item.id === null || item.id === undefined) {
    item.id = normalizeLabel(item.label);
  }
  if (item.submenu != null) {
    item.submenu = item.submenu.map(submenuItem => cloneMenuItem(submenuItem));
  }
  return item;
}
function acceleratorForKeystroke(keystroke) {
  if (!keystroke) {
    return null;
  }
  let modifiers = keystroke.split(/-(?=.)/);
  const key = modifiers
    .pop()
    .toUpperCase()
    .replace('+', 'Plus');
  modifiers = modifiers.map(modifier =>
    modifier
      .replace(/shift/gi, 'Shift')
      .replace(/cmd/gi, 'Command')
      .replace(/ctrl/gi, 'Ctrl')
      .replace(/alt/gi, 'Alt')
  );
  const keys = [...modifiers, key];
  return keys.join('+');
}
module.exports = {
  merge,
  unmerge,
  normalizeLabel,
  cloneMenuItem,
  acceleratorForKeystroke
};

================
File: src/menu-manager.js
================
const path = require('path');
const _ = require('underscore-plus');
const {ipcRenderer} = require('electron');
const CSON = require('season');
const fs = require('fs-plus');
const {Disposable} = require('event-kit');
const MenuHelpers = require('./menu-helpers');
const buildMetadata = require('../package.json');
var platformMenu;
if (buildMetadata) {
  platformMenu = (buildMetadata._atomMenu && buildMetadata._atomMenu.menu);
}
module.exports = MenuManager = class MenuManager {
  constructor({resourcePath, keymapManager, packageManager}) {
    this.resourcePath = resourcePath;
    this.keymapManager = keymapManager;
    this.packageManager = packageManager;
    this.initialized = false;
    this.pendingUpdateOperation = null;
    this.template = [];
    this.keymapManager.onDidLoadBundledKeymaps(() => this.loadPlatformItems());
    this.packageManager.onDidActivateInitialPackages(() => this.sortPackagesMenu());
  }
  initialize({resourcePath}) {
    this.resourcePath = resourcePath;
    this.keymapManager.onDidReloadKeymap(() => this.update());
    this.update();
    this.initialized = true;
  }
  add(items) {
    items = _.deepClone(items);
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      if (item.label == null) {
        continue;
      }
      this.merge(this.template, item);
    }
    this.update();
    return new Disposable(() => this.remove(items));
  }
  remove(items) {
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      this.unmerge(this.template, item);
    }
    return this.update();
  }
  clear() {
    this.template = [];
    return this.update();
  }
  includeSelector(selector) {
    try {
      if (document.body.webkitMatchesSelector(selector)) {
        return true;
      }
    } catch (error) {
      return false;
    }
    if (this.testEditor == null) {
      const testDocument = document.implementation.createDocument(document.namespaceURI, 'html');
      const testBody = testDocument.createElement('body');
      testBody.classList.add(...this.classesForElement(document.body));
      const testWorkspace = testDocument.createElement('atom-workspace');
      let workspaceClasses = this.classesForElement(document.body.querySelector('atom-workspace'));
      if (workspaceClasses.length === 0) {
        workspaceClasses = ['workspace'];
      }
      testWorkspace.classList.add(...workspaceClasses);
      testBody.appendChild(testWorkspace);
      this.testEditor = testDocument.createElement('atom-text-editor');
      this.testEditor.classList.add('editor');
      testWorkspace.appendChild(this.testEditor);
    }
    let element = this.testEditor;
    while (element) {
      if (element.webkitMatchesSelector(selector)) {
        return true;
      }
      element = element.parentElement;
    }
    return false;
  }
  update() {
    if (!this.initialized) {
      return;
    }
    if (this.pendingUpdateOperation != null) {
      clearTimeout(this.pendingUpdateOperation);
    }
    this.pendingUpdateOperation = setTimeout(() => {
      const unsetKeystrokes = new Set();
      for (let binding of this.keymapManager.getKeyBindings()) {
        if (binding.command === 'unset!') {
          unsetKeystrokes.add(binding.keystrokes);
        }
      }
      const keystrokesByCommand = {};
      for (let binding of this.keymapManager.getKeyBindings()) {
        if (!this.includeSelector(binding.selector)) {
          continue;
        }
        if (unsetKeystrokes.has(binding.keystrokes)) {
          continue;
        }
        if (process.platform === 'darwin' && /^alt-(shift-)?.$/.test(binding.keystrokes)) {
          continue;
        }
        if (process.platform === 'win32' && /^ctrl-alt-(shift-)?.$/.test(binding.keystrokes)) {
          continue;
        }
        if (keystrokesByCommand[binding.command] == null) {
          keystrokesByCommand[binding.command] = [];
        }
        keystrokesByCommand[binding.command].unshift(binding.keystrokes);
      }
      this.sendToBrowserProcess(this.template, keystrokesByCommand);
    }, 1);
  }
  loadPlatformItems() {
    if (platformMenu != null) {
      return this.add(platformMenu);
    } else {
      const menusDirPath = path.join(this.resourcePath, 'menus');
      const platformMenuPath = fs.resolve(menusDirPath, process.platform, ['cson', 'json']);
      const {menu} = CSON.readFileSync(platformMenuPath);
      return this.add(menu);
    }
  }
  merge(menu, item) {
    MenuHelpers.merge(menu, item);
  }
  unmerge(menu, item) {
    MenuHelpers.unmerge(menu, item);
  }
  sendToBrowserProcess(template, keystrokesByCommand) {
    ipcRenderer.send('update-application-menu', template, keystrokesByCommand);
  }
  classesForElement(element) {
    var classList;
    if (element && element.classList) {
      return Array.prototype.slice.apply(element.classList);
    } else {
      return [];
    }
  }
  sortPackagesMenu() {
    const packagesMenu = _.find(this.template, ({id}) => MenuHelpers.normalizeLabel(id) === 'Packages');
    if (!(packagesMenu && packagesMenu.submenu != null)) {
      return;
    }
    packagesMenu.submenu.sort((item1, item2) => {
      if (item1.label && item2.label) {
        return MenuHelpers.normalizeLabel(item1.label).localeCompare(MenuHelpers.normalizeLabel(item2.label));
      } else {
        return 0;
      }
    });
    return this.update();
  }
};

================
File: src/menu-sort-helpers.js
================
function splitArray(arr, predicate) {
  let lastArr = [];
  const multiArr = [lastArr];
  arr.forEach(item => {
    if (predicate(item)) {
      if (lastArr.length > 0) {
        lastArr = [];
        multiArr.push(lastArr);
      }
    } else {
      lastArr.push(item);
    }
  });
  return multiArr;
}
function joinArrays(arrays, joiner) {
  const joinedArr = [];
  arrays.forEach((arr, i) => {
    if (i > 0 && arr.length > 0) {
      joinedArr.push(joiner);
    }
    joinedArr.push(...arr);
  });
  return joinedArr;
}
const pushOntoMultiMap = (map, key, value) => {
  if (!map.has(key)) {
    map.set(key, []);
  }
  map.get(key).push(value);
};
function indexOfGroupContainingCommand(groups, command, ignoreGroup) {
  return groups.findIndex(
    candiateGroup =>
      candiateGroup !== ignoreGroup &&
      candiateGroup.some(candidateItem => candidateItem.command === command)
  );
}
function sortTopologically(originalOrder, edgesById) {
  const sorted = [];
  const marked = new Set();
  function visit(id) {
    if (marked.has(id)) {
      return;
    }
    marked.add(id);
    const edges = edgesById.get(id);
    if (edges != null) {
      edges.forEach(visit);
    }
    sorted.push(id);
  }
  originalOrder.forEach(visit);
  return sorted;
}
function attemptToMergeAGroup(groups) {
  for (let i = 0; i < groups.length; i++) {
    const group = groups[i];
    for (const item of group) {
      const toCommands = [...(item.before || []), ...(item.after || [])];
      for (const command of toCommands) {
        const index = indexOfGroupContainingCommand(groups, command, group);
        if (index === -1) {
          continue;
        }
        const mergeTarget = groups[index];
        mergeTarget.push(...group);
        groups.splice(i, 1);
        return true;
      }
    }
  }
  return false;
}
function mergeGroups(groups) {
  let mergedAGroup = true;
  while (mergedAGroup) {
    mergedAGroup = attemptToMergeAGroup(groups);
  }
  return groups;
}
function sortItemsInGroup(group) {
  const originalOrder = group.map((node, i) => i);
  const edges = new Map();
  const commandToIndex = new Map(group.map((item, i) => [item.command, i]));
  group.forEach((item, i) => {
    if (item.before) {
      item.before.forEach(toCommand => {
        const to = commandToIndex.get(toCommand);
        if (to != null) {
          pushOntoMultiMap(edges, to, i);
        }
      });
    }
    if (item.after) {
      item.after.forEach(toCommand => {
        const to = commandToIndex.get(toCommand);
        if (to != null) {
          pushOntoMultiMap(edges, i, to);
        }
      });
    }
  });
  const sortedNodes = sortTopologically(originalOrder, edges);
  return sortedNodes.map(i => group[i]);
}
function findEdgesInGroup(groups, i, edges) {
  const group = groups[i];
  for (const item of group) {
    if (item.beforeGroupContaining) {
      for (const command of item.beforeGroupContaining) {
        const to = indexOfGroupContainingCommand(groups, command, group);
        if (to !== -1) {
          pushOntoMultiMap(edges, to, i);
          return;
        }
      }
    }
    if (item.afterGroupContaining) {
      for (const command of item.afterGroupContaining) {
        const to = indexOfGroupContainingCommand(groups, command, group);
        if (to !== -1) {
          pushOntoMultiMap(edges, i, to);
          return;
        }
      }
    }
  }
}
function sortGroups(groups) {
  const originalOrder = groups.map((item, i) => i);
  const edges = new Map();
  for (let i = 0; i < groups.length; i++) {
    findEdgesInGroup(groups, i, edges);
  }
  const sortedGroupIndexes = sortTopologically(originalOrder, edges);
  return sortedGroupIndexes.map(i => groups[i]);
}
function isSeparator(item) {
  return item.type === 'separator';
}
function sortMenuItems(menuItems) {
  const groups = splitArray(menuItems, isSeparator);
  const mergedGroups = mergeGroups(groups);
  const mergedGroupsWithSortedItems = mergedGroups.map(sortItemsInGroup);
  const sortedGroups = sortGroups(mergedGroupsWithSortedItems);
  return joinArrays(sortedGroups, { type: 'separator' });
}
module.exports = { sortMenuItems };

================
File: src/model.js
================
var nextInstanceId = 1;
module.exports = class Model {
  static resetNextInstanceId() {
    nextInstanceId = 1;
  }
  constructor(params) {
    this.alive = true;
    this.assignId(params != null ? params.id : undefined);
  }
  assignId(id) {
    if (this.id == null) {
      this.id = id != null ? id : nextInstanceId++;
    }
    if (id >= nextInstanceId) {
      nextInstanceId = id + 1;
    }
  }
  destroy() {
    if (!this.isAlive()) {
      return;
    }
    this.alive = false;
    if (typeof this.destroyed === "function") {
      this.destroyed();
    }
  }
  isAlive() {
    return this.alive;
  }
  isDestroyed() {
    return !this.isAlive();
  }
};

================
File: src/module-cache.js
================
const Module = require('module');
const path = require('path');
const semver = require('semver');
class Range extends semver.Range {
  constructor() {
    super(...arguments);
    this.matchedVersions = new Set();
    this.unmatchedVersions = new Set();
  }
  test(version) {
    if (this.matchedVersions.has(version)) return true;
    if (this.unmatchedVersions.has(version)) return false;
    const matches = super.test(...arguments);
    if (matches) {
      this.matchedVersions.add(version);
    } else {
      this.unmatchedVersions.add(version);
    }
    return matches;
  }
}
let nativeModules = null;
const cache = {
  builtins: {},
  debug: false,
  dependencies: {},
  extensions: {},
  folders: {},
  ranges: {},
  registered: false,
  resourcePath: null,
  resourcePathWithTrailingSlash: null
};
let isAbsolute;
if (process.platform === 'win32') {
  isAbsolute = pathToCheck =>
    pathToCheck &&
    (pathToCheck[1] === ':' ||
      (pathToCheck[0] === '\\' && pathToCheck[1] === '\\'));
} else {
  isAbsolute = pathToCheck => pathToCheck && pathToCheck[0] === '/';
}
const isCorePath = pathToCheck =>
  pathToCheck.startsWith(cache.resourcePathWithTrailingSlash);
function loadDependencies(modulePath, rootPath, rootMetadata, moduleCache) {
  const fs = require('fs-plus');
  for (let childPath of fs.listSync(path.join(modulePath, 'node_modules'))) {
    if (path.basename(childPath) === '.bin') continue;
    if (
      rootPath === modulePath &&
      (rootMetadata.packageDependencies &&
        rootMetadata.packageDependencies.hasOwnProperty(
          path.basename(childPath)
        ))
    ) {
      continue;
    }
    const childMetadataPath = path.join(childPath, 'package.json');
    if (!fs.isFileSync(childMetadataPath)) continue;
    const childMetadata = JSON.parse(fs.readFileSync(childMetadataPath));
    if (childMetadata && childMetadata.version) {
      let mainPath;
      try {
        mainPath = require.resolve(childPath);
      } catch (error) {
        mainPath = null;
      }
      if (mainPath) {
        moduleCache.dependencies.push({
          name: childMetadata.name,
          version: childMetadata.version,
          path: path.relative(rootPath, mainPath)
        });
      }
      loadDependencies(childPath, rootPath, rootMetadata, moduleCache);
    }
  }
}
function loadFolderCompatibility(
  modulePath,
  rootPath,
  rootMetadata,
  moduleCache
) {
  const fs = require('fs-plus');
  const metadataPath = path.join(modulePath, 'package.json');
  if (!fs.isFileSync(metadataPath)) return;
  const metadata = JSON.parse(fs.readFileSync(metadataPath));
  const dependencies = metadata.dependencies || {};
  for (let name in dependencies) {
    if (!semver.validRange(dependencies[name])) {
      delete dependencies[name];
    }
  }
  const onDirectory = childPath => path.basename(childPath) !== 'node_modules';
  const extensions = ['.js', '.coffee', '.json', '.node'];
  let paths = {};
  function onFile(childPath) {
    const needle = path.extname(childPath);
    if (extensions.includes(needle)) {
      const relativePath = path.relative(rootPath, path.dirname(childPath));
      paths[relativePath] = true;
    }
  }
  fs.traverseTreeSync(modulePath, onFile, onDirectory);
  paths = Object.keys(paths);
  if (paths.length > 0 && Object.keys(dependencies).length > 0) {
    moduleCache.folders.push({ paths, dependencies });
  }
  for (let childPath of fs.listSync(path.join(modulePath, 'node_modules'))) {
    if (path.basename(childPath) === '.bin') continue;
    if (
      rootPath === modulePath &&
      (rootMetadata.packageDependencies &&
        rootMetadata.packageDependencies.hasOwnProperty(
          path.basename(childPath)
        ))
    ) {
      continue;
    }
    loadFolderCompatibility(childPath, rootPath, rootMetadata, moduleCache);
  }
}
function loadExtensions(modulePath, rootPath, rootMetadata, moduleCache) {
  const fs = require('fs-plus');
  const extensions = ['.js', '.coffee', '.json', '.node'];
  const nodeModulesPath = path.join(rootPath, 'node_modules');
  function onFile(filePath) {
    filePath = path.relative(rootPath, filePath);
    const segments = filePath.split(path.sep);
    if (segments.includes('test')) return;
    if (segments.includes('tests')) return;
    if (segments.includes('spec')) return;
    if (segments.includes('specs')) return;
    if (
      segments.length > 1 &&
      !['exports', 'lib', 'node_modules', 'src', 'static', 'vendor'].includes(
        segments[0]
      )
    )
      return;
    const extension = path.extname(filePath);
    if (extensions.includes(extension)) {
      if (moduleCache.extensions[extension] == null) {
        moduleCache.extensions[extension] = [];
      }
      moduleCache.extensions[extension].push(filePath);
    }
  }
  function onDirectory(childPath) {
    if (rootMetadata.name === 'atom') {
      const parentPath = path.dirname(childPath);
      if (parentPath === nodeModulesPath) {
        const packageName = path.basename(childPath);
        if (
          rootMetadata.packageDependencies &&
          rootMetadata.packageDependencies.hasOwnProperty(packageName)
        )
          return false;
      }
    }
    return true;
  }
  fs.traverseTreeSync(rootPath, onFile, onDirectory);
}
function satisfies(version, rawRange) {
  let parsedRange;
  if (!(parsedRange = cache.ranges[rawRange])) {
    parsedRange = new Range(rawRange);
    cache.ranges[rawRange] = parsedRange;
  }
  return parsedRange.test(version);
}
function resolveFilePath(relativePath, parentModule) {
  if (!relativePath) return;
  if (!(parentModule && parentModule.filename)) return;
  if (relativePath[0] !== '.' && !isAbsolute(relativePath)) return;
  const resolvedPath = path.resolve(
    path.dirname(parentModule.filename),
    relativePath
  );
  if (!isCorePath(resolvedPath)) return;
  let extension = path.extname(resolvedPath);
  if (extension) {
    if (
      cache.extensions[extension] &&
      cache.extensions[extension].has(resolvedPath)
    )
      return resolvedPath;
  } else {
    for (extension in cache.extensions) {
      const paths = cache.extensions[extension];
      const resolvedPathWithExtension = `${resolvedPath}${extension}`;
      if (paths.has(resolvedPathWithExtension)) {
        return resolvedPathWithExtension;
      }
    }
  }
}
function resolveModulePath(relativePath, parentModule) {
  if (!relativePath) return;
  if (!(parentModule && parentModule.filename)) return;
  if (!nativeModules) nativeModules = process.binding('natives');
  if (nativeModules.hasOwnProperty(relativePath)) return;
  if (relativePath[0] === '.') return;
  if (isAbsolute(relativePath)) return;
  const folderPath = path.dirname(parentModule.filename);
  const range =
    cache.folders[folderPath] && cache.folders[folderPath][relativePath];
  if (!range) {
    const builtinPath = cache.builtins[relativePath];
    if (builtinPath) {
      return builtinPath;
    } else {
      return;
    }
  }
  const candidates = cache.dependencies[relativePath];
  if (candidates == null) return;
  for (let version in candidates) {
    const resolvedPath = candidates[version];
    if (Module._cache[resolvedPath] || isCorePath(resolvedPath)) {
      if (satisfies(version, range)) return resolvedPath;
    }
  }
}
function registerBuiltins(devMode) {
  if (
    devMode ||
    !cache.resourcePath.startsWith(`${process.resourcesPath}${path.sep}`)
  ) {
    const fs = require('fs-plus');
    const atomJsPath = path.join(cache.resourcePath, 'exports', 'atom.js');
    if (fs.isFileSync(atomJsPath)) {
      cache.builtins.atom = atomJsPath;
    }
  }
  if (cache.builtins.atom == null) {
    cache.builtins.atom = path.join(cache.resourcePath, 'exports', 'atom.js');
  }
}
exports.create = function(modulePath) {
  const fs = require('fs-plus');
  modulePath = fs.realpathSync(modulePath);
  const metadataPath = path.join(modulePath, 'package.json');
  const metadata = JSON.parse(fs.readFileSync(metadataPath));
  const moduleCache = {
    version: 1,
    dependencies: [],
    extensions: {},
    folders: []
  };
  loadDependencies(modulePath, modulePath, metadata, moduleCache);
  loadFolderCompatibility(modulePath, modulePath, metadata, moduleCache);
  loadExtensions(modulePath, modulePath, metadata, moduleCache);
  metadata._atomModuleCache = moduleCache;
  fs.writeFileSync(metadataPath, JSON.stringify(metadata, null, 2));
};
exports.register = function({ resourcePath, devMode } = {}) {
  if (cache.registered) return;
  const originalResolveFilename = Module._resolveFilename;
  Module._resolveFilename = function(relativePath, parentModule) {
    let resolvedPath = resolveModulePath(relativePath, parentModule);
    if (!resolvedPath) {
      resolvedPath = resolveFilePath(relativePath, parentModule);
    }
    return resolvedPath || originalResolveFilename(relativePath, parentModule);
  };
  cache.registered = true;
  cache.resourcePath = resourcePath;
  cache.resourcePathWithTrailingSlash = `${resourcePath}${path.sep}`;
  registerBuiltins(devMode);
};
exports.add = function(directoryPath, metadata) {
  if (metadata == null) {
    try {
      metadata = require(`${directoryPath}${path.sep}package.json`);
    } catch (error) {
      return;
    }
  }
  const cacheToAdd = metadata && metadata._atomModuleCache;
  if (!cacheToAdd) return;
  for (const dependency of cacheToAdd.dependencies || []) {
    if (!cache.dependencies[dependency.name]) {
      cache.dependencies[dependency.name] = {};
    }
    if (!cache.dependencies[dependency.name][dependency.version]) {
      cache.dependencies[dependency.name][
        dependency.version
      ] = `${directoryPath}${path.sep}${dependency.path}`;
    }
  }
  for (const entry of cacheToAdd.folders || []) {
    for (const folderPath of entry.paths) {
      if (folderPath) {
        cache.folders[`${directoryPath}${path.sep}${folderPath}`] =
          entry.dependencies;
      } else {
        cache.folders[directoryPath] = entry.dependencies;
      }
    }
  }
  for (const extension in cacheToAdd.extensions) {
    const paths = cacheToAdd.extensions[extension];
    if (!cache.extensions[extension]) {
      cache.extensions[extension] = new Set();
    }
    for (let filePath of paths) {
      cache.extensions[extension].add(`${directoryPath}${path.sep}${filePath}`);
    }
  }
};
exports.cache = cache;
exports.Range = Range;

================
File: src/module-utils.js
================
function requireModule(path) {
  const modul = require(path);
  if (modul === null || modul === undefined) {
    return modul;
  } else {
    if (
      modul.__esModule === true &&
      (modul.default !== undefined && modul.default !== null)
    ) {
      return modul.default;
    } else {
      return modul;
    }
  }
}
exports.requireModule = requireModule;

================
File: src/native-compile-cache.js
================
const Module = require('module');
const path = require('path');
const crypto = require('crypto');
const vm = require('vm');
function computeHash(contents) {
  return crypto
    .createHash('sha1')
    .update(contents, 'utf8')
    .digest('hex');
}
class NativeCompileCache {
  constructor() {
    this.cacheStore = null;
    this.previousModuleCompile = null;
  }
  setCacheStore(store) {
    this.cacheStore = store;
  }
  setV8Version(v8Version) {
    this.v8Version = v8Version.toString();
  }
  install() {
    this.savePreviousModuleCompile();
    this.overrideModuleCompile();
  }
  uninstall() {
    this.restorePreviousModuleCompile();
  }
  savePreviousModuleCompile() {
    this.previousModuleCompile = Module.prototype._compile;
  }
  runInThisContext(code, filename) {
    const script = new vm.Script(code, filename);
    const cachedData = script.createCachedData();
    return {
      result: script.runInThisContext(),
      cacheBuffer: typeof cachedData !== 'undefined' ? cachedData : null
    };
  }
  runInThisContextCached(code, filename, cachedData) {
    const script = new vm.Script(code, { filename, cachedData });
    return {
      result: script.runInThisContext(),
      wasRejected: script.cachedDataRejected
    };
  }
  overrideModuleCompile() {
    let self = this;
    Module.prototype._compile = function(content, filename) {
      let moduleSelf = this;
      content = content.replace(/^#!.*/, '');
      function require(path) {
        return moduleSelf.require(path);
      }
      require.resolve = function(request) {
        return Module._resolveFilename(request, moduleSelf);
      };
      require.main = process.mainModule;
      require.extensions = Module._extensions;
      require.cache = Module._cache;
      let dirname = path.dirname(filename);
      let wrapper = Module.wrap(content);
      let cacheKey = computeHash(wrapper + self.v8Version);
      let compiledWrapper = null;
      if (self.cacheStore.has(cacheKey)) {
        let buffer = self.cacheStore.get(cacheKey);
        let compilationResult = self.runInThisContextCached(
          wrapper,
          filename,
          buffer
        );
        compiledWrapper = compilationResult.result;
        if (compilationResult.wasRejected) {
          self.cacheStore.delete(cacheKey);
        }
      } else {
        let compilationResult;
        try {
          compilationResult = self.runInThisContext(wrapper, filename);
        } catch (err) {
          console.error(`Error running script ${filename}`);
          throw err;
        }
        if (compilationResult.cacheBuffer) {
          self.cacheStore.set(cacheKey, compilationResult.cacheBuffer);
        }
        compiledWrapper = compilationResult.result;
      }
      let args = [
        moduleSelf.exports,
        require,
        moduleSelf,
        filename,
        dirname,
        process,
        global,
        Buffer
      ];
      return compiledWrapper.apply(moduleSelf.exports, args);
    };
  }
  restorePreviousModuleCompile() {
    Module.prototype._compile = this.previousModuleCompile;
  }
}
module.exports = new NativeCompileCache();

================
File: src/native-watcher-registry.js
================
const path = require('path');
function absolute(...parts) {
  const candidate = path.join(...parts);
  return path.isAbsolute(candidate)
    ? candidate
    : path.join(path.sep, candidate);
}
class RegistryTree {
  constructor(basePathSegments, createNative) {
    this.basePathSegments = basePathSegments;
    this.root = new RegistryNode();
    this.createNative = createNative;
  }
  add(pathSegments, attachToNative) {
    const absolutePathSegments = this.basePathSegments.concat(pathSegments);
    const absolutePath = absolute(...absolutePathSegments);
    const attachToNew = childPaths => {
      const native = this.createNative(absolutePath);
      const leaf = new RegistryWatcherNode(
        native,
        absolutePathSegments,
        childPaths
      );
      this.root = this.root.insert(pathSegments, leaf);
      const sub = native.onWillStop(() => {
        sub.dispose();
        this.root =
          this.root.remove(pathSegments, this.createNative) ||
          new RegistryNode();
      });
      attachToNative(native, absolutePath);
      return native;
    };
    this.root.lookup(pathSegments).when({
      parent: (parent, remaining) => {
        const native = parent.getNativeWatcher();
        parent.addChildPath(remaining);
        attachToNative(native, absolute(...parent.getAbsolutePathSegments()));
      },
      children: children => {
        const newNative = attachToNew(children.map(child => child.path));
        for (let i = 0; i < children.length; i++) {
          const childNode = children[i].node;
          const childNative = childNode.getNativeWatcher();
          childNative.reattachTo(newNative, absolutePath);
          childNative.dispose();
          childNative.stop();
        }
      },
      missing: () => attachToNew([])
    });
  }
  getRoot() {
    return this.root;
  }
  print() {
    return this.root.print();
  }
}
class RegistryNode {
  constructor() {
    this.children = {};
  }
  lookup(pathSegments) {
    if (pathSegments.length === 0) {
      return new ChildrenResult(this.leaves([]));
    }
    const child = this.children[pathSegments[0]];
    if (child === undefined) {
      return new MissingResult(this);
    }
    return child.lookup(pathSegments.slice(1));
  }
  insert(pathSegments, leaf) {
    if (pathSegments.length === 0) {
      return leaf;
    }
    const pathKey = pathSegments[0];
    let child = this.children[pathKey];
    if (child === undefined) {
      child = new RegistryNode();
    }
    this.children[pathKey] = child.insert(pathSegments.slice(1), leaf);
    return this;
  }
  remove(pathSegments, createSplitNative) {
    if (pathSegments.length === 0) {
      return this;
    }
    const pathKey = pathSegments[0];
    const child = this.children[pathKey];
    if (child === undefined) {
      return this;
    }
    const newChild = child.remove(pathSegments.slice(1), createSplitNative);
    if (newChild === null) {
      delete this.children[pathKey];
    } else {
      this.children[pathKey] = newChild;
    }
    return Object.keys(this.children).length === 0 ? null : this;
  }
  leaves(prefix) {
    const results = [];
    for (const p of Object.keys(this.children)) {
      results.push(...this.children[p].leaves(prefix.concat([p])));
    }
    return results;
  }
  print(indent = 0) {
    let spaces = '';
    for (let i = 0; i < indent; i++) {
      spaces += ' ';
    }
    let result = '';
    for (const p of Object.keys(this.children)) {
      result += `${spaces}${p}\n${this.children[p].print(indent + 2)}`;
    }
    return result;
  }
}
// Private: Leaf node within a {NativeWatcherRegistry} tree. Represents a directory that is covered by a
// {NativeWatcher}.
class RegistryWatcherNode {
  // Private: Allocate a new node to track a {NativeWatcher}.
  //
  // * `nativeWatcher` An existing {NativeWatcher} instance.
  // * `absolutePathSegments` The absolute path to this {NativeWatcher}'s directory as an {Array} of
  constructor(nativeWatcher, absolutePathSegments, childPaths) {
    this.nativeWatcher = nativeWatcher;
    this.absolutePathSegments = absolutePathSegments;
    this.childPaths = new Set();
    for (let i = 0; i < childPaths.length; i++) {
      this.childPaths.add(path.join(...childPaths[i]));
    }
  }
  addChildPath(childPathSegments) {
    this.childPaths.add(path.join(...childPathSegments));
  }
  removeChildPath(childPathSegments) {
    this.childPaths.delete(path.join(...childPathSegments));
  }
  getNativeWatcher() {
    return this.nativeWatcher;
  }
  getAbsolutePathSegments() {
    return this.absolutePathSegments;
  }
  lookup(pathSegments) {
    return new ParentResult(this, pathSegments);
  }
  remove(pathSegments, createSplitNative) {
    if (pathSegments.length !== 0) {
      return this;
    } else if (this.childPaths.size > 0) {
      let newSubTree = new RegistryTree(
        this.absolutePathSegments,
        createSplitNative
      );
      for (const childPath of this.childPaths) {
        const childPathSegments = childPath.split(path.sep);
        newSubTree.add(childPathSegments, (native, attachmentPath) => {
          this.nativeWatcher.reattachTo(native, attachmentPath);
        });
      }
      return newSubTree.getRoot();
    } else {
      return null;
    }
  }
  leaves(prefix) {
    return [{ node: this, path: prefix }];
  }
  print(indent = 0) {
    let result = '';
    for (let i = 0; i < indent; i++) {
      result += ' ';
    }
    result += '[watcher';
    if (this.childPaths.size > 0) {
      result += ` +${this.childPaths.size}`;
    }
    result += ']\n';
    return result;
  }
}
class MissingResult {
  constructor(lastParent) {
    this.lastParent = lastParent;
  }
  when(actions) {
    return actions.missing(this.lastParent);
  }
}
class ParentResult {
  constructor(parent, remainingPathSegments) {
    this.parent = parent;
    this.remainingPathSegments = remainingPathSegments;
  }
  when(actions) {
    return actions.parent(this.parent, this.remainingPathSegments);
  }
}
class ChildrenResult {
  constructor(children) {
    this.children = children;
  }
  when(actions) {
    return actions.children(this.children);
  }
}
class NativeWatcherRegistry {
  constructor(createNative) {
    this.tree = new RegistryTree([], createNative);
  }
  async attach(watcher) {
    const normalizedDirectory = await watcher.getNormalizedPathPromise();
    const pathSegments = normalizedDirectory
      .split(path.sep)
      .filter(segment => segment.length > 0);
    this.tree.add(pathSegments, (native, nativePath) => {
      watcher.attachToNative(native, nativePath);
    });
  }
  print() {
    return this.tree.print();
  }
}
module.exports = { NativeWatcherRegistry };

================
File: src/notification-manager.js
================
const { Emitter } = require('event-kit');
const Notification = require('../src/notification');
module.exports = class NotificationManager {
  constructor() {
    this.notifications = [];
    this.emitter = new Emitter();
  }
  onDidAddNotification(callback) {
    return this.emitter.on('did-add-notification', callback);
  }
  onDidClearNotifications(callback) {
    return this.emitter.on('did-clear-notifications', callback);
  }
  addSuccess(message, options) {
    return this.addNotification(new Notification('success', message, options));
  }
  addInfo(message, options) {
    return this.addNotification(new Notification('info', message, options));
  }
  addWarning(message, options) {
    return this.addNotification(new Notification('warning', message, options));
  }
  addError(message, options) {
    return this.addNotification(new Notification('error', message, options));
  }
  addFatalError(message, options) {
    return this.addNotification(new Notification('fatal', message, options));
  }
  add(type, message, options) {
    return this.addNotification(new Notification(type, message, options));
  }
  addNotification(notification) {
    this.notifications.push(notification);
    this.emitter.emit('did-add-notification', notification);
    return notification;
  }
  getNotifications() {
    return this.notifications.slice();
  }
  clear() {
    this.notifications = [];
    this.emitter.emit('did-clear-notifications');
  }
};

================
File: src/notification.js
================
const { Emitter } = require('event-kit');
const _ = require('underscore-plus');
module.exports = class Notification {
  constructor(type, message, options = {}) {
    this.type = type;
    this.message = message;
    this.options = options;
    this.emitter = new Emitter();
    this.timestamp = new Date();
    this.dismissed = true;
    if (this.isDismissable()) this.dismissed = false;
    this.displayed = false;
    this.validate();
  }
  validate() {
    if (typeof this.message !== 'string') {
      throw new Error(
        `Notification must be created with string message: ${this.message}`
      );
    }
    if (!_.isObject(this.options) || Array.isArray(this.options)) {
      throw new Error(
        `Notification must be created with an options object: ${this.options}`
      );
    }
  }
  onDidDismiss(callback) {
    return this.emitter.on('did-dismiss', callback);
  }
  onDidDisplay(callback) {
    return this.emitter.on('did-display', callback);
  }
  getOptions() {
    return this.options;
  }
  getType() {
    return this.type;
  }
  getMessage() {
    return this.message;
  }
  getTimestamp() {
    return this.timestamp;
  }
  getDetail() {
    return this.options.detail;
  }
  isEqual(other) {
    return (
      this.getMessage() === other.getMessage() &&
      this.getType() === other.getType() &&
      this.getDetail() === other.getDetail()
    );
  }
  dismiss() {
    if (!this.isDismissable() || this.isDismissed()) return;
    this.dismissed = true;
    this.emitter.emit('did-dismiss', this);
  }
  isDismissed() {
    return this.dismissed;
  }
  isDismissable() {
    return !!this.options.dismissable;
  }
  wasDisplayed() {
    return this.displayed;
  }
  setDisplayed(displayed) {
    this.displayed = displayed;
    this.emitter.emit('did-display', this);
  }
  getIcon() {
    if (this.options.icon != null) return this.options.icon;
    switch (this.type) {
      case 'fatal':
        return 'bug';
      case 'error':
        return 'flame';
      case 'warning':
        return 'alert';
      case 'info':
        return 'info';
      case 'success':
        return 'check';
    }
  }
};

================
File: src/null-grammar.js
================
const { Disposable } = require('event-kit');
module.exports = {
  name: 'Null Grammar',
  scopeName: 'text.plain.null-grammar',
  scopeForId(id) {
    if (id === -1 || id === -2) {
      return this.scopeName;
    } else {
      return null;
    }
  },
  startIdForScope(scopeName) {
    if (scopeName === this.scopeName) {
      return -1;
    } else {
      return null;
    }
  },
  endIdForScope(scopeName) {
    if (scopeName === this.scopeName) {
      return -2;
    } else {
      return null;
    }
  },
  tokenizeLine(text) {
    return {
      tags: [
        this.startIdForScope(this.scopeName),
        text.length,
        this.endIdForScope(this.scopeName)
      ],
      ruleStack: null
    };
  },
  onDidUpdate(callback) {
    return new Disposable(noop);
  }
};
function noop() {}

================
File: src/package-manager.js
================
const path = require('path');
let normalizePackageData = null;
const _ = require('underscore-plus');
const { Emitter } = require('event-kit');
const fs = require('fs-plus');
const CSON = require('season');
const ServiceHub = require('service-hub');
const Package = require('./package');
const ThemePackage = require('./theme-package');
const ModuleCache = require('./module-cache');
const packageJSON = require('../package.json');
module.exports = class PackageManager {
  constructor(params) {
    ({
      config: this.config,
      styleManager: this.styleManager,
      notificationManager: this.notificationManager,
      keymapManager: this.keymapManager,
      commandRegistry: this.commandRegistry,
      grammarRegistry: this.grammarRegistry,
      deserializerManager: this.deserializerManager,
      viewRegistry: this.viewRegistry,
      uriHandlerRegistry: this.uriHandlerRegistry
    } = params);
    this.emitter = new Emitter();
    this.activationHookEmitter = new Emitter();
    this.packageDirPaths = [];
    this.deferredActivationHooks = [];
    this.triggeredActivationHooks = new Set();
    this.packagesCache =
      packageJSON._atomPackages != null ? packageJSON._atomPackages : {};
    this.packageDependencies =
      packageJSON.packageDependencies != null
        ? packageJSON.packageDependencies
        : {};
    this.initialPackagesLoaded = false;
    this.initialPackagesActivated = false;
    this.preloadedPackages = {};
    this.loadedPackages = {};
    this.activePackages = {};
    this.activatingPackages = {};
    this.packageStates = {};
    this.serviceHub = new ServiceHub();
    this.packageActivators = [];
    this.registerPackageActivator(this, ['atom', 'textmate']);
  }
  initialize(params) {
    this.devMode = params.devMode;
    this.resourcePath = params.resourcePath;
    if (params.configDirPath != null && !params.safeMode) {
      if (this.devMode) {
        this.packageDirPaths.push(
          path.join(params.configDirPath, 'dev', 'packages')
        );
        this.packageDirPaths.push(path.join(this.resourcePath, 'packages'));
      }
      this.packageDirPaths.push(path.join(params.configDirPath, 'packages'));
    }
  }
  setContextMenuManager(contextMenuManager) {
    this.contextMenuManager = contextMenuManager;
  }
  setMenuManager(menuManager) {
    this.menuManager = menuManager;
  }
  setThemeManager(themeManager) {
    this.themeManager = themeManager;
  }
  async reset() {
    this.serviceHub.clear();
    await this.deactivatePackages();
    this.loadedPackages = {};
    this.preloadedPackages = {};
    this.packageStates = {};
    this.packagesCache =
      packageJSON._atomPackages != null ? packageJSON._atomPackages : {};
    this.packageDependencies =
      packageJSON.packageDependencies != null
        ? packageJSON.packageDependencies
        : {};
    this.triggeredActivationHooks.clear();
    this.activatePromise = null;
  }
  onDidLoadInitialPackages(callback) {
    return this.emitter.on('did-load-initial-packages', callback);
  }
  onDidActivateInitialPackages(callback) {
    return this.emitter.on('did-activate-initial-packages', callback);
  }
  getActivatePromise() {
    if (this.activatePromise) {
      return this.activatePromise;
    } else {
      return Promise.resolve();
    }
  }
  onDidActivatePackage(callback) {
    return this.emitter.on('did-activate-package', callback);
  }
  onDidDeactivatePackage(callback) {
    return this.emitter.on('did-deactivate-package', callback);
  }
  onDidLoadPackage(callback) {
    return this.emitter.on('did-load-package', callback);
  }
  onDidUnloadPackage(callback) {
    return this.emitter.on('did-unload-package', callback);
  }
  static possibleApmPaths(configPath) {
    if (process.env.APM_PATH || configPath) {
      return process.env.APM_PATH || configPath;
    }
    const commandName = process.platform === 'win32' ? 'apm.cmd' : 'apm';
    const bundledPPMRoot = path.join(process.resourcesPath, 'app', 'ppm', 'bin', commandName);
    const unbundledPPMRoot = path.join(__dirname, '..', 'ppm', 'bin', commandName);
    if (fs.isFileSync(bundledPPMRoot)) {
      return bundledPPMRoot;
    } else {
      return unbundledPPMRoot;
    }
  }
  getApmPath() {
    const configPath = atom.config.get('core.apmPath');
    if (configPath || this.apmPath) {
      return configPath || this.apmPath;
    } else {
       this.apmPath = PackageManager.possibleApmPaths();
       return this.apmPath
    }
  }
  getPackageDirPaths() {
    return _.clone(this.packageDirPaths);
  }
  resolvePackagePath(name) {
    if (fs.isDirectorySync(name)) {
      return name;
    }
    let packagePath = fs.resolve(...this.packageDirPaths, name);
    if (fs.isDirectorySync(packagePath)) {
      return packagePath;
    }
    packagePath = path.join(this.resourcePath, 'node_modules', name);
    if (this.hasAtomEngine(packagePath)) {
      return packagePath;
    }
    return null;
  }
  isBundledPackage(name) {
    return this.getPackageDependencies().hasOwnProperty(name);
  }
  enablePackage(name) {
    const pack = this.loadPackage(name);
    if (pack != null) {
      pack.enable();
    }
    return pack;
  }
  disablePackage(name) {
    const pack = this.loadPackage(name);
    if (!this.isPackageDisabled(name) && pack != null) {
      pack.disable();
    }
    return pack;
  }
  isPackageDisabled(name) {
    return _.include(this.config.get('core.disabledPackages') || [], name);
  }
  getActivePackages() {
    return _.values(this.activePackages);
  }
  getActivePackage(name) {
    return this.activePackages[name];
  }
  isPackageActive(name) {
    return this.getActivePackage(name) != null;
  }
  hasActivatedInitialPackages() {
    return this.initialPackagesActivated;
  }
  getLoadedPackages() {
    return _.values(this.loadedPackages);
  }
  getLoadedPackagesForTypes(types) {
    return this.getLoadedPackages().filter(p => types.includes(p.getType()));
  }
  getLoadedPackage(name) {
    return this.loadedPackages[name];
  }
  isPackageLoaded(name) {
    return this.getLoadedPackage(name) != null;
  }
  hasLoadedInitialPackages() {
    return this.initialPackagesLoaded;
  }
  getAvailablePackagePaths() {
    return this.getAvailablePackages().map(a => a.path);
  }
  getAvailablePackageNames() {
    return this.getAvailablePackages().map(a => a.name);
  }
  getAvailablePackageMetadata() {
    const packages = [];
    for (const pack of this.getAvailablePackages()) {
      const loadedPackage = this.getLoadedPackage(pack.name);
      const metadata =
        loadedPackage != null
          ? loadedPackage.metadata
          : this.loadPackageMetadata(pack, true);
      packages.push(metadata);
    }
    return packages;
  }
  getAvailablePackages() {
    const packages = [];
    const packagesByName = new Set();
    for (const packageDirPath of this.packageDirPaths) {
      if (fs.isDirectorySync(packageDirPath)) {
        const packageNames = fs
          .readdirSync(packageDirPath, { withFileTypes: true })
          .filter(
            dirent =>
              dirent.isDirectory() ||
              (dirent.isSymbolicLink() &&
                fs.isDirectorySync(path.join(packageDirPath, dirent.name)))
          )
          .map(dirent => dirent.name);
        for (const packageName of packageNames) {
          if (
            !packageName.startsWith('.') &&
            !packagesByName.has(packageName)
          ) {
            const packagePath = path.join(packageDirPath, packageName);
            packages.push({
              name: packageName,
              path: packagePath,
              isBundled: false
            });
            packagesByName.add(packageName);
          }
        }
      }
    }
    for (const packageName in this.packageDependencies) {
      if (!packagesByName.has(packageName)) {
        packages.push({
          name: packageName,
          path: path.join(this.resourcePath, 'node_modules', packageName),
          isBundled: true
        });
      }
    }
    return packages.sort((a, b) => a.name.localeCompare(b.name));
  }
  getPackageState(name) {
    return this.packageStates[name];
  }
  setPackageState(name, state) {
    this.packageStates[name] = state;
  }
  getPackageDependencies() {
    return this.packageDependencies;
  }
  hasAtomEngine(packagePath) {
    const metadata = this.loadPackageMetadata(packagePath, true);
    return (
      metadata != null &&
      metadata.engines != null &&
      metadata.engines.atom != null
    );
  }
  unobserveDisabledPackages() {
    if (this.disabledPackagesSubscription != null) {
      this.disabledPackagesSubscription.dispose();
    }
    this.disabledPackagesSubscription = null;
  }
  observeDisabledPackages() {
    if (this.disabledPackagesSubscription != null) {
      return;
    }
    this.disabledPackagesSubscription = this.config.onDidChange(
      'core.disabledPackages',
      ({ newValue, oldValue }) => {
        const packagesToEnable = _.difference(oldValue, newValue);
        const packagesToDisable = _.difference(newValue, oldValue);
        packagesToDisable.forEach(name => {
          if (this.getActivePackage(name)) this.deactivatePackage(name);
        });
        packagesToEnable.forEach(name => this.activatePackage(name));
        return null;
      }
    );
  }
  unobservePackagesWithKeymapsDisabled() {
    if (this.packagesWithKeymapsDisabledSubscription != null) {
      this.packagesWithKeymapsDisabledSubscription.dispose();
    }
    this.packagesWithKeymapsDisabledSubscription = null;
  }
  observePackagesWithKeymapsDisabled() {
    if (this.packagesWithKeymapsDisabledSubscription != null) {
      return;
    }
    const performOnLoadedActivePackages = (
      packageNames,
      disabledPackageNames,
      action
    ) => {
      for (const packageName of packageNames) {
        if (!disabledPackageNames.has(packageName)) {
          const pack = this.getLoadedPackage(packageName);
          if (pack != null) {
            action(pack);
          }
        }
      }
    };
    this.packagesWithKeymapsDisabledSubscription = this.config.onDidChange(
      'core.packagesWithKeymapsDisabled',
      ({ newValue, oldValue }) => {
        const keymapsToEnable = _.difference(oldValue, newValue);
        const keymapsToDisable = _.difference(newValue, oldValue);
        const disabledPackageNames = new Set(
          this.config.get('core.disabledPackages')
        );
        performOnLoadedActivePackages(
          keymapsToDisable,
          disabledPackageNames,
          p => p.deactivateKeymaps()
        );
        performOnLoadedActivePackages(
          keymapsToEnable,
          disabledPackageNames,
          p => p.activateKeymaps()
        );
        return null;
      }
    );
  }
  preloadPackages() {
    const result = [];
    for (const packageName in this.packagesCache) {
      result.push(
        this.preloadPackage(packageName, this.packagesCache[packageName])
      );
    }
    return result;
  }
  preloadPackage(packageName, pack) {
    const metadata = pack.metadata || {};
    if (typeof metadata.name !== 'string' || metadata.name.length < 1) {
      metadata.name = packageName;
    }
    if (
      metadata.repository != null &&
      metadata.repository.type === 'git' &&
      typeof metadata.repository.url === 'string'
    ) {
      metadata.repository.url = metadata.repository.url.replace(
        /(^git\+)|(\.git$)/g,
        ''
      );
    }
    const options = {
      path: pack.rootDirPath,
      name: packageName,
      preloadedPackage: true,
      bundledPackage: true,
      metadata,
      packageManager: this,
      config: this.config,
      styleManager: this.styleManager,
      commandRegistry: this.commandRegistry,
      keymapManager: this.keymapManager,
      notificationManager: this.notificationManager,
      grammarRegistry: this.grammarRegistry,
      themeManager: this.themeManager,
      menuManager: this.menuManager,
      contextMenuManager: this.contextMenuManager,
      deserializerManager: this.deserializerManager,
      viewRegistry: this.viewRegistry
    };
    pack = metadata.theme ? new ThemePackage(options) : new Package(options);
    pack.preload();
    this.preloadedPackages[packageName] = pack;
    return pack;
  }
  loadPackages() {
    // Ensure atom exports is already in the require cache so the load time
    // of the first package isn't skewed by being the first to require atom
    require('../exports/atom');
    const disabledPackageNames = new Set(
      this.config.get('core.disabledPackages')
    );
    this.config.transact(() => {
      for (const pack of this.getAvailablePackages()) {
        this.loadAvailablePackage(pack, disabledPackageNames);
      }
    });
    this.initialPackagesLoaded = true;
    this.emitter.emit('did-load-initial-packages');
  }
  loadPackage(nameOrPath) {
    if (path.basename(nameOrPath)[0].match(/^\./)) {
      return null;
    }
    const pack = this.getLoadedPackage(nameOrPath);
    if (pack) {
      return pack;
    }
    const packagePath = this.resolvePackagePath(nameOrPath);
    if (packagePath) {
      const name = path.basename(nameOrPath);
      return this.loadAvailablePackage({
        name,
        path: packagePath,
        isBundled: this.isBundledPackagePath(packagePath)
      });
    }
    console.warn(`Could not resolve '${nameOrPath}' to a package path`);
    return null;
  }
  loadAvailablePackage(availablePackage, disabledPackageNames) {
    const preloadedPackage = this.preloadedPackages[availablePackage.name];
    if (
      disabledPackageNames != null &&
      disabledPackageNames.has(availablePackage.name)
    ) {
      if (preloadedPackage != null) {
        preloadedPackage.deactivate();
        delete preloadedPackage[availablePackage.name];
      }
      return null;
    }
    const loadedPackage = this.getLoadedPackage(availablePackage.name);
    if (loadedPackage != null) {
      return loadedPackage;
    }
    if (preloadedPackage != null) {
      if (availablePackage.isBundled) {
        preloadedPackage.finishLoading();
        this.loadedPackages[availablePackage.name] = preloadedPackage;
        return preloadedPackage;
      } else {
        preloadedPackage.deactivate();
        delete preloadedPackage[availablePackage.name];
      }
    }
    let metadata;
    try {
      metadata = this.loadPackageMetadata(availablePackage) || {};
    } catch (error) {
      this.handleMetadataError(error, availablePackage.path);
      return null;
    }
    const options = {
      path: availablePackage.path,
      name: availablePackage.name,
      metadata,
      bundledPackage: availablePackage.isBundled,
      packageManager: this,
      config: this.config,
      styleManager: this.styleManager,
      commandRegistry: this.commandRegistry,
      keymapManager: this.keymapManager,
      notificationManager: this.notificationManager,
      grammarRegistry: this.grammarRegistry,
      themeManager: this.themeManager,
      menuManager: this.menuManager,
      contextMenuManager: this.contextMenuManager,
      deserializerManager: this.deserializerManager,
      viewRegistry: this.viewRegistry
    };
    const pack = metadata.theme
      ? new ThemePackage(options)
      : new Package(options);
    pack.load();
    this.loadedPackages[pack.name] = pack;
    this.emitter.emit('did-load-package', pack);
    return pack;
  }
  unloadPackages() {
    _.keys(this.loadedPackages).forEach(name => this.unloadPackage(name));
  }
  unloadPackage(name) {
    if (this.isPackageActive(name)) {
      throw new Error(`Tried to unload active package '${name}'`);
    }
    const pack = this.getLoadedPackage(name);
    if (pack) {
      delete this.loadedPackages[pack.name];
      this.emitter.emit('did-unload-package', pack);
    } else {
      throw new Error(`No loaded package for name '${name}'`);
    }
  }
  activate() {
    let promises = [];
    for (let [activator, types] of this.packageActivators) {
      const packages = this.getLoadedPackagesForTypes(types);
      promises = promises.concat(activator.activatePackages(packages));
    }
    this.activatePromise = Promise.all(promises).then(() => {
      this.triggerDeferredActivationHooks();
      this.initialPackagesActivated = true;
      this.emitter.emit('did-activate-initial-packages');
      this.activatePromise = null;
    });
    return this.activatePromise;
  }
  registerURIHandlerForPackage(packageName, handler) {
    return this.uriHandlerRegistry.registerHostHandler(packageName, handler);
  }
  registerPackageActivator(activator, types) {
    this.packageActivators.push([activator, types]);
  }
  activatePackages(packages) {
    const promises = [];
    this.config.transactAsync(() => {
      for (const pack of packages) {
        const promise = this.activatePackage(pack.name);
        if (!pack.activationShouldBeDeferred()) {
          promises.push(promise);
        }
      }
      return Promise.all(promises);
    });
    this.observeDisabledPackages();
    this.observePackagesWithKeymapsDisabled();
    return promises;
  }
  activatePackage(name) {
    let pack = this.getActivePackage(name);
    if (pack) {
      return Promise.resolve(pack);
    }
    pack = this.loadPackage(name);
    if (!pack) {
      return Promise.reject(new Error(`Failed to load package '${name}'`));
    }
    this.activatingPackages[pack.name] = pack;
    const activationPromise = pack.activate().then(() => {
      if (this.activatingPackages[pack.name] != null) {
        delete this.activatingPackages[pack.name];
        this.activePackages[pack.name] = pack;
        this.emitter.emit('did-activate-package', pack);
      }
      return pack;
    });
    if (this.deferredActivationHooks == null) {
      this.triggeredActivationHooks.forEach(hook =>
        this.activationHookEmitter.emit(hook)
      );
    }
    return activationPromise;
  }
  triggerDeferredActivationHooks() {
    if (this.deferredActivationHooks == null) {
      return;
    }
    for (const hook of this.deferredActivationHooks) {
      this.activationHookEmitter.emit(hook);
    }
    this.deferredActivationHooks = null;
  }
  triggerActivationHook(hook) {
    if (hook == null || !_.isString(hook) || hook.length <= 0) {
      return new Error('Cannot trigger an empty activation hook');
    }
    this.triggeredActivationHooks.add(hook);
    if (this.deferredActivationHooks != null) {
      this.deferredActivationHooks.push(hook);
    } else {
      this.activationHookEmitter.emit(hook);
    }
  }
  onDidTriggerActivationHook(hook, callback) {
    if (hook == null || !_.isString(hook) || hook.length <= 0) {
      return;
    }
    return this.activationHookEmitter.on(hook, callback);
  }
  serialize() {
    for (const pack of this.getActivePackages()) {
      this.serializePackage(pack);
    }
    return this.packageStates;
  }
  serializePackage(pack) {
    if (typeof pack.serialize === 'function') {
      this.setPackageState(pack.name, pack.serialize());
    }
  }
  async deactivatePackages() {
    await this.config.transactAsync(() =>
      Promise.all(
        this.getLoadedPackages().map(pack =>
          this.deactivatePackage(pack.name, true)
        )
      )
    );
    this.unobserveDisabledPackages();
    this.unobservePackagesWithKeymapsDisabled();
  }
  async deactivatePackage(name, suppressSerialization) {
    const pack = this.getLoadedPackage(name);
    if (pack == null) {
      return;
    }
    if (!suppressSerialization && this.isPackageActive(pack.name)) {
      this.serializePackage(pack);
    }
    const deactivationResult = pack.deactivate();
    if (deactivationResult && typeof deactivationResult.then === 'function') {
      await deactivationResult;
    }
    delete this.activePackages[pack.name];
    delete this.activatingPackages[pack.name];
    this.emitter.emit('did-deactivate-package', pack);
  }
  handleMetadataError(error, packagePath) {
    const metadataPath = path.join(packagePath, 'package.json');
    const detail = `${error.message} in ${metadataPath}`;
    const stack = `${error.stack}\n  at ${metadataPath}:1:1`;
    const message = `Failed to load the ${path.basename(packagePath)} package`;
    this.notificationManager.addError(message, {
      stack,
      detail,
      packageName: path.basename(packagePath),
      dismissable: true
    });
  }
  uninstallDirectory(directory) {
    const symlinkPromise = new Promise(resolve =>
      fs.isSymbolicLink(directory, isSymLink => resolve(isSymLink))
    );
    const dirPromise = new Promise(resolve =>
      fs.isDirectory(directory, isDir => resolve(isDir))
    );
    return Promise.all([symlinkPromise, dirPromise]).then(values => {
      const [isSymLink, isDir] = values;
      if (!isSymLink && isDir) {
        return fs.remove(directory, function() {});
      }
    });
  }
  reloadActivePackageStyleSheets() {
    for (const pack of this.getActivePackages()) {
      if (
        pack.getType() !== 'theme' &&
        typeof pack.reloadStylesheets === 'function'
      ) {
        pack.reloadStylesheets();
      }
    }
  }
  isBundledPackagePath(packagePath) {
    if (
      this.devMode &&
      !this.resourcePath.startsWith(`${process.resourcesPath}${path.sep}`)
    ) {
      return false;
    }
    if (this.resourcePathWithTrailingSlash == null) {
      this.resourcePathWithTrailingSlash = `${this.resourcePath}${path.sep}`;
    }
    return (
      packagePath != null &&
      packagePath.startsWith(this.resourcePathWithTrailingSlash)
    );
  }
  loadPackageMetadata(packagePathOrAvailablePackage, ignoreErrors = false) {
    let isBundled, packageName, packagePath;
    if (typeof packagePathOrAvailablePackage === 'object') {
      const availablePackage = packagePathOrAvailablePackage;
      packageName = availablePackage.name;
      packagePath = availablePackage.path;
      isBundled = availablePackage.isBundled;
    } else {
      packagePath = packagePathOrAvailablePackage;
      packageName = path.basename(packagePath);
      isBundled = this.isBundledPackagePath(packagePath);
    }
    let metadata;
    if (isBundled && this.packagesCache[packageName] != null) {
      metadata = this.packagesCache[packageName].metadata;
    }
    if (metadata == null) {
      const metadataPath = CSON.resolve(path.join(packagePath, 'package'));
      if (metadataPath) {
        try {
          metadata = CSON.readFileSync(metadataPath);
          this.normalizePackageMetadata(metadata);
        } catch (error) {
          if (!ignoreErrors) {
            throw error;
          }
        }
      }
    }
    if (metadata == null) {
      metadata = {};
    }
    if (typeof metadata.name !== 'string' || metadata.name.length <= 0) {
      metadata.name = packageName;
    }
    if (
      metadata.repository &&
      metadata.repository.type === 'git' &&
      typeof metadata.repository.url === 'string'
    ) {
      metadata.repository.url = metadata.repository.url.replace(
        /(^git\+)|(\.git$)/g,
        ''
      );
    }
    return metadata;
  }
  normalizePackageMetadata(metadata) {
    if (metadata != null) {
      normalizePackageData =
        normalizePackageData || require('normalize-package-data');
      normalizePackageData(metadata);
    }
  }
};
const NullVersionRange = {
  test() {
    return false;
  }
};

================
File: src/package-transpilation-registry.js
================
'use strict';
const crypto = require('crypto');
const fs = require('fs');
const path = require('path');
const minimatch = require('minimatch');
let Resolve = null;
class PackageTranspilationRegistry {
  constructor() {
    this.configByPackagePath = {};
    this.specByFilePath = {};
    this.transpilerPaths = {};
  }
  addTranspilerConfigForPath(packagePath, packageName, packageMeta, config) {
    this.configByPackagePath[packagePath] = {
      name: packageName,
      meta: packageMeta,
      path: packagePath,
      specs: config.map(spec => Object.assign({}, spec))
    };
  }
  removeTranspilerConfigForPath(packagePath) {
    delete this.configByPackagePath[packagePath];
    const packagePathWithSep = packagePath.endsWith(path.sep)
      ? path.join(packagePath)
      : path.join(packagePath) + path.sep;
    Object.keys(this.specByFilePath).forEach(filePath => {
      if (path.join(filePath).startsWith(packagePathWithSep)) {
        delete this.specByFilePath[filePath];
      }
    });
  }
  wrapTranspiler(transpiler) {
    return {
      getCachePath: (sourceCode, filePath) => {
        const spec = this.getPackageTranspilerSpecForFilePath(filePath);
        if (spec) {
          return this.getCachePath(sourceCode, filePath, spec);
        }
        return transpiler.getCachePath(sourceCode, filePath);
      },
      compile: (sourceCode, filePath) => {
        const spec = this.getPackageTranspilerSpecForFilePath(filePath);
        if (spec) {
          return this.transpileWithPackageTranspiler(
            sourceCode,
            filePath,
            spec
          );
        }
        return transpiler.compile(sourceCode, filePath);
      },
      shouldCompile: (sourceCode, filePath) => {
        if (this.transpilerPaths[filePath]) {
          return false;
        }
        const spec = this.getPackageTranspilerSpecForFilePath(filePath);
        if (spec) {
          return true;
        }
        return transpiler.shouldCompile(sourceCode, filePath);
      }
    };
  }
  getPackageTranspilerSpecForFilePath(filePath) {
    if (this.specByFilePath[filePath] !== undefined)
      return this.specByFilePath[filePath];
    let thisPath = filePath;
    let lastPath = null;
    while (thisPath !== lastPath) {
      let config = this.configByPackagePath[thisPath];
      if (config) {
        const relativePath = path.relative(thisPath, filePath);
        if (
          relativePath.startsWith(`node_modules${path.sep}`) ||
          relativePath.indexOf(`${path.sep}node_modules${path.sep}`) > -1
        ) {
          return false;
        }
        for (let i = 0; i < config.specs.length; i++) {
          const spec = config.specs[i];
          if (minimatch(filePath, path.join(config.path, spec.glob))) {
            spec._config = config;
            this.specByFilePath[filePath] = spec;
            return spec;
          }
        }
      }
      lastPath = thisPath;
      thisPath = path.join(thisPath, '..');
    }
    this.specByFilePath[filePath] = null;
    return null;
  }
  getCachePath(sourceCode, filePath, spec) {
    const transpilerPath = this.getTranspilerPath(spec);
    const transpilerSource =
      spec._transpilerSource || fs.readFileSync(transpilerPath, 'utf8');
    spec._transpilerSource = transpilerSource;
    const transpiler = this.getTranspiler(spec);
    let hash = crypto
      .createHash('sha1')
      .update(JSON.stringify(spec.options || {}))
      .update(transpilerSource, 'utf8')
      .update(sourceCode, 'utf8');
    if (transpiler && transpiler.getCacheKeyData) {
      const meta = this.getMetadata(spec);
      const additionalCacheData = transpiler.getCacheKeyData(
        sourceCode,
        filePath,
        spec.options || {},
        meta
      );
      hash.update(additionalCacheData, 'utf8');
    }
    return path.join(
      'package-transpile',
      spec._config.name,
      hash.digest('hex')
    );
  }
  transpileWithPackageTranspiler(sourceCode, filePath, spec) {
    const transpiler = this.getTranspiler(spec);
    if (transpiler) {
      const meta = this.getMetadata(spec);
      const result = transpiler.transpile(
        sourceCode,
        filePath,
        spec.options || {},
        meta
      );
      if (result === undefined || (result && result.code === undefined)) {
        return sourceCode;
      } else if (result.code) {
        return result.code.toString();
      } else {
        throw new Error(
          'Could not find a property `.code` on the transpilation results of ' +
            filePath
        );
      }
    } else {
      const err = new Error(
        "Could not resolve transpiler '" +
          spec.transpiler +
          "' from '" +
          spec._config.path +
          "'"
      );
      throw err;
    }
  }
  getMetadata(spec) {
    return {
      name: spec._config.name,
      path: spec._config.path,
      meta: spec._config.meta
    };
  }
  getTranspilerPath(spec) {
    Resolve = Resolve || require('resolve');
    return Resolve.sync(spec.transpiler, {
      basedir: spec._config.path,
      extensions: Object.keys(require.extensions)
    });
  }
  getTranspiler(spec) {
    const transpilerPath = this.getTranspilerPath(spec);
    if (transpilerPath) {
      const transpiler = require(transpilerPath);
      this.transpilerPaths[transpilerPath] = true;
      return transpiler;
    }
  }
}
module.exports = PackageTranspilationRegistry;

================
File: src/package.js
================
const path = require('path');
const asyncEach = require('async/each');
const CSON = require('season');
const fs = require('fs-plus');
const { Emitter, CompositeDisposable } = require('event-kit');
const dedent = require('dedent');
const CompileCache = require('./compile-cache');
const ModuleCache = require('./module-cache');
const BufferedProcess = require('./buffered-process');
const { requireModule } = require('./module-utils');
module.exports = class Package {
  constructor(params) {
    this.config = params.config;
    this.packageManager = params.packageManager;
    this.styleManager = params.styleManager;
    this.commandRegistry = params.commandRegistry;
    this.keymapManager = params.keymapManager;
    this.notificationManager = params.notificationManager;
    this.grammarRegistry = params.grammarRegistry;
    this.themeManager = params.themeManager;
    this.menuManager = params.menuManager;
    this.contextMenuManager = params.contextMenuManager;
    this.deserializerManager = params.deserializerManager;
    this.viewRegistry = params.viewRegistry;
    this.emitter = new Emitter();
    this.mainModule = null;
    this.path = params.path;
    this.preloadedPackage = params.preloadedPackage;
    this.metadata =
      params.metadata || this.packageManager.loadPackageMetadata(this.path);
    this.bundledPackage =
      params.bundledPackage != null
        ? params.bundledPackage
        : this.packageManager.isBundledPackagePath(this.path);
    this.name =
      (this.metadata && this.metadata.name) ||
      params.name ||
      path.basename(this.path);
    this.reset();
  }
  onDidDeactivate(callback) {
    return this.emitter.on('did-deactivate', callback);
  }
  enable() {
    return this.config.removeAtKeyPath('core.disabledPackages', this.name);
  }
  disable() {
    return this.config.pushAtKeyPath('core.disabledPackages', this.name);
  }
  isTheme() {
    return this.metadata && this.metadata.theme;
  }
  measure(key, fn) {
    const startTime = window.performance.now();
    const value = fn();
    this[key] = Math.round(window.performance.now() - startTime);
    return value;
  }
  getType() {
    return 'atom';
  }
  getStyleSheetPriority() {
    return 0;
  }
  preload() {
    this.loadKeymaps();
    this.loadMenus();
    this.registerDeserializerMethods();
    this.activateCoreStartupServices();
    this.registerURIHandler();
    this.configSchemaRegisteredOnLoad = this.registerConfigSchemaFromMetadata();
    this.requireMainModule();
    this.settingsPromise = this.loadSettings();
    this.activationDisposables = new CompositeDisposable();
    this.activateKeymaps();
    this.activateMenus();
    for (let settings of this.settings) {
      settings.activate(this.config);
    }
    this.settingsActivated = true;
  }
  finishLoading() {
    this.measure('loadTime', () => {
      this.path = path.join(this.packageManager.resourcePath, this.path);
      ModuleCache.add(this.path, this.metadata);
      this.loadStylesheets();
      this.getMainModulePath();
    });
  }
  load() {
    this.measure('loadTime', () => {
      try {
        ModuleCache.add(this.path, this.metadata);
        this.loadKeymaps();
        this.loadMenus();
        this.loadStylesheets();
        this.registerDeserializerMethods();
        this.activateCoreStartupServices();
        this.registerURIHandler();
        this.registerTranspilerConfig();
        this.configSchemaRegisteredOnLoad = this.registerConfigSchemaFromMetadata();
        this.settingsPromise = this.loadSettings();
        if (this.shouldRequireMainModuleOnLoad() && this.mainModule == null) {
          this.requireMainModule();
        }
      } catch (error) {
        this.handleError(`Failed to load the ${this.name} package`, error);
      }
    });
    return this;
  }
  unload() {
    this.unregisterTranspilerConfig();
  }
  shouldRequireMainModuleOnLoad() {
    return !(
      this.metadata.deserializers ||
      this.metadata.viewProviders ||
      this.metadata.configSchema ||
      this.activationShouldBeDeferred() ||
      localStorage.getItem(this.getCanDeferMainModuleRequireStorageKey()) ===
        'true'
    );
  }
  reset() {
    this.stylesheets = [];
    this.keymaps = [];
    this.menus = [];
    this.grammars = [];
    this.settings = [];
    this.mainInitialized = false;
    this.mainActivated = false;
    this.deserialized = false;
  }
  initializeIfNeeded() {
    if (this.mainInitialized) return;
    this.measure('initializeTime', () => {
      try {
        if (!this.mainModule) this.requireMainModule();
        if (typeof this.mainModule.initialize === 'function') {
          this.mainModule.initialize(
            this.packageManager.getPackageState(this.name) || {}
          );
        }
        this.mainInitialized = true;
      } catch (error) {
        this.handleError(
          `Failed to initialize the ${this.name} package`,
          error
        );
      }
    });
  }
  activate() {
    if (!this.grammarsPromise) this.grammarsPromise = this.loadGrammars();
    if (!this.activationPromise) {
      this.activationPromise = new Promise((resolve, reject) => {
        this.resolveActivationPromise = resolve;
        this.measure('activateTime', () => {
          try {
            this.activateResources();
            if (this.activationShouldBeDeferred()) {
              return this.subscribeToDeferredActivation();
            } else {
              return this.activateNow();
            }
          } catch (error) {
            return this.handleError(
              `Failed to activate the ${this.name} package`,
              error
            );
          }
        });
      });
    }
    return Promise.all([
      this.grammarsPromise,
      this.settingsPromise,
      this.activationPromise
    ]);
  }
  activateNow() {
    try {
      if (!this.mainModule) this.requireMainModule();
      this.configSchemaRegisteredOnActivate = this.registerConfigSchemaFromMainModule();
      this.registerViewProviders();
      this.activateStylesheets();
      if (this.mainModule && !this.mainActivated) {
        this.initializeIfNeeded();
        if (typeof this.mainModule.activateConfig === 'function') {
          this.mainModule.activateConfig();
        }
        if (typeof this.mainModule.activate === 'function') {
          this.mainModule.activate(
            this.packageManager.getPackageState(this.name) || {}
          );
        }
        this.mainActivated = true;
        this.activateServices();
      }
      if (this.activationCommandSubscriptions)
        this.activationCommandSubscriptions.dispose();
      if (this.activationHookSubscriptions)
        this.activationHookSubscriptions.dispose();
      if (this.workspaceOpenerSubscriptions)
        this.workspaceOpenerSubscriptions.dispose();
    } catch (error) {
      this.handleError(`Failed to activate the ${this.name} package`, error);
    }
    if (typeof this.resolveActivationPromise === 'function')
      this.resolveActivationPromise();
  }
  registerConfigSchemaFromMetadata() {
    const configSchema = this.metadata.configSchema;
    if (configSchema) {
      this.config.setSchema(this.name, {
        type: 'object',
        properties: configSchema
      });
      return true;
    } else {
      return false;
    }
  }
  registerConfigSchemaFromMainModule() {
    if (this.mainModule && !this.configSchemaRegisteredOnLoad) {
      if (typeof this.mainModule.config === 'object') {
        this.config.setSchema(this.name, {
          type: 'object',
          properties: this.mainModule.config
        });
        return true;
      }
    }
    return false;
  }
  activateConfig() {
    if (this.configSchemaRegisteredOnLoad) return;
    this.requireMainModule();
    this.registerConfigSchemaFromMainModule();
  }
  activateStylesheets() {
    if (this.stylesheetsActivated) return;
    this.stylesheetDisposables = new CompositeDisposable();
    const priority = this.getStyleSheetPriority();
    for (let [sourcePath, source] of this.stylesheets) {
      const match = path.basename(sourcePath).match(/[^.]*\.([^.]*)\./);
      let context;
      if (match) {
        context = match[1];
      } else if (this.metadata.theme === 'syntax') {
        context = 'atom-text-editor';
      }
      this.stylesheetDisposables.add(
        this.styleManager.addStyleSheet(source, {
          sourcePath,
          priority,
          context,
          skipDeprecatedSelectorsTransformation:
            this.bundledPackage ? this.bundledPackage : !this.config.get("core.transformDeprecatedStyleSheetSelectors"),
          skipDeprecatedMathUsageTransformation:
            this.bundledPackage ? this.bundledPackage : !this.config.get("core.transformDeprecatedStyleSheetMathExpressions")
        })
      );
    }
    this.stylesheetsActivated = true;
  }
  activateResources() {
    if (!this.activationDisposables)
      this.activationDisposables = new CompositeDisposable();
    const packagesWithKeymapsDisabled = this.config.get(
      'core.packagesWithKeymapsDisabled'
    );
    if (
      packagesWithKeymapsDisabled &&
      packagesWithKeymapsDisabled.includes(this.name)
    ) {
      this.deactivateKeymaps();
    } else if (!this.keymapActivated) {
      this.activateKeymaps();
    }
    if (!this.menusActivated) {
      this.activateMenus();
    }
    if (!this.grammarsActivated) {
      for (let grammar of this.grammars) {
        grammar.activate();
      }
      this.grammarsActivated = true;
    }
    if (!this.settingsActivated) {
      for (let settings of this.settings) {
        settings.activate(this.config);
      }
      this.settingsActivated = true;
    }
  }
  activateKeymaps() {
    if (this.keymapActivated) return;
    this.keymapDisposables = new CompositeDisposable();
    const validateSelectors = !this.preloadedPackage;
    for (let [keymapPath, map] of this.keymaps) {
      this.keymapDisposables.add(
        this.keymapManager.add(keymapPath, map, 0, validateSelectors)
      );
    }
    this.menuManager.update();
    this.keymapActivated = true;
  }
  deactivateKeymaps() {
    if (!this.keymapActivated) return;
    if (this.keymapDisposables) {
      this.keymapDisposables.dispose();
    }
    this.menuManager.update();
    this.keymapActivated = false;
  }
  hasKeymaps() {
    for (let [, map] of this.keymaps) {
      if (map.length > 0) return true;
    }
    return false;
  }
  activateMenus() {
    const validateSelectors = !this.preloadedPackage;
    for (const [menuPath, map] of this.menus) {
      if (map['context-menu']) {
        try {
          const itemsBySelector = map['context-menu'];
          this.activationDisposables.add(
            this.contextMenuManager.add(itemsBySelector, validateSelectors)
          );
        } catch (error) {
          if (error.code === 'EBADSELECTOR') {
            error.message += ` in ${menuPath}`;
            error.stack += `\n  at ${menuPath}:1:1`;
          }
          throw error;
        }
      }
    }
    for (const [, map] of this.menus) {
      if (map.menu)
        this.activationDisposables.add(this.menuManager.add(map.menu));
    }
    this.menusActivated = true;
  }
  activateServices() {
    let methodName, version, versions;
    for (var name in this.metadata.providedServices) {
      ({ versions } = this.metadata.providedServices[name]);
      const servicesByVersion = {};
      for (version in versions) {
        methodName = versions[version];
        if (typeof this.mainModule[methodName] === 'function') {
          servicesByVersion[version] = this.mainModule[methodName]();
        } else {
          console.warn(`Package ${this.name} declares it provides ${name}@${version} but it doesn't expose a function in ${methodName}`)
        }
      }
      this.activationDisposables.add(
        this.packageManager.serviceHub.provide(name, servicesByVersion)
      );
    }
    for (name in this.metadata.consumedServices) {
      ({ versions } = this.metadata.consumedServices[name]);
      for (version in versions) {
        methodName = versions[version];
        if (typeof this.mainModule[methodName] === 'function') {
          this.activationDisposables.add(
            this.packageManager.serviceHub.consume(
              name,
              version,
              this.mainModule[methodName].bind(this.mainModule)
            )
          );
        } else {
          console.warn(`Package ${this.name} declares it consumes ${name}@${version} but it doesn't expose a function in ${methodName}`)
        }
      }
    }
  }
  registerURIHandler() {
    const handlerConfig = this.getURIHandler();
    const methodName = handlerConfig && handlerConfig.method;
    if (methodName) {
      this.uriHandlerSubscription = this.packageManager.registerURIHandlerForPackage(
        this.name,
        (...args) => this.handleURI(methodName, args)
      );
    }
  }
  unregisterURIHandler() {
    if (this.uriHandlerSubscription) this.uriHandlerSubscription.dispose();
  }
  handleURI(methodName, args) {
    this.activate().then(() => {
      if (this.mainModule[methodName])
        this.mainModule[methodName].apply(this.mainModule, args);
    });
    if (!this.mainActivated) this.activateNow();
  }
  registerTranspilerConfig() {
    if (this.metadata.atomTranspilers) {
      CompileCache.addTranspilerConfigForPath(
        this.path,
        this.name,
        this.metadata,
        this.metadata.atomTranspilers
      );
    }
  }
  unregisterTranspilerConfig() {
    if (this.metadata.atomTranspilers) {
      CompileCache.removeTranspilerConfigForPath(this.path);
    }
  }
  loadKeymaps() {
    if (this.bundledPackage && this.packageManager.packagesCache[this.name]) {
      this.keymaps = [];
      for (const keymapPath in this.packageManager.packagesCache[this.name]
        .keymaps) {
        const keymapObject = this.packageManager.packagesCache[this.name]
          .keymaps[keymapPath];
        this.keymaps.push([`core:${keymapPath}`, keymapObject]);
      }
    } else {
      this.keymaps = this.getKeymapPaths().map(keymapPath => [
        keymapPath,
        CSON.readFileSync(keymapPath, { allowDuplicateKeys: false }) || {}
      ]);
    }
  }
  loadMenus() {
    if (this.bundledPackage && this.packageManager.packagesCache[this.name]) {
      this.menus = [];
      for (const menuPath in this.packageManager.packagesCache[this.name]
        .menus) {
        const menuObject = this.packageManager.packagesCache[this.name].menus[
          menuPath
        ];
        this.menus.push([`core:${menuPath}`, menuObject]);
      }
    } else {
      this.menus = this.getMenuPaths().map(menuPath => [
        menuPath,
        CSON.readFileSync(menuPath) || {}
      ]);
    }
  }
  getKeymapPaths() {
    const keymapsDirPath = path.join(this.path, 'keymaps');
    if (this.metadata.keymaps) {
      return this.metadata.keymaps.map(name =>
        fs.resolve(keymapsDirPath, name, ['json', 'cson', ''])
      );
    } else {
      return fs.listSync(keymapsDirPath, ['cson', 'json']);
    }
  }
  getMenuPaths() {
    const menusDirPath = path.join(this.path, 'menus');
    if (this.metadata.menus) {
      return this.metadata.menus.map(name =>
        fs.resolve(menusDirPath, name, ['json', 'cson', ''])
      );
    } else {
      return fs.listSync(menusDirPath, ['cson', 'json']);
    }
  }
  loadStylesheets() {
    this.stylesheets = this.getStylesheetPaths().map(stylesheetPath => [
      stylesheetPath,
      this.themeManager.loadStylesheet(stylesheetPath, true)
    ]);
  }
  registerDeserializerMethods() {
    if (this.metadata.deserializers) {
      Object.keys(this.metadata.deserializers).forEach(deserializerName => {
        const methodName = this.metadata.deserializers[deserializerName];
        this.deserializerManager.add({
          name: deserializerName,
          deserialize: (state, atomEnvironment) => {
            this.registerViewProviders();
            this.requireMainModule();
            this.initializeIfNeeded();
            if (atomEnvironment.packages.hasActivatedInitialPackages()) {
              this.activateNow();
            }
            this.deserialized = true;
            return this.mainModule[methodName](state, atomEnvironment);
          }
        });
      });
    }
  }
  activateCoreStartupServices() {
    const directoryProviderService =
      this.metadata.providedServices &&
      this.metadata.providedServices['atom.directory-provider'];
    if (directoryProviderService) {
      this.requireMainModule();
      const servicesByVersion = {};
      for (let version in directoryProviderService.versions) {
        const methodName = directoryProviderService.versions[version];
        if (typeof this.mainModule[methodName] === 'function') {
          servicesByVersion[version] = this.mainModule[methodName]();
        }
      }
      this.packageManager.serviceHub.provide(
        'atom.directory-provider',
        servicesByVersion
      );
    }
  }
  registerViewProviders() {
    if (this.metadata.viewProviders && !this.registeredViewProviders) {
      this.requireMainModule();
      this.metadata.viewProviders.forEach(methodName => {
        this.viewRegistry.addViewProvider(model => {
          this.initializeIfNeeded();
          return this.mainModule[methodName](model);
        });
      });
      this.registeredViewProviders = true;
    }
  }
  getStylesheetsPath() {
    return path.join(this.path, 'styles');
  }
  getStylesheetPaths() {
    if (
      this.bundledPackage &&
      this.packageManager.packagesCache[this.name] &&
      this.packageManager.packagesCache[this.name].styleSheetPaths
    ) {
      const { styleSheetPaths } = this.packageManager.packagesCache[this.name];
      return styleSheetPaths.map(styleSheetPath =>
        path.join(this.path, styleSheetPath)
      );
    } else {
      let indexStylesheet;
      const stylesheetDirPath = this.getStylesheetsPath();
      if (this.metadata.mainStyleSheet) {
        return [fs.resolve(this.path, this.metadata.mainStyleSheet)];
      } else if (this.metadata.styleSheets) {
        return this.metadata.styleSheets.map(name =>
          fs.resolve(stylesheetDirPath, name, ['css', 'less', ''])
        );
      } else if (
        (indexStylesheet = fs.resolve(this.path, 'index', ['css', 'less']))
      ) {
        return [indexStylesheet];
      } else {
        return fs.listSync(stylesheetDirPath, ['css', 'less']);
      }
    }
  }
  loadGrammarsSync() {
    if (this.grammarsLoaded) return;
    let grammarPaths;
    if (this.preloadedPackage && this.packageManager.packagesCache[this.name]) {
      ({ grammarPaths } = this.packageManager.packagesCache[this.name]);
    } else {
      grammarPaths = fs.listSync(path.join(this.path, 'grammars'), [
        'json',
        'cson'
      ]);
    }
    for (let grammarPath of grammarPaths) {
      if (
        this.preloadedPackage &&
        this.packageManager.packagesCache[this.name]
      ) {
        grammarPath = path.resolve(
          this.packageManager.resourcePath,
          grammarPath
        );
      }
      try {
        const grammar = this.grammarRegistry.readGrammarSync(grammarPath);
        grammar.packageName = this.name;
        grammar.bundledPackage = this.bundledPackage;
        this.grammars.push(grammar);
        grammar.activate();
      } catch (error) {
        console.warn(
          `Failed to load grammar: ${grammarPath}`,
          error.stack || error
        );
      }
    }
    this.grammarsLoaded = true;
    this.grammarsActivated = true;
  }
  loadGrammars() {
    if (this.grammarsLoaded) return Promise.resolve();
    const loadGrammar = (grammarPath, callback) => {
      if (this.preloadedPackage) {
        grammarPath = path.resolve(
          this.packageManager.resourcePath,
          grammarPath
        );
      }
      return this.grammarRegistry.readGrammar(grammarPath, (error, grammar) => {
        if (error) {
          const detail = `${error.message} in ${grammarPath}`;
          const stack = `${error.stack}\n  at ${grammarPath}:1:1`;
          this.notificationManager.addFatalError(
            `Failed to load a ${this.name} package grammar`,
            { stack, detail, packageName: this.name, dismissable: true }
          );
        } else {
          grammar.packageName = this.name;
          grammar.bundledPackage = this.bundledPackage;
          this.grammars.push(grammar);
          if (this.grammarsActivated) grammar.activate();
        }
        return callback();
      });
    };
    return new Promise(resolve => {
      if (
        this.preloadedPackage &&
        this.packageManager.packagesCache[this.name]
      ) {
        const { grammarPaths } = this.packageManager.packagesCache[this.name];
        return asyncEach(grammarPaths, loadGrammar, () => resolve());
      } else {
        const grammarsDirPath = path.join(this.path, 'grammars');
        fs.exists(grammarsDirPath, grammarsDirExists => {
          if (!grammarsDirExists) return resolve();
          fs.list(grammarsDirPath, ['json', 'cson'], (error, grammarPaths) => {
            if (error || !grammarPaths) return resolve();
            asyncEach(grammarPaths, loadGrammar, () => resolve());
          });
        });
      }
    });
  }
  loadSettings() {
    this.settings = [];
    const loadSettingsFile = (settingsPath, callback) => {
      return SettingsFile.load(settingsPath, (error, settingsFile) => {
        if (error) {
          const detail = `${error.message} in ${settingsPath}`;
          const stack = `${error.stack}\n  at ${settingsPath}:1:1`;
          this.notificationManager.addFatalError(
            `Failed to load the ${this.name} package settings`,
            { stack, detail, packageName: this.name, dismissable: true }
          );
        } else {
          this.settings.push(settingsFile);
          if (this.settingsActivated) settingsFile.activate(this.config);
        }
        return callback();
      });
    };
    if (this.preloadedPackage && this.packageManager.packagesCache[this.name]) {
      for (let settingsPath in this.packageManager.packagesCache[this.name]
        .settings) {
        const properties = this.packageManager.packagesCache[this.name]
          .settings[settingsPath];
        const settingsFile = new SettingsFile(
          `core:${settingsPath}`,
          properties || {}
        );
        this.settings.push(settingsFile);
        if (this.settingsActivated) settingsFile.activate(this.config);
      }
    } else {
      return new Promise(resolve => {
        const settingsDirPath = path.join(this.path, 'settings');
        fs.exists(settingsDirPath, settingsDirExists => {
          if (!settingsDirExists) return resolve();
          fs.list(settingsDirPath, ['json', 'cson'], (error, settingsPaths) => {
            if (error || !settingsPaths) return resolve();
            asyncEach(settingsPaths, loadSettingsFile, () => resolve());
          });
        });
      });
    }
  }
  serialize() {
    if (this.mainActivated) {
      if (typeof this.mainModule.serialize === 'function') {
        try {
          return this.mainModule.serialize();
        } catch (error) {
          console.error(
            `Error serializing package '${this.name}'`,
            error.stack
          );
        }
      }
    }
  }
  async deactivate() {
    this.activationPromise = null;
    this.resolveActivationPromise = null;
    if (this.activationCommandSubscriptions)
      this.activationCommandSubscriptions.dispose();
    if (this.activationHookSubscriptions)
      this.activationHookSubscriptions.dispose();
    this.configSchemaRegisteredOnActivate = false;
    this.unregisterURIHandler();
    this.deactivateResources();
    this.deactivateKeymaps();
    if (!this.mainActivated) {
      this.emitter.emit('did-deactivate');
      return;
    }
    if (typeof this.mainModule.deactivate === 'function') {
      try {
        const deactivationResult = this.mainModule.deactivate();
        if (
          deactivationResult &&
          typeof deactivationResult.then === 'function'
        ) {
          await deactivationResult;
        }
      } catch (error) {
        console.error(`Error deactivating package '${this.name}'`, error.stack);
      }
    }
    if (typeof this.mainModule.deactivateConfig === 'function') {
      try {
        await this.mainModule.deactivateConfig();
      } catch (error) {
        console.error(`Error deactivating package '${this.name}'`, error.stack);
      }
    }
    this.mainActivated = false;
    this.mainInitialized = false;
    this.emitter.emit('did-deactivate');
  }
  deactivateResources() {
    for (let grammar of this.grammars) {
      grammar.deactivate();
    }
    for (let settings of this.settings) {
      settings.deactivate(this.config);
    }
    if (this.stylesheetDisposables) this.stylesheetDisposables.dispose();
    if (this.activationDisposables) this.activationDisposables.dispose();
    if (this.keymapDisposables) this.keymapDisposables.dispose();
    this.stylesheetsActivated = false;
    this.grammarsActivated = false;
    this.settingsActivated = false;
    this.menusActivated = false;
  }
  reloadStylesheets() {
    try {
      this.loadStylesheets();
    } catch (error) {
      this.handleError(
        `Failed to reload the ${this.name} package stylesheets`,
        error
      );
    }
    if (this.stylesheetDisposables) this.stylesheetDisposables.dispose();
    this.stylesheetDisposables = new CompositeDisposable();
    this.stylesheetsActivated = false;
    this.activateStylesheets();
  }
  requireMainModule() {
    if (this.bundledPackage && this.packageManager.packagesCache[this.name]) {
      if (this.packageManager.packagesCache[this.name].main) {
        this.mainModule = requireModule(
          this.packageManager.packagesCache[this.name].main
        );
        return this.mainModule;
      }
    } else if (this.mainModuleRequired) {
      return this.mainModule;
    } else if (!this.isCompatible()) {
      const nativeModuleNames = this.incompatibleModules
        .map(m => m.name)
        .join(', ');
      console.warn(dedent`
        Failed to require the main module of '${
          this.name
        }' because it requires one or more incompatible native modules (${nativeModuleNames}).
        Run \`pulsar -p rebuild\` in the package directory and restart Pulsar to resolve.\
      `);
    } else {
      const mainModulePath = this.getMainModulePath();
      if (fs.isFileSync(mainModulePath)) {
        this.mainModuleRequired = true;
        const previousViewProviderCount = this.viewRegistry.getViewProviderCount();
        const previousDeserializerCount = this.deserializerManager.getDeserializerCount();
        this.mainModule = requireModule(mainModulePath);
        if (
          this.viewRegistry.getViewProviderCount() ===
            previousViewProviderCount &&
          this.deserializerManager.getDeserializerCount() ===
            previousDeserializerCount
        ) {
          localStorage.setItem(
            this.getCanDeferMainModuleRequireStorageKey(),
            'true'
          );
        } else {
          localStorage.removeItem(
            this.getCanDeferMainModuleRequireStorageKey()
          );
        }
        return this.mainModule;
      }
    }
  }
  getMainModulePath() {
    if (this.resolvedMainModulePath) return this.mainModulePath;
    this.resolvedMainModulePath = true;
    if (this.bundledPackage && this.packageManager.packagesCache[this.name]) {
      if (this.packageManager.packagesCache[this.name].main) {
        this.mainModulePath = path.resolve(
          this.packageManager.resourcePath,
          'static',
          this.packageManager.packagesCache[this.name].main
        );
      } else {
        this.mainModulePath = null;
      }
    } else {
      const mainModulePath = this.metadata.main
        ? path.join(this.path, this.metadata.main)
        : path.join(this.path, 'index');
      this.mainModulePath = fs.resolveExtension(mainModulePath, [
        '',
        ...CompileCache.supportedExtensions
      ]);
    }
    return this.mainModulePath;
  }
  activationShouldBeDeferred() {
    return (
      !this.deserialized &&
      (this.hasActivationCommands() ||
        this.hasActivationHooks() ||
        this.hasWorkspaceOpeners() ||
        this.hasDeferredURIHandler())
    );
  }
  hasActivationHooks() {
    const hooks = this.getActivationHooks();
    return hooks && hooks.length > 0;
  }
  hasWorkspaceOpeners() {
    const openers = this.getWorkspaceOpeners();
    return openers && openers.length > 0;
  }
  hasActivationCommands() {
    const object = this.getActivationCommands();
    for (let selector in object) {
      const commands = object[selector];
      if (commands.length > 0) return true;
    }
    return false;
  }
  hasDeferredURIHandler() {
    const handler = this.getURIHandler();
    return handler && handler.deferActivation !== false;
  }
  subscribeToDeferredActivation() {
    this.subscribeToActivationCommands();
    this.subscribeToActivationHooks();
    this.subscribeToWorkspaceOpeners();
  }
  subscribeToActivationCommands() {
    this.activationCommandSubscriptions = new CompositeDisposable();
    const object = this.getActivationCommands();
    for (let selector in object) {
      const commands = object[selector];
      for (let command of commands) {
        ((selector, command) => {
          // Add dummy command so it appears in menu.
          // The real command will be registered on package activation
          try {
            this.activationCommandSubscriptions.add(
              this.commandRegistry.add(selector, command, function() {})
            );
          } catch (error) {
            if (error.code === 'EBADSELECTOR') {
              const metadataPath = path.join(this.path, 'package.json');
              error.message += ` in ${metadataPath}`;
              error.stack += `\n  at ${metadataPath}:1:1`;
            }
            throw error;
          }
          this.activationCommandSubscriptions.add(
            this.commandRegistry.onWillDispatch(event => {
              if (event.type !== command) return;
              let currentTarget = event.target;
              while (currentTarget) {
                if (currentTarget.webkitMatchesSelector(selector)) {
                  this.activationCommandSubscriptions.dispose();
                  this.activateNow();
                  break;
                }
                currentTarget = currentTarget.parentElement;
              }
            })
          );
        })(selector, command);
      }
    }
  }
  getActivationCommands() {
    if (this.activationCommands) return this.activationCommands;
    this.activationCommands = {};
    if (this.metadata.activationCommands) {
      for (let selector in this.metadata.activationCommands) {
        const commands = this.metadata.activationCommands[selector];
        if (!this.activationCommands[selector])
          this.activationCommands[selector] = [];
        if (typeof commands === 'string') {
          this.activationCommands[selector].push(commands);
        } else if (Array.isArray(commands)) {
          this.activationCommands[selector].push(...commands);
        }
      }
    }
    return this.activationCommands;
  }
  subscribeToActivationHooks() {
    this.activationHookSubscriptions = new CompositeDisposable();
    for (let hook of this.getActivationHooks()) {
      if (typeof hook === 'string' && hook.trim().length > 0) {
        this.activationHookSubscriptions.add(
          this.packageManager.onDidTriggerActivationHook(hook, () =>
            this.activateNow()
          )
        );
      }
    }
  }
  getActivationHooks() {
    if (this.metadata && this.activationHooks) return this.activationHooks;
    if (this.metadata.activationHooks) {
      if (Array.isArray(this.metadata.activationHooks)) {
        this.activationHooks = Array.from(
          new Set(this.metadata.activationHooks)
        );
      } else if (typeof this.metadata.activationHooks === 'string') {
        this.activationHooks = [this.metadata.activationHooks];
      } else {
        this.activationHooks = [];
      }
    } else {
      this.activationHooks = [];
    }
    return this.activationHooks;
  }
  subscribeToWorkspaceOpeners() {
    this.workspaceOpenerSubscriptions = new CompositeDisposable();
    for (let opener of this.getWorkspaceOpeners()) {
      this.workspaceOpenerSubscriptions.add(
        atom.workspace.addOpener(filePath => {
          if (filePath === opener) {
            this.activateNow();
            this.workspaceOpenerSubscriptions.dispose();
            return atom.workspace.createItemForURI(opener);
          }
        })
      );
    }
  }
  getWorkspaceOpeners() {
    if (this.workspaceOpeners) return this.workspaceOpeners;
    if (this.metadata.workspaceOpeners) {
      if (Array.isArray(this.metadata.workspaceOpeners)) {
        this.workspaceOpeners = Array.from(
          new Set(this.metadata.workspaceOpeners)
        );
      } else if (typeof this.metadata.workspaceOpeners === 'string') {
        this.workspaceOpeners = [this.metadata.workspaceOpeners];
      } else {
        this.workspaceOpeners = [];
      }
    } else {
      this.workspaceOpeners = [];
    }
    return this.workspaceOpeners;
  }
  getURIHandler() {
    return this.metadata && this.metadata.uriHandler;
  }
  isNativeModule(modulePath) {
    try {
      return this.getModulePathNodeFiles(modulePath).length > 0;
    } catch (error) {
      return false;
    }
  }
  getModulePathNodeFiles(modulePath) {
    try {
      const modulePathNodeFiles = fs.listSync(
        path.join(modulePath, 'build', 'Release'),
        ['.node']
      );
      return modulePathNodeFiles;
    } catch (error) {
      return [];
    }
  }
  getNativeModuleDependencyPathsMap() {
    const nativeModulePaths = new Map();
    if (this.metadata._atomModuleCache) {
      const nodeFilePaths = [];
      const relativeNativeModuleBindingPaths =
        (this.metadata._atomModuleCache.extensions &&
          this.metadata._atomModuleCache.extensions['.node']) ||
        [];
      for (let relativeNativeModuleBindingPath of relativeNativeModuleBindingPaths) {
        const nodeFilePath = path.join(
          this.path,
          relativeNativeModuleBindingPath,
          '..',
          '..',
          '..'
        );
        nodeFilePaths.push(nodeFilePath);
      }
      nativeModulePaths.set(this.path, nodeFilePaths);
      return nativeModulePaths;
    }
    const traversePath = nodeModulesPath => {
      try {
        for (let modulePath of fs.listSync(nodeModulesPath)) {
          const modulePathNodeFiles = this.getModulePathNodeFiles(modulePath);
          if (modulePathNodeFiles) {
            nativeModulePaths.set(modulePath, modulePathNodeFiles);
          }
          traversePath(path.join(modulePath, 'node_modules'));
        }
      } catch (error) {}
    };
    traversePath(path.join(this.path, 'node_modules'));
    return nativeModulePaths;
  }
  getNativeModuleDependencyPaths() {
    return [...this.getNativeModuleDependencyPathsMap().keys()];
  }
  isCompatible() {
    if (this.compatible == null) {
      if (this.preloadedPackage) {
        this.compatible = true;
      } else if (this.getMainModulePath()) {
        this.incompatibleModules = this.getIncompatibleNativeModules();
        this.compatible = this.incompatibleModules.length === 0;
      } else {
        this.compatible = true;
      }
    }
    return this.compatible;
  }
  rebuild() {
    return new Promise(resolve =>
      this.runRebuildProcess(result => {
        if (result.code === 0) {
          global.localStorage.removeItem(
            this.getBuildFailureOutputStorageKey()
          );
        } else {
          this.compatible = false;
          global.localStorage.setItem(
            this.getBuildFailureOutputStorageKey(),
            result.stderr
          );
        }
        resolve(result);
      })
    );
  }
  getBuildFailureOutput() {
    return global.localStorage.getItem(this.getBuildFailureOutputStorageKey());
  }
  runRebuildProcess(done) {
    let stderr = '';
    let stdout = '';
    return new BufferedProcess({
      command: this.packageManager.getApmPath(),
      args: ['rebuild', '--no-color'],
      options: { cwd: this.path },
      stderr(output) {
        stderr += output;
      },
      stdout(output) {
        stdout += output;
      },
      exit(code) {
        done({ code, stdout, stderr });
      }
    });
  }
  getBuildFailureOutputStorageKey() {
    return `installed-packages:${this.name}:${
      this.metadata.version
    }:build-error`;
  }
  getCanDeferMainModuleRequireStorageKey() {
    return `installed-packages:${this.name}:${
      this.metadata.version
    }:can-defer-main-module-require`;
  }
  getIncompatibleNativeModules() {
    const incompatibleNativeModules = [];
    const nativeModulePaths = this.getNativeModuleDependencyPathsMap();
    for (const [nativeModulePath, nodeFilesPaths] of nativeModulePaths) {
      try {
        for (const nodeFilePath of nodeFilesPaths) {
          require(nodeFilePath);
        }
      } catch (error) {
        let version;
        try {
          ({ version } = require(`${nativeModulePath}/package.json`));
        } catch (error2) {}
        incompatibleNativeModules.push({
          path: nativeModulePath,
          name: path.basename(nativeModulePath),
          version,
          error: error.message
        });
      }
    }
    return incompatibleNativeModules;
  }
  handleError(message, error) {
    if (atom.inSpecMode()) throw error;
    let detail, location, stack;
    if (error.filename && error.location && error instanceof SyntaxError) {
      location = `${error.filename}:${error.location.first_line + 1}:${error
        .location.first_column + 1}`;
      detail = `${error.message} in ${location}`;
      stack = 'SyntaxError: ' + error.message + '\n' + 'at ' + location;
    } else if (
      error.less &&
      error.filename &&
      error.column != null &&
      error.line != null
    ) {
      location = `${error.filename}:${error.line}:${error.column}`;
      detail = `${error.message} in ${location}`;
      stack = 'LessError: ' + error.message + '\n' + 'at ' + location;
    } else {
      detail = error.message;
      stack = error.stack || error;
    }
    this.notificationManager.addFatalError(message, {
      stack,
      detail,
      packageName: this.name,
      dismissable: true
    });
  }
};
class SettingsFile {
  static load(path, callback) {
    CSON.readFile(path, (error, properties = {}) => {
      if (error) {
        callback(error);
      } else {
        callback(null, new SettingsFile(path, properties));
      }
    });
  }
  constructor(path, properties) {
    this.path = path;
    this.properties = properties;
  }
  activate(config) {
    for (let selector in this.properties) {
      config.set(null, this.properties[selector], {
        scopeSelector: selector,
        source: this.path
      });
    }
  }
  deactivate(config) {
    for (let selector in this.properties) {
      config.unset(null, { scopeSelector: selector, source: this.path });
    }
  }
}

================
File: src/pane-axis-element.js
================
const { CompositeDisposable } = require('event-kit');
require('./pane-resize-handle-element');
class PaneAxisElement extends HTMLElement {
  connectedCallback() {
    if (this.subscriptions == null) {
      this.subscriptions = this.subscribeToModel();
    }
    this.model
      .getChildren()
      .map((child, index) => this.childAdded({ child, index }));
  }
  disconnectedCallback() {
    this.subscriptions.dispose();
    this.subscriptions = null;
    this.model.getChildren().map(child => this.childRemoved({ child }));
  }
  initialize(model, viewRegistry) {
    this.model = model;
    this.viewRegistry = viewRegistry;
    if (this.subscriptions == null) {
      this.subscriptions = this.subscribeToModel();
    }
    const iterable = this.model.getChildren();
    for (let index = 0; index < iterable.length; index++) {
      const child = iterable[index];
      this.childAdded({ child, index });
    }
    switch (this.model.getOrientation()) {
      case 'horizontal':
        this.classList.add('horizontal', 'pane-row');
        break;
      case 'vertical':
        this.classList.add('vertical', 'pane-column');
        break;
    }
    return this;
  }
  subscribeToModel() {
    const subscriptions = new CompositeDisposable();
    subscriptions.add(this.model.onDidAddChild(this.childAdded.bind(this)));
    subscriptions.add(
      this.model.onDidRemoveChild(this.childRemoved.bind(this))
    );
    subscriptions.add(
      this.model.onDidReplaceChild(this.childReplaced.bind(this))
    );
    subscriptions.add(
      this.model.observeFlexScale(this.flexScaleChanged.bind(this))
    );
    return subscriptions;
  }
  isPaneResizeHandleElement(element) {
    return (
      (element != null ? element.nodeName.toLowerCase() : undefined) ===
      'atom-pane-resize-handle'
    );
  }
  childAdded({ child, index }) {
    let resizeHandle;
    const view = this.viewRegistry.getView(child);
    this.insertBefore(view, this.children[index * 2]);
    const prevElement = view.previousSibling;
    if (prevElement != null && !this.isPaneResizeHandleElement(prevElement)) {
      resizeHandle = document.createElement('atom-pane-resize-handle');
      this.insertBefore(resizeHandle, view);
    }
    const nextElement = view.nextSibling;
    if (nextElement != null && !this.isPaneResizeHandleElement(nextElement)) {
      resizeHandle = document.createElement('atom-pane-resize-handle');
      return this.insertBefore(resizeHandle, nextElement);
    }
  }
  childRemoved({ child }) {
    const view = this.viewRegistry.getView(child);
    const siblingView = view.previousSibling;
    if (siblingView != null && this.isPaneResizeHandleElement(siblingView)) {
      siblingView.remove();
    }
    return view.remove();
  }
  childReplaced({ index, oldChild, newChild }) {
    let focusedElement;
    if (this.hasFocus()) {
      focusedElement = document.activeElement;
    }
    this.childRemoved({ child: oldChild, index });
    this.childAdded({ child: newChild, index });
    if (document.activeElement === document.body) {
      return focusedElement != null ? focusedElement.focus() : undefined;
    }
  }
  flexScaleChanged(flexScale) {
    this.style.flexGrow = flexScale;
  }
  hasFocus() {
    return (
      this === document.activeElement || this.contains(document.activeElement)
    );
  }
}
window.customElements.define('atom-pane-axis', PaneAxisElement);
function createPaneAxisElement() {
  return document.createElement('atom-pane-axis');
}
module.exports = {
  createPaneAxisElement
};

================
File: src/pane-axis.js
================
const { Emitter, CompositeDisposable } = require('event-kit');
const { flatten } = require('underscore-plus');
const Model = require('./model');
const { createPaneAxisElement } = require('./pane-axis-element');
class PaneAxis extends Model {
  static deserialize(state, { deserializers, views }) {
    state.children = state.children.map(childState =>
      deserializers.deserialize(childState)
    );
    return new PaneAxis(state, views);
  }
  constructor({ orientation, children, flexScale }, viewRegistry) {
    super();
    this.parent = null;
    this.container = null;
    this.orientation = orientation;
    this.viewRegistry = viewRegistry;
    this.emitter = new Emitter();
    this.subscriptionsByChild = new WeakMap();
    this.subscriptions = new CompositeDisposable();
    this.flexScale = flexScale != null ? flexScale : 1;
    this.children = [];
    if (children) {
      for (let child of children) {
        this.addChild(child);
      }
    }
  }
  serialize() {
    return {
      deserializer: 'PaneAxis',
      children: this.children.map(child => child.serialize()),
      orientation: this.orientation,
      flexScale: this.flexScale
    };
  }
  getElement() {
    if (!this.element) {
      this.element = createPaneAxisElement().initialize(
        this,
        this.viewRegistry
      );
    }
    return this.element;
  }
  getFlexScale() {
    return this.flexScale;
  }
  setFlexScale(flexScale) {
    this.flexScale = flexScale;
    this.emitter.emit('did-change-flex-scale', this.flexScale);
    return this.flexScale;
  }
  getParent() {
    return this.parent;
  }
  setParent(parent) {
    this.parent = parent;
    return this.parent;
  }
  getContainer() {
    return this.container;
  }
  setContainer(container) {
    if (container && container !== this.container) {
      this.container = container;
      this.children.forEach(child => child.setContainer(container));
    }
  }
  getOrientation() {
    return this.orientation;
  }
  getChildren() {
    return this.children.slice();
  }
  getPanes() {
    return flatten(this.children.map(child => child.getPanes()));
  }
  getItems() {
    return flatten(this.children.map(child => child.getItems()));
  }
  onDidAddChild(fn) {
    return this.emitter.on('did-add-child', fn);
  }
  onDidRemoveChild(fn) {
    return this.emitter.on('did-remove-child', fn);
  }
  onDidReplaceChild(fn) {
    return this.emitter.on('did-replace-child', fn);
  }
  onDidDestroy(fn) {
    return this.emitter.once('did-destroy', fn);
  }
  onDidChangeFlexScale(fn) {
    return this.emitter.on('did-change-flex-scale', fn);
  }
  observeFlexScale(fn) {
    fn(this.flexScale);
    return this.onDidChangeFlexScale(fn);
  }
  addChild(child, index = this.children.length) {
    this.children.splice(index, 0, child);
    child.setParent(this);
    child.setContainer(this.container);
    this.subscribeToChild(child);
    return this.emitter.emit('did-add-child', { child, index });
  }
  adjustFlexScale() {
    let total = 0;
    for (var child of this.children) {
      total += child.getFlexScale();
    }
    const needTotal = this.children.length;
    for (child of this.children) {
      child.setFlexScale((needTotal * child.getFlexScale()) / total);
    }
  }
  removeChild(child, replacing = false) {
    const index = this.children.indexOf(child);
    if (index === -1) {
      throw new Error('Removing non-existent child');
    }
    this.unsubscribeFromChild(child);
    this.children.splice(index, 1);
    this.adjustFlexScale();
    this.emitter.emit('did-remove-child', { child, index });
    if (!replacing && this.children.length < 2) {
      this.reparentLastChild();
    }
  }
  replaceChild(oldChild, newChild) {
    this.unsubscribeFromChild(oldChild);
    this.subscribeToChild(newChild);
    newChild.setParent(this);
    newChild.setContainer(this.container);
    const index = this.children.indexOf(oldChild);
    this.children.splice(index, 1, newChild);
    this.emitter.emit('did-replace-child', { oldChild, newChild, index });
  }
  insertChildBefore(currentChild, newChild) {
    const index = this.children.indexOf(currentChild);
    return this.addChild(newChild, index);
  }
  insertChildAfter(currentChild, newChild) {
    const index = this.children.indexOf(currentChild);
    return this.addChild(newChild, index + 1);
  }
  reparentLastChild() {
    const lastChild = this.children[0];
    lastChild.setFlexScale(this.flexScale);
    this.parent.replaceChild(this, lastChild);
    this.destroy();
  }
  subscribeToChild(child) {
    const subscription = child.onDidDestroy(() => this.removeChild(child));
    this.subscriptionsByChild.set(child, subscription);
    this.subscriptions.add(subscription);
  }
  unsubscribeFromChild(child) {
    const subscription = this.subscriptionsByChild.get(child);
    this.subscriptions.remove(subscription);
    subscription.dispose();
  }
  destroyed() {
    this.subscriptions.dispose();
    this.emitter.emit('did-destroy');
    this.emitter.dispose();
  }
}
module.exports = PaneAxis;

================
File: src/pane-container-element.js
================
const { CompositeDisposable } = require('event-kit');
class PaneContainerElement extends HTMLElement {
  constructor() {
    super();
    this.subscriptions = new CompositeDisposable();
  }
  initialize(model, { views }) {
    this.model = model;
    this.views = views;
    if (this.views == null) {
      throw new Error(
        'Must pass a views parameter when initializing PaneContainerElements'
      );
    }
    this.subscriptions.add(this.model.observeRoot(this.rootChanged.bind(this)));
    return this;
  }
  connectedCallback() {
    this.classList.add('panes');
  }
  rootChanged(root) {
    const focusedElement = this.hasFocus() ? document.activeElement : null;
    if (this.firstChild != null) {
      this.firstChild.remove();
    }
    if (root != null) {
      const view = this.views.getView(root);
      this.appendChild(view);
      if (focusedElement != null) {
        focusedElement.focus();
      }
    }
  }
  hasFocus() {
    return (
      this === document.activeElement || this.contains(document.activeElement)
    );
  }
}
window.customElements.define('atom-pane-container', PaneContainerElement);
function createPaneContainerElement() {
  return document.createElement('atom-pane-container');
}
module.exports = {
  createPaneContainerElement
};

================
File: src/pane-container.js
================
const { find } = require('underscore-plus');
const { Emitter, CompositeDisposable } = require('event-kit');
const Pane = require('./pane');
const ItemRegistry = require('./item-registry');
const { createPaneContainerElement } = require('./pane-container-element');
const SERIALIZATION_VERSION = 1;
const STOPPED_CHANGING_ACTIVE_PANE_ITEM_DELAY = 100;
module.exports = class PaneContainer {
  constructor(params) {
    let applicationDelegate, deserializerManager, notificationManager;
    ({
      config: this.config,
      applicationDelegate,
      notificationManager,
      deserializerManager,
      viewRegistry: this.viewRegistry,
      location: this.location
    } = params);
    this.emitter = new Emitter();
    this.subscriptions = new CompositeDisposable();
    this.itemRegistry = new ItemRegistry();
    this.alive = true;
    this.stoppedChangingActivePaneItemTimeout = null;
    this.setRoot(
      new Pane({
        container: this,
        config: this.config,
        applicationDelegate,
        notificationManager,
        deserializerManager,
        viewRegistry: this.viewRegistry
      })
    );
    this.didActivatePane(this.getRoot());
  }
  getLocation() {
    return this.location;
  }
  getElement() {
    return this.element != null
      ? this.element
      : (this.element = createPaneContainerElement().initialize(this, {
          views: this.viewRegistry
        }));
  }
  destroy() {
    this.alive = false;
    for (let pane of this.getRoot().getPanes()) {
      pane.destroy();
    }
    this.cancelStoppedChangingActivePaneItemTimeout();
    this.subscriptions.dispose();
    this.emitter.dispose();
  }
  isAlive() {
    return this.alive;
  }
  isDestroyed() {
    return !this.isAlive();
  }
  serialize(params) {
    return {
      deserializer: 'PaneContainer',
      version: SERIALIZATION_VERSION,
      root: this.root ? this.root.serialize() : null,
      activePaneId: this.activePane.id
    };
  }
  deserialize(state, deserializerManager) {
    if (state.version !== SERIALIZATION_VERSION) return;
    this.itemRegistry = new ItemRegistry();
    this.setRoot(deserializerManager.deserialize(state.root));
    this.activePane =
      find(this.getRoot().getPanes(), pane => pane.id === state.activePaneId) ||
      this.getPanes()[0];
    if (this.config.get('core.destroyEmptyPanes')) this.destroyEmptyPanes();
  }
  onDidChangeRoot(fn) {
    return this.emitter.on('did-change-root', fn);
  }
  observeRoot(fn) {
    fn(this.getRoot());
    return this.onDidChangeRoot(fn);
  }
  onDidAddPane(fn) {
    return this.emitter.on('did-add-pane', fn);
  }
  observePanes(fn) {
    for (let pane of this.getPanes()) {
      fn(pane);
    }
    return this.onDidAddPane(({ pane }) => fn(pane));
  }
  onDidDestroyPane(fn) {
    return this.emitter.on('did-destroy-pane', fn);
  }
  onWillDestroyPane(fn) {
    return this.emitter.on('will-destroy-pane', fn);
  }
  onDidChangeActivePane(fn) {
    return this.emitter.on('did-change-active-pane', fn);
  }
  onDidActivatePane(fn) {
    return this.emitter.on('did-activate-pane', fn);
  }
  observeActivePane(fn) {
    fn(this.getActivePane());
    return this.onDidChangeActivePane(fn);
  }
  onDidAddPaneItem(fn) {
    return this.emitter.on('did-add-pane-item', fn);
  }
  observePaneItems(fn) {
    for (let item of this.getPaneItems()) {
      fn(item);
    }
    return this.onDidAddPaneItem(({ item }) => fn(item));
  }
  onDidChangeActivePaneItem(fn) {
    return this.emitter.on('did-change-active-pane-item', fn);
  }
  onDidStopChangingActivePaneItem(fn) {
    return this.emitter.on('did-stop-changing-active-pane-item', fn);
  }
  observeActivePaneItem(fn) {
    fn(this.getActivePaneItem());
    return this.onDidChangeActivePaneItem(fn);
  }
  onWillDestroyPaneItem(fn) {
    return this.emitter.on('will-destroy-pane-item', fn);
  }
  onDidDestroyPaneItem(fn) {
    return this.emitter.on('did-destroy-pane-item', fn);
  }
  getRoot() {
    return this.root;
  }
  setRoot(root) {
    this.root = root;
    this.root.setParent(this);
    this.root.setContainer(this);
    this.emitter.emit('did-change-root', this.root);
    if (this.getActivePane() == null && this.root instanceof Pane) {
      this.didActivatePane(this.root);
    }
  }
  replaceChild(oldChild, newChild) {
    if (oldChild !== this.root) {
      throw new Error('Replacing non-existent child');
    }
    this.setRoot(newChild);
  }
  getPanes() {
    if (this.alive) {
      return this.getRoot().getPanes();
    } else {
      return [];
    }
  }
  getPaneItems() {
    return this.getRoot().getItems();
  }
  getActivePane() {
    return this.activePane;
  }
  getActivePaneItem() {
    return this.getActivePane().getActiveItem();
  }
  paneForURI(uri) {
    return find(this.getPanes(), pane => pane.itemForURI(uri) != null);
  }
  paneForItem(item) {
    return find(this.getPanes(), pane => pane.getItems().includes(item));
  }
  saveAll() {
    for (let pane of this.getPanes()) {
      pane.saveItems();
    }
  }
  confirmClose(options) {
    const promises = [];
    for (const pane of this.getPanes()) {
      for (const item of pane.getItems()) {
        promises.push(pane.promptToSaveItem(item, options));
      }
    }
    return Promise.all(promises).then(results => !results.includes(false));
  }
  activateNextPane() {
    const panes = this.getPanes();
    if (panes.length > 1) {
      const currentIndex = panes.indexOf(this.activePane);
      const nextIndex = (currentIndex + 1) % panes.length;
      panes[nextIndex].activate();
      return true;
    } else {
      return false;
    }
  }
  activatePreviousPane() {
    const panes = this.getPanes();
    if (panes.length > 1) {
      const currentIndex = panes.indexOf(this.activePane);
      let previousIndex = currentIndex - 1;
      if (previousIndex < 0) {
        previousIndex = panes.length - 1;
      }
      panes[previousIndex].activate();
      return true;
    } else {
      return false;
    }
  }
  moveActiveItemToPane(destPane) {
    const item = this.activePane.getActiveItem();
    if (!destPane.isItemAllowed(item)) {
      return;
    }
    this.activePane.moveItemToPane(item, destPane);
    destPane.setActiveItem(item);
  }
  copyActiveItemToPane(destPane) {
    const item = this.activePane.copyActiveItem();
    if (item && destPane.isItemAllowed(item)) {
      destPane.activateItem(item);
    }
  }
  destroyEmptyPanes() {
    for (let pane of this.getPanes()) {
      if (pane.items.length === 0) {
        pane.destroy();
      }
    }
  }
  didAddPane(event) {
    this.emitter.emit('did-add-pane', event);
    const items = event.pane.getItems();
    for (let i = 0, length = items.length; i < length; i++) {
      const item = items[i];
      this.didAddPaneItem(item, event.pane, i);
    }
  }
  willDestroyPane(event) {
    this.emitter.emit('will-destroy-pane', event);
  }
  didDestroyPane(event) {
    this.emitter.emit('did-destroy-pane', event);
  }
  didActivatePane(activePane) {
    if (activePane !== this.activePane) {
      if (!this.getPanes().includes(activePane)) {
        throw new Error(
          'Setting active pane that is not present in pane container'
        );
      }
      this.activePane = activePane;
      this.emitter.emit('did-change-active-pane', this.activePane);
      this.didChangeActiveItemOnPane(
        this.activePane,
        this.activePane.getActiveItem()
      );
    }
    this.emitter.emit('did-activate-pane', this.activePane);
    return this.activePane;
  }
  didAddPaneItem(item, pane, index) {
    this.itemRegistry.addItem(item);
    this.emitter.emit('did-add-pane-item', { item, pane, index });
  }
  willDestroyPaneItem(event) {
    return this.emitter.emitAsync('will-destroy-pane-item', event);
  }
  didDestroyPaneItem(event) {
    this.itemRegistry.removeItem(event.item);
    this.emitter.emit('did-destroy-pane-item', event);
  }
  didChangeActiveItemOnPane(pane, activeItem) {
    if (pane === this.getActivePane()) {
      this.emitter.emit('did-change-active-pane-item', activeItem);
      this.cancelStoppedChangingActivePaneItemTimeout();
      this.stoppedChangingActivePaneItemTimeout = setTimeout(() => {
        this.stoppedChangingActivePaneItemTimeout = null;
        this.emitter.emit('did-stop-changing-active-pane-item', activeItem);
      }, STOPPED_CHANGING_ACTIVE_PANE_ITEM_DELAY);
    }
  }
  cancelStoppedChangingActivePaneItemTimeout() {
    if (this.stoppedChangingActivePaneItemTimeout != null) {
      clearTimeout(this.stoppedChangingActivePaneItemTimeout);
    }
  }
};

================
File: src/pane-element.js
================
const path = require('path');
const { CompositeDisposable } = require('event-kit');
class PaneElement extends HTMLElement {
  constructor() {
    super();
    this.attached = false;
    this.subscriptions = new CompositeDisposable();
    this.inlineDisplayStyles = new WeakMap();
    this.subscribeToDOMEvents();
    this.itemViews = document.createElement('div');
  }
  connectedCallback() {
    this.initializeContent();
    this.attached = true;
    if (this.model.isFocused()) {
      this.focus();
    }
  }
  detachedCallback() {
    this.attached = false;
  }
  initializeContent() {
    this.setAttribute('class', 'pane');
    this.setAttribute('tabindex', -1);
    this.appendChild(this.itemViews);
    this.itemViews.setAttribute('class', 'item-views');
  }
  subscribeToDOMEvents() {
    const handleFocus = event => {
      if (
        !(
          this.isActivating ||
          this.model.isDestroyed() ||
          this.contains(event.relatedTarget)
        )
      ) {
        this.model.focus();
      }
      if (event.target !== this) return;
      const view = this.getActiveView();
      if (view) {
        view.focus();
        event.stopPropagation();
      }
    };
    const handleBlur = event => {
      if (!this.contains(event.relatedTarget)) {
        this.model.blur();
      }
    };
    const handleDragOver = event => {
      event.preventDefault();
      event.stopPropagation();
    };
    const handleDrop = event => {
      event.preventDefault();
      event.stopPropagation();
      this.getModel().activate();
      const pathsToOpen = [...event.dataTransfer.files].map(file => file.path);
      if (pathsToOpen.length > 0) {
        this.applicationDelegate.open({ pathsToOpen, here: true });
      }
    };
    this.addEventListener('focus', handleFocus, { capture: true });
    this.addEventListener('blur', handleBlur, { capture: true });
    this.addEventListener('dragover', handleDragOver);
    this.addEventListener('drop', handleDrop);
  }
  initialize(model, { views, applicationDelegate }) {
    this.model = model;
    this.views = views;
    this.applicationDelegate = applicationDelegate;
    if (this.views == null) {
      throw new Error(
        'Must pass a views parameter when initializing PaneElements'
      );
    }
    if (this.applicationDelegate == null) {
      throw new Error(
        'Must pass an applicationDelegate parameter when initializing PaneElements'
      );
    }
    this.subscriptions.add(this.model.onDidActivate(this.activated.bind(this)));
    this.subscriptions.add(
      this.model.observeActive(this.activeStatusChanged.bind(this))
    );
    this.subscriptions.add(
      this.model.observeActiveItem(this.activeItemChanged.bind(this))
    );
    this.subscriptions.add(
      this.model.onDidRemoveItem(this.itemRemoved.bind(this))
    );
    this.subscriptions.add(
      this.model.onDidDestroy(this.paneDestroyed.bind(this))
    );
    this.subscriptions.add(
      this.model.observeFlexScale(this.flexScaleChanged.bind(this))
    );
    return this;
  }
  getModel() {
    return this.model;
  }
  activated() {
    this.isActivating = true;
    if (!this.hasFocus()) {
      this.focus();
    }
    this.isActivating = false;
  }
  activeStatusChanged(active) {
    if (active) {
      this.classList.add('active');
    } else {
      this.classList.remove('active');
    }
  }
  activeItemChanged(item) {
    delete this.dataset.activeItemName;
    delete this.dataset.activeItemPath;
    if (this.changePathDisposable != null) {
      this.changePathDisposable.dispose();
    }
    if (item == null) {
      return;
    }
    const hasFocus = this.hasFocus();
    const itemView = this.views.getView(item);
    const itemPath = typeof item.getPath === 'function' ? item.getPath() : null;
    if (itemPath) {
      this.dataset.activeItemName = path.basename(itemPath);
      this.dataset.activeItemPath = itemPath;
      if (item.onDidChangePath != null) {
        this.changePathDisposable = item.onDidChangePath(() => {
          const itemPath = item.getPath();
          this.dataset.activeItemName = path.basename(itemPath);
          this.dataset.activeItemPath = itemPath;
        });
      }
    }
    if (!this.itemViews.contains(itemView)) {
      this.itemViews.appendChild(itemView);
    }
    for (const child of this.itemViews.children) {
      if (child === itemView) {
        if (this.attached) {
          this.showItemView(child);
        }
      } else {
        this.hideItemView(child);
      }
    }
    if (hasFocus) {
      itemView.focus();
    }
  }
  showItemView(itemView) {
    const inlineDisplayStyle = this.inlineDisplayStyles.get(itemView);
    if (inlineDisplayStyle != null) {
      itemView.style.display = inlineDisplayStyle;
    } else {
      itemView.style.display = '';
    }
  }
  hideItemView(itemView) {
    const inlineDisplayStyle = itemView.style.display;
    if (inlineDisplayStyle !== 'none') {
      if (inlineDisplayStyle != null) {
        this.inlineDisplayStyles.set(itemView, inlineDisplayStyle);
      }
      itemView.style.display = 'none';
    }
  }
  itemRemoved({ item, index, destroyed }) {
    const viewToRemove = this.views.getView(item);
    if (viewToRemove) {
      viewToRemove.remove();
    }
  }
  paneDestroyed() {
    this.subscriptions.dispose();
    if (this.changePathDisposable != null) {
      this.changePathDisposable.dispose();
    }
  }
  flexScaleChanged(flexScale) {
    this.style.flexGrow = flexScale;
  }
  getActiveView() {
    return this.views.getView(this.model.getActiveItem());
  }
  hasFocus() {
    return (
      this === document.activeElement || this.contains(document.activeElement)
    );
  }
}
function createPaneElement() {
  return document.createElement('atom-pane');
}
window.customElements.define('atom-pane', PaneElement);
module.exports = {
  createPaneElement
};

================
File: src/pane-resize-handle-element.js
================
class PaneResizeHandleElement extends HTMLElement {
  constructor() {
    super();
    this.resizePane = this.resizePane.bind(this);
    this.resizeStopped = this.resizeStopped.bind(this);
    this.subscribeToDOMEvents();
  }
  subscribeToDOMEvents() {
    this.addEventListener('dblclick', this.resizeToFitContent.bind(this));
    this.addEventListener('mousedown', this.resizeStarted.bind(this));
  }
  connectedCallback() {
    if (this.parentElement) {
      this.isHorizontal = this.parentElement.classList.contains('horizontal');
      this.classList.add(this.isHorizontal ? 'horizontal' : 'vertical');
    }
  }
  disconnectedCallback() {
    this.resizeStopped();
  }
  resizeToFitContent() {
    if (this.previousSibling != null) {
      this.previousSibling.model.setFlexScale(1);
    }
    return this.nextSibling != null
      ? this.nextSibling.model.setFlexScale(1)
      : undefined;
  }
  resizeStarted(e) {
    e.stopPropagation();
    if (!this.overlay) {
      this.overlay = document.createElement('div');
      this.overlay.classList.add('atom-pane-cursor-overlay');
      this.overlay.classList.add(this.isHorizontal ? 'horizontal' : 'vertical');
      this.appendChild(this.overlay);
    }
    document.addEventListener('mousemove', this.resizePane);
    document.addEventListener('mouseup', this.resizeStopped);
  }
  resizeStopped() {
    document.removeEventListener('mousemove', this.resizePane);
    document.removeEventListener('mouseup', this.resizeStopped);
    if (this.overlay) {
      this.removeChild(this.overlay);
      this.overlay = undefined;
    }
  }
  calcRatio(ratio1, ratio2, total) {
    const allRatio = ratio1 + ratio2;
    return [(total * ratio1) / allRatio, (total * ratio2) / allRatio];
  }
  setFlexGrow(prevSize, nextSize) {
    this.prevModel = this.previousSibling.model;
    this.nextModel = this.nextSibling.model;
    const totalScale =
      this.prevModel.getFlexScale() + this.nextModel.getFlexScale();
    const flexGrows = this.calcRatio(prevSize, nextSize, totalScale);
    this.prevModel.setFlexScale(flexGrows[0]);
    this.nextModel.setFlexScale(flexGrows[1]);
  }
  fixInRange(val, minValue, maxValue) {
    return Math.min(Math.max(val, minValue), maxValue);
  }
  resizePane({ clientX, clientY, which }) {
    if (which !== 1) {
      return this.resizeStopped();
    }
    if (this.previousSibling == null || this.nextSibling == null) {
      return this.resizeStopped();
    }
    if (this.isHorizontal) {
      const totalWidth =
        this.previousSibling.clientWidth + this.nextSibling.clientWidth;
      let leftWidth =
        clientX - this.previousSibling.getBoundingClientRect().left;
      leftWidth = this.fixInRange(leftWidth, 0, totalWidth);
      const rightWidth = totalWidth - leftWidth;
      this.setFlexGrow(leftWidth, rightWidth);
    } else {
      const totalHeight =
        this.previousSibling.clientHeight + this.nextSibling.clientHeight;
      let topHeight =
        clientY - this.previousSibling.getBoundingClientRect().top;
      topHeight = this.fixInRange(topHeight, 0, totalHeight);
      const bottomHeight = totalHeight - topHeight;
      this.setFlexGrow(topHeight, bottomHeight);
    }
  }
}
window.customElements.define(
  'atom-pane-resize-handle',
  PaneResizeHandleElement
);
function createPaneResizeHandleElement() {
  return document.createElement('atom-pane-resize-handle');
}
module.exports = {
  createPaneResizeHandleElement
};

================
File: src/pane.js
================
const Grim = require('grim');
const { CompositeDisposable, Emitter } = require('event-kit');
const PaneAxis = require('./pane-axis');
const TextEditor = require('./text-editor');
const { createPaneElement } = require('./pane-element');
let nextInstanceId = 1;
class SaveCancelledError extends Error {}
module.exports = class Pane {
  inspect() {
    return `Pane ${this.id}`;
  }
  static deserialize(
    state,
    { deserializers, applicationDelegate, config, notifications, views }
  ) {
    const { activeItemIndex } = state;
    const activeItemURI = state.activeItemURI || state.activeItemUri;
    const items = [];
    for (const itemState of state.items) {
      const item = deserializers.deserialize(itemState);
      if (item) items.push(item);
    }
    state.items = items;
    state.activeItem = items[activeItemIndex];
    if (!state.activeItem && activeItemURI) {
      state.activeItem = state.items.find(
        item =>
          typeof item.getURI === 'function' && item.getURI() === activeItemURI
      );
    }
    return new Pane(
      Object.assign(
        {
          deserializerManager: deserializers,
          notificationManager: notifications,
          viewRegistry: views,
          config,
          applicationDelegate
        },
        state
      )
    );
  }
  constructor(params = {}) {
    this.setPendingItem = this.setPendingItem.bind(this);
    this.getPendingItem = this.getPendingItem.bind(this);
    this.clearPendingItem = this.clearPendingItem.bind(this);
    this.onItemDidTerminatePendingState = this.onItemDidTerminatePendingState.bind(
      this
    );
    this.saveItem = this.saveItem.bind(this);
    this.saveItemAs = this.saveItemAs.bind(this);
    this.id = params.id;
    if (this.id != null) {
      nextInstanceId = Math.max(nextInstanceId, this.id + 1);
    } else {
      this.id = nextInstanceId++;
    }
    this.activeItem = params.activeItem;
    this.focused = params.focused != null ? params.focused : false;
    this.applicationDelegate = params.applicationDelegate;
    this.notificationManager = params.notificationManager;
    this.config = params.config;
    this.deserializerManager = params.deserializerManager;
    this.viewRegistry = params.viewRegistry;
    this.emitter = new Emitter();
    this.alive = true;
    this.subscriptionsPerItem = new WeakMap();
    this.items = [];
    this.itemStack = [];
    this.container = null;
    this.addItems((params.items || []).filter(item => item));
    if (!this.getActiveItem()) this.setActiveItem(this.items[0]);
    this.addItemsToStack(params.itemStackIndices || []);
    this.setFlexScale(params.flexScale || 1);
  }
  getElement() {
    if (!this.element) {
      this.element = createPaneElement().initialize(this, {
        views: this.viewRegistry,
        applicationDelegate: this.applicationDelegate
      });
    }
    return this.element;
  }
  serialize() {
    const itemsToBeSerialized = this.items.filter(
      item => item && typeof item.serialize === 'function'
    );
    const itemStackIndices = [];
    for (const item of this.itemStack) {
      if (typeof item.serialize === 'function') {
        itemStackIndices.push(itemsToBeSerialized.indexOf(item));
      }
    }
    const activeItemIndex = itemsToBeSerialized.indexOf(this.activeItem);
    return {
      deserializer: 'Pane',
      id: this.id,
      items: itemsToBeSerialized.map(item => item.serialize()),
      itemStackIndices,
      activeItemIndex,
      focused: this.focused,
      flexScale: this.flexScale
    };
  }
  getParent() {
    return this.parent;
  }
  setParent(parent) {
    this.parent = parent;
  }
  getContainer() {
    return this.container;
  }
  setContainer(container) {
    if (container && container !== this.container) {
      this.container = container;
      container.didAddPane({ pane: this });
    }
  }
  isItemAllowed(item) {
    if (typeof item.getAllowedLocations !== 'function') {
      return true;
    } else {
      return item
        .getAllowedLocations()
        .includes(this.getContainer().getLocation());
    }
  }
  setFlexScale(flexScale) {
    this.flexScale = flexScale;
    this.emitter.emit('did-change-flex-scale', this.flexScale);
    return this.flexScale;
  }
  getFlexScale() {
    return this.flexScale;
  }
  increaseSize() {
    if (this.getContainer().getPanes().length > 1) {
      this.setFlexScale(this.getFlexScale() * 1.1);
    }
  }
  decreaseSize() {
    if (this.getContainer().getPanes().length > 1) {
      this.setFlexScale(this.getFlexScale() / 1.1);
    }
  }
  onDidChangeFlexScale(callback) {
    return this.emitter.on('did-change-flex-scale', callback);
  }
  observeFlexScale(callback) {
    callback(this.flexScale);
    return this.onDidChangeFlexScale(callback);
  }
  onDidActivate(callback) {
    return this.emitter.on('did-activate', callback);
  }
  onWillDestroy(callback) {
    return this.emitter.on('will-destroy', callback);
  }
  onDidDestroy(callback) {
    return this.emitter.once('did-destroy', callback);
  }
  onDidChangeActive(callback) {
    return this.container.onDidChangeActivePane(activePane => {
      const isActive = this === activePane;
      callback(isActive);
    });
  }
  observeActive(callback) {
    callback(this.isActive());
    return this.onDidChangeActive(callback);
  }
  onDidAddItem(callback) {
    return this.emitter.on('did-add-item', callback);
  }
  onDidRemoveItem(callback) {
    return this.emitter.on('did-remove-item', callback);
  }
  onWillRemoveItem(callback) {
    return this.emitter.on('will-remove-item', callback);
  }
  onDidMoveItem(callback) {
    return this.emitter.on('did-move-item', callback);
  }
  observeItems(callback) {
    for (let item of this.getItems()) {
      callback(item);
    }
    return this.onDidAddItem(({ item }) => callback(item));
  }
  onDidChangeActiveItem(callback) {
    return this.emitter.on('did-change-active-item', callback);
  }
  onChooseNextMRUItem(callback) {
    return this.emitter.on('choose-next-mru-item', callback);
  }
  onChooseLastMRUItem(callback) {
    return this.emitter.on('choose-last-mru-item', callback);
  }
  onDoneChoosingMRUItem(callback) {
    return this.emitter.on('done-choosing-mru-item', callback);
  }
  observeActiveItem(callback) {
    callback(this.getActiveItem());
    return this.onDidChangeActiveItem(callback);
  }
  onWillDestroyItem(callback) {
    return this.emitter.on('will-destroy-item', callback);
  }
  focus() {
    return this.activate();
  }
  blur() {
    this.focused = false;
    return true;
  }
  isFocused() {
    return this.focused;
  }
  getPanes() {
    return [this];
  }
  unsubscribeFromItem(item) {
    const subscription = this.subscriptionsPerItem.get(item);
    if (subscription) {
      subscription.dispose();
      this.subscriptionsPerItem.delete(item);
    }
  }
  getItems() {
    return this.items.slice();
  }
  getActiveItem() {
    return this.activeItem;
  }
  setActiveItem(activeItem, options) {
    const modifyStack = options && options.modifyStack;
    if (activeItem !== this.activeItem) {
      if (modifyStack !== false) this.addItemToStack(activeItem);
      this.activeItem = activeItem;
      this.emitter.emit('did-change-active-item', this.activeItem);
      if (this.container)
        this.container.didChangeActiveItemOnPane(this, this.activeItem);
    }
    return this.activeItem;
  }
  addItemsToStack(itemStackIndices) {
    if (this.items.length > 0) {
      if (
        itemStackIndices.length !== this.items.length ||
        itemStackIndices.includes(-1)
      ) {
        itemStackIndices = this.items.map((item, i) => i);
      }
      for (let itemIndex of itemStackIndices) {
        this.addItemToStack(this.items[itemIndex]);
      }
    }
  }
  addItemToStack(newItem) {
    if (newItem == null) {
      return;
    }
    const index = this.itemStack.indexOf(newItem);
    if (index !== -1) this.itemStack.splice(index, 1);
    return this.itemStack.push(newItem);
  }
  getActiveEditor() {
    if (this.activeItem instanceof TextEditor) return this.activeItem;
  }
  itemAtIndex(index) {
    return this.items[index];
  }
  activateNextRecentlyUsedItem() {
    if (this.items.length > 1) {
      if (this.itemStackIndex == null)
        this.itemStackIndex = this.itemStack.length - 1;
      if (this.itemStackIndex === 0)
        this.itemStackIndex = this.itemStack.length;
      this.itemStackIndex--;
      const nextRecentlyUsedItem = this.itemStack[this.itemStackIndex];
      this.emitter.emit('choose-next-mru-item', nextRecentlyUsedItem);
      this.setActiveItem(nextRecentlyUsedItem, { modifyStack: false });
    }
  }
  activatePreviousRecentlyUsedItem() {
    if (this.items.length > 1) {
      if (
        this.itemStackIndex + 1 === this.itemStack.length ||
        this.itemStackIndex == null
      ) {
        this.itemStackIndex = -1;
      }
      this.itemStackIndex++;
      const previousRecentlyUsedItem = this.itemStack[this.itemStackIndex];
      this.emitter.emit('choose-last-mru-item', previousRecentlyUsedItem);
      this.setActiveItem(previousRecentlyUsedItem, { modifyStack: false });
    }
  }
  moveActiveItemToTopOfStack() {
    delete this.itemStackIndex;
    this.addItemToStack(this.activeItem);
    this.emitter.emit('done-choosing-mru-item');
  }
  activateNextItem() {
    const index = this.getActiveItemIndex();
    if (index < this.items.length - 1) {
      this.activateItemAtIndex(index + 1);
    } else {
      this.activateItemAtIndex(0);
    }
  }
  activatePreviousItem() {
    const index = this.getActiveItemIndex();
    if (index > 0) {
      this.activateItemAtIndex(index - 1);
    } else {
      this.activateItemAtIndex(this.items.length - 1);
    }
  }
  activateLastItem() {
    this.activateItemAtIndex(this.items.length - 1);
  }
  moveItemRight() {
    const index = this.getActiveItemIndex();
    const rightItemIndex = index + 1;
    if (rightItemIndex <= this.items.length - 1)
      this.moveItem(this.getActiveItem(), rightItemIndex);
  }
  moveItemLeft() {
    const index = this.getActiveItemIndex();
    const leftItemIndex = index - 1;
    if (leftItemIndex >= 0)
      return this.moveItem(this.getActiveItem(), leftItemIndex);
  }
  getActiveItemIndex() {
    return this.items.indexOf(this.activeItem);
  }
  activateItemAtIndex(index) {
    const item = this.itemAtIndex(index) || this.getActiveItem();
    return this.setActiveItem(item);
  }
  activateItem(item, options = {}) {
    if (item) {
      const index =
        this.getPendingItem() === this.activeItem
          ? this.getActiveItemIndex()
          : this.getActiveItemIndex() + 1;
      this.addItem(item, Object.assign({}, options, { index }));
      this.setActiveItem(item);
    }
  }
  addItem(item, options = {}) {
    if (typeof options === 'number') {
      Grim.deprecate(
        `Pane::addItem(item, ${options}) is deprecated in favor of Pane::addItem(item, {index: ${options}})`
      );
      options = { index: options };
    }
    const index =
      options.index != null ? options.index : this.getActiveItemIndex() + 1;
    const moved = options.moved != null ? options.moved : false;
    const pending = options.pending != null ? options.pending : false;
    if (!item || typeof item !== 'object') {
      throw new Error(
        `Pane items must be objects. Attempted to add item ${item}.`
      );
    }
    if (typeof item.isDestroyed === 'function' && item.isDestroyed()) {
      throw new Error(
        `Adding a pane item with URI '${typeof item.getURI === 'function' &&
          item.getURI()}' that has already been destroyed`
      );
    }
    if (this.items.includes(item)) return;
    const itemSubscriptions = new CompositeDisposable();
    this.subscriptionsPerItem.set(item, itemSubscriptions);
    if (typeof item.onDidDestroy === 'function') {
      itemSubscriptions.add(
        item.onDidDestroy(() => this.removeItem(item, false))
      );
    }
    if (typeof item.onDidTerminatePendingState === 'function') {
      itemSubscriptions.add(
        item.onDidTerminatePendingState(() => {
          if (this.getPendingItem() === item) this.clearPendingItem();
        })
      );
    }
    this.items.splice(index, 0, item);
    const lastPendingItem = this.getPendingItem();
    const replacingPendingItem = lastPendingItem != null && !moved;
    if (replacingPendingItem) this.pendingItem = null;
    if (pending) this.setPendingItem(item);
    this.emitter.emit('did-add-item', { item, index, moved });
    if (!moved) {
      if (this.container) this.container.didAddPaneItem(item, this, index);
    }
    if (replacingPendingItem) this.destroyItem(lastPendingItem);
    if (!this.getActiveItem()) this.setActiveItem(item);
    return item;
  }
  setPendingItem(item) {
    if (this.pendingItem !== item) {
      const mostRecentPendingItem = this.pendingItem;
      this.pendingItem = item;
      if (mostRecentPendingItem) {
        this.emitter.emit(
          'item-did-terminate-pending-state',
          mostRecentPendingItem
        );
      }
    }
  }
  getPendingItem() {
    return this.pendingItem || null;
  }
  clearPendingItem() {
    this.setPendingItem(null);
  }
  onItemDidTerminatePendingState(callback) {
    return this.emitter.on('item-did-terminate-pending-state', callback);
  }
  addItems(items, index = this.getActiveItemIndex() + 1) {
    items = items.filter(item => !this.items.includes(item));
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      this.addItem(item, { index: index + i });
    }
    return items;
  }
  removeItem(item, moved) {
    const index = this.items.indexOf(item);
    if (index === -1) return;
    if (this.getPendingItem() === item) this.pendingItem = null;
    this.removeItemFromStack(item);
    this.emitter.emit('will-remove-item', {
      item,
      index,
      destroyed: !moved,
      moved
    });
    this.unsubscribeFromItem(item);
    if (item === this.activeItem) {
      if (this.items.length === 1) {
        this.setActiveItem(undefined);
      } else if (index === 0) {
        this.activateNextItem();
      } else {
        this.activatePreviousItem();
      }
    }
    this.items.splice(index, 1);
    this.emitter.emit('did-remove-item', {
      item,
      index,
      destroyed: !moved,
      moved
    });
    if (!moved && this.container)
      this.container.didDestroyPaneItem({ item, index, pane: this });
    if (this.items.length === 0 && this.config.get('core.destroyEmptyPanes'))
      this.destroy();
  }
  removeItemFromStack(item) {
    const index = this.itemStack.indexOf(item);
    if (index !== -1) this.itemStack.splice(index, 1);
  }
  moveItem(item, newIndex) {
    const oldIndex = this.items.indexOf(item);
    this.items.splice(oldIndex, 1);
    this.items.splice(newIndex, 0, item);
    this.emitter.emit('did-move-item', { item, oldIndex, newIndex });
  }
  moveItemToPane(item, pane, index) {
    this.removeItem(item, true);
    return pane.addItem(item, { index, moved: true });
  }
  destroyActiveItem() {
    return this.destroyItem(this.activeItem);
  }
  async destroyItem(item, force) {
    const index = this.items.indexOf(item);
    if (index === -1) return false;
    if (
      !force &&
      typeof item.isPermanentDockItem === 'function' &&
      item.isPermanentDockItem() &&
      (!this.container || this.container.getLocation() !== 'center')
    ) {
      return false;
    }
    if (this.emitter.listenerCountForEventName('will-destroy-item') > 0) {
      await this.emitter.emitAsync('will-destroy-item', { item, index });
    }
    if (
      this.container &&
      this.container.emitter.listenerCountForEventName(
        'will-destroy-pane-item'
      ) > 0
    ) {
      let preventClosing = false;
      await this.container.willDestroyPaneItem({
        item,
        index,
        pane: this,
        prevent: () => {
          preventClosing = true;
        }
      });
      if (preventClosing) return false;
    }
    if (
      !force &&
      typeof item.shouldPromptToSave === 'function' &&
      item.shouldPromptToSave()
    ) {
      if (!(await this.promptToSaveItem(item))) return false;
    }
    this.removeItem(item, false);
    if (typeof item.destroy === 'function') item.destroy();
    return true;
  }
  destroyItems() {
    return Promise.all(this.getItems().map(item => this.destroyItem(item)));
  }
  destroyInactiveItems() {
    return Promise.all(
      this.getItems()
        .filter(item => item !== this.activeItem)
        .map(item => this.destroyItem(item))
    );
  }
  promptToSaveItem(item, options = {}) {
    return new Promise((resolve, reject) => {
      if (
        typeof item.shouldPromptToSave !== 'function' ||
        !item.shouldPromptToSave(options)
      ) {
        return resolve(true);
      }
      let uri;
      if (typeof item.getURI === 'function') {
        uri = item.getURI();
      } else if (typeof item.getUri === 'function') {
        uri = item.getUri();
      } else {
        return resolve(true);
      }
      const title =
        (typeof item.getTitle === 'function' && item.getTitle()) || uri;
      const saveDialog = (saveButtonText, saveFn, message) => {
        this.applicationDelegate.confirm(
          {
            message,
            detail:
              'Your changes will be lost if you close this item without saving.',
            buttons: [saveButtonText, 'Cancel', "&Don't Save"]
          },
          response => {
            switch (response) {
              case 0:
                return saveFn(item, error => {
                  if (error instanceof SaveCancelledError) {
                    resolve(false);
                  } else if (error) {
                    saveDialog(
                      'Save as',
                      this.saveItemAs,
                      `'${title}' could not be saved.\nError: ${this.getMessageForErrorCode(
                        error.code
                      )}`
                    );
                  } else {
                    resolve(true);
                  }
                });
              case 1:
                return resolve(false);
              case 2:
                return resolve(true);
            }
          }
        );
      };
      saveDialog(
        'Save',
        this.saveItem,
        `'${title}' has changes, do you want to save them?`
      );
    });
  }
  saveActiveItem(nextAction) {
    return this.saveItem(this.getActiveItem(), nextAction);
  }
  saveActiveItemAs(nextAction) {
    return this.saveItemAs(this.getActiveItem(), nextAction);
  }
  saveItem(item, nextAction) {
    if (!item) return Promise.resolve();
    let itemURI;
    if (typeof item.getURI === 'function') {
      itemURI = item.getURI();
    } else if (typeof item.getUri === 'function') {
      itemURI = item.getUri();
    }
    if (itemURI != null) {
      if (typeof item.save === 'function') {
        return promisify(() => item.save())
          .then(() => {
            if (nextAction) nextAction();
          })
          .catch(error => {
            if (nextAction) {
              nextAction(error);
            } else {
              this.handleSaveError(error, item);
            }
          });
      } else if (nextAction) {
        nextAction();
        return Promise.resolve();
      }
    } else {
      return this.saveItemAs(item, nextAction);
    }
  }
  async saveItemAs(item, nextAction) {
    if (!item) return;
    if (typeof item.saveAs !== 'function') return;
    const saveOptions =
      typeof item.getSaveDialogOptions === 'function'
        ? item.getSaveDialogOptions()
        : {};
    const itemPath = item.getPath();
    if (itemPath && !saveOptions.defaultPath)
      saveOptions.defaultPath = itemPath;
    let resolveSaveDialogPromise = null;
    const saveDialogPromise = new Promise(resolve => {
      resolveSaveDialogPromise = resolve;
    });
    this.applicationDelegate.showSaveDialog(saveOptions, newItemPath => {
      if (newItemPath) {
        promisify(() => item.saveAs(newItemPath))
          .then(() => {
            if (nextAction) {
              resolveSaveDialogPromise(nextAction());
            } else {
              resolveSaveDialogPromise();
            }
          })
          .catch(error => {
            if (nextAction) {
              resolveSaveDialogPromise(nextAction(error));
            } else {
              this.handleSaveError(error, item);
              resolveSaveDialogPromise();
            }
          });
      } else if (nextAction) {
        resolveSaveDialogPromise(
          nextAction(new SaveCancelledError('Save Cancelled'))
        );
      } else {
        resolveSaveDialogPromise();
      }
    });
    return saveDialogPromise;
  }
  saveItems() {
    for (let item of this.getItems()) {
      if (typeof item.isModified === 'function' && item.isModified()) {
        this.saveItem(item);
      }
    }
  }
  itemForURI(uri) {
    return this.items.find(item => {
      if (typeof item.getURI === 'function') {
        return item.getURI() === uri;
      } else if (typeof item.getUri === 'function') {
        return item.getUri() === uri;
      }
    });
  }
  activateItemForURI(uri) {
    const item = this.itemForURI(uri);
    if (item) {
      this.activateItem(item);
      return true;
    } else {
      return false;
    }
  }
  copyActiveItem() {
    if (this.activeItem && typeof this.activeItem.copy === 'function') {
      return this.activeItem.copy();
    }
  }
  isActive() {
    return this.container && this.container.getActivePane() === this;
  }
  activate() {
    if (this.isDestroyed()) throw new Error('Pane has been destroyed');
    this.focused = true;
    if (this.container) this.container.didActivatePane(this);
    this.emitter.emit('did-activate');
  }
  destroy() {
    if (
      this.container &&
      this.container.isAlive() &&
      this.container.getPanes().length === 1
    ) {
      return this.destroyItems();
    }
    this.emitter.emit('will-destroy');
    this.alive = false;
    if (this.container) {
      this.container.willDestroyPane({ pane: this });
      if (this.isActive()) this.container.activateNextPane();
    }
    this.emitter.emit('did-destroy');
    this.emitter.dispose();
    for (let item of this.items.slice()) {
      if (typeof item.destroy === 'function') item.destroy();
    }
    if (this.container) this.container.didDestroyPane({ pane: this });
  }
  isAlive() {
    return this.alive;
  }
  isDestroyed() {
    return !this.isAlive();
  }
  splitLeft(params) {
    return this.split('horizontal', 'before', params);
  }
  splitRight(params) {
    return this.split('horizontal', 'after', params);
  }
  splitUp(params) {
    return this.split('vertical', 'before', params);
  }
  splitDown(params) {
    return this.split('vertical', 'after', params);
  }
  split(orientation, side, params) {
    if (params && params.copyActiveItem) {
      if (!params.items) params.items = [];
      params.items.push(this.copyActiveItem());
    }
    if (this.parent.orientation !== orientation) {
      this.parent.replaceChild(
        this,
        new PaneAxis(
          {
            container: this.container,
            orientation,
            children: [this],
            flexScale: this.flexScale
          },
          this.viewRegistry
        )
      );
      this.setFlexScale(1);
    }
    const newPane = new Pane(
      Object.assign(
        {
          applicationDelegate: this.applicationDelegate,
          notificationManager: this.notificationManager,
          deserializerManager: this.deserializerManager,
          config: this.config,
          viewRegistry: this.viewRegistry
        },
        params
      )
    );
    switch (side) {
      case 'before':
        this.parent.insertChildBefore(this, newPane);
        break;
      case 'after':
        this.parent.insertChildAfter(this, newPane);
        break;
    }
    if (params && params.moveActiveItem && this.activeItem)
      this.moveItemToPane(this.activeItem, newPane);
    newPane.activate();
    return newPane;
  }
  findLeftmostSibling() {
    if (this.parent.orientation === 'horizontal') {
      const [leftmostSibling] = this.parent.children;
      if (leftmostSibling instanceof PaneAxis) {
        return this;
      } else {
        return leftmostSibling;
      }
    } else {
      return this;
    }
  }
  findRightmostSibling() {
    if (this.parent.orientation === 'horizontal') {
      const rightmostSibling = this.parent.children[
        this.parent.children.length - 1
      ];
      if (rightmostSibling instanceof PaneAxis) {
        return this;
      } else {
        return rightmostSibling;
      }
    } else {
      return this;
    }
  }
  findOrCreateRightmostSibling() {
    const rightmostSibling = this.findRightmostSibling();
    if (rightmostSibling === this) {
      return this.splitRight();
    } else {
      return rightmostSibling;
    }
  }
  findTopmostSibling() {
    if (this.parent.orientation === 'vertical') {
      const [topmostSibling] = this.parent.children;
      if (topmostSibling instanceof PaneAxis) {
        return this;
      } else {
        return topmostSibling;
      }
    } else {
      return this;
    }
  }
  findBottommostSibling() {
    if (this.parent.orientation === 'vertical') {
      const bottommostSibling = this.parent.children[
        this.parent.children.length - 1
      ];
      if (bottommostSibling instanceof PaneAxis) {
        return this;
      } else {
        return bottommostSibling;
      }
    } else {
      return this;
    }
  }
  findOrCreateBottommostSibling() {
    const bottommostSibling = this.findBottommostSibling();
    if (bottommostSibling === this) {
      return this.splitDown();
    } else {
      return bottommostSibling;
    }
  }
  close() {
    return Promise.all(
      this.getItems().map(item => this.promptToSaveItem(item))
    ).then(results => {
      if (!results.includes(false)) return this.destroy();
    });
  }
  handleSaveError(error, item) {
    const itemPath =
      error.path || (typeof item.getPath === 'function' && item.getPath());
    const addWarningWithPath = (message, options) => {
      if (itemPath) message = `${message} '${itemPath}'`;
      this.notificationManager.addWarning(message, options);
    };
    const customMessage = this.getMessageForErrorCode(error.code);
    if (customMessage != null) {
      addWarningWithPath(`Unable to save file: ${customMessage}`);
    } else if (
      error.code === 'EISDIR' ||
      (error.message && error.message.endsWith('is a directory'))
    ) {
      return this.notificationManager.addWarning(
        `Unable to save file: ${error.message}`
      );
    } else if (
      ['EPERM', 'EBUSY', 'UNKNOWN', 'EEXIST', 'ELOOP', 'EAGAIN'].includes(
        error.code
      )
    ) {
      addWarningWithPath('Unable to save file', { detail: error.message });
    } else {
      const errorMatch = /ENOTDIR, not a directory '([^']+)'/.exec(
        error.message
      );
      if (errorMatch) {
        const fileName = errorMatch[1];
        this.notificationManager.addWarning(
          `Unable to save file: A directory in the path '${fileName}' could not be written to`
        );
      } else {
        throw error;
      }
    }
  }
  getMessageForErrorCode(errorCode) {
    switch (errorCode) {
      case 'EACCES':
        return 'Permission denied';
      case 'ECONNRESET':
        return 'Connection reset';
      case 'EINTR':
        return 'Interrupted system call';
      case 'EIO':
        return 'I/O error writing file';
      case 'ENOSPC':
        return 'No space left on device';
      case 'ENOTSUP':
        return 'Operation not supported on socket';
      case 'ENXIO':
        return 'No such device or address';
      case 'EROFS':
        return 'Read-only file system';
      case 'ESPIPE':
        return 'Invalid seek';
      case 'ETIMEDOUT':
        return 'Connection timed out';
    }
  }
};
function promisify(callback) {
  try {
    return Promise.resolve(callback());
  } catch (error) {
    return Promise.reject(error);
  }
}

================
File: src/panel-container-element.js
================
'use strict';
const { createFocusTrap } = require('focus-trap');
const { CompositeDisposable } = require('event-kit');
class PanelContainerElement extends HTMLElement {
  constructor() {
    super();
    this.subscriptions = new CompositeDisposable();
  }
  connectedCallback() {
    if (this.model.dock) {
      this.model.dock.elementAttached();
    }
  }
  initialize(model, viewRegistry) {
    this.model = model;
    this.viewRegistry = viewRegistry;
    this.subscriptions.add(
      this.model.onDidAddPanel(this.panelAdded.bind(this))
    );
    this.subscriptions.add(this.model.onDidDestroy(this.destroyed.bind(this)));
    this.classList.add(this.model.getLocation());
    if (this.model.dock != null) {
      this.appendChild(this.model.dock.getElement());
    }
    return this;
  }
  getModel() {
    return this.model;
  }
  panelAdded({ panel, index }) {
    const panelElement = panel.getElement();
    panelElement.classList.add(this.model.getLocation());
    if (this.model.isModal()) {
      panelElement.classList.add('overlay', 'from-top');
    } else {
      panelElement.classList.add(
        'tool-panel',
        `panel-${this.model.getLocation()}`
      );
    }
    if (index >= this.childNodes.length) {
      this.appendChild(panelElement);
    } else {
      const referenceItem = this.childNodes[index];
      this.insertBefore(panelElement, referenceItem);
    }
    if (this.model.isModal()) {
      this.hideAllPanelsExcept(panel);
      this.subscriptions.add(
        panel.onDidChangeVisible(visible => {
          if (visible) {
            this.hideAllPanelsExcept(panel);
          }
        })
      );
      if (panel.autoFocus) {
        const focusOptions = {
          fallbackFocus: panelElement,
          escapeDeactivates: false,
          delayInitialFocus: false
        };
        if (panel.autoFocus !== true) {
          focusOptions.initialFocus = panel.autoFocus;
        }
        const modalFocusTrap = createFocusTrap(panelElement, focusOptions);
        this.subscriptions.add(
          panel.onDidChangeVisible(visible => {
            if (visible) {
              modalFocusTrap.activate();
            } else {
              modalFocusTrap.deactivate();
            }
          })
        );
      }
    }
  }
  destroyed() {
    this.subscriptions.dispose();
    if (this.parentNode != null) {
      this.parentNode.removeChild(this);
    }
  }
  hideAllPanelsExcept(excludedPanel) {
    for (let panel of this.model.getPanels()) {
      if (panel !== excludedPanel) {
        panel.hide();
      }
    }
  }
}
window.customElements.define('atom-panel-container', PanelContainerElement);
function createPanelContainerElement() {
  return document.createElement('atom-panel-container');
}
module.exports = {
  createPanelContainerElement
};

================
File: src/panel-container.js
================
'use strict';
const { Emitter, CompositeDisposable } = require('event-kit');
const { createPanelContainerElement } = require('./panel-container-element');
module.exports = class PanelContainer {
  constructor({ location, dock, viewRegistry } = {}) {
    this.location = location;
    this.emitter = new Emitter();
    this.subscriptions = new CompositeDisposable();
    this.panels = [];
    this.dock = dock;
    this.viewRegistry = viewRegistry;
  }
  destroy() {
    for (let panel of this.getPanels()) {
      panel.destroy();
    }
    this.subscriptions.dispose();
    this.emitter.emit('did-destroy', this);
    this.emitter.dispose();
  }
  getElement() {
    if (!this.element) {
      this.element = createPanelContainerElement().initialize(
        this,
        this.viewRegistry
      );
    }
    return this.element;
  }
  onDidAddPanel(callback) {
    return this.emitter.on('did-add-panel', callback);
  }
  onDidRemovePanel(callback) {
    return this.emitter.on('did-remove-panel', callback);
  }
  onDidDestroy(callback) {
    return this.emitter.once('did-destroy', callback);
  }
  getLocation() {
    return this.location;
  }
  isModal() {
    return this.location === 'modal';
  }
  getPanels() {
    return this.panels.slice();
  }
  addPanel(panel) {
    this.subscriptions.add(panel.onDidDestroy(this.panelDestroyed.bind(this)));
    const index = this.getPanelIndex(panel);
    if (index === this.panels.length) {
      this.panels.push(panel);
    } else {
      this.panels.splice(index, 0, panel);
    }
    this.emitter.emit('did-add-panel', { panel, index });
    return panel;
  }
  panelForItem(item) {
    for (let panel of this.panels) {
      if (panel.getItem() === item) {
        return panel;
      }
    }
    return null;
  }
  panelDestroyed(panel) {
    const index = this.panels.indexOf(panel);
    if (index > -1) {
      this.panels.splice(index, 1);
      this.emitter.emit('did-remove-panel', { panel, index });
    }
  }
  getPanelIndex(panel) {
    const priority = panel.getPriority();
    if (['bottom', 'right'].includes(this.location)) {
      for (let i = this.panels.length - 1; i >= 0; i--) {
        const p = this.panels[i];
        if (priority < p.getPriority()) {
          return i + 1;
        }
      }
      return 0;
    } else {
      for (let i = 0; i < this.panels.length; i++) {
        const p = this.panels[i];
        if (priority < p.getPriority()) {
          return i;
        }
      }
      return this.panels.length;
    }
  }
};

================
File: src/panel.js
================
const { Emitter } = require('event-kit');
module.exports = class Panel {
  constructor({ item, autoFocus, visible, priority, className }, viewRegistry) {
    this.destroyed = false;
    this.item = item;
    this.autoFocus = autoFocus == null ? false : autoFocus;
    this.visible = visible == null ? true : visible;
    this.priority = priority == null ? 100 : priority;
    this.className = className;
    this.viewRegistry = viewRegistry;
    this.emitter = new Emitter();
  }
  destroy() {
    if (this.destroyed) return;
    this.destroyed = true;
    this.hide();
    if (this.element) this.element.remove();
    this.emitter.emit('did-destroy', this);
    return this.emitter.dispose();
  }
  getElement() {
    if (!this.element) {
      this.element = document.createElement('atom-panel');
      if (!this.visible) this.element.style.display = 'none';
      if (this.className)
        this.element.classList.add(...this.className.split(' '));
      this.element.appendChild(this.viewRegistry.getView(this.item));
    }
    return this.element;
  }
  onDidChangeVisible(callback) {
    return this.emitter.on('did-change-visible', callback);
  }
  onDidDestroy(callback) {
    return this.emitter.once('did-destroy', callback);
  }
  getItem() {
    return this.item;
  }
  getPriority() {
    return this.priority;
  }
  getClassName() {
    return this.className;
  }
  isVisible() {
    return this.visible;
  }
  hide() {
    let wasVisible = this.visible;
    this.visible = false;
    if (this.element) this.element.style.display = 'none';
    if (wasVisible) this.emitter.emit('did-change-visible', this.visible);
  }
  show() {
    let wasVisible = this.visible;
    this.visible = true;
    if (this.element) this.element.style.display = null;
    if (!wasVisible) this.emitter.emit('did-change-visible', this.visible);
  }
};

================
File: src/path-watcher.js
================
const fs = require('fs');
const path = require('path');
const { Emitter, Disposable, CompositeDisposable } = require('event-kit');
const nsfw = require('nsfw');
const { NativeWatcherRegistry } = require('./native-watcher-registry');
const ACTION_MAP = new Map([
  [nsfw.actions.MODIFIED, 'modified'],
  [nsfw.actions.CREATED, 'created'],
  [nsfw.actions.DELETED, 'deleted'],
  [nsfw.actions.RENAMED, 'renamed']
]);
const WATCHER_STATE = {
  STOPPED: Symbol('stopped'),
  STARTING: Symbol('starting'),
  RUNNING: Symbol('running'),
  STOPPING: Symbol('stopping')
};
class NativeWatcher {
  constructor(normalizedPath) {
    this.normalizedPath = normalizedPath;
    this.emitter = new Emitter();
    this.subs = new CompositeDisposable();
    this.state = WATCHER_STATE.STOPPED;
    this.onEvents = this.onEvents.bind(this);
    this.onError = this.onError.bind(this);
  }
  async start() {
    if (this.state !== WATCHER_STATE.STOPPED) {
      return;
    }
    this.state = WATCHER_STATE.STARTING;
    await this.doStart();
    this.state = WATCHER_STATE.RUNNING;
    this.emitter.emit('did-start');
  }
  doStart() {
    return Promise.reject(new Error('doStart() not overridden'));
  }
  isRunning() {
    return this.state === WATCHER_STATE.RUNNING;
  }
  onDidStart(callback) {
    return this.emitter.on('did-start', callback);
  }
  onDidChange(callback) {
    this.start();
    const sub = this.emitter.on('did-change', callback);
    return new Disposable(() => {
      sub.dispose();
      if (this.emitter.listenerCountForEventName('did-change') === 0) {
        this.stop();
      }
    });
  }
  onShouldDetach(callback) {
    return this.emitter.on('should-detach', callback);
  }
  onWillStop(callback) {
    return this.emitter.on('will-stop', callback);
  }
  onDidStop(callback) {
    return this.emitter.on('did-stop', callback);
  }
  onDidError(callback) {
    return this.emitter.on('did-error', callback);
  }
  reattachTo(replacement, watchedPath, options) {
    this.emitter.emit('should-detach', { replacement, watchedPath, options });
  }
  async stop() {
    if (this.state !== WATCHER_STATE.RUNNING) {
      return;
    }
    this.state = WATCHER_STATE.STOPPING;
    this.emitter.emit('will-stop');
    await this.doStop();
    this.state = WATCHER_STATE.STOPPED;
    this.emitter.emit('did-stop');
  }
  doStop() {
    return Promise.resolve();
  }
  dispose() {
    this.emitter.dispose();
  }
  onEvents(events) {
    this.emitter.emit('did-change', events);
  }
  onError(err) {
    this.emitter.emit('did-error', err);
  }
}
class NSFWNativeWatcher extends NativeWatcher {
  async doStart(rootPath, eventCallback, errorCallback) {
    const handler = events => {
      this.onEvents(
        events.map(event => {
          const action =
            ACTION_MAP.get(event.action) || `unexpected (${event.action})`;
          const payload = { action };
          if (event.file) {
            payload.path = path.join(event.directory, event.file);
          } else {
            payload.oldPath = path.join(
              event.directory,
              typeof event.oldFile === 'undefined' ? '' : event.oldFile
            );
            payload.path = path.join(
              event.directory,
              typeof event.newFile === 'undefined' ? '' : event.newFile
            );
          }
          return payload;
        })
      );
    };
    this.watcher = await nsfw(this.normalizedPath, handler, {
      debounceMS: 100,
      errorCallback: this.onError
    });
    await this.watcher.start();
  }
  doStop() {
    return this.watcher.stop();
  }
}
// Extended: Manage a subscription to filesystem events that occur beneath a root directory. Construct these by
// calling `watchPath`. To watch for events within active project directories, use {Project::onDidChangeFiles}
// instead.
//
// Multiple PathWatchers may be backed by a single native watcher to conserve operation system resources.
//
// Call {::dispose} to stop receiving events and, if possible, release underlying resources. A PathWatcher may be
// added to a {CompositeDisposable} to manage its lifetime along with other {Disposable} resources like event
// subscriptions.
//
// ```js
// const {watchPath} = require('atom')
class PathWatcher {
  constructor(nativeWatcherRegistry, watchedPath, options) {
    this.watchedPath = watchedPath;
    this.nativeWatcherRegistry = nativeWatcherRegistry;
    this.normalizedPath = null;
    this.native = null;
    this.changeCallbacks = new Map();
    this.attachedPromise = new Promise(resolve => {
      this.resolveAttachedPromise = resolve;
    });
    this.startPromise = new Promise((resolve, reject) => {
      this.resolveStartPromise = resolve;
      this.rejectStartPromise = reject;
    });
    this.normalizedPathPromise = new Promise((resolve, reject) => {
      fs.realpath(watchedPath, (err, real) => {
        if (err) {
          reject(err);
          return;
        }
        this.normalizedPath = real;
        resolve(real);
      });
    });
    this.normalizedPathPromise.catch(err => this.rejectStartPromise(err));
    this.emitter = new Emitter();
    this.subs = new CompositeDisposable();
  }
  getNormalizedPathPromise() {
    return this.normalizedPathPromise;
  }
  getAttachedPromise() {
    return this.attachedPromise;
  }
  getStartPromise() {
    return this.startPromise;
  }
  onDidChange(callback) {
    if (this.native) {
      const sub = this.native.onDidChange(events =>
        this.onNativeEvents(events, callback)
      );
      this.changeCallbacks.set(callback, sub);
      this.native.start();
    } else {
      this.nativeWatcherRegistry.attach(this).then(() => {
        this.onDidChange(callback);
      });
    }
    return new Disposable(() => {
      const sub = this.changeCallbacks.get(callback);
      this.changeCallbacks.delete(callback);
      sub.dispose();
    });
  }
  onDidError(callback) {
    return this.emitter.on('did-error', callback);
  }
  attachToNative(native) {
    this.subs.dispose();
    this.native = native;
    if (native.isRunning()) {
      this.resolveStartPromise();
    } else {
      this.subs.add(
        native.onDidStart(() => {
          this.resolveStartPromise();
        })
      );
    }
    for (const [callback, formerSub] of this.changeCallbacks) {
      const newSub = native.onDidChange(events =>
        this.onNativeEvents(events, callback)
      );
      this.changeCallbacks.set(callback, newSub);
      formerSub.dispose();
    }
    this.subs.add(
      native.onDidError(err => {
        this.emitter.emit('did-error', err);
      })
    );
    this.subs.add(
      native.onShouldDetach(({ replacement, watchedPath }) => {
        if (
          this.native === native &&
          replacement !== native &&
          this.normalizedPath.startsWith(watchedPath)
        ) {
          this.attachToNative(replacement);
        }
      })
    );
    this.subs.add(
      native.onWillStop(() => {
        if (this.native === native) {
          this.subs.dispose();
          this.native = null;
        }
      })
    );
    this.resolveAttachedPromise();
  }
  onNativeEvents(events, callback) {
    const isWatchedPath = eventPath =>
      eventPath.startsWith(this.normalizedPath);
    const filtered = [];
    for (let i = 0; i < events.length; i++) {
      const event = events[i];
      if (event.action === 'renamed') {
        const srcWatched = isWatchedPath(event.oldPath);
        const destWatched = isWatchedPath(event.path);
        if (srcWatched && destWatched) {
          filtered.push(event);
        } else if (srcWatched && !destWatched) {
          filtered.push({
            action: 'deleted',
            kind: event.kind,
            path: event.oldPath
          });
        } else if (!srcWatched && destWatched) {
          filtered.push({
            action: 'created',
            kind: event.kind,
            path: event.path
          });
        }
      } else {
        if (isWatchedPath(event.path)) {
          filtered.push(event);
        }
      }
    }
    if (filtered.length > 0) {
      callback(filtered);
    }
  }
  dispose() {
    for (const sub of this.changeCallbacks.values()) {
      sub.dispose();
    }
    this.emitter.dispose();
    this.subs.dispose();
  }
}
class PathWatcherManager {
  static active() {
    if (!this.activeManager) {
      this.activeManager = new PathWatcherManager(
        atom.config.get('core.fileSystemWatcher')
      );
      this.sub = atom.config.onDidChange(
        'core.fileSystemWatcher',
        ({ newValue }) => {
          this.transitionTo(newValue);
        }
      );
    }
    return this.activeManager;
  }
  static async transitionTo(setting) {
    const current = this.active();
    if (this.transitionPromise) {
      await this.transitionPromise;
    }
    if (current.setting === setting) {
      return;
    }
    current.isShuttingDown = true;
    let resolveTransitionPromise = () => {};
    this.transitionPromise = new Promise(resolve => {
      resolveTransitionPromise = resolve;
    });
    const replacement = new PathWatcherManager(setting);
    this.activeManager = replacement;
    await Promise.all(
      Array.from(current.live, async ([root, native]) => {
        const w = await replacement.createWatcher(root, () => {});
        native.reattachTo(w.native, root, w.native.options || {});
      })
    );
    current.stopAllWatchers();
    resolveTransitionPromise();
    this.transitionPromise = null;
  }
  constructor(setting) {
    this.setting = setting;
    this.live = new Map();
    this.nativeRegistry = new NativeWatcherRegistry(normalizedPath => {
      const nativeWatcher = new NSFWNativeWatcher(normalizedPath);
      this.live.set(normalizedPath, nativeWatcher);
      const sub = nativeWatcher.onWillStop(() => {
        this.live.delete(normalizedPath);
        sub.dispose();
      });
      return nativeWatcher;
    });
    this.isShuttingDown = false;
  }
  async createWatcher(rootPath, eventCallback) {
    if (this.isShuttingDown) {
      await this.constructor.transitionPromise;
      return PathWatcherManager.active().createWatcher(
        rootPath,
        eventCallback
      );
    }
    const w = new PathWatcher(this.nativeRegistry, rootPath);
    w.onDidChange(eventCallback);
    await w.getStartPromise();
    return w;
  }
  print() {
    return this.nativeRegistry.print();
  }
  stopAllWatchers() {
    return Promise.all(Array.from(this.live, ([, w]) => w.stop()));
  }
}
function watchPath(rootPath, options, eventCallback) {
  return PathWatcherManager.active().createWatcher(
    rootPath,
    eventCallback
  );
}
function stopAllWatchers() {
  return PathWatcherManager.active().stopAllWatchers();
}
watchPath.printWatchers = function() {
  return PathWatcherManager.active().print();
};
module.exports = { watchPath, stopAllWatchers };

================
File: src/project.js
================
const path = require('path');
const _ = require('underscore-plus');
const fs = require('fs-plus');
const { Emitter, Disposable, CompositeDisposable } = require('event-kit');
const TextBuffer = require('text-buffer');
const { watchPath } = require('./path-watcher');
const DefaultDirectoryProvider = require('./default-directory-provider');
const Model = require('./model');
const GitRepositoryProvider = require('./git-repository-provider');
module.exports = class Project extends Model {
  constructor({
    notificationManager,
    packageManager,
    config,
    applicationDelegate,
    grammarRegistry
  }) {
    super();
    this.notificationManager = notificationManager;
    this.applicationDelegate = applicationDelegate;
    this.grammarRegistry = grammarRegistry;
    this.emitter = new Emitter();
    this.buffers = [];
    this.rootDirectories = [];
    this.repositories = [];
    this.directoryProviders = [];
    this.defaultDirectoryProvider = new DefaultDirectoryProvider();
    this.repositoryPromisesByPath = new Map();
    this.repositoryProviders = [new GitRepositoryProvider(this, config)];
    this.loadPromisesByPath = {};
    this.watcherPromisesByPath = {};
    this.retiredBufferIDs = new Set();
    this.retiredBufferPaths = new Set();
    this.subscriptions = new CompositeDisposable();
    this.consumeServices(packageManager);
  }
  destroyed() {
    for (let buffer of this.buffers.slice()) {
      buffer.destroy();
    }
    for (let repository of this.repositories.slice()) {
      if (repository != null) repository.destroy();
    }
    for (let path in this.watcherPromisesByPath) {
      this.watcherPromisesByPath[path].then(watcher => {
        watcher.dispose();
      });
    }
    this.rootDirectories = [];
    this.repositories = [];
  }
  reset(packageManager) {
    this.emitter.dispose();
    this.emitter = new Emitter();
    this.subscriptions.dispose();
    this.subscriptions = new CompositeDisposable();
    for (let buffer of this.buffers) {
      if (buffer != null) buffer.destroy();
    }
    this.buffers = [];
    this.setPaths([]);
    this.loadPromisesByPath = {};
    this.retiredBufferIDs = new Set();
    this.retiredBufferPaths = new Set();
    this.consumeServices(packageManager);
  }
  destroyUnretainedBuffers() {
    for (let buffer of this.getBuffers()) {
      if (!buffer.isRetained()) buffer.destroy();
    }
  }
  replace(projectSpecification) {
    if (projectSpecification == null) {
      atom.config.clearProjectSettings();
      this.setPaths([]);
    } else {
      if (projectSpecification.originPath == null) {
        return;
      }
      if (!Array.isArray(projectSpecification.paths)) {
        projectSpecification.paths = [
          path.dirname(projectSpecification.originPath)
        ];
      }
      atom.config.resetProjectSettings(
        projectSpecification.config,
        projectSpecification.originPath
      );
      this.setPaths(projectSpecification.paths);
    }
    this.emitter.emit('did-replace', projectSpecification);
  }
  onDidReplace(callback) {
    return this.emitter.on('did-replace', callback);
  }
  deserialize(state) {
    this.retiredBufferIDs = new Set();
    this.retiredBufferPaths = new Set();
    const handleBufferState = bufferState => {
      if (bufferState.shouldDestroyOnFileDelete == null) {
        bufferState.shouldDestroyOnFileDelete = () =>
          atom.config.get('core.closeDeletedFileTabs');
      }
      bufferState.mustExist = bufferState.digestWhenLastPersisted !== false;
      return TextBuffer.deserialize(bufferState).catch(_ => {
        this.retiredBufferIDs.add(bufferState.id);
        this.retiredBufferPaths.add(bufferState.filePath);
        return null;
      });
    };
    const bufferPromises = [];
    for (let bufferState of state.buffers) {
      bufferPromises.push(handleBufferState(bufferState));
    }
    return Promise.all(bufferPromises).then(buffers => {
      this.buffers = buffers.filter(Boolean);
      for (let buffer of this.buffers) {
        this.grammarRegistry.maintainLanguageMode(buffer);
        this.subscribeToBuffer(buffer);
      }
      this.setPaths(state.paths || [], { mustExist: true, exact: true });
    });
  }
  serialize(options = {}) {
    return {
      deserializer: 'Project',
      paths: this.getPaths(),
      buffers: _.compact(
        this.buffers.map(function(buffer) {
          if (buffer.isRetained()) {
            const isUnloading = options.isUnloading === true;
            return buffer.serialize({
              markerLayers: isUnloading,
              history: isUnloading
            });
          }
        })
      )
    };
  }
  onDidChangePaths(callback) {
    return this.emitter.on('did-change-paths', callback);
  }
  onDidAddBuffer(callback) {
    return this.emitter.on('did-add-buffer', callback);
  }
  observeBuffers(callback) {
    for (let buffer of this.getBuffers()) {
      callback(buffer);
    }
    return this.onDidAddBuffer(callback);
  }
  onDidChangeFiles(callback) {
    return this.emitter.on('did-change-files', callback);
  }
  observeRepositories(callback) {
    for (const repo of this.repositories) {
      if (repo != null) {
        callback(repo);
      }
    }
    return this.onDidAddRepository(callback);
  }
  onDidAddRepository(callback) {
    return this.emitter.on('did-add-repository', callback);
  }
  getRepositories() {
    return this.repositories;
  }
  repositoryForDirectory(directory) {
    const pathForDirectory = directory.getRealPathSync();
    let promise = this.repositoryPromisesByPath.get(pathForDirectory);
    if (!promise) {
      const promises = this.repositoryProviders.map(provider =>
        provider.repositoryForDirectory(directory)
      );
      promise = Promise.all(promises).then(repositories => {
        const repo = repositories.find(repo => repo != null) || null;
        if (repo == null)
          this.repositoryPromisesByPath.delete(pathForDirectory);
        if (repo && repo.onDidDestroy) {
          repo.onDidDestroy(() =>
            this.repositoryPromisesByPath.delete(pathForDirectory)
          );
        }
        return repo;
      });
      this.repositoryPromisesByPath.set(pathForDirectory, promise);
    }
    return promise;
  }
  getPaths() {
    try {
      return this.rootDirectories.map(rootDirectory => rootDirectory.getPath());
    } catch (e) {
      atom.notifications.addError(
        "Please clear Pulsar's window state with: pulsar --clear-window-state"
      );
    }
  }
  setPaths(projectPaths, options = {}) {
    for (let repository of this.repositories) {
      if (repository != null) repository.destroy();
    }
    this.rootDirectories = [];
    this.repositories = [];
    for (let path in this.watcherPromisesByPath) {
      this.watcherPromisesByPath[path].then(watcher => {
        watcher.dispose();
      });
    }
    this.watcherPromisesByPath = {};
    const missingProjectPaths = [];
    for (let projectPath of projectPaths) {
      try {
        this.addPath(projectPath, {
          emitEvent: false,
          mustExist: true,
          exact: options.exact === true
        });
      } catch (e) {
        if (e.missingProjectPaths != null) {
          missingProjectPaths.push(...e.missingProjectPaths);
        } else {
          throw e;
        }
      }
    }
    this.emitter.emit('did-change-paths', projectPaths);
    if (options.mustExist === true && missingProjectPaths.length > 0) {
      const err = new Error('One or more project directories do not exist');
      err.missingProjectPaths = missingProjectPaths;
      throw err;
    }
  }
  addPath(projectPath, options = {}) {
    const directory = this.getDirectoryForProjectPath(projectPath);
    let ok = true;
    if (options.exact === true) {
      ok = directory.getPath() === projectPath;
    }
    ok = ok && directory.existsSync();
    if (!ok) {
      if (options.mustExist === true) {
        const err = new Error(`Project directory ${directory} does not exist`);
        err.missingProjectPaths = [projectPath];
        throw err;
      } else {
        return;
      }
    }
    for (let existingDirectory of this.getDirectories()) {
      if (existingDirectory.getPath() === directory.getPath()) {
        return;
      }
    }
    this.rootDirectories.push(directory);
    const didChangeCallback = events => {
      if (this.rootDirectories.includes(directory)) {
        this.emitter.emit('did-change-files', events);
      }
    };
    this.watcherPromisesByPath[directory.getPath()] =
      directory.onDidChangeFiles != null
        ? Promise.resolve(directory.onDidChangeFiles(didChangeCallback))
        : watchPath(directory.getPath(), {}, didChangeCallback);
    for (let watchedPath in this.watcherPromisesByPath) {
      if (!this.rootDirectories.find(dir => dir.getPath() === watchedPath)) {
        this.watcherPromisesByPath[watchedPath].then(watcher => {
          watcher.dispose();
        });
      }
    }
    let repo = null;
    for (let provider of this.repositoryProviders) {
      if (provider.repositoryForDirectorySync) {
        repo = provider.repositoryForDirectorySync(directory);
      }
      if (repo) {
        break;
      }
    }
    this.repositories.push(repo != null ? repo : null);
    if (repo != null) {
      this.emitter.emit('did-add-repository', repo);
    }
    if (options.emitEvent !== false) {
      this.emitter.emit('did-change-paths', this.getPaths());
    }
  }
  getProvidedDirectoryForProjectPath(projectPath) {
    for (let provider of this.directoryProviders) {
      if (typeof provider.directoryForURISync === 'function') {
        const directory = provider.directoryForURISync(projectPath);
        if (directory) {
          return directory;
        }
      }
    }
    return null;
  }
  getDirectoryForProjectPath(projectPath) {
    let directory = this.getProvidedDirectoryForProjectPath(projectPath);
    if (directory == null) {
      directory = this.defaultDirectoryProvider.directoryForURISync(
        projectPath
      );
    }
    return directory;
  }
  getWatcherPromise(projectPath) {
    return (
      this.watcherPromisesByPath[projectPath] ||
      Promise.reject(new Error(`${projectPath} is not a project root`))
    );
  }
  removePath(projectPath) {
    if (!this.getPaths().includes(projectPath)) {
      projectPath = this.defaultDirectoryProvider.normalizePath(projectPath);
    }
    let indexToRemove = null;
    for (let i = 0; i < this.rootDirectories.length; i++) {
      const directory = this.rootDirectories[i];
      if (directory.getPath() === projectPath) {
        indexToRemove = i;
        break;
      }
    }
    if (indexToRemove != null) {
      this.rootDirectories.splice(indexToRemove, 1);
      const [removedRepository] = this.repositories.splice(indexToRemove, 1);
      if (!this.repositories.includes(removedRepository)) {
        if (removedRepository) removedRepository.destroy();
      }
      if (this.watcherPromisesByPath[projectPath] != null) {
        this.watcherPromisesByPath[projectPath].then(w => w.dispose());
      }
      delete this.watcherPromisesByPath[projectPath];
      this.emitter.emit('did-change-paths', this.getPaths());
      return true;
    } else {
      return false;
    }
  }
  getDirectories() {
    return this.rootDirectories;
  }
  resolvePath(uri) {
    if (!uri) {
      return;
    }
    if (uri.match(/[A-Za-z0-9+-.]+:\/\//)) {
      return uri;
    } else {
      let projectPath;
      if (fs.isAbsolute(uri)) {
        return this.defaultDirectoryProvider.normalizePath(fs.resolveHome(uri));
      } else if ((projectPath = this.getPaths()[0])) {
        return this.defaultDirectoryProvider.normalizePath(
          fs.resolveHome(path.join(projectPath, uri))
        );
      } else {
        return undefined;
      }
    }
  }
  relativize(fullPath) {
    return this.relativizePath(fullPath)[1];
  }
  relativizePath(fullPath) {
    let result = [null, fullPath];
    if (fullPath != null) {
      for (let rootDirectory of this.rootDirectories) {
        const relativePath = rootDirectory.relativize(fullPath);
        if (relativePath != null && relativePath.length < result[1].length) {
          result = [rootDirectory.getPath(), relativePath];
        }
      }
    }
    return result;
  }
  contains(pathToCheck) {
    return this.rootDirectories.some(dir => dir.contains(pathToCheck));
  }
  consumeServices({ serviceHub }) {
    serviceHub.consume('atom.directory-provider', '^0.1.0', provider => {
      this.directoryProviders.unshift(provider);
      return new Disposable(() => {
        return this.directoryProviders.splice(
          this.directoryProviders.indexOf(provider),
          1
        );
      });
    });
    return serviceHub.consume(
      'atom.repository-provider',
      '^0.1.0',
      provider => {
        this.repositoryProviders.unshift(provider);
        if (this.repositories.includes(null)) {
          this.setPaths(this.getPaths());
        }
        return new Disposable(() => {
          return this.repositoryProviders.splice(
            this.repositoryProviders.indexOf(provider),
            1
          );
        });
      }
    );
  }
  getBuffers() {
    return this.buffers.slice();
  }
  isPathModified(filePath) {
    const bufferForPath = this.findBufferForPath(this.resolvePath(filePath));
    return bufferForPath && bufferForPath.isModified();
  }
  findBufferForPath(filePath) {
    return _.find(this.buffers, buffer => buffer.getPath() === filePath);
  }
  findBufferForId(id) {
    return _.find(this.buffers, buffer => buffer.getId() === id);
  }
  bufferForPathSync(filePath) {
    const absoluteFilePath = this.resolvePath(filePath);
    if (this.retiredBufferPaths.has(absoluteFilePath)) {
      return null;
    }
    let existingBuffer;
    if (filePath) {
      existingBuffer = this.findBufferForPath(absoluteFilePath);
    }
    return existingBuffer != null
      ? existingBuffer
      : this.buildBufferSync(absoluteFilePath);
  }
  bufferForIdSync(id) {
    if (this.retiredBufferIDs.has(id)) {
      return null;
    }
    let existingBuffer;
    if (id) {
      existingBuffer = this.findBufferForId(id);
    }
    return existingBuffer != null ? existingBuffer : this.buildBufferSync();
  }
  bufferForPath(absoluteFilePath) {
    let existingBuffer;
    if (absoluteFilePath != null) {
      existingBuffer = this.findBufferForPath(absoluteFilePath);
    }
    if (existingBuffer) {
      return Promise.resolve(existingBuffer);
    } else {
      return this.buildBuffer(absoluteFilePath);
    }
  }
  shouldDestroyBufferOnFileDelete() {
    return atom.config.get('core.closeDeletedFileTabs');
  }
  buildBufferSync(absoluteFilePath) {
    const params = {
      shouldDestroyOnFileDelete: this.shouldDestroyBufferOnFileDelete
    };
    let buffer;
    if (absoluteFilePath != null) {
      buffer = TextBuffer.loadSync(absoluteFilePath, params);
    } else {
      buffer = new TextBuffer(params);
    }
    this.addBuffer(buffer);
    return buffer;
  }
  async buildBuffer(absoluteFilePath) {
    const params = {
      shouldDestroyOnFileDelete: this.shouldDestroyBufferOnFileDelete
    };
    let buffer;
    if (absoluteFilePath != null) {
      if (this.loadPromisesByPath[absoluteFilePath] == null) {
        this.loadPromisesByPath[absoluteFilePath] = TextBuffer.load(
          absoluteFilePath,
          params
        )
          .then(result => {
            delete this.loadPromisesByPath[absoluteFilePath];
            return result;
          })
          .catch(error => {
            delete this.loadPromisesByPath[absoluteFilePath];
            throw error;
          });
      }
      buffer = await this.loadPromisesByPath[absoluteFilePath];
    } else {
      buffer = new TextBuffer(params);
    }
    this.grammarRegistry.autoAssignLanguageMode(buffer);
    this.addBuffer(buffer);
    return buffer;
  }
  addBuffer(buffer, options = {}) {
    this.buffers.push(buffer);
    this.subscriptions.add(this.grammarRegistry.maintainLanguageMode(buffer));
    this.subscribeToBuffer(buffer);
    this.emitter.emit('did-add-buffer', buffer);
    return buffer;
  }
  removeBuffer(buffer) {
    const index = this.buffers.indexOf(buffer);
    if (index !== -1) {
      return this.removeBufferAtIndex(index);
    }
  }
  removeBufferAtIndex(index, options = {}) {
    const [buffer] = this.buffers.splice(index, 1);
    return buffer != null ? buffer.destroy() : undefined;
  }
  eachBuffer(...args) {
    let subscriber;
    if (args.length > 1) {
      subscriber = args.shift();
    }
    const callback = args.shift();
    for (let buffer of this.getBuffers()) {
      callback(buffer);
    }
    if (subscriber) {
      return subscriber.subscribe(this, 'buffer-created', buffer =>
        callback(buffer)
      );
    } else {
      return this.on('buffer-created', buffer => callback(buffer));
    }
  }
  subscribeToBuffer(buffer) {
    buffer.onWillSave(async ({ path }) =>
      this.applicationDelegate.emitWillSavePath(path)
    );
    buffer.onDidSave(({ path }) =>
      this.applicationDelegate.emitDidSavePath(path)
    );
    buffer.onDidDestroy(() => this.removeBuffer(buffer));
    buffer.onDidChangePath(() => {
      if (!(this.getPaths().length > 0)) {
        this.setPaths([path.dirname(buffer.getPath())]);
      }
    });
    buffer.onWillThrowWatchError(({ error, handle }) => {
      handle();
      const message =
        `Unable to read file after file \`${error.eventType}\` event.` +
        `Make sure you have permission to access \`${buffer.getPath()}\`.`;
      this.notificationManager.addWarning(message, {
        detail: error.message,
        dismissable: true
      });
    });
  }
};

================
File: src/protocol-handler-installer.js
================
const { ipcRenderer } = require('electron');
const SETTING = 'core.uriHandlerRegistration';
const PROMPT = 'prompt';
const ALWAYS = 'always';
const NEVER = 'never';
module.exports = class ProtocolHandlerInstaller {
  isSupported() {
    return ['win32', 'darwin'].includes(process.platform);
  }
  async isDefaultProtocolClient() {
    return ipcRenderer.invoke('isDefaultProtocolClient', {
      protocol: 'atom',
      path: process.execPath,
      args: ['--uri-handler', '--']
    });
  }
  async setAsDefaultProtocolClient() {
    return (
      this.isSupported() &&
      ipcRenderer.invoke('setAsDefaultProtocolClient', {
        protocol: 'atom',
        path: process.execPath,
        args: ['--uri-handler', '--']
      })
    );
  }
  async initialize(config, notifications) {
    if (!this.isSupported()) {
      return;
    }
    const behaviorWhenNotProtocolClient = config.get(SETTING);
    switch (behaviorWhenNotProtocolClient) {
      case PROMPT:
        if (await !this.isDefaultProtocolClient()) {
          this.promptToBecomeProtocolClient(config, notifications);
        }
        break;
      case ALWAYS:
        if (await !this.isDefaultProtocolClient()) {
          this.setAsDefaultProtocolClient();
        }
        break;
      case NEVER:
        if (process.platform === 'win32') {
          const Registry = require('winreg');
          const commandKey = new Registry({ hive: 'HKCR', key: `\\atom` });
          commandKey.destroy((_err, _val) => {
          });
        }
        break;
      default:
    }
  }
  promptToBecomeProtocolClient(config, notifications) {
    let notification;
    const withSetting = (value, fn) => {
      return function() {
        config.set(SETTING, value);
        fn();
      };
    };
    const accept = () => {
      notification.dismiss();
      this.setAsDefaultProtocolClient();
    };
    const decline = () => {
      notification.dismiss();
    };
    notification = notifications.addInfo(
      'Register as default atom:// URI handler?',
      {
        dismissable: true,
        icon: 'link',
        description:
          'Pulsar is not currently set as the default handler for atom:// URIs. Would you like Pulsar to handle ' +
          'atom:// URIs?',
        buttons: [
          {
            text: 'Yes',
            className: 'btn btn-info btn-primary',
            onDidClick: accept
          },
          {
            text: 'Yes, Always',
            className: 'btn btn-info',
            onDidClick: withSetting(ALWAYS, accept)
          },
          {
            text: 'No',
            className: 'btn btn-info',
            onDidClick: decline
          },
          {
            text: 'No, Never',
            className: 'btn btn-info',
            onDidClick: withSetting(NEVER, decline)
          }
        ]
      }
    );
  }
};

================
File: src/rb-tree.js
================
"use strict"
module.exports = createRBTree
var RED   = 0
var BLACK = 1
function RBNode(color, key, value, left, right, count) {
  this._color = color
  this.key = key
  this.value = value
  this.left = left
  this.right = right
  this._count = count
}
function cloneNode(node) {
  return new RBNode(node._color, node.key, node.value, node.left, node.right, node._count)
}
function repaint(color, node) {
  return new RBNode(color, node.key, node.value, node.left, node.right, node._count)
}
function recount(node) {
  node._count = 1 + (node.left ? node.left._count : 0) + (node.right ? node.right._count : 0)
}
function RedBlackTree(compare, root) {
  this._compare = compare
  this.root = root
}
var proto = RedBlackTree.prototype
Object.defineProperty(proto, "keys", {
  get: function() {
    var result = []
    this.forEach(function(k,v) {
      result.push(k)
    })
    return result
  }
})
Object.defineProperty(proto, "values", {
  get: function() {
    var result = []
    this.forEach(function(k,v) {
      result.push(v)
    })
    return result
  }
})
Object.defineProperty(proto, "length", {
  get: function() {
    if(this.root) {
      return this.root._count
    }
    return 0
  }
})
proto.insert = function(key, value) {
  var cmp = this._compare
  var n = this.root
  var n_stack = []
  var d_stack = []
  while(n) {
    var d = cmp(key, n.key)
    n_stack.push(n)
    d_stack.push(d)
    if(d === 0) {
      return this
    } if(d < 0) {
      n = n.left
    } else {
      n = n.right
    }
  }
  n_stack.push(new RBNode(RED, key, value, null, null, 1))
  for(var s=n_stack.length-2; s>=0; --s) {
    var n = n_stack[s]
    if(d_stack[s] <= 0) {
      n_stack[s] = new RBNode(n._color, n.key, n.value, n_stack[s+1], n.right, n._count+1)
    } else {
      n_stack[s] = new RBNode(n._color, n.key, n.value, n.left, n_stack[s+1], n._count+1)
    }
  }
  for(var s=n_stack.length-1; s>1; --s) {
    var p = n_stack[s-1]
    var n = n_stack[s]
    if(p._color === BLACK || n._color === BLACK) {
      break
    }
    var pp = n_stack[s-2]
    if(pp.left === p) {
      if(p.left === n) {
        var y = pp.right
        if(y && y._color === RED) {
          p._color = BLACK
          pp.right = repaint(BLACK, y)
          pp._color = RED
          s -= 1
        } else {
          pp._color = RED
          pp.left = p.right
          p._color = BLACK
          p.right = pp
          n_stack[s-2] = p
          n_stack[s-1] = n
          recount(pp)
          recount(p)
          if(s >= 3) {
            var ppp = n_stack[s-3]
            if(ppp.left === pp) {
              ppp.left = p
            } else {
              ppp.right = p
            }
          }
          break
        }
      } else {
        var y = pp.right
        if(y && y._color === RED) {
          p._color = BLACK
          pp.right = repaint(BLACK, y)
          pp._color = RED
          s -= 1
        } else {
          p.right = n.left
          pp._color = RED
          pp.left = n.right
          n._color = BLACK
          n.left = p
          n.right = pp
          n_stack[s-2] = n
          n_stack[s-1] = p
          recount(pp)
          recount(p)
          recount(n)
          if(s >= 3) {
            var ppp = n_stack[s-3]
            if(ppp.left === pp) {
              ppp.left = n
            } else {
              ppp.right = n
            }
          }
          break
        }
      }
    } else {
      if(p.right === n) {
        var y = pp.left
        if(y && y._color === RED) {
          p._color = BLACK
          pp.left = repaint(BLACK, y)
          pp._color = RED
          s -= 1
        } else {
          pp._color = RED
          pp.right = p.left
          p._color = BLACK
          p.left = pp
          n_stack[s-2] = p
          n_stack[s-1] = n
          recount(pp)
          recount(p)
          if(s >= 3) {
            var ppp = n_stack[s-3]
            if(ppp.right === pp) {
              ppp.right = p
            } else {
              ppp.left = p
            }
          }
          break
        }
      } else {
        var y = pp.left
        if(y && y._color === RED) {
          p._color = BLACK
          pp.left = repaint(BLACK, y)
          pp._color = RED
          s -= 1
        } else {
          p.left = n.right
          pp._color = RED
          pp.right = n.left
          n._color = BLACK
          n.right = p
          n.left = pp
          n_stack[s-2] = n
          n_stack[s-1] = p
          recount(pp)
          recount(p)
          recount(n)
          if(s >= 3) {
            var ppp = n_stack[s-3]
            if(ppp.right === pp) {
              ppp.right = n
            } else {
              ppp.left = n
            }
          }
          break
        }
      }
    }
  }
  n_stack[0]._color = BLACK
  return new RedBlackTree(cmp, n_stack[0])
}
function doVisitFull(visit, node) {
  if(node.left) {
    var v = doVisitFull(visit, node.left)
    if(v) { return v }
  }
  var v = visit(node.key, node.value)
  if(v) { return v }
  if(node.right) {
    return doVisitFull(visit, node.right)
  }
}
function doVisitHalf(lo, compare, visit, node) {
  var l = compare(lo, node.key)
  if(l <= 0) {
    if(node.left) {
      var v = doVisitHalf(lo, compare, visit, node.left)
      if(v) { return v }
    }
    var v = visit(node.key, node.value)
    if(v) { return v }
  }
  if(node.right) {
    return doVisitHalf(lo, compare, visit, node.right)
  }
}
function doVisit(lo, hi, compare, visit, node) {
  var l = compare(lo, node.key)
  var h = compare(hi, node.key)
  var v
  if(l <= 0) {
    if(node.left) {
      v = doVisit(lo, hi, compare, visit, node.left)
      if(v) { return v }
    }
    if(h > 0) {
      v = visit(node.key, node.value)
      if(v) { return v }
    }
  }
  if(h > 0 && node.right) {
    return doVisit(lo, hi, compare, visit, node.right)
  }
}
proto.forEach = function rbTreeForEach(visit, lo, hi) {
  if(!this.root) {
    return
  }
  switch(arguments.length) {
    case 1:
      return doVisitFull(visit, this.root)
    break
    case 2:
      return doVisitHalf(lo, this._compare, visit, this.root)
    break
    case 3:
      if(this._compare(lo, hi) >= 0) {
        return
      }
      return doVisit(lo, hi, this._compare, visit, this.root)
    break
  }
}
Object.defineProperty(proto, "begin", {
  get: function() {
    var stack = []
    var n = this.root
    while(n) {
      stack.push(n)
      n = n.left
    }
    return new RedBlackTreeIterator(this, stack)
  }
})
Object.defineProperty(proto, "end", {
  get: function() {
    var stack = []
    var n = this.root
    while(n) {
      stack.push(n)
      n = n.right
    }
    return new RedBlackTreeIterator(this, stack)
  }
})
proto.at = function(idx) {
  if(idx < 0) {
    return new RedBlackTreeIterator(this, [])
  }
  var n = this.root
  var stack = []
  while(true) {
    stack.push(n)
    if(n.left) {
      if(idx < n.left._count) {
        n = n.left
        continue
      }
      idx -= n.left._count
    }
    if(!idx) {
      return new RedBlackTreeIterator(this, stack)
    }
    idx -= 1
    if(n.right) {
      if(idx >= n.right._count) {
        break
      }
      n = n.right
    } else {
      break
    }
  }
  return new RedBlackTreeIterator(this, [])
}
proto.ge = function(key) {
  var cmp = this._compare
  var n = this.root
  var stack = []
  var last_ptr = 0
  while(n) {
    var d = cmp(key, n.key)
    stack.push(n)
    if(d <= 0) {
      last_ptr = stack.length
    }
    if(d <= 0) {
      n = n.left
    } else {
      n = n.right
    }
  }
  stack.length = last_ptr
  return new RedBlackTreeIterator(this, stack)
}
proto.gt = function(key) {
  var cmp = this._compare
  var n = this.root
  var stack = []
  var last_ptr = 0
  while(n) {
    var d = cmp(key, n.key)
    stack.push(n)
    if(d < 0) {
      last_ptr = stack.length
    }
    if(d < 0) {
      n = n.left
    } else {
      n = n.right
    }
  }
  stack.length = last_ptr
  return new RedBlackTreeIterator(this, stack)
}
proto.lt = function(key) {
  var cmp = this._compare
  var n = this.root
  var stack = []
  var last_ptr = 0
  while(n) {
    var d = cmp(key, n.key)
    stack.push(n)
    if(d > 0) {
      last_ptr = stack.length
    }
    if(d <= 0) {
      n = n.left
    } else {
      n = n.right
    }
  }
  stack.length = last_ptr
  return new RedBlackTreeIterator(this, stack)
}
proto.le = function(key) {
  var cmp = this._compare
  var n = this.root
  var stack = []
  var last_ptr = 0
  while(n) {
    var d = cmp(key, n.key)
    stack.push(n)
    if(d >= 0) {
      last_ptr = stack.length
    }
    if(d < 0) {
      n = n.left
    } else {
      n = n.right
    }
  }
  stack.length = last_ptr
  return new RedBlackTreeIterator(this, stack)
}
proto.find = function(key) {
  var cmp = this._compare
  var n = this.root
  var stack = []
  while(n) {
    var d = cmp(key, n.key)
    stack.push(n)
    if(d === 0) {
      return new RedBlackTreeIterator(this, stack)
    }
    if(d <= 0) {
      n = n.left
    } else {
      n = n.right
    }
  }
  return new RedBlackTreeIterator(this, [])
}
proto.remove = function(key) {
  var iter = this.find(key)
  if(iter) {
    return iter.remove()
  }
  return this
}
proto.get = function(key) {
  var cmp = this._compare
  var n = this.root
  while(n) {
    var d = cmp(key, n.key)
    if(d === 0) {
      return n.value
    }
    if(d <= 0) {
      n = n.left
    } else {
      n = n.right
    }
  }
  return
}
function RedBlackTreeIterator(tree, stack) {
  this.tree = tree
  this._stack = stack
}
var iproto = RedBlackTreeIterator.prototype
Object.defineProperty(iproto, "valid", {
  get: function() {
    return this._stack.length > 0
  }
})
Object.defineProperty(iproto, "node", {
  get: function() {
    if(this._stack.length > 0) {
      return this._stack[this._stack.length-1]
    }
    return null
  },
  enumerable: true
})
iproto.clone = function() {
  return new RedBlackTreeIterator(this.tree, this._stack.slice())
}
function swapNode(n, v) {
  n.key = v.key
  n.value = v.value
  n.left = v.left
  n.right = v.right
  n._color = v._color
  n._count = v._count
}
function fixDoubleBlack(stack) {
  var n, p, s, z
  for(var i=stack.length-1; i>=0; --i) {
    n = stack[i]
    if(i === 0) {
      n._color = BLACK
      return
    }
    p = stack[i-1]
    if(p.left === n) {
      s = p.right
      if(s.right && s.right._color === RED) {
        s = p.right = cloneNode(s)
        z = s.right = cloneNode(s.right)
        p.right = s.left
        s.left = p
        s.right = z
        s._color = p._color
        n._color = BLACK
        p._color = BLACK
        z._color = BLACK
        recount(p)
        recount(s)
        if(i > 1) {
          var pp = stack[i-2]
          if(pp.left === p) {
            pp.left = s
          } else {
            pp.right = s
          }
        }
        stack[i-1] = s
        return
      } else if(s.left && s.left._color === RED) {
        s = p.right = cloneNode(s)
        z = s.left = cloneNode(s.left)
        p.right = z.left
        s.left = z.right
        z.left = p
        z.right = s
        z._color = p._color
        p._color = BLACK
        s._color = BLACK
        n._color = BLACK
        recount(p)
        recount(s)
        recount(z)
        if(i > 1) {
          var pp = stack[i-2]
          if(pp.left === p) {
            pp.left = z
          } else {
            pp.right = z
          }
        }
        stack[i-1] = z
        return
      }
      if(s._color === BLACK) {
        if(p._color === RED) {
          p._color = BLACK
          p.right = repaint(RED, s)
          return
        } else {
          p.right = repaint(RED, s)
          continue
        }
      } else {
        s = cloneNode(s)
        p.right = s.left
        s.left = p
        s._color = p._color
        p._color = RED
        recount(p)
        recount(s)
        if(i > 1) {
          var pp = stack[i-2]
          if(pp.left === p) {
            pp.left = s
          } else {
            pp.right = s
          }
        }
        stack[i-1] = s
        stack[i] = p
        if(i+1 < stack.length) {
          stack[i+1] = n
        } else {
          stack.push(n)
        }
        i = i+2
      }
    } else {
      s = p.left
      if(s.left && s.left._color === RED) {
        s = p.left = cloneNode(s)
        z = s.left = cloneNode(s.left)
        p.left = s.right
        s.right = p
        s.left = z
        s._color = p._color
        n._color = BLACK
        p._color = BLACK
        z._color = BLACK
        recount(p)
        recount(s)
        if(i > 1) {
          var pp = stack[i-2]
          if(pp.right === p) {
            pp.right = s
          } else {
            pp.left = s
          }
        }
        stack[i-1] = s
        return
      } else if(s.right && s.right._color === RED) {
        s = p.left = cloneNode(s)
        z = s.right = cloneNode(s.right)
        p.left = z.right
        s.right = z.left
        z.right = p
        z.left = s
        z._color = p._color
        p._color = BLACK
        s._color = BLACK
        n._color = BLACK
        recount(p)
        recount(s)
        recount(z)
        if(i > 1) {
          var pp = stack[i-2]
          if(pp.right === p) {
            pp.right = z
          } else {
            pp.left = z
          }
        }
        stack[i-1] = z
        return
      }
      if(s._color === BLACK) {
        if(p._color === RED) {
          p._color = BLACK
          p.left = repaint(RED, s)
          return
        } else {
          p.left = repaint(RED, s)
          continue
        }
      } else {
        s = cloneNode(s)
        p.left = s.right
        s.right = p
        s._color = p._color
        p._color = RED
        recount(p)
        recount(s)
        if(i > 1) {
          var pp = stack[i-2]
          if(pp.right === p) {
            pp.right = s
          } else {
            pp.left = s
          }
        }
        stack[i-1] = s
        stack[i] = p
        if(i+1 < stack.length) {
          stack[i+1] = n
        } else {
          stack.push(n)
        }
        i = i+2
      }
    }
  }
}
iproto.remove = function() {
  var stack = this._stack
  if(stack.length === 0) {
    return this.tree
  }
  var cstack = new Array(stack.length)
  var n = stack[stack.length-1]
  cstack[cstack.length-1] = new RBNode(n._color, n.key, n.value, n.left, n.right, n._count)
  for(var i=stack.length-2; i>=0; --i) {
    var n = stack[i]
    if(n.left === stack[i+1]) {
      cstack[i] = new RBNode(n._color, n.key, n.value, cstack[i+1], n.right, n._count)
    } else {
      cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i+1], n._count)
    }
  }
  n = cstack[cstack.length-1]
  if(n.left && n.right) {
    var split = cstack.length
    n = n.left
    while(n.right) {
      cstack.push(n)
      n = n.right
    }
    var v = cstack[split-1]
    cstack.push(new RBNode(n._color, v.key, v.value, n.left, n.right, n._count))
    cstack[split-1].key = n.key
    cstack[split-1].value = n.value
    for(var i=cstack.length-2; i>=split; --i) {
      n = cstack[i]
      cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i+1], n._count)
    }
    cstack[split-1].left = cstack[split]
  }
  n = cstack[cstack.length-1]
  if(n._color === RED) {
    var p = cstack[cstack.length-2]
    if(p.left === n) {
      p.left = null
    } else if(p.right === n) {
      p.right = null
    }
    cstack.pop()
    for(var i=0; i<cstack.length; ++i) {
      cstack[i]._count--
    }
    return new RedBlackTree(this.tree._compare, cstack[0])
  } else {
    if(n.left || n.right) {
      if(n.left) {
        swapNode(n, n.left)
      } else if(n.right) {
        swapNode(n, n.right)
      }
      n._color = BLACK
      for(var i=0; i<cstack.length-1; ++i) {
        cstack[i]._count--
      }
      return new RedBlackTree(this.tree._compare, cstack[0])
    } else if(cstack.length === 1) {
      return new RedBlackTree(this.tree._compare, null)
    } else {
      for(var i=0; i<cstack.length; ++i) {
        cstack[i]._count--
      }
      var parent = cstack[cstack.length-2]
      fixDoubleBlack(cstack)
      if(parent.left === n) {
        parent.left = null
      } else {
        parent.right = null
      }
    }
  }
  return new RedBlackTree(this.tree._compare, cstack[0])
}
Object.defineProperty(iproto, "key", {
  get: function() {
    if(this._stack.length > 0) {
      return this._stack[this._stack.length-1].key
    }
    return
  },
  enumerable: true
})
Object.defineProperty(iproto, "value", {
  get: function() {
    if(this._stack.length > 0) {
      return this._stack[this._stack.length-1].value
    }
    return
  },
  enumerable: true
})
Object.defineProperty(iproto, "index", {
  get: function() {
    var idx = 0
    var stack = this._stack
    if(stack.length === 0) {
      var r = this.tree.root
      if(r) {
        return r._count
      }
      return 0
    } else if(stack[stack.length-1].left) {
      idx = stack[stack.length-1].left._count
    }
    for(var s=stack.length-2; s>=0; --s) {
      if(stack[s+1] === stack[s].right) {
        ++idx
        if(stack[s].left) {
          idx += stack[s].left._count
        }
      }
    }
    return idx
  },
  enumerable: true
})
iproto.next = function() {
  var stack = this._stack
  if(stack.length === 0) {
    return
  }
  var n = stack[stack.length-1]
  if(n.right) {
    n = n.right
    while(n) {
      stack.push(n)
      n = n.left
    }
  } else {
    stack.pop()
    while(stack.length > 0 && stack[stack.length-1].right === n) {
      n = stack[stack.length-1]
      stack.pop()
    }
  }
}
Object.defineProperty(iproto, "hasNext", {
  get: function() {
    var stack = this._stack
    if(stack.length === 0) {
      return false
    }
    if(stack[stack.length-1].right) {
      return true
    }
    for(var s=stack.length-1; s>0; --s) {
      if(stack[s-1].left === stack[s]) {
        return true
      }
    }
    return false
  }
})
iproto.update = function(value) {
  var stack = this._stack
  if(stack.length === 0) {
    throw new Error("Can't update empty node!")
  }
  var cstack = new Array(stack.length)
  var n = stack[stack.length-1]
  cstack[cstack.length-1] = new RBNode(n._color, n.key, value, n.left, n.right, n._count)
  for(var i=stack.length-2; i>=0; --i) {
    n = stack[i]
    if(n.left === stack[i+1]) {
      cstack[i] = new RBNode(n._color, n.key, n.value, cstack[i+1], n.right, n._count)
    } else {
      cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i+1], n._count)
    }
  }
  return new RedBlackTree(this.tree._compare, cstack[0])
}
iproto.prev = function() {
  var stack = this._stack
  if(stack.length === 0) {
    return
  }
  var n = stack[stack.length-1]
  if(n.left) {
    n = n.left
    while(n) {
      stack.push(n)
      n = n.right
    }
  } else {
    stack.pop()
    while(stack.length > 0 && stack[stack.length-1].left === n) {
      n = stack[stack.length-1]
      stack.pop()
    }
  }
}
Object.defineProperty(iproto, "hasPrev", {
  get: function() {
    var stack = this._stack
    if(stack.length === 0) {
      return false
    }
    if(stack[stack.length-1].left) {
      return true
    }
    for(var s=stack.length-1; s>0; --s) {
      if(stack[s-1].right === stack[s]) {
        return true
      }
    }
    return false
  }
})
function defaultCompare(a, b) {
  if(a < b) {
    return -1
  }
  if(a > b) {
    return 1
  }
  return 0
}
function createRBTree(compare) {
  return new RedBlackTree(compare || defaultCompare, null)
}

================
File: src/register-default-commands.js
================
const {ipcRenderer} = require('electron');
const Grim = require('grim');
module.exports = function({commandRegistry, commandInstaller, config, notificationManager, project, clipboard}) {
  commandRegistry.add('atom-workspace', {
    'pane:show-next-recently-used-item': function() {
      return this.getModel().getActivePane().activateNextRecentlyUsedItem();
    },
    'pane:show-previous-recently-used-item': function() {
      return this.getModel().getActivePane().activatePreviousRecentlyUsedItem();
    },
    'pane:move-active-item-to-top-of-stack': function() {
      return this.getModel().getActivePane().moveActiveItemToTopOfStack();
    },
    'pane:show-next-item': function() {
      return this.getModel().getActivePane().activateNextItem();
    },
    'pane:show-previous-item': function() {
      return this.getModel().getActivePane().activatePreviousItem();
    },
    'pane:show-item-1': function() {
      return this.getModel().getActivePane().activateItemAtIndex(0);
    },
    'pane:show-item-2': function() {
      return this.getModel().getActivePane().activateItemAtIndex(1);
    },
    'pane:show-item-3': function() {
      return this.getModel().getActivePane().activateItemAtIndex(2);
    },
    'pane:show-item-4': function() {
      return this.getModel().getActivePane().activateItemAtIndex(3);
    },
    'pane:show-item-5': function() {
      return this.getModel().getActivePane().activateItemAtIndex(4);
    },
    'pane:show-item-6': function() {
      return this.getModel().getActivePane().activateItemAtIndex(5);
    },
    'pane:show-item-7': function() {
      return this.getModel().getActivePane().activateItemAtIndex(6);
    },
    'pane:show-item-8': function() {
      return this.getModel().getActivePane().activateItemAtIndex(7);
    },
    'pane:show-item-9': function() {
      return this.getModel().getActivePane().activateLastItem();
    },
    'pane:move-item-right': function() {
      return this.getModel().getActivePane().moveItemRight();
    },
    'pane:move-item-left': function() {
      return this.getModel().getActivePane().moveItemLeft();
    },
    'window:increase-font-size': function() {
      return this.getModel().increaseFontSize();
    },
    'window:decrease-font-size': function() {
      return this.getModel().decreaseFontSize();
    },
    'window:reset-font-size': function() {
      return this.getModel().resetFontSize();
    },
    'application:about': function() {
      return ipcRenderer.send('command', 'application:about');
    },
    'application:show-preferences': function() {
      return ipcRenderer.send('command', 'application:show-settings');
    },
    'application:show-settings': function() {
      return ipcRenderer.send('command', 'application:show-settings');
    },
    'application:quit': function() {
      return ipcRenderer.send('command', 'application:quit');
    },
    'application:hide': function() {
      return ipcRenderer.send('command', 'application:hide');
    },
    'application:hide-other-applications': function() {
      return ipcRenderer.send('command', 'application:hide-other-applications');
    },
    'application:install-update': function() {
      return ipcRenderer.send('command', 'application:install-update');
    },
    'application:unhide-all-applications': function() {
      return ipcRenderer.send('command', 'application:unhide-all-applications');
    },
    'application:new-window': function() {
      return ipcRenderer.send('command', 'application:new-window');
    },
    'application:new-file': function() {
      return ipcRenderer.send('command', 'application:new-file');
    },
    'application:open': function() {
      var defaultPath, ref, ref1, ref2;
      defaultPath = (ref = (ref1 = atom.workspace.getActiveTextEditor()) != null ? ref1.getPath() : void 0) != null ? ref : (ref2 = atom.project.getPaths()) != null ? ref2[0] : void 0;
      return ipcRenderer.send('open-chosen-any', defaultPath);
    },
    'application:open-file': function() {
      var defaultPath, ref, ref1, ref2;
      defaultPath = (ref = (ref1 = atom.workspace.getActiveTextEditor()) != null ? ref1.getPath() : void 0) != null ? ref : (ref2 = atom.project.getPaths()) != null ? ref2[0] : void 0;
      return ipcRenderer.send('open-chosen-file', defaultPath);
    },
    'application:open-folder': function() {
      var defaultPath, ref, ref1, ref2;
      defaultPath = (ref = (ref1 = atom.workspace.getActiveTextEditor()) != null ? ref1.getPath() : void 0) != null ? ref : (ref2 = atom.project.getPaths()) != null ? ref2[0] : void 0;
      return ipcRenderer.send('open-chosen-folder', defaultPath);
    },
    'application:open-dev': function() {
      return ipcRenderer.send('command', 'application:open-dev');
    },
    'application:open-safe': function() {
      return ipcRenderer.send('command', 'application:open-safe');
    },
    'application:add-project-folder': function() {
      return atom.addProjectFolder();
    },
    'application:minimize': function() {
      return ipcRenderer.send('command', 'application:minimize');
    },
    'application:zoom': function() {
      return ipcRenderer.send('command', 'application:zoom');
    },
    'application:bring-all-windows-to-front': function() {
      return ipcRenderer.send('command', 'application:bring-all-windows-to-front');
    },
    'application:open-your-config': function() {
      return ipcRenderer.send('command', 'application:open-your-config');
    },
    'application:open-your-init-script': function() {
      return ipcRenderer.send('command', 'application:open-your-init-script');
    },
    'application:open-your-keymap': function() {
      return ipcRenderer.send('command', 'application:open-your-keymap');
    },
    'application:open-your-snippets': function() {
      return ipcRenderer.send('command', 'application:open-your-snippets');
    },
    'application:open-your-stylesheet': function() {
      return ipcRenderer.send('command', 'application:open-your-stylesheet');
    },
    'application:open-license': function() {
      return this.getModel().openLicense();
    },
    'window:run-package-specs': function() {
      return this.runPackageSpecs();
    },
    'window:toggle-left-dock': function() {
      return this.getModel().getLeftDock().toggle();
    },
    'window:toggle-right-dock': function() {
      return this.getModel().getRightDock().toggle();
    },
    'window:toggle-bottom-dock': function() {
      return this.getModel().getBottomDock().toggle();
    },
    'window:focus-next-pane': function() {
      return this.getModel().activateNextPane();
    },
    'window:focus-previous-pane': function() {
      return this.getModel().activatePreviousPane();
    },
    'window:focus-pane-above': function() {
      return this.focusPaneViewAbove();
    },
    'window:focus-pane-below': function() {
      return this.focusPaneViewBelow();
    },
    'window:focus-pane-on-left': function() {
      return this.focusPaneViewOnLeft();
    },
    'window:focus-pane-on-right': function() {
      return this.focusPaneViewOnRight();
    },
    'window:move-active-item-to-pane-above': function() {
      return this.moveActiveItemToPaneAbove();
    },
    'window:move-active-item-to-pane-below': function() {
      return this.moveActiveItemToPaneBelow();
    },
    'window:move-active-item-to-pane-on-left': function() {
      return this.moveActiveItemToPaneOnLeft();
    },
    'window:move-active-item-to-pane-on-right': function() {
      return this.moveActiveItemToPaneOnRight();
    },
    'window:copy-active-item-to-pane-above': function() {
      return this.moveActiveItemToPaneAbove({
        keepOriginal: true
      });
    },
    'window:copy-active-item-to-pane-below': function() {
      return this.moveActiveItemToPaneBelow({
        keepOriginal: true
      });
    },
    'window:copy-active-item-to-pane-on-left': function() {
      return this.moveActiveItemToPaneOnLeft({
        keepOriginal: true
      });
    },
    'window:copy-active-item-to-pane-on-right': function() {
      return this.moveActiveItemToPaneOnRight({
        keepOriginal: true
      });
    },
    'window:save-all': function() {
      return this.getModel().saveAll();
    },
    'window:toggle-invisibles': function() {
      return config.set("editor.showInvisibles", !config.get("editor.showInvisibles"));
    },
    'window:log-deprecation-warnings': function() {
      return Grim.logDeprecations();
    },
    'window:toggle-auto-indent': function() {
      return config.set("editor.autoIndent", !config.get("editor.autoIndent"));
    },
    'pane:reopen-closed-item': function() {
      return this.getModel().reopenItem();
    },
    'core:close': function() {
      return this.getModel().closeActivePaneItemOrEmptyPaneOrWindow();
    },
    'core:save': function() {
      return this.getModel().saveActivePaneItem();
    },
    'core:save-as': function() {
      return this.getModel().saveActivePaneItemAs();
    }
  }, false);
  if (process.platform === 'darwin') {
    commandRegistry.add('atom-workspace', 'window:install-shell-commands', (function() {
      return commandInstaller.installShellCommandsInteractively();
    }), false);
  }
  commandRegistry.add('atom-pane', {
    'pane:save-items': function() {
      return this.getModel().saveItems();
    },
    'pane:split-left': function() {
      return this.getModel().splitLeft();
    },
    'pane:split-right': function() {
      return this.getModel().splitRight();
    },
    'pane:split-up': function() {
      return this.getModel().splitUp();
    },
    'pane:split-down': function() {
      return this.getModel().splitDown();
    },
    'pane:split-left-and-copy-active-item': function() {
      return this.getModel().splitLeft({
        copyActiveItem: true
      });
    },
    'pane:split-right-and-copy-active-item': function() {
      return this.getModel().splitRight({
        copyActiveItem: true
      });
    },
    'pane:split-up-and-copy-active-item': function() {
      return this.getModel().splitUp({
        copyActiveItem: true
      });
    },
    'pane:split-down-and-copy-active-item': function() {
      return this.getModel().splitDown({
        copyActiveItem: true
      });
    },
    'pane:split-left-and-move-active-item': function() {
      return this.getModel().splitLeft({
        moveActiveItem: true
      });
    },
    'pane:split-right-and-move-active-item': function() {
      return this.getModel().splitRight({
        moveActiveItem: true
      });
    },
    'pane:split-up-and-move-active-item': function() {
      return this.getModel().splitUp({
        moveActiveItem: true
      });
    },
    'pane:split-down-and-move-active-item': function() {
      return this.getModel().splitDown({
        moveActiveItem: true
      });
    },
    'pane:close': function() {
      return this.getModel().close();
    },
    'pane:close-other-items': function() {
      return this.getModel().destroyInactiveItems();
    },
    'pane:increase-size': function() {
      return this.getModel().increaseSize();
    },
    'pane:decrease-size': function() {
      return this.getModel().decreaseSize();
    }
  }, false);
  commandRegistry.add('atom-text-editor', stopEventPropagation({
    'core:move-left': function() {
      return this.moveLeft();
    },
    'core:move-right': function() {
      return this.moveRight();
    },
    'core:select-left': function() {
      return this.selectLeft();
    },
    'core:select-right': function() {
      return this.selectRight();
    },
    'core:select-up': function() {
      return this.selectUp();
    },
    'core:select-down': function() {
      return this.selectDown();
    },
    'core:select-all': function() {
      return this.selectAll();
    },
    'editor:select-word': function() {
      return this.selectWordsContainingCursors();
    },
    'editor:consolidate-selections': function(event) {
      if (!this.consolidateSelections()) {
        return event.abortKeyBinding();
      }
    },
    'editor:move-to-beginning-of-next-paragraph': function() {
      return this.moveToBeginningOfNextParagraph();
    },
    'editor:move-to-beginning-of-previous-paragraph': function() {
      return this.moveToBeginningOfPreviousParagraph();
    },
    'editor:move-to-beginning-of-screen-line': function() {
      return this.moveToBeginningOfScreenLine();
    },
    'editor:move-to-beginning-of-line': function() {
      return this.moveToBeginningOfLine();
    },
    'editor:move-to-end-of-screen-line': function() {
      return this.moveToEndOfScreenLine();
    },
    'editor:move-to-end-of-line': function() {
      return this.moveToEndOfLine();
    },
    'editor:move-to-first-character-of-line': function() {
      return this.moveToFirstCharacterOfLine();
    },
    'editor:move-to-beginning-of-word': function() {
      return this.moveToBeginningOfWord();
    },
    'editor:move-to-end-of-word': function() {
      return this.moveToEndOfWord();
    },
    'editor:move-to-beginning-of-next-word': function() {
      return this.moveToBeginningOfNextWord();
    },
    'editor:move-to-previous-word-boundary': function() {
      return this.moveToPreviousWordBoundary();
    },
    'editor:move-to-next-word-boundary': function() {
      return this.moveToNextWordBoundary();
    },
    'editor:move-to-previous-subword-boundary': function() {
      return this.moveToPreviousSubwordBoundary();
    },
    'editor:move-to-next-subword-boundary': function() {
      return this.moveToNextSubwordBoundary();
    },
    'editor:select-to-beginning-of-next-paragraph': function() {
      return this.selectToBeginningOfNextParagraph();
    },
    'editor:select-to-beginning-of-previous-paragraph': function() {
      return this.selectToBeginningOfPreviousParagraph();
    },
    'editor:select-to-end-of-line': function() {
      return this.selectToEndOfLine();
    },
    'editor:select-to-beginning-of-line': function() {
      return this.selectToBeginningOfLine();
    },
    'editor:select-to-end-of-word': function() {
      return this.selectToEndOfWord();
    },
    'editor:select-to-beginning-of-word': function() {
      return this.selectToBeginningOfWord();
    },
    'editor:select-to-beginning-of-next-word': function() {
      return this.selectToBeginningOfNextWord();
    },
    'editor:select-to-next-word-boundary': function() {
      return this.selectToNextWordBoundary();
    },
    'editor:select-to-previous-word-boundary': function() {
      return this.selectToPreviousWordBoundary();
    },
    'editor:select-to-next-subword-boundary': function() {
      return this.selectToNextSubwordBoundary();
    },
    'editor:select-to-previous-subword-boundary': function() {
      return this.selectToPreviousSubwordBoundary();
    },
    'editor:select-to-first-character-of-line': function() {
      return this.selectToFirstCharacterOfLine();
    },
    'editor:select-line': function() {
      return this.selectLinesContainingCursors();
    },
    'editor:select-larger-syntax-node': function() {
      return this.selectLargerSyntaxNode();
    },
    'editor:select-smaller-syntax-node': function() {
      return this.selectSmallerSyntaxNode();
    }
  }), false);
  commandRegistry.add('atom-text-editor:not([readonly])', stopEventPropagation({
    'core:undo': function() {
      return this.undo();
    },
    'core:redo': function() {
      return this.redo();
    }
  }), false);
  commandRegistry.add('atom-text-editor', stopEventPropagationAndGroupUndo(config, {
    'core:copy': function() {
      return this.copySelectedText();
    },
    'editor:copy-selection': function() {
      return this.copyOnlySelectedText();
    }
  }), false);
  commandRegistry.add('atom-text-editor:not([readonly])', stopEventPropagationAndGroupUndo(config, {
    'core:backspace': function() {
      return this.backspace();
    },
    'core:delete': function() {
      return this.delete();
    },
    'core:cut': function() {
      return this.cutSelectedText();
    },
    'core:paste': function() {
      return this.pasteText();
    },
    'editor:paste-without-reformatting': function() {
      return this.pasteText({
        normalizeLineEndings: false,
        autoIndent: false,
        preserveTrailingLineIndentation: true
      });
    },
    'editor:delete-to-previous-word-boundary': function() {
      return this.deleteToPreviousWordBoundary();
    },
    'editor:delete-to-next-word-boundary': function() {
      return this.deleteToNextWordBoundary();
    },
    'editor:delete-to-beginning-of-word': function() {
      return this.deleteToBeginningOfWord();
    },
    'editor:delete-to-beginning-of-line': function() {
      return this.deleteToBeginningOfLine();
    },
    'editor:delete-to-end-of-line': function() {
      return this.deleteToEndOfLine();
    },
    'editor:delete-to-end-of-word': function() {
      return this.deleteToEndOfWord();
    },
    'editor:delete-to-beginning-of-subword': function() {
      return this.deleteToBeginningOfSubword();
    },
    'editor:delete-to-end-of-subword': function() {
      return this.deleteToEndOfSubword();
    },
    'editor:delete-line': function() {
      return this.deleteLine();
    },
    'editor:cut-to-end-of-line': function() {
      return this.cutToEndOfLine();
    },
    'editor:cut-to-end-of-buffer-line': function() {
      return this.cutToEndOfBufferLine();
    },
    'editor:transpose': function() {
      return this.transpose();
    },
    'editor:upper-case': function() {
      return this.upperCase();
    },
    'editor:lower-case': function() {
      return this.lowerCase();
    }
  }), false);
  commandRegistry.add('atom-text-editor:not([mini])', stopEventPropagation({
    'core:move-up': function() {
      return this.moveUp();
    },
    'core:move-down': function() {
      return this.moveDown();
    },
    'core:move-to-top': function() {
      return this.moveToTop();
    },
    'core:move-to-bottom': function() {
      return this.moveToBottom();
    },
    'core:page-up': function() {
      return this.pageUp();
    },
    'core:page-down': function() {
      return this.pageDown();
    },
    'core:select-to-top': function() {
      return this.selectToTop();
    },
    'core:select-to-bottom': function() {
      return this.selectToBottom();
    },
    'core:select-page-up': function() {
      return this.selectPageUp();
    },
    'core:select-page-down': function() {
      return this.selectPageDown();
    },
    'editor:add-selection-below': function() {
      return this.addSelectionBelow();
    },
    'editor:add-selection-above': function() {
      return this.addSelectionAbove();
    },
    'editor:split-selections-into-lines': function() {
      return this.splitSelectionsIntoLines();
    },
    'editor:toggle-soft-tabs': function() {
      return this.toggleSoftTabs();
    },
    'editor:toggle-soft-wrap': function() {
      return this.toggleSoftWrapped();
    },
    'editor:fold-all': function() {
      return this.foldAll();
    },
    'editor:unfold-all': function() {
      return this.unfoldAll();
    },
    'editor:fold-current-row': function() {
      this.foldCurrentRow();
      return this.scrollToCursorPosition();
    },
    'editor:unfold-current-row': function() {
      this.unfoldCurrentRow();
      return this.scrollToCursorPosition();
    },
    'editor:fold-selection': function() {
      return this.foldSelectedLines();
    },
    'editor:fold-at-indent-level-1': function() {
      this.foldAllAtIndentLevel(0);
      return this.scrollToCursorPosition();
    },
    'editor:fold-at-indent-level-2': function() {
      this.foldAllAtIndentLevel(1);
      return this.scrollToCursorPosition();
    },
    'editor:fold-at-indent-level-3': function() {
      this.foldAllAtIndentLevel(2);
      return this.scrollToCursorPosition();
    },
    'editor:fold-at-indent-level-4': function() {
      this.foldAllAtIndentLevel(3);
      return this.scrollToCursorPosition();
    },
    'editor:fold-at-indent-level-5': function() {
      this.foldAllAtIndentLevel(4);
      return this.scrollToCursorPosition();
    },
    'editor:fold-at-indent-level-6': function() {
      this.foldAllAtIndentLevel(5);
      return this.scrollToCursorPosition();
    },
    'editor:fold-at-indent-level-7': function() {
      this.foldAllAtIndentLevel(6);
      return this.scrollToCursorPosition();
    },
    'editor:fold-at-indent-level-8': function() {
      this.foldAllAtIndentLevel(7);
      return this.scrollToCursorPosition();
    },
    'editor:fold-at-indent-level-9': function() {
      this.foldAllAtIndentLevel(8);
      return this.scrollToCursorPosition();
    },
    'editor:log-cursor-scope': function() {
      return showCursorScope(this.getCursorScope(), notificationManager);
    },
    'editor:log-cursor-syntax-tree-scope': function() {
      return showSyntaxTree(this.getCursorSyntaxTreeScope(), notificationManager);
    },
    'editor:copy-path': function() {
      return copyPathToClipboard(this, project, clipboard, false);
    },
    'editor:copy-project-path': function() {
      return copyPathToClipboard(this, project, clipboard, true);
    },
    'editor:toggle-indent-guide': function() {
      return config.set('editor.showIndentGuide', !config.get('editor.showIndentGuide'));
    },
    'editor:toggle-line-numbers': function() {
      return config.set('editor.showLineNumbers', !config.get('editor.showLineNumbers'));
    },
    'editor:scroll-to-cursor': function() {
      return this.scrollToCursorPosition();
    }
  }), false);
  return commandRegistry.add('atom-text-editor:not([mini]):not([readonly])', stopEventPropagationAndGroupUndo(config, {
    'editor:indent': function() {
      return this.indent();
    },
    'editor:auto-indent': function() {
      return this.autoIndentSelectedRows();
    },
    'editor:indent-selected-rows': function() {
      return this.indentSelectedRows();
    },
    'editor:outdent-selected-rows': function() {
      return this.outdentSelectedRows();
    },
    'editor:newline': function() {
      return this.insertNewline();
    },
    'editor:newline-below': function() {
      return this.insertNewlineBelow();
    },
    'editor:newline-above': function() {
      return this.insertNewlineAbove();
    },
    'editor:toggle-line-comments': function() {
      return this.toggleLineCommentsInSelection();
    },
    'editor:checkout-head-revision': function() {
      return atom.workspace.checkoutHeadRevision(this);
    },
    'editor:move-line-up': function() {
      return this.moveLineUp();
    },
    'editor:move-line-down': function() {
      return this.moveLineDown();
    },
    'editor:move-selection-left': function() {
      return this.moveSelectionLeft();
    },
    'editor:move-selection-right': function() {
      return this.moveSelectionRight();
    },
    'editor:duplicate-lines': function() {
      return this.duplicateLines();
    },
    'editor:join-lines': function() {
      return this.joinLines();
    }
  }), false);
};
var stopEventPropagation = function(commandListeners) {
  const newCommandListeners = {};
  for (let commandName in commandListeners) {
    let commandListener = commandListeners[commandName];
    newCommandListeners[commandName] = function(event) {
      event.stopPropagation();
      return commandListener.call(this.getModel(), event);
    };
  }
  return newCommandListeners;
};
var stopEventPropagationAndGroupUndo = function(config, commandListeners) {
  const newCommandListeners = {};
  for (let commandName in commandListeners) {
    let commandListener = commandListeners[commandName];
    newCommandListeners[commandName] = function(event) {
      event.stopPropagation();
      const model = this.getModel();
      model.transact(model.getUndoGroupingInterval(),() => commandListener.call(model, event));
    };
  }
  return newCommandListeners;
};
var showCursorScope = function(descriptor, notificationManager) {
  let list = descriptor.scopes.toString().split(',');
  list = list.map((item) => `* ${item}`);
  const content = `Scopes at Cursor\n${list.join('\n')}`;
  return notificationManager.addInfo(content, {dismissable: true});
};
var showSyntaxTree = function(descriptor, notificationManager) {
  let list = descriptor.scopes.toString().split(',');
  list = list.map((item) => `* ${item}`);
  const content = `Syntax tree at Cursor\n${list.join('\n')}`;
  return notificationManager.addInfo(content, {dismissable: true});
};
var copyPathToClipboard = function(editor, project, clipboard, relative) {
  let filePath;
  if (filePath = editor.getPath()) {
    if (relative) {
      filePath = project.relativize(filePath);
    }
    clipboard.write(filePath);
  }
};

================
File: src/reopen-project-list-view.js
================
const SelectListView = require('atom-select-list');
module.exports = class ReopenProjectListView {
  constructor(callback) {
    this.callback = callback;
    this.selectListView = new SelectListView({
      emptyMessage: 'No projects in history.',
      itemsClassList: ['mark-active'],
      items: [],
      filterKeyForItem: project => project.name,
      elementForItem: project => {
        let element = document.createElement('li');
        if (project.name === this.currentProjectName) {
          element.classList.add('active');
        }
        element.textContent = project.name;
        return element;
      },
      didConfirmSelection: project => {
        this.cancel();
        this.callback(project.value);
      },
      didCancelSelection: () => {
        this.cancel();
      }
    });
    this.selectListView.element.classList.add('reopen-project');
  }
  get element() {
    return this.selectListView.element;
  }
  dispose() {
    this.cancel();
    return this.selectListView.destroy();
  }
  cancel() {
    if (this.panel != null) {
      this.panel.destroy();
    }
    this.panel = null;
    this.currentProjectName = null;
    if (this.previouslyFocusedElement) {
      this.previouslyFocusedElement.focus();
      this.previouslyFocusedElement = null;
    }
  }
  attach() {
    this.previouslyFocusedElement = document.activeElement;
    if (this.panel == null) {
      this.panel = atom.workspace.addModalPanel({ item: this });
    }
    this.selectListView.focus();
    this.selectListView.reset();
  }
  async toggle() {
    if (this.panel != null) {
      this.cancel();
    } else {
      this.currentProjectName =
        atom.project != null ? this.makeName(atom.project.getPaths()) : null;
      const projects = atom.history
        .getProjects()
        .map(p => ({ name: this.makeName(p.paths), value: p.paths }));
      await this.selectListView.update({ items: projects });
      this.attach();
    }
  }
  makeName(paths) {
    return paths.join(', ');
  }
};

================
File: src/reopen-project-menu-manager.js
================
const { CompositeDisposable } = require('event-kit');
const path = require('path');
const TASK_DESCRIPTION_MAX_LENGTH = 260;
module.exports = class ReopenProjectMenuManager {
  constructor({ menu, commands, history, config, open }) {
    this.menuManager = menu;
    this.historyManager = history;
    this.config = config;
    this.open = open;
    this.projects = [];
    this.subscriptions = new CompositeDisposable();
    this.subscriptions.add(
      history.onDidChangeProjects(this.update.bind(this)),
      config.onDidChange(
        'core.reopenProjectMenuCount',
        ({ oldValue, newValue }) => {
          this.update();
        }
      ),
      commands.add('atom-workspace', {
        'application:reopen-project': this.reopenProjectCommand.bind(this)
      })
    );
    this.applyWindowsJumpListRemovals();
  }
  reopenProjectCommand(e) {
    if (e.detail != null && e.detail.index != null) {
      this.open(this.projects[e.detail.index].paths);
    } else {
      this.createReopenProjectListView();
    }
  }
  createReopenProjectListView() {
    if (this.reopenProjectListView == null) {
      const ReopenProjectListView = require('./reopen-project-list-view');
      this.reopenProjectListView = new ReopenProjectListView(paths => {
        if (paths != null) {
          this.open(paths);
        }
      });
    }
    this.reopenProjectListView.toggle();
  }
  update() {
    this.disposeProjectMenu();
    this.projects = this.historyManager
      .getProjects()
      .slice(0, this.config.get('core.reopenProjectMenuCount'));
    const newMenu = ReopenProjectMenuManager.createProjectsMenu(this.projects);
    this.lastProjectMenu = this.menuManager.add([newMenu]);
    this.updateWindowsJumpList();
  }
  static taskDescription(paths) {
    const description = paths
      .map(path => `${ReopenProjectMenuManager.betterBaseName(path)} (${path})`)
      .join(' ');
    if (description.length > TASK_DESCRIPTION_MAX_LENGTH) {
      return description.substring(0, TASK_DESCRIPTION_MAX_LENGTH - 3) + "..."
    } else {
      return description;
    }
  }
  async applyWindowsJumpListRemovals() {
    if (process.platform !== 'win32') return;
    if (this.app === undefined) {
      this.app = require('electron').remote.app;
    }
    const removed = this.app
      .getJumpListSettings()
      .removedItems.map(i => i.description);
    if (removed.length === 0) return;
    for (let project of this.historyManager.getProjects()) {
      if (
        removed.includes(
          ReopenProjectMenuManager.taskDescription(project.paths)
        )
      ) {
        await this.historyManager.removeProject(project.paths);
      }
    }
  }
  updateWindowsJumpList() {
    if (process.platform !== 'win32') return;
    if (this.app === undefined) {
      this.app = require('electron').remote.app;
    }
    this.app.setJumpList([
      {
        type: 'custom',
        name: 'Recent Projects',
        items: this.projects.map(project => ({
          type: 'task',
          title: project.paths
            .map(ReopenProjectMenuManager.betterBaseName)
            .join(', '),
          description: ReopenProjectMenuManager.taskDescription(project.paths),
          program: process.execPath,
          args: project.paths.map(path => `"${path}"`).join(' '),
          iconPath: path.join(
            path.dirname(process.execPath),
            'resources',
            'cli',
            'folder.ico'
          ),
          iconIndex: 0
        }))
      },
      { type: 'recent' },
      {
        items: [
          {
            type: 'task',
            title: 'New Window',
            program: process.execPath,
            args: '--new-window',
            description: 'Opens a new Pulsar window'
          }
        ]
      }
    ]);
  }
  dispose() {
    this.subscriptions.dispose();
    this.disposeProjectMenu();
    if (this.reopenProjectListView != null) {
      this.reopenProjectListView.dispose();
    }
  }
  disposeProjectMenu() {
    if (this.lastProjectMenu) {
      this.lastProjectMenu.dispose();
      this.lastProjectMenu = null;
    }
  }
  static createProjectsMenu(projects) {
    return {
      label: 'File',
      id: 'File',
      submenu: [
        {
          label: 'Reopen Project',
          id: 'Reopen Project',
          submenu: projects.map((project, index) => ({
            label: this.createLabel(project),
            command: 'application:reopen-project',
            commandDetail: { index: index, paths: project.paths }
          }))
        }
      ]
    };
  }
  static createLabel(project) {
    return project.paths.length === 1
      ? project.paths[0]
      : project.paths.map(this.betterBaseName).join(', ');
  }
  static betterBaseName(directory) {
    const match = directory.match(/^([a-z]:)[\\]?$/i);
    return match ? match[1] + '\\' : path.basename(directory);
  }
};

================
File: src/replace-handler.js
================
const {PathReplacer} = require('scandal');
module.exports = function(filePaths, regexSource, regexFlags, replacementText) {
  const callback = this.async();
  const replacer = new PathReplacer();
  const regex = new RegExp(regexSource, regexFlags);
  replacer.on('file-error', ({code, path, message}) => emit('replace:file-error', {code, path, message}));
  replacer.on('path-replaced', (result) => emit('replace:path-replaced', result));
  replacer.replacePaths(regex, replacementText, filePaths, () => callback());
};

================
File: src/ripgrep-directory-searcher.js
================
const { spawn } = require('child_process');
const path = require('path');
function updateLeadingContext(message, pendingLeadingContext, options) {
  if (message.type !== 'match' && message.type !== 'context') {
    return;
  }
  if (options.leadingContextLineCount) {
    pendingLeadingContext.push(cleanResultLine(message.data.lines));
    if (pendingLeadingContext.length > options.leadingContextLineCount) {
      pendingLeadingContext.shift();
    }
  }
}
function updateTrailingContexts(message, pendingTrailingContexts, options) {
  if (message.type !== 'match' && message.type !== 'context') {
    return;
  }
  if (options.trailingContextLineCount) {
    for (const trailingContextLines of pendingTrailingContexts) {
      trailingContextLines.push(cleanResultLine(message.data.lines));
      if (trailingContextLines.length === options.trailingContextLineCount) {
        pendingTrailingContexts.delete(trailingContextLines);
      }
    }
  }
}
function cleanResultLine(resultLine) {
  resultLine = getText(resultLine);
  return resultLine[resultLine.length - 1] === '\n'
    ? resultLine.slice(0, -1)
    : resultLine;
}
function getPositionFromColumn(lines, column) {
  let currentLength = 0;
  let currentLine = 0;
  let previousLength = 0;
  while (column >= currentLength) {
    previousLength = currentLength;
    currentLength += lines[currentLine].length + 1;
    currentLine++;
  }
  return [currentLine - 1, column - previousLength];
}
function processUnicodeMatch(match) {
  const text = getText(match.lines);
  if (text.length === Buffer.byteLength(text)) {
    return;
  }
  let remainingBuffer = Buffer.from(text);
  let currentLength = 0;
  let previousPosition = 0;
  function convertPosition(position) {
    const currentBuffer = remainingBuffer.slice(0, position - previousPosition);
    currentLength = currentBuffer.toString().length + currentLength;
    remainingBuffer = remainingBuffer.slice(position);
    previousPosition = position;
    return currentLength;
  }
  for (const submatch of match.submatches) {
    submatch.start = convertPosition(submatch.start);
    submatch.end = convertPosition(submatch.end);
  }
}
function processSubmatch(submatch, lineText, offsetRow) {
  const lineParts = lineText.split('\n');
  const start = getPositionFromColumn(lineParts, submatch.start);
  const end = getPositionFromColumn(lineParts, submatch.end);
  for (let i = start[0]; i > 0; i--) {
    lineParts.shift();
  }
  while (end[0] < lineParts.length - 1) {
    lineParts.pop();
  }
  start[0] += offsetRow;
  end[0] += offsetRow;
  return {
    range: [start, end],
    lineText: cleanResultLine({ text: lineParts.join('\n') })
  };
}
function getText(input) {
  return 'text' in input
    ? input.text
    : Buffer.from(input.bytes, 'base64').toString();
}
module.exports = class RipgrepDirectorySearcher {
  canSearchDirectory() {
    return true;
  }
  search(directories, regexp, options) {
    const numPathsFound = { num: 0 };
    const allPromises = directories.map(directory =>
      this.searchInDirectory(directory, regexp, options, numPathsFound)
    );
    const promise = Promise.all(allPromises);
    promise.cancel = () => {
      for (const promise of allPromises) {
        promise.cancel();
      }
    };
    return promise;
  }
  searchInDirectory(directory, regexp, options, numPathsFound) {
    if (!this.rgPath) {
      this.rgPath = require('vscode-ripgrep').rgPath.replace(
        /\bapp\.asar\b/,
        'app.asar.unpacked'
      );
    }
    const directoryPath = directory.getPath();
    const regexpStr = this.prepareRegexp(regexp.source);
    const args = ['--json', '--regexp', regexpStr];
    if (options.leadingContextLineCount) {
      args.push('--before-context', options.leadingContextLineCount);
    }
    if (options.trailingContextLineCount) {
      args.push('--after-context', options.trailingContextLineCount);
    }
    if (regexp.ignoreCase) {
      args.push('--ignore-case');
    }
    for (const inclusion of this.prepareGlobs(
      options.inclusions,
      directoryPath
    )) {
      args.push('--glob', inclusion);
    }
    for (const exclusion of this.prepareGlobs(
      options.exclusions,
      directoryPath
    )) {
      args.push('--glob', '!' + exclusion);
    }
    if (this.isMultilineRegexp(regexpStr)) {
      args.push('--multiline');
    }
    if (options.includeHidden) {
      args.push('--hidden');
    }
    if (options.follow) {
      args.push('--follow');
    }
    if (!options.excludeVcsIgnores) {
      args.push('--no-ignore-vcs');
    }
    if (options.PCRE2) {
      args.push('--pcre2');
    }
    args.push('.');
    const child = spawn(this.rgPath, args, {
      cwd: directoryPath,
      stdio: ['pipe', 'pipe', 'pipe']
    });
    const didMatch = options.didMatch || (() => {});
    let cancelled = false;
    const returnedPromise = new Promise((resolve, reject) => {
      let buffer = '';
      let bufferError = '';
      let pendingEvent;
      let pendingLeadingContext;
      let pendingTrailingContexts;
      child.on('close', (code, signal) => {
        if (code !== null && code > 1) {
          reject(new Error(bufferError));
        } else {
          resolve();
        }
      });
      child.stderr.on('data', chunk => {
        bufferError += chunk;
      });
      child.stdout.on('data', chunk => {
        if (cancelled) {
          return;
        }
        buffer += chunk;
        const lines = buffer.split('\n');
        buffer = lines.pop();
        for (const line of lines) {
          const message = JSON.parse(line);
          updateTrailingContexts(message, pendingTrailingContexts, options);
          if (message.type === 'begin') {
            pendingEvent = {
              filePath: path.join(directoryPath, getText(message.data.path)),
              matches: []
            };
            pendingLeadingContext = [];
            pendingTrailingContexts = new Set();
          } else if (message.type === 'match') {
            const trailingContextLines = [];
            pendingTrailingContexts.add(trailingContextLines);
            processUnicodeMatch(message.data);
            for (const submatch of message.data.submatches) {
              const { lineText, range } = processSubmatch(
                submatch,
                getText(message.data.lines),
                message.data.line_number - 1
              );
              pendingEvent.matches.push({
                matchText: getText(submatch.match),
                lineText,
                lineTextOffset: 0,
                range,
                leadingContextLines: [...pendingLeadingContext],
                trailingContextLines
              });
            }
          } else if (message.type === 'end') {
            options.didSearchPaths(++numPathsFound.num);
            didMatch(pendingEvent);
            pendingEvent = null;
          }
          updateLeadingContext(message, pendingLeadingContext, options);
        }
      });
    });
    returnedPromise.cancel = () => {
      child.kill();
      cancelled = true;
    };
    return returnedPromise;
  }
  prepareGlobs(globs, projectRootPath) {
    const output = [];
    for (let pattern of globs) {
      pattern = pattern.replace(new RegExp(`\\${path.sep}`, 'g'), '/');
      if (pattern.length === 0) {
        continue;
      }
      const projectName = path.basename(projectRootPath);
      if (pattern === projectName) {
        output.push('**/*');
        continue;
      }
      if (pattern.startsWith(projectName + '/')) {
        pattern = pattern.slice(projectName.length + 1);
      }
      if (pattern.endsWith('/')) {
        pattern = pattern.slice(0, -1);
      }
      output.push(pattern);
      output.push(pattern.endsWith('/**') ? pattern : `${pattern}/**`);
    }
    return output;
  }
  prepareRegexp(regexpStr) {
    if (regexpStr === '--') {
      return '\\-\\-';
    }
    regexpStr = regexpStr.replace(/\\\//g, '/');
    return regexpStr;
  }
  isMultilineRegexp(regexpStr) {
    if (regexpStr.includes('\\n')) {
      return true;
    }
    return false;
  }
};

================
File: src/scan-handler.js
================
const path = require("path");
const async = require("async");
const {PathSearcher, PathScanner, search} = require('scandal');
module.exports = function(rootPaths, regexSource, options, searchOptions = {}) {
  const callback = this.async();
  const PATHS_COUNTER_SEARCHED_CHUNK = 50;
  var pathsSearched = 0;
  var searcher = new PathSearcher(searchOptions);
  searcher.on('file-error', function({code, path, message}) {
    return emit('scan:file-error', {code, path, message});
  });
  searcher.on('results-found', function(result) {
    return emit('scan:result-found', result);
  });
  let flags = "g";
  if (options.ignoreCase) {
    flags += "i";
  }
  var regex = new RegExp(regexSource, flags);
  return async.each(rootPaths, function(rootPath, next) {
    const options2 = Object.assign({}, options, {
      inclusions: processPaths(rootPath, options.inclusions),
      globalExclusions: processPaths(rootPath, options.globalExclusions)
    });
    const scanner = new PathScanner(rootPath, options2);
    scanner.on('path-found', function() {
      pathsSearched++;
      if (pathsSearched % PATHS_COUNTER_SEARCHED_CHUNK === 0) {
        emit('scan:paths-searched', pathsSearched);
      }
    });
    search(regex, scanner, searcher, function() {
      emit('scan:paths-searched', pathsSearched);
      next();
    });
  }, callback);
};
var processPaths = function(rootPath, paths) {
  if (paths == null || paths.length == 0) {
    return paths;
  }
  const rootPathBase = path.basename(rootPath);
  const results = [];
  for (let givenPath of paths) {
    const segments = givenPath.split(path.sep);
    const firstSegment = segments.shift();
    results.push(givenPath);
    if (firstSegment === rootPathBase) {
      if (segments.length === 0) {
        results.push(path.join("**", "*"));
      } else {
        results.push(path.join(...segments));
      }
    }
  }
  return results;
};

================
File: src/scope-descriptor.js
================
module.exports = class ScopeDescriptor {
  static fromObject(scopes) {
    if (scopes instanceof ScopeDescriptor) {
      return scopes;
    } else {
      return new ScopeDescriptor({ scopes });
    }
  }
  constructor({ scopes }) {
    this.scopes = scopes;
  }
  getScopesArray() {
    return this.scopes;
  }
  getScopeChain() {
    if (this.scopes[0] != null && this.scopes[0].includes('.')) {
      let result = '';
      for (let i = 0; i < this.scopes.length; i++) {
        const scope = this.scopes[i];
        if (i > 0) {
          result += ' ';
        }
        if (scope[0] !== '.') {
          result += '.';
        }
        result += scope;
      }
      return result;
    } else {
      return this.scopes.join(' ');
    }
  }
  toString() {
    return this.getScopeChain();
  }
  isEqual(other) {
    if (this.scopes.length !== other.scopes.length) {
      return false;
    }
    for (let i = 0; i < this.scopes.length; i++) {
      const scope = this.scopes[i];
      if (scope !== other.scopes[i]) {
        return false;
      }
    }
    return true;
  }
};

================
File: src/scope-resolver.js
================
const { CompositeDisposable } = require('event-kit');
const { Point } = require('text-buffer');
const ScopeDescriptor = require('./scope-descriptor');
function comparePoints(a, b) {
  const rows = a.row - b.row;
  if (rows === 0) {
    return a.column - b.column;
  } else {
    return rows;
  }
}
function rangeSpecToString(range) {
  let [sp, ep] = [range.startPosition, range.endPosition];
  return `(${sp.row}, ${sp.column}) - (${ep.row}, ${ep.column})`;
}
function resolveNodeDescriptor(node, descriptor) {
  let parts = descriptor.split('.');
  let result = node;
  while (result !== null && parts.length > 0) {
    let part = parts.shift();
    if (!result[part]) { return null; }
    result = result[part];
  }
  return result;
}
function resolveNodePosition(node, descriptor) {
  let parts = descriptor.split('.');
  let lastPart = parts.pop();
  let result = parts.length === 0 ?
    node :
    resolveNodeDescriptor(node, parts.join('.'));
  if (!result) { return null; }
  return result[lastPart];
}
function interpretPredicateValue(value) {
  if (value === "true") { return true; }
  if (value === "false") { return false; }
  if (/^\d+$/.test(value)) { return Number(value); }
  return value;
}
function interpretPossibleKeyValuePair(rawValue, coerceValue = false) {
  if (!rawValue.includes(' ')) { return [rawValue, null]; }
  let parts = rawValue.split(' ');
  let key = parts.shift(), value = parts.join(' ');
  if (coerceValue) value = interpretPredicateValue(value);
  return [key, value];
}
class ConfigCache {
  constructor(config) {
    this.subscriptions = new CompositeDisposable();
    this.cachesByGrammar = new Map();
    this.config = config;
    this.subscriptions.add(
      this.config.onDidChange(() => this.clearAll()),
      atom.grammars.onDidAddGrammar(() => this.clearAll()),
      atom.grammars.onDidUpdateGrammar(() => this.clearAll())
    );
  }
  dispose() {
    this.subscriptions.dispose();
  }
  clearAll() {
    for (let cache of this.cachesByGrammar.values()) {
      cache.clear();
    }
  }
  getCacheForGrammar(grammar) {
    let { scopeName } = grammar;
    let cache = this.cachesByGrammar.get(scopeName);
    if (!cache) {
      cache = new Map();
      this.cachesByGrammar.set(scopeName, cache);
    }
    return cache;
  }
}
ConfigCache.CACHES_FOR_CONFIG_OBJECTS = new Map();
ConfigCache.forConfig = (config) => {
  let { CACHES_FOR_CONFIG_OBJECTS } = ConfigCache;
  let configCache = CACHES_FOR_CONFIG_OBJECTS.get(config);
  if (!configCache) {
    configCache = new ConfigCache(config);
    CACHES_FOR_CONFIG_OBJECTS.set(config, configCache);
  }
  return configCache;
};
ConfigCache.clear = () => {
  ConfigCache.CACHES_FOR_CONFIG_OBJECTS.clear();
};
class ScopeResolver {
  constructor(languageLayer, idForScope) {
    this.languageLayer = languageLayer;
    this.buffer = languageLayer.buffer;
    this.config = languageLayer?.languageMode?.config ?? atom.config;
    this.grammar = languageLayer.grammar;
    this.idForScope = idForScope ?? (x => x);
    this.boundaries = new Map;
    this.rangeData = new Map;
    this.pointKeyCache = new Map;
    this.patternCache = new Map;
    this.configCache = ConfigCache.forConfig(this.config)
      .getCacheForGrammar(this.grammar);
  }
  getOrCompilePattern(pattern) {
    let regex = this.patternCache.get(pattern);
    if (!regex) {
      regex = new RegExp(pattern);
      this.patternCache.set(pattern, regex);
    }
    return regex;
  }
  getConfig(key) {
    if (this.configCache.has(key)) {
      return this.configCache.get(key);
    }
    let value = this.config.get(key, {
      scope: new ScopeDescriptor({ scopes: [this.grammar.scopeName] })
    });
    this.configCache.set(key, value);
    return value;
  }
  indexToPosition(index) {
    return this.buffer.positionForCharacterIndex(index);
  }
  positionToIndex(position)  {
    return this.buffer.characterIndexForPosition(position);
  }
  adjustPositionByOffset(position, offset) {
    let index = this.positionToIndex(position);
    index += offset;
    let newPosition = this.indexToPosition(index);
    return this.buffer.clipPosition(newPosition);
  }
  shouldInvalidateOnChange(capture) {
    return capture.setProperties &&
      ('highlight.invalidateOnChange' in capture.setProperties);
  }
  shouldInvalidateFoldOnChange(capture) {
    return capture.setProperties &&
      ('fold.invalidateOnChange' in capture.setProperties);
  }
  _keyForPoint(point) {
    let { row, column } = point;
    let key = `${row},${column}`;
    let normalized = this.pointKeyCache.get(key);
    if (!normalized) {
      normalized = new Point(Number(row), Number(column));
      this.pointKeyCache.set(key, normalized.freeze());
    }
    return normalized;
  }
  _keyForRange(range) {
    let { startIndex, endIndex } = range;
    return `${startIndex}/${endIndex}`;
  }
  setDataForRange(range, props) {
    let key = this._keyForRange(range);
    let normalizedProps = { ...props };
    for (let prop of ['final', 'shy']) {
      if (`test.${prop}` in normalizedProps) {
        normalizedProps[`capture.${prop}`] = normalizedProps[`test.${prop}`];
      }
    }
    return this.rangeData.set(key, normalizedProps);
  }
  getDataForRange(syntax) {
    let key = this._keyForRange(syntax);
    return this.rangeData.get(key);
  }
  isValidRange(range) {
    let { startPosition, startIndex, endPosition, endIndex } = range;
    if (!(
      typeof startIndex === 'number' &&
      typeof endIndex === 'number' &&
      typeof startPosition === 'object' &&
      typeof endPosition === 'object'
    )) { return false; }
    if (startIndex > endIndex) { return false; }
    if (comparePoints(startPosition, endPosition) >= 0) { return false; }
    return true;
  }
  adjustsCaptureRange(capture) {
    let { setProperties: props = {} } = capture;
    let keys = Object.keys(props);
    if (keys.length === 0) { return false; }
    return keys.some(k => this.capturePropertyIsAdjustment(k));
  }
  rangeExceedsBoundsOfCapture(range, capture) {
    return range.startIndex < capture.node.startIndex ||
      range.endIndex > capture.node.endIndex;
  }
  normalizeAdjustmentProperty(prop) {
    if (prop.startsWith('adjust.')) {
      prop = prop.replace(/^adjust\./, '');
    }
    return prop;
  }
  capturePropertyIsAdjustment(prop) {
    prop = this.normalizeAdjustmentProperty(prop);
    return prop in ScopeResolver.ADJUSTMENTS;
  }
  applyAdjustment(prop, ...args) {
    prop = this.normalizeAdjustmentProperty(prop);
    return ScopeResolver.ADJUSTMENTS[prop](...args);
  }
  normalizeTestProperty(prop) {
    if (prop.startsWith('test.')) {
      prop = prop.substring(5);
    }
    // TEMP: Normalize `onlyIfNotFoo` and `onlyIfFoo` to `foo`.
    if (prop.startsWith('onlyIfNot')) {
      prop = prop.charAt(9).toLowerCase() + prop.substring(10);
    }
    if (prop.startsWith('onlyIf')) {
      prop = prop.charAt(6).toLowerCase() + prop.substring(7);
    }
    return prop;
  }
  normalizeCaptureSettingProperty(prop) {
    if (prop.startsWith('capture.')) {
      prop = prop.substring(8);
    }
    if (prop === 'test.final' || prop === 'test.shy') {
      prop = prop.substring(5);
    }
    return prop;
  }
  capturePropertyIsTest(prop) {
    prop = this.normalizeTestProperty(prop);
    return prop in ScopeResolver.TESTS;
  }
  capturePropertyIsCaptureSetting(prop) {
    if (prop === 'test.final' || prop === 'test.shy') {
      return true;
    }
    if (prop.includes('.') && !prop.startsWith('capture.')) {
      return false;
    }
    prop = this.normalizeCaptureSettingProperty(prop);
    return prop in ScopeResolver.CAPTURE_SETTINGS;
  }
  applyTest(prop, ...args) {
    let isLegacyNegation = prop.includes('onlyIfNot');
    prop = this.normalizeTestProperty(prop);
    let result = ScopeResolver.TESTS[prop](...args);
    return isLegacyNegation ? !result : result;
  }
  applyCaptureSettingProperty(prop, ...args) {
    prop = this.normalizeCaptureSettingProperty(prop);
    return ScopeResolver.CAPTURE_SETTINGS[prop](...args);
  }
  warnAboutExceededRange(range, capture) {
    let msg = ['Cannot extend past original range of capture!'];
    msg.push(`Scope name: ${capture.name}`);
    msg.push(`Original range: ${rangeSpecToString(capture.node)}`);
    msg.push(`Adjusted range: ${rangeSpecToString(range)}`);
    if (atom.inDevMode()) {
      throw new Error(msg.join('\n'));
    }
    console.warn(msg.join('\n'));
  }
  determineCaptureRange(capture) {
    let { setProperties: props = {} } = capture;
    if (!this.adjustsCaptureRange(capture)) { return capture.node; }
    let range = {
      startPosition: capture.node.startPosition,
      startIndex: capture.node.startIndex,
      endPosition: capture.node.endPosition,
      endIndex: capture.node.endIndex
    };
    for (let key in props) {
      if (this.capturePropertyIsAdjustment(key)) {
        let value = props[key];
        range = this.applyAdjustment(key, capture.node, value, range, this);
        if (range === null) { return null; }
      }
    }
    if (this.rangeExceedsBoundsOfCapture(range, capture)) {
      this.warnAboutExceededRange(range, capture);
    }
    if (!this.isValidRange(range)) { return null; }
    return range;
  }
  isFinal(existingData = {}) {
    return ('capture.final' in existingData) ||
      ('final' in existingData);
  }
  test(capture, existingData) {
    let {
      node,
      setProperties: props = {},
      assertedProperties: asserted = {},
      refutedProperties: refuted = {}
    } = capture;
    if (this.isFinal(existingData)) {
      return false;
    }
    for (let key in props) {
      let isCaptureSettingProperty = this.capturePropertyIsCaptureSetting(key);
      let isTest = this.capturePropertyIsTest(key);
      if (!(isCaptureSettingProperty || isTest)) { continue; }
      let value = props[key] ?? true;
      if (isCaptureSettingProperty) {
        if (!this.applyCaptureSettingProperty(key, node, existingData, this)) {
          return false;
        }
      } else {
        if (!this.applyTest(key, node, value, existingData, this)) {
          return false;
        }
      }
    }
    for (let key in asserted) {
      if (!this.capturePropertyIsTest(key)) { continue; }
      let value = asserted[key] ?? true;
      let result = this.applyTest(key, node, value, existingData, this);
      if (!result) return false;
    }
    for (let key in refuted) {
      if (!this.capturePropertyIsTest(key)) { continue; }
      let value = refuted[key] ?? true;
      let result = this.applyTest(key, node, value, existingData, this);
      if (result) return false;
    }
    return true;
  }
  store(capture) {
    let {
      node,
      name,
      setProperties: props = {}
    } = capture;
    name = ScopeResolver.interpolateName(name, node);
    let range = this.determineCaptureRange(capture);
    if (range === null) {
      return false;
    }
    let data = this.getDataForRange(range);
    if (!this.test(capture, data)) {
      return false;
    } else {
      this.setDataForRange(range, props);
    }
    if (name === '_IGNORE_' || name.startsWith('_IGNORE_.')) {
      return false;
    }
    let id = this.idForScope(
        name,
        node.childCount === 0 ? node.text : undefined,
    );
    let {
      startPosition: start,
      endPosition: end
    } = range;
    this.setBoundary(start, id, 'open');
    this.setBoundary(end, id, 'close');
    return range;
  }
  setBoundary(point, id, which, { root = false } = {}) {
    let key = this._keyForPoint(point);
      if (!this.boundaries.has(key)) {
      this.boundaries.set(key, { open: [], close: [] })
    }
    let bundle = this.boundaries.get(key);
    let idBundle = bundle[which];
    if (which === 'open') {
      if (root) { idBundle.unshift(id); }
      else { idBundle.push(id); }
    } else {
      if (root) { idBundle.push(id); }
      else { idBundle.unshift(id); }
    }
  }
  reset() {
    this.boundaries.clear();
    this.rangeData.clear();
  }
  destroy() {
    this.reset();
    this.patternCache.clear();
    this.pointKeyCache.clear();
  }
  *[Symbol.iterator]() {
    let keys = [...this.boundaries.keys()];
    keys.sort((a, b) => a.compare(b));
    for (let key of keys) {
      yield [key, this.boundaries.get(key)];
    }
  }
}
ScopeResolver.interpolateName = (name, node) => {
  if (name.includes('_TEXT_') &&
   !node.text.includes(' ')) {
    name = name.replace('_TEXT_', node.text);
  }
  if (name.includes('_TYPE_')) {
    name = name.replace('_TYPE_', node.type);
  }
  return name;
};
ScopeResolver.CAPTURE_SETTINGS = {
  final(_node, existingData) {
    if (!existingData) return true;
    return !('capture.final' in existingData) && !('final' in existingData);
  },
  shy(_node, existingData) {
    return existingData === undefined;
  }
};
ScopeResolver.TESTS = {
  type(node, nodeType) {
    if (!nodeType.includes(' ')) { return node.type === nodeType }
    let nodeTypes = nodeType.split(/\s+/);
    return nodeTypes.some(t => t === node.type);
  },
  hasError(node) {
    return node.hasError;
  },
  injection(node, value, existingData, instance) {
    return instance.languageLayer.depth > 0;
  },
  root(node) {
    return !node.parent;
  },
  first(node) {
    if (!node.parent) { return true; }
    return node?.parent?.firstChild?.id === node.id;
  },
  last(node) {
    if (!node.parent) { return true; }
    return node?.parent?.lastChild?.id === node.id;
  },
  firstOfType(node) {
    if (!node.parent) { return true; }
    let type = node.type;
    let parent = node.parent;
    if ((parent?.childCount ?? 0) === 0) { return false; }
    for (let i = 0; i < parent.childCount; i++) {
      let child = parent?.child(i);
      if (!child) { continue; }
      if (child?.id === node.id) { return true; }
      else if (child?.type === type) { return false; }
    }
    return false;
  },
  lastOfType(node) {
    if (!node.parent) { return true; }
    let type = node.type;
    let parent = node.parent;
    if ((parent?.childCount ?? 0) === 0) { return false; }
    for (let i = parent.childCount - 1; i >= 0; i--) {
      let child = parent?.child(i);
      if (!child) { continue; }
      if (child?.id === node.id) { return true; }
      else if (child?.type === type) { return false; }
    }
    return false;
  },
  lastTextOnRow(node, value, existingData, instance) {
    let { buffer } = instance;
    let text = buffer.lineForRow(node.endPosition.row);
    let textAfterNode = text.slice(node.endPosition.column);
    return !/\S/.test(textAfterNode);
  },
  firstTextOnRow(node, value, existingData, instance) {
    let { buffer } = instance;
    let text = buffer.lineForRow(node.startPosition.row);
    let textBeforeNode = text.slice(0, node.startPosition.column);
    return !/\S/.test(textBeforeNode);
  },
  descendantOfType(node, type) {
    let multiple = type.includes(' ');
    let target = multiple ? type.split(/\s+/) : type;
    let current = node;
    while (current.parent) {
      current = current.parent;
      if (multiple && target.includes(current.type)) { return true; }
      else if (!multiple && target === current.type) { return true; }
    }
    return false;
  },
  ancestorTypeNearerThan(node, types) {
    let [target, ...rejected] = types.split(/\s+/);
    rejected = new Set(rejected)
    let current = node;
    while (current.parent) {
      current = current.parent;
      if (rejected.has(current.type)) { return false; }
      if (target === current.type) { return true; }
    }
    return false;
  },
  ancestorOfType(node, type) {
    let target = type.includes(' ') ? type.split(/\s+/) : type;
    let descendants = node.descendantsOfType(target);
    return descendants.length > 0;
  },
  rangeWithData(node, rawValue, existingData) {
    if (existingData === undefined) { return false; }
    let [key, value] = interpretPossibleKeyValuePair(rawValue, false);
    if (!key) { return true; }
    return (value !== null) ?
      existingData[key] === value :
      (key in existingData);
  },
  descendantOfNodeWithData(node, rawValue, existingData, instance) {
    let current = node;
    let [key, value] = interpretPossibleKeyValuePair(rawValue, false);
    if (!key) { return true; }
    while (current.parent) {
      current = current.parent;
      let data = instance.getDataForRange(current);
      if (data === undefined) { continue; }
      let passes = (value !== null) ? data[key] === value : (key in data);
      if (passes) { return true; }
    }
    return false;
  },
  startsOnSameRowAs(node, descriptor) {
    let otherNodePosition = resolveNodePosition(node, descriptor);
    if (!otherNodePosition) return false
    return otherNodePosition.row === node.startPosition.row;
  },
  endsOnSameRowAs(node, descriptor) {
    let otherNodePosition = resolveNodePosition(node, descriptor);
    if (!otherNodePosition) return false
    return otherNodePosition.row === node.endPosition.row;
  },
  config(node, rawValue, existingData, instance) {
    let [key, value] = interpretPossibleKeyValuePair(rawValue, true);
    if (!key) { return true; }
    let configValue = instance.getConfig(key) ?? false;
    return value === null ? !!configValue : configValue === value;
  }
};
ScopeResolver.ADJUSTMENTS = {
  startAt(node, value, range, resolver) {
    let start = resolveNodePosition(node, value);
    if (!start) { return null; }
    range.startPosition = start;
    range.startIndex = resolver.positionToIndex(range.startPosition);
    return range;
  },
  endAt(node, value, range, resolver) {
    let end = resolveNodePosition(node, value);
    if (!end) { return null; }
    range.endPosition = end;
    range.endIndex = resolver.positionToIndex(range.endPosition);
    return range;
  },
  offsetStart(node, value, range, resolver) {
    let offset = Number(value);
    if (isNaN(offset)) { return null; }
    let { startPosition } = range;
    let offsetPosition = resolver.adjustPositionByOffset(startPosition, offset);
    let offsetIndex = resolver.positionToIndex(offsetPosition);
    range.startPosition = offsetPosition;
    range.startIndex = offsetIndex;
    return range;
  },
  offsetEnd(node, value, range, resolver) {
    let offset = Number(value);
    if (isNaN(offset)) { return null; }
    let { endPosition } = range;
    let offsetPosition = resolver.adjustPositionByOffset(endPosition, offset);
    let offsetIndex = resolver.positionToIndex(offsetPosition);
    range.endPosition = offsetPosition;
    range.endIndex = offsetIndex;
    return range;
  },
  startAndEndAroundFirstMatchOf(node, value, position, resolver) {
    let regex = resolver.getOrCompilePattern(value);
    let match = node.text.match(regex);
    if (!match) { return null; }
    let oldStartPosition = { ...node.startPosition };
    let startOffset = match.index;
    let endOffset = match.index + match[0].length;
    position.startPosition = resolver.adjustPositionByOffset(
      oldStartPosition, startOffset);
    position.endPosition = resolver.adjustPositionByOffset(
      oldStartPosition, endOffset);
    position.startIndex = resolver.positionToIndex(position.startPosition);
    position.endIndex = resolver.positionToIndex(position.endPosition);
    return position;
  },
  startBeforeFirstMatchOf(node, value, position, resolver) {
    let regex = resolver.getOrCompilePattern(value);
    let match = node.text.match(regex);
    if (!match) { return null; }
    let oldStartPosition = { ...node.startPosition };
    let startOffset = match.index;
    position.startPosition = resolver.adjustPositionByOffset(
      oldStartPosition, startOffset);
    position.startIndex = resolver.positionToIndex(position.startPosition);
    return position;
  },
  startAfterFirstMatchOf(node, value, position, resolver) {
    let regex = resolver.getOrCompilePattern(value);
    let match = node.text.match(regex);
    if (!match) { return null; }
    let oldStartPosition = { ...node.startPosition };
    let startOffset = match.index + match[0].length;
    position.startPosition = resolver.adjustPositionByOffset(
      oldStartPosition, startOffset);
    position.startIndex = resolver.positionToIndex(position.startPosition);
    return position;
  },
  endBeforeFirstMatchOf(node, value, position, resolver) {
    let regex = resolver.getOrCompilePattern(value);
    let match = node.text.match(regex);
    if (!match) { return null; }
    let oldStartPosition = { ...node.startPosition };
    let endOffset = match.index;
    position.endPosition = resolver.adjustPositionByOffset(
      oldStartPosition, endOffset);
    position.endIndex = resolver.positionToIndex(position.endPosition);
    return position;
  },
  endAfterFirstMatchOf(node, value, position, resolver) {
    let regex = resolver.getOrCompilePattern(value);
    let match = node.text.match(regex);
    if (!match) { return null; }
    let oldStartPosition = { ...node.startPosition };
    let endOffset = match.index + match[0].length;
    position.endPosition = resolver.adjustPositionByOffset(
      oldStartPosition, endOffset);
    position.endIndex = resolver.positionToIndex(position.endPosition);
    return position;
  }
};
ScopeResolver.clearConfigCache = () => {
  ConfigCache.clear();
};
module.exports = ScopeResolver;

================
File: src/selection.js
================
const { Point, Range } = require('text-buffer');
const { pick } = require('underscore-plus');
const { Emitter } = require('event-kit');
const NonWhitespaceRegExp = /\S/;
let nextId = 0;
module.exports = class Selection {
  constructor({ cursor, marker, editor, id }) {
    this.id = id != null ? id : nextId++;
    this.cursor = cursor;
    this.marker = marker;
    this.editor = editor;
    this.emitter = new Emitter();
    this.initialScreenRange = null;
    this.wordwise = false;
    this.cursor.selection = this;
    this.decoration = this.editor.decorateMarker(this.marker, {
      type: 'highlight',
      class: 'selection'
    });
    this.marker.onDidChange(e => this.markerDidChange(e));
    this.marker.onDidDestroy(() => this.markerDidDestroy());
  }
  destroy() {
    this.marker.destroy();
  }
  isLastSelection() {
    return this === this.editor.getLastSelection();
  }
  onDidChangeRange(callback) {
    return this.emitter.on('did-change-range', callback);
  }
  onDidDestroy(callback) {
    return this.emitter.once('did-destroy', callback);
  }
  getScreenRange() {
    return this.marker.getScreenRange();
  }
  setScreenRange(screenRange, options) {
    return this.setBufferRange(
      this.editor.bufferRangeForScreenRange(screenRange),
      options
    );
  }
  getBufferRange() {
    return this.marker.getBufferRange();
  }
  setBufferRange(bufferRange, options = {}) {
    bufferRange = Range.fromObject(bufferRange);
    if (options.reversed == null) options.reversed = this.isReversed();
    if (!options.preserveFolds)
      this.editor.destroyFoldsContainingBufferPositions(
        [bufferRange.start, bufferRange.end],
        true
      );
    this.modifySelection(() => {
      const needsFlash = options.flash;
      options.flash = null;
      this.marker.setBufferRange(bufferRange, options);
      const autoscroll =
        options.autoscroll != null
          ? options.autoscroll
          : this.isLastSelection();
      if (autoscroll) this.autoscroll();
      if (needsFlash)
        this.decoration.flash('flash', this.editor.selectionFlashDuration);
    });
  }
  getBufferRowRange() {
    const range = this.getBufferRange();
    const start = range.start.row;
    let end = range.end.row;
    if (range.end.column === 0) end = Math.max(start, end - 1);
    return [start, end];
  }
  getTailScreenPosition() {
    return this.marker.getTailScreenPosition();
  }
  getTailBufferPosition() {
    return this.marker.getTailBufferPosition();
  }
  getHeadScreenPosition() {
    return this.marker.getHeadScreenPosition();
  }
  getHeadBufferPosition() {
    return this.marker.getHeadBufferPosition();
  }
  isEmpty() {
    return this.getBufferRange().isEmpty();
  }
  isReversed() {
    return this.marker.isReversed();
  }
  isSingleScreenLine() {
    return this.getScreenRange().isSingleLine();
  }
  getText() {
    return this.editor.buffer.getTextInRange(this.getBufferRange());
  }
  intersectsBufferRange(bufferRange) {
    return this.getBufferRange().intersectsWith(bufferRange);
  }
  intersectsScreenRowRange(startRow, endRow) {
    return this.getScreenRange().intersectsRowRange(startRow, endRow);
  }
  intersectsScreenRow(screenRow) {
    return this.getScreenRange().intersectsRow(screenRow);
  }
  intersectsWith(otherSelection, exclusive) {
    return this.getBufferRange().intersectsWith(
      otherSelection.getBufferRange(),
      exclusive
    );
  }
  clear(options) {
    this.goalScreenRange = null;
    if (!this.retainSelection) this.marker.clearTail();
    const autoscroll =
      options && options.autoscroll != null
        ? options.autoscroll
        : this.isLastSelection();
    if (autoscroll) this.autoscroll();
    this.finalize();
  }
  selectToScreenPosition(position, options) {
    position = Point.fromObject(position);
    this.modifySelection(() => {
      if (this.initialScreenRange) {
        if (position.isLessThan(this.initialScreenRange.start)) {
          this.marker.setScreenRange([position, this.initialScreenRange.end], {
            reversed: true
          });
        } else {
          this.marker.setScreenRange(
            [this.initialScreenRange.start, position],
            { reversed: false }
          );
        }
      } else {
        this.cursor.setScreenPosition(position, options);
      }
      if (this.linewise) {
        this.expandOverLine(options);
      } else if (this.wordwise) {
        this.expandOverWord(options);
      }
    });
  }
  selectToBufferPosition(position) {
    this.modifySelection(() => this.cursor.setBufferPosition(position));
  }
  selectRight(columnCount) {
    this.modifySelection(() => this.cursor.moveRight(columnCount));
  }
  selectLeft(columnCount) {
    this.modifySelection(() => this.cursor.moveLeft(columnCount));
  }
  selectUp(rowCount) {
    this.modifySelection(() => this.cursor.moveUp(rowCount));
  }
  selectDown(rowCount) {
    this.modifySelection(() => this.cursor.moveDown(rowCount));
  }
  selectToTop() {
    this.modifySelection(() => this.cursor.moveToTop());
  }
  selectToBottom() {
    this.modifySelection(() => this.cursor.moveToBottom());
  }
  selectAll() {
    this.setBufferRange(this.editor.buffer.getRange(), { autoscroll: false });
  }
  selectToBeginningOfLine() {
    this.modifySelection(() => this.cursor.moveToBeginningOfLine());
  }
  selectToFirstCharacterOfLine() {
    this.modifySelection(() => this.cursor.moveToFirstCharacterOfLine());
  }
  selectToEndOfLine() {
    this.modifySelection(() => this.cursor.moveToEndOfScreenLine());
  }
  selectToEndOfBufferLine() {
    this.modifySelection(() => this.cursor.moveToEndOfLine());
  }
  selectToBeginningOfWord() {
    this.modifySelection(() => this.cursor.moveToBeginningOfWord());
  }
  selectToEndOfWord() {
    this.modifySelection(() => this.cursor.moveToEndOfWord());
  }
  selectToBeginningOfNextWord() {
    this.modifySelection(() => this.cursor.moveToBeginningOfNextWord());
  }
  selectToPreviousWordBoundary() {
    this.modifySelection(() => this.cursor.moveToPreviousWordBoundary());
  }
  selectToNextWordBoundary() {
    this.modifySelection(() => this.cursor.moveToNextWordBoundary());
  }
  selectToPreviousSubwordBoundary() {
    this.modifySelection(() => this.cursor.moveToPreviousSubwordBoundary());
  }
  selectToNextSubwordBoundary() {
    this.modifySelection(() => this.cursor.moveToNextSubwordBoundary());
  }
  selectToBeginningOfNextParagraph() {
    this.modifySelection(() => this.cursor.moveToBeginningOfNextParagraph());
  }
  selectToBeginningOfPreviousParagraph() {
    this.modifySelection(() =>
      this.cursor.moveToBeginningOfPreviousParagraph()
    );
  }
  selectWord(options = {}) {
    if (this.cursor.isSurroundedByWhitespace()) options.wordRegex = /[\t ]*/;
    if (this.cursor.isBetweenWordAndNonWord()) {
      options.includeNonWordCharacters = false;
    }
    this.setBufferRange(
      this.cursor.getCurrentWordBufferRange(options),
      options
    );
    this.wordwise = true;
    this.initialScreenRange = this.getScreenRange();
  }
  expandOverWord(options) {
    this.setBufferRange(
      this.getBufferRange().union(this.cursor.getCurrentWordBufferRange()),
      { autoscroll: false }
    );
    const autoscroll =
      options && options.autoscroll != null
        ? options.autoscroll
        : this.isLastSelection();
    if (autoscroll) this.cursor.autoscroll();
  }
  selectLine(row, options) {
    if (row != null) {
      this.setBufferRange(
        this.editor.bufferRangeForBufferRow(row, { includeNewline: true }),
        options
      );
    } else {
      const startRange = this.editor.bufferRangeForBufferRow(
        this.marker.getStartBufferPosition().row
      );
      const endRange = this.editor.bufferRangeForBufferRow(
        this.marker.getEndBufferPosition().row,
        { includeNewline: true }
      );
      this.setBufferRange(startRange.union(endRange), options);
    }
    this.linewise = true;
    this.wordwise = false;
    this.initialScreenRange = this.getScreenRange();
  }
  expandOverLine(options) {
    const range = this.getBufferRange().union(
      this.cursor.getCurrentLineBufferRange({ includeNewline: true })
    );
    this.setBufferRange(range, { autoscroll: false });
    const autoscroll =
      options && options.autoscroll != null
        ? options.autoscroll
        : this.isLastSelection();
    if (autoscroll) this.cursor.autoscroll();
  }
  ensureWritable(methodName, opts) {
    if (!opts.bypassReadOnly && this.editor.isReadOnly()) {
      if (atom.inDevMode() || atom.inSpecMode()) {
        const e = new Error(
          'Attempt to mutate a read-only TextEditor through a Selection'
        );
        e.detail =
          `Your package is attempting to call ${methodName} on a selection within an editor that has been marked ` +
          ' read-only. Pass {bypassReadOnly: true} to modify it anyway, or test editors with .isReadOnly() before ' +
          ' attempting modifications.';
        throw e;
      }
      return false;
    }
    return true;
  }
  insertText(text, options = {}) {
    if (!this.ensureWritable('insertText', options)) return;
    let desiredIndentLevel, indentAdjustment;
    const oldBufferRange = this.getBufferRange();
    const wasReversed = this.isReversed();
    this.clear(options);
    let autoIndentFirstLine = false;
    const precedingText = this.editor.getTextInRange([
      [oldBufferRange.start.row, 0],
      oldBufferRange.start
    ]);
    const remainingLines = text.split('\n');
    const firstInsertedLine = remainingLines.shift();
    if (
      options.indentBasis != null &&
      !options.preserveTrailingLineIndentation
    ) {
      indentAdjustment =
        this.editor.indentLevelForLine(precedingText) - options.indentBasis;
      this.adjustIndent(remainingLines, indentAdjustment);
    }
    const textIsAutoIndentable =
      text === '\n' || text === '\r\n' || NonWhitespaceRegExp.test(text);
    if (
      options.autoIndent &&
      textIsAutoIndentable &&
      !NonWhitespaceRegExp.test(precedingText) &&
      remainingLines.length > 0
    ) {
      autoIndentFirstLine = true;
      const firstLine = precedingText + firstInsertedLine;
      const languageMode = this.editor.buffer.getLanguageMode();
      desiredIndentLevel =
        languageMode.suggestedIndentForLineAtBufferRow &&
        languageMode.suggestedIndentForLineAtBufferRow(
          oldBufferRange.start.row,
          firstLine,
          this.editor.getTabLength()
        );
      if (desiredIndentLevel != null) {
        indentAdjustment =
          desiredIndentLevel - this.editor.indentLevelForLine(firstLine);
        this.adjustIndent(remainingLines, indentAdjustment);
      }
    }
    text = firstInsertedLine;
    if (remainingLines.length > 0) text += `\n${remainingLines.join('\n')}`;
    const newBufferRange = this.editor.buffer.setTextInRange(
      oldBufferRange,
      text,
      pick(options, 'undo', 'normalizeLineEndings')
    );
    if (options.select) {
      this.setBufferRange(newBufferRange, { reversed: wasReversed });
    } else {
      if (wasReversed) this.cursor.setBufferPosition(newBufferRange.end);
    }
    if (autoIndentFirstLine) {
      this.editor.setIndentationForBufferRow(
        oldBufferRange.start.row,
        desiredIndentLevel
      );
    }
    if (options.autoIndentNewline && text === '\n') {
      this.editor.autoIndentBufferRow(newBufferRange.end.row, {
        preserveLeadingWhitespace: true,
        skipBlankLines: false
      });
    } else if (options.autoDecreaseIndent && NonWhitespaceRegExp.test(text)) {
      this.editor.autoDecreaseIndentForBufferRow(newBufferRange.start.row);
    }
    const autoscroll =
      options.autoscroll != null ? options.autoscroll : this.isLastSelection();
    if (autoscroll) this.autoscroll();
    return newBufferRange;
  }
  backspace(options = {}) {
    if (!this.ensureWritable('backspace', options)) return;
    if (this.isEmpty()) this.selectLeft();
    this.deleteSelectedText(options);
  }
  deleteToPreviousWordBoundary(options = {}) {
    if (!this.ensureWritable('deleteToPreviousWordBoundary', options)) return;
    if (this.isEmpty()) this.selectToPreviousWordBoundary();
    this.deleteSelectedText(options);
  }
  deleteToNextWordBoundary(options = {}) {
    if (!this.ensureWritable('deleteToNextWordBoundary', options)) return;
    if (this.isEmpty()) this.selectToNextWordBoundary();
    this.deleteSelectedText(options);
  }
  deleteToBeginningOfWord(options = {}) {
    if (!this.ensureWritable('deleteToBeginningOfWord', options)) return;
    if (this.isEmpty()) this.selectToBeginningOfWord();
    this.deleteSelectedText(options);
  }
  deleteToBeginningOfLine(options = {}) {
    if (!this.ensureWritable('deleteToBeginningOfLine', options)) return;
    if (this.isEmpty() && this.cursor.isAtBeginningOfLine()) {
      this.selectLeft();
    } else {
      this.selectToBeginningOfLine();
    }
    this.deleteSelectedText(options);
  }
  delete(options = {}) {
    if (!this.ensureWritable('delete', options)) return;
    if (this.isEmpty()) this.selectRight();
    this.deleteSelectedText(options);
  }
  deleteToEndOfLine(options = {}) {
    if (!this.ensureWritable('deleteToEndOfLine', options)) return;
    if (this.isEmpty()) {
      if (this.cursor.isAtEndOfLine()) {
        this.delete(options);
        return;
      }
      this.selectToEndOfLine();
    }
    this.deleteSelectedText(options);
  }
  deleteToEndOfWord(options = {}) {
    if (!this.ensureWritable('deleteToEndOfWord', options)) return;
    if (this.isEmpty()) this.selectToEndOfWord();
    this.deleteSelectedText(options);
  }
  deleteToBeginningOfSubword(options = {}) {
    if (!this.ensureWritable('deleteToBeginningOfSubword', options)) return;
    if (this.isEmpty()) this.selectToPreviousSubwordBoundary();
    this.deleteSelectedText(options);
  }
  deleteToEndOfSubword(options = {}) {
    if (!this.ensureWritable('deleteToEndOfSubword', options)) return;
    if (this.isEmpty()) this.selectToNextSubwordBoundary();
    this.deleteSelectedText(options);
  }
  deleteSelectedText(options = {}) {
    if (!this.ensureWritable('deleteSelectedText', options)) return;
    const bufferRange = this.getBufferRange();
    if (!bufferRange.isEmpty()) this.editor.buffer.delete(bufferRange);
    if (this.cursor) this.cursor.setBufferPosition(bufferRange.start);
  }
  deleteLine(options = {}) {
    if (!this.ensureWritable('deleteLine', options)) return;
    const range = this.getBufferRange();
    if (range.isEmpty()) {
      const start = this.cursor.getScreenRow();
      const range = this.editor.bufferRowsForScreenRows(start, start + 1);
      if (range[1] > range[0]) {
        this.editor.buffer.deleteRows(range[0], range[1] - 1);
      } else {
        this.editor.buffer.deleteRow(range[0]);
      }
    } else {
      const start = range.start.row;
      let end = range.end.row;
      if (end !== this.editor.buffer.getLastRow() && range.end.column === 0)
        end--;
      this.editor.buffer.deleteRows(start, end);
    }
    this.cursor.setBufferPosition({
      row: this.cursor.getBufferRow(),
      column: range.start.column
    });
  }
  joinLines(options = {}) {
    if (!this.ensureWritable('joinLines', options)) return;
    let joinMarker;
    const selectedRange = this.getBufferRange();
    if (selectedRange.isEmpty()) {
      if (selectedRange.start.row === this.editor.buffer.getLastRow()) return;
    } else {
      joinMarker = this.editor.markBufferRange(selectedRange, {
        invalidate: 'never'
      });
    }
    const rowCount = Math.max(1, selectedRange.getRowCount() - 1);
    for (let i = 0; i < rowCount; i++) {
      this.cursor.setBufferPosition([selectedRange.start.row]);
      this.cursor.moveToEndOfLine();
      const scanRange = this.cursor.getCurrentLineBufferRange();
      let trailingWhitespaceRange = null;
      this.editor.scanInBufferRange(/[ \t]+$/, scanRange, ({ range }) => {
        trailingWhitespaceRange = range;
      });
      if (trailingWhitespaceRange) {
        this.setBufferRange(trailingWhitespaceRange);
        this.deleteSelectedText(options);
      }
      const currentRow = selectedRange.start.row;
      const nextRow = currentRow + 1;
      const insertSpace =
        nextRow <= this.editor.buffer.getLastRow() &&
        this.editor.buffer.lineLengthForRow(nextRow) > 0 &&
        this.editor.buffer.lineLengthForRow(currentRow) > 0;
      if (insertSpace) this.insertText(' ', options);
      this.cursor.moveToEndOfLine();
      this.modifySelection(() => {
        this.cursor.moveRight();
        this.cursor.moveToFirstCharacterOfLine();
      });
      this.deleteSelectedText(options);
      if (insertSpace) this.cursor.moveLeft();
    }
    if (joinMarker) {
      const newSelectedRange = joinMarker.getBufferRange();
      this.setBufferRange(newSelectedRange);
      joinMarker.destroy();
    }
  }
  outdentSelectedRows(options = {}) {
    if (!this.ensureWritable('outdentSelectedRows', options)) return;
    const [start, end] = this.getBufferRowRange();
    const { buffer } = this.editor;
    const leadingTabRegex = new RegExp(
      `^( {1,${this.editor.getTabLength()}}|\t)`
    );
    for (let row = start; row <= end; row++) {
      const match = buffer.lineForRow(row).match(leadingTabRegex);
      if (match && match[0].length > 0) {
        buffer.delete([[row, 0], [row, match[0].length]]);
      }
    }
  }
  autoIndentSelectedRows(options = {}) {
    if (!this.ensureWritable('autoIndentSelectedRows', options)) return;
    const [start, end] = this.getBufferRowRange();
    return this.editor.autoIndentBufferRows(start, end);
  }
  toggleLineComments(options = {}) {
    if (!this.ensureWritable('toggleLineComments', options)) return;
    let bufferRowRange = this.getBufferRowRange() || [null, null];
    this.editor.toggleLineCommentsForBufferRows(...bufferRowRange, {
      correctSelection: true,
      selection: this
    });
  }
  cutToEndOfLine(maintainClipboard, options = {}) {
    if (!this.ensureWritable('cutToEndOfLine', options)) return;
    if (this.isEmpty()) this.selectToEndOfLine();
    return this.cut(maintainClipboard, false, options.bypassReadOnly);
  }
  cutToEndOfBufferLine(maintainClipboard, options = {}) {
    if (!this.ensureWritable('cutToEndOfBufferLine', options)) return;
    if (this.isEmpty()) this.selectToEndOfBufferLine();
    this.cut(maintainClipboard, false, options.bypassReadOnly);
  }
  cut(maintainClipboard = false, fullLine = false, bypassReadOnly = false) {
    if (!this.ensureWritable('cut', { bypassReadOnly })) return;
    this.copy(maintainClipboard, fullLine);
    this.delete({ bypassReadOnly });
  }
  copy(maintainClipboard = false, fullLine = false) {
    if (this.isEmpty()) return;
    const { start, end } = this.getBufferRange();
    const selectionText = this.editor.getTextInRange([start, end]);
    const precedingText = this.editor.getTextInRange([[start.row, 0], start]);
    const startLevel = this.editor.indentLevelForLine(precedingText);
    if (maintainClipboard) {
      let {
        text: clipboardText,
        metadata
      } = this.editor.constructor.clipboard.readWithMetadata();
      if (!metadata) metadata = {};
      if (!metadata.selections) {
        metadata.selections = [
          {
            text: clipboardText,
            indentBasis: metadata.indentBasis,
            fullLine: metadata.fullLine
          }
        ];
      }
      metadata.selections.push({
        text: selectionText,
        indentBasis: startLevel,
        fullLine
      });
      this.editor.constructor.clipboard.write(
        [clipboardText, selectionText].join('\n'),
        metadata
      );
    } else {
      this.editor.constructor.clipboard.write(selectionText, {
        indentBasis: startLevel,
        fullLine
      });
    }
  }
  fold() {
    const range = this.getBufferRange();
    if (!range.isEmpty()) {
      this.editor.foldBufferRange(range);
      this.cursor.setBufferPosition(range.end);
    }
  }
  adjustIndent(lines, indentAdjustment) {
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      if (indentAdjustment === 0 || line === '') {
        continue;
      } else if (indentAdjustment > 0) {
        lines[i] = this.editor.buildIndentString(indentAdjustment) + line;
      } else {
        const currentIndentLevel = this.editor.indentLevelForLine(lines[i]);
        const indentLevel = Math.max(0, currentIndentLevel + indentAdjustment);
        lines[i] = line.replace(
          /^[\t ]+/,
          this.editor.buildIndentString(indentLevel)
        );
      }
    }
  }
  // Indent the current line(s).
  //
  // If the selection is empty, indents the current line if the cursor precedes
  // non-whitespace characters, and otherwise inserts a tab. If the selection is
  // non empty, calls {::indentSelectedRows}.
  //
  // * `options` (optional) {Object} with the keys:
  //   * `autoIndent` If `true`, the line is indented to an automatically-inferred
  //     level. Otherwise, {TextEditor::getTabText} is inserted.
  //   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify text within a read-only editor. (default: false)
  indent({ autoIndent, bypassReadOnly } = {}) {
    if (!this.ensureWritable('indent', { bypassReadOnly })) return;
    const { row } = this.cursor.getBufferPosition();
    if (this.isEmpty()) {
      this.cursor.skipLeadingWhitespace();
      const desiredIndent = this.editor.suggestedIndentForBufferRow(row);
      let delta = desiredIndent - this.cursor.getIndentLevel();
      if (autoIndent && delta > 0) {
        if (!this.editor.getSoftTabs()) delta = Math.max(delta, 1);
        this.insertText(this.editor.buildIndentString(delta), {
          bypassReadOnly
        });
      } else {
        this.insertText(
          this.editor.buildIndentString(1, this.cursor.getBufferColumn()),
          { bypassReadOnly }
        );
      }
    } else {
      this.indentSelectedRows({ bypassReadOnly });
    }
  }
  indentSelectedRows(options = {}) {
    if (!this.ensureWritable('indentSelectedRows', options)) return;
    const [start, end] = this.getBufferRowRange();
    for (let row = start; row <= end; row++) {
      if (this.editor.buffer.lineLengthForRow(row) !== 0) {
        this.editor.buffer.insert([row, 0], this.editor.getTabText());
      }
    }
  }
  addSelectionBelow() {
    const range = this.getGoalScreenRange().copy();
    const nextRow = range.end.row + 1;
    for (
      let row = nextRow, end = this.editor.getLastScreenRow();
      row <= end;
      row++
    ) {
      range.start.row = row;
      range.end.row = row;
      const clippedRange = this.editor.clipScreenRange(range, {
        skipSoftWrapIndentation: true
      });
      if (range.isEmpty()) {
        if (range.end.column > 0 && clippedRange.end.column === 0) continue;
      } else {
        if (clippedRange.isEmpty()) continue;
      }
      const containingSelections = this.editor.selectionsMarkerLayer.findMarkers(
        { containsScreenRange: clippedRange }
      );
      if (containingSelections.length === 0) {
        const selection = this.editor.addSelectionForScreenRange(clippedRange);
        selection.setGoalScreenRange(range);
      }
      break;
    }
  }
  addSelectionAbove() {
    const range = this.getGoalScreenRange().copy();
    const previousRow = range.end.row - 1;
    for (let row = previousRow; row >= 0; row--) {
      range.start.row = row;
      range.end.row = row;
      const clippedRange = this.editor.clipScreenRange(range, {
        skipSoftWrapIndentation: true
      });
      if (range.isEmpty()) {
        if (range.end.column > 0 && clippedRange.end.column === 0) continue;
      } else {
        if (clippedRange.isEmpty()) continue;
      }
      const containingSelections = this.editor.selectionsMarkerLayer.findMarkers(
        { containsScreenRange: clippedRange }
      );
      if (containingSelections.length === 0) {
        const selection = this.editor.addSelectionForScreenRange(clippedRange);
        selection.setGoalScreenRange(range);
      }
      break;
    }
  }
  merge(otherSelection, options = {}) {
    const myGoalScreenRange = this.getGoalScreenRange();
    const otherGoalScreenRange = otherSelection.getGoalScreenRange();
    if (myGoalScreenRange && otherGoalScreenRange) {
      options.goalScreenRange = myGoalScreenRange.union(otherGoalScreenRange);
    } else {
      options.goalScreenRange = myGoalScreenRange || otherGoalScreenRange;
    }
    const bufferRange = this.getBufferRange().union(
      otherSelection.getBufferRange()
    );
    this.setBufferRange(
      bufferRange,
      Object.assign({ autoscroll: false }, options)
    );
    otherSelection.destroy();
  }
  compare(otherSelection) {
    return this.marker.compare(otherSelection.marker);
  }
  setGoalScreenRange(range) {
    this.goalScreenRange = Range.fromObject(range);
  }
  getGoalScreenRange() {
    return this.goalScreenRange || this.getScreenRange();
  }
  markerDidChange(e) {
    const {
      oldHeadBufferPosition,
      oldTailBufferPosition,
      newHeadBufferPosition
    } = e;
    const {
      oldHeadScreenPosition,
      oldTailScreenPosition,
      newHeadScreenPosition
    } = e;
    const { textChanged } = e;
    if (!oldHeadScreenPosition.isEqual(newHeadScreenPosition)) {
      this.cursor.goalColumn = null;
      const cursorMovedEvent = {
        oldBufferPosition: oldHeadBufferPosition,
        oldScreenPosition: oldHeadScreenPosition,
        newBufferPosition: newHeadBufferPosition,
        newScreenPosition: newHeadScreenPosition,
        textChanged,
        cursor: this.cursor
      };
      this.cursor.emitter.emit('did-change-position', cursorMovedEvent);
      this.editor.cursorMoved(cursorMovedEvent);
    }
    const rangeChangedEvent = {
      oldBufferRange: new Range(oldHeadBufferPosition, oldTailBufferPosition),
      oldScreenRange: new Range(oldHeadScreenPosition, oldTailScreenPosition),
      newBufferRange: this.getBufferRange(),
      newScreenRange: this.getScreenRange(),
      selection: this
    };
    this.emitter.emit('did-change-range', rangeChangedEvent);
    this.editor.selectionRangeChanged(rangeChangedEvent);
  }
  markerDidDestroy() {
    if (this.editor.isDestroyed()) return;
    this.destroyed = true;
    this.cursor.destroyed = true;
    this.editor.removeSelection(this);
    this.cursor.emitter.emit('did-destroy');
    this.emitter.emit('did-destroy');
    this.cursor.emitter.dispose();
    this.emitter.dispose();
  }
  finalize() {
    if (
      !this.initialScreenRange ||
      !this.initialScreenRange.isEqual(this.getScreenRange())
    ) {
      this.initialScreenRange = null;
    }
    if (this.isEmpty()) {
      this.wordwise = false;
      this.linewise = false;
    }
  }
  autoscroll(options) {
    if (this.marker.hasTail()) {
      this.editor.scrollToScreenRange(
        this.getScreenRange(),
        Object.assign({ reversed: this.isReversed() }, options)
      );
    } else {
      this.cursor.autoscroll(options);
    }
  }
  clearAutoscroll() {}
  modifySelection(fn) {
    this.retainSelection = true;
    this.plantTail();
    fn();
    this.retainSelection = false;
  }
  plantTail() {
    this.marker.plantTail();
  }
};

================
File: src/selectors.js
================
module.exports = { selectorMatchesAnyScope, matcherForSelector };
const { isSubset } = require('underscore-plus');
function parse(selector) {
  return typeof selector === 'string'
    ? selector.replace(/^\./, '').split('.')
    : selector;
}
const always = scope => true;
// Essential: Return a matcher function for a selector.
//
// * selector, a {String} selector
// Returns {(scope: String) -> Boolean}, a matcher function returning
// true iff the scope matches the selector.
function matcherForSelector(selector) {
  const parts = parse(selector);
  if (typeof parts === 'function') return parts;
  return selector ? scope => isSubset(parts, parse(scope)) : always;
}
function selectorMatchesAnyScope(selector, scopes) {
  return !selector || scopes.some(matcherForSelector(selector));
}

================
File: src/startup-time.js
================
let startTime;
let markers = [];
module.exports = {
  setStartTime() {
    if (!startTime) {
      startTime = Date.now();
    }
  },
  addMarker(label, dateTime) {
    if (!startTime) {
      return;
    }
    dateTime = dateTime || Date.now();
    markers.push({ label, time: dateTime - startTime });
  },
  importData(data) {
    startTime = data.startTime;
    markers = data.markers;
  },
  exportData() {
    if (!startTime) {
      return undefined;
    }
    return { startTime, markers };
  },
  deleteData() {
    startTime = undefined;
    markers = [];
  }
};

================
File: src/state-store.js
================
'use strict';
module.exports = class StateStore {
  constructor(databaseName, version) {
    this.connected = false;
    this.databaseName = databaseName;
    this.version = version;
  }
  get dbPromise() {
    if (!this._dbPromise) {
      this._dbPromise = new Promise(resolve => {
        const dbOpenRequest = indexedDB.open(this.databaseName, this.version);
        dbOpenRequest.onupgradeneeded = event => {
          let db = event.target.result;
          db.onerror = error => {
            atom.notifications.addFatalError('Error loading database', {
              stack: new Error('Error loading database').stack,
              dismissable: true
            });
            console.error('Error loading database', error);
          };
          db.createObjectStore('states');
        };
        dbOpenRequest.onsuccess = () => {
          this.connected = true;
          resolve(dbOpenRequest.result);
        };
        dbOpenRequest.onerror = error => {
          atom.notifications.addFatalError('Could not connect to indexedDB', {
            stack: new Error('Could not connect to indexedDB').stack,
            dismissable: true
          });
          console.error('Could not connect to indexedDB', error);
          this.connected = false;
          resolve(null);
        };
      });
    }
    return this._dbPromise;
  }
  isConnected() {
    return this.connected;
  }
  connect() {
    return this.dbPromise.then(db => !!db);
  }
  save(key, value) {
    return new Promise((resolve, reject) => {
      this.dbPromise.then(db => {
        if (db == null) return resolve();
        const request = db
          .transaction(['states'], 'readwrite')
          .objectStore('states')
          .put({ value: value, storedAt: new Date().toString() }, key);
        request.onsuccess = resolve;
        request.onerror = reject;
      });
    });
  }
  load(key) {
    return this.dbPromise.then(db => {
      if (!db) return;
      return new Promise((resolve, reject) => {
        const request = db
          .transaction(['states'])
          .objectStore('states')
          .get(key);
        request.onsuccess = event => {
          let result = event.target.result;
          if (result && !result.isJSON) {
            resolve(result.value);
          } else {
            resolve(null);
          }
        };
        request.onerror = event => reject(event);
      });
    });
  }
  delete(key) {
    return new Promise((resolve, reject) => {
      this.dbPromise.then(db => {
        if (db == null) return resolve();
        const request = db
          .transaction(['states'], 'readwrite')
          .objectStore('states')
          .delete(key);
        request.onsuccess = resolve;
        request.onerror = reject;
      });
    });
  }
  clear() {
    return this.dbPromise.then(db => {
      if (!db) return;
      return new Promise((resolve, reject) => {
        const request = db
          .transaction(['states'], 'readwrite')
          .objectStore('states')
          .clear();
        request.onsuccess = resolve;
        request.onerror = reject;
      });
    });
  }
  count() {
    return this.dbPromise.then(db => {
      if (!db) return;
      return new Promise((resolve, reject) => {
        const request = db
          .transaction(['states'])
          .objectStore('states')
          .count();
        request.onsuccess = () => {
          resolve(request.result);
        };
        request.onerror = reject;
      });
    });
  }
};

================
File: src/storage-folder.js
================
const path = require('path');
const fs = require('fs-plus');
module.exports = class StorageFolder {
  constructor(containingPath) {
    if (containingPath) {
      this.path = path.join(containingPath, 'storage');
    }
  }
  store(name, object) {
    return new Promise((resolve, reject) => {
      if (!this.path) return resolve();
      fs.writeFile(
        this.pathForKey(name),
        JSON.stringify(object),
        'utf8',
        error => (error ? reject(error) : resolve())
      );
    });
  }
  load(name) {
    return new Promise(resolve => {
      if (!this.path) return resolve(null);
      const statePath = this.pathForKey(name);
      fs.readFile(statePath, 'utf8', (error, stateString) => {
        if (error && error.code !== 'ENOENT') {
          console.warn(
            `Error reading state file: ${statePath}`,
            error.stack,
            error
          );
        }
        if (!stateString) return resolve(null);
        try {
          resolve(JSON.parse(stateString));
        } catch (error) {
          console.warn(
            `Error parsing state file: ${statePath}`,
            error.stack,
            error
          );
          resolve(null);
        }
      });
    });
  }
  pathForKey(name) {
    return path.join(this.getPath(), name);
  }
  getPath() {
    return this.path;
  }
};

================
File: src/style-manager.js
================
const { Emitter, Disposable } = require('event-kit');
const crypto = require('crypto');
const fs = require('fs-plus');
const path = require('path');
const postcss = require('postcss');
const selectorParser = require('postcss-selector-parser');
const { createStylesElement } = require('./styles-element');
const DEPRECATED_SYNTAX_SELECTORS = require('./deprecated-syntax-selectors');
module.exports = class StyleManager {
  constructor() {
    this.emitter = new Emitter();
    this.styleElements = [];
    this.styleElementsBySourcePath = {};
    this.deprecationsBySourcePath = {};
  }
  initialize({ configDirPath }) {
    this.configDirPath = configDirPath;
    if (this.configDirPath != null) {
      this.cacheDirPath = path.join(
        this.configDirPath,
        'compile-cache',
        'style-manager'
      );
    }
  }
  observeStyleElements(callback) {
    for (let styleElement of this.getStyleElements()) {
      callback(styleElement);
    }
    return this.onDidAddStyleElement(callback);
  }
  onDidAddStyleElement(callback) {
    return this.emitter.on('did-add-style-element', callback);
  }
  onDidRemoveStyleElement(callback) {
    return this.emitter.on('did-remove-style-element', callback);
  }
  onDidUpdateStyleElement(callback) {
    return this.emitter.on('did-update-style-element', callback);
  }
  onDidUpdateDeprecations(callback) {
    return this.emitter.on('did-update-deprecations', callback);
  }
  getStyleElements() {
    return this.styleElements.slice();
  }
  addStyleSheet(source, params = {}) {
    let styleElement;
    let updated;
    if (
      params.sourcePath != null &&
      this.styleElementsBySourcePath[params.sourcePath] != null
    ) {
      updated = true;
      styleElement = this.styleElementsBySourcePath[params.sourcePath];
    } else {
      updated = false;
      styleElement = document.createElement('style');
      if (params.sourcePath != null) {
        styleElement.sourcePath = params.sourcePath;
        styleElement.setAttribute('source-path', params.sourcePath);
      }
      if (params.context != null) {
        styleElement.context = params.context;
        styleElement.setAttribute('context', params.context);
      }
      if (params.priority != null) {
        styleElement.priority = params.priority;
        styleElement.setAttribute('priority', params.priority);
      }
    }
    let textContent = source
    let deprecationMessages = [];
    if (!params.skipDeprecatedSelectorsTransformation) {
      const transformed = this.upgradeStyleSheet(
        textContent,
        params.context,
        transformDeprecatedShadowDOMSelectors
      );
      textContent = transformed.source;
      deprecationMessages.push(transformed.deprecationMessage);
    }
    if (!params.skipDeprecatedMathUsageTransformation) {
      const transformed = this.upgradeStyleSheet(
        textContent,
        params.context,
        transformDeprecatedMathUsage
      );
      textContent = transformed.source;
      deprecationMessages.push(transformed.deprecationMessage);
    }
    styleElement.textContent = textContent;
    deprecationMessages = deprecationMessages.filter((ele) => ele);
    if (deprecationMessages.length > 0) {
      let deprecationMsg = deprecationMessages.join("\n");
      this.deprecationsBySourcePath[params.sourcePath] = {
        message: deprecationMsg
      };
      this.emitter.emit("did-update-deprecations");
    }
    if (updated) {
      this.emitter.emit("did-update-style-element", styleElement);
    } else {
      this.addStyleElement(styleElement);
    }
    return new Disposable(() => {
      this.removeStyleElement(styleElement);
    });
  }
  addStyleElement(styleElement) {
    let insertIndex = this.styleElements.length;
    if (styleElement.priority != null) {
      for (let i = 0; i < this.styleElements.length; i++) {
        const existingElement = this.styleElements[i];
        if (existingElement.priority > styleElement.priority) {
          insertIndex = i;
          break;
        }
      }
    }
    this.styleElements.splice(insertIndex, 0, styleElement);
    if (
      styleElement.sourcePath != null &&
      this.styleElementsBySourcePath[styleElement.sourcePath] == null
    ) {
      this.styleElementsBySourcePath[styleElement.sourcePath] = styleElement;
    }
    this.emitter.emit('did-add-style-element', styleElement);
  }
  removeStyleElement(styleElement) {
    const index = this.styleElements.indexOf(styleElement);
    if (index !== -1) {
      this.styleElements.splice(index, 1);
      if (styleElement.sourcePath != null) {
        delete this.styleElementsBySourcePath[styleElement.sourcePath];
      }
      this.emitter.emit('did-remove-style-element', styleElement);
    }
  }
  upgradeStyleSheet(styleSheet, context, upgradeName) {
    let cb;
    if (upgradeName === "math") {
      cb = transformDeprecatedMathUsage;
    } else if (upgradeName === "selector") {
      cb = transformDeprecatedShadowDOMSelectors;
    } else if (typeof upgradeName === "function") {
      cb = upgradeName;
    }
    if (this.cacheDirPath != null) {
      const hash = crypto.createHash("sha1");
      if (context != null) {
        hash.update(context);
      }
      hash.update(styleSheet);
      const cacheFilePath = path.join(this.cacheDirPath, hash.digest("hex"));
      try {
        return JSON.parse(fs.readFileSync(cacheFilePath));
      } catch(e) {
        const transformed = cb(styleSheet, context);
        fs.writeFileSync(cacheFilePath, JSON.stringify(transformed));
        return transformed;
      }
    } else {
      return cb(styleSheet, context);
    }
  }
  getDeprecations() {
    return this.deprecationsBySourcePath;
  }
  clearDeprecations() {
    this.deprecationsBySourcePath = {};
  }
  getSnapshot() {
    return this.styleElements.slice();
  }
  restoreSnapshot(styleElementsToRestore) {
    for (let styleElement of this.getStyleElements()) {
      if (!styleElementsToRestore.includes(styleElement)) {
        this.removeStyleElement(styleElement);
      }
    }
    const existingStyleElements = this.getStyleElements();
    for (let styleElement of styleElementsToRestore) {
      if (!existingStyleElements.includes(styleElement)) {
        this.addStyleElement(styleElement);
      }
    }
  }
  buildStylesElement() {
    const stylesElement = createStylesElement();
    stylesElement.initialize(this);
    return stylesElement;
  }
  getUserStyleSheetPath() {
    if (this.configDirPath == null) {
      return '';
    } else {
      const stylesheetPath = fs.resolve(
        path.join(this.configDirPath, 'styles'),
        ['css', 'less']
      );
      if (fs.isFileSync(stylesheetPath)) {
        return stylesheetPath;
      } else {
        return path.join(this.configDirPath, 'styles.less');
      }
    }
  }
};
function transformDeprecatedShadowDOMSelectors(css, context) {
  const transformedSelectors = [];
  let transformedSource;
  try {
    transformedSource = postcss.parse(css);
  } catch (e) {
    transformedSource = null;
  }
  if (transformedSource) {
    transformedSource.walkRules(rule => {
      const transformedSelector = selectorParser(selectors => {
        selectors.each(selector => {
          const firstNode = selector.nodes[0];
          if (
            context === 'atom-text-editor' &&
            firstNode.type === 'pseudo' &&
            firstNode.value === ':host'
          ) {
            const atomTextEditorElementNode = selectorParser.tag({
              value: 'atom-text-editor'
            });
            firstNode.replaceWith(atomTextEditorElementNode);
          }
          let previousNodeIsAtomTextEditor = false;
          let targetsAtomTextEditorShadow = context === 'atom-text-editor';
          let previousNode;
          selector.each(node => {
            if (targetsAtomTextEditorShadow && node.type === 'class') {
              if (DEPRECATED_SYNTAX_SELECTORS.has(node.value)) {
                node.value = `syntax--${node.value}`;
              }
            } else {
              if (
                previousNodeIsAtomTextEditor &&
                node.type === 'pseudo' &&
                node.value === '::shadow'
              ) {
                node.type = 'className';
                node.value = '.editor';
                targetsAtomTextEditorShadow = true;
              }
            }
            previousNode = node;
            if (node.type === 'combinator') {
              previousNodeIsAtomTextEditor = false;
            } else if (
              previousNode.type === 'tag' &&
              previousNode.value === 'atom-text-editor'
            ) {
              previousNodeIsAtomTextEditor = true;
            }
          });
        });
      }).processSync(rule.selector, { lossless: true });
      if (transformedSelector !== rule.selector) {
        transformedSelectors.push({
          before: rule.selector,
          after: transformedSelector
        });
        rule.selector = transformedSelector;
      }
    });
    let deprecationMessage;
    if (transformedSelectors.length > 0) {
      deprecationMessage =
        'Starting from Pulsar v1.13.0, the contents of `atom-text-editor` elements ';
      deprecationMessage +=
        'are no longer encapsulated within a shadow DOM boundary. ';
      deprecationMessage +=
        'This means you should stop using `:host` and `::shadow` ';
      deprecationMessage +=
        'pseudo-selectors, and prepend all your syntax selectors with `syntax--`. ';
      deprecationMessage +=
        'To prevent breakage with existing style sheets, Pulsar will automatically ';
      deprecationMessage += 'upgrade the following selectors:\n\n';
      deprecationMessage +=
        transformedSelectors
          .map(selector => `* \`${selector.before}\` => \`${selector.after}\``)
          .join('\n\n') + '\n\n';
      deprecationMessage +=
        'Automatic translation of selectors will be removed in a few release cycles to minimize startup time. ';
      deprecationMessage +=
        'Please, make sure to upgrade the above selectors as soon as possible.';
    }
    return { source: transformedSource.toString(), deprecationMessage };
  } else {
    return { source: css };
  }
}
function transformDeprecatedMathUsage(css, context) {
  const transformedProperties = [];
  let transformedSource;
  const cssKeyIgnoreList = [ "font", "background", "grid-column", "cursor", "aspect-ratio" ];
  const cssValueIgnoreList = /hsl|abs|acos|asin|atan|atan2|cos|mod|rem|sign|sin|tan|url/g;
  const mathExpressionRegex =
  /(-*(\d(\.\d)?)+(cm|mm|Q|in|pc|pt|px|em|ex|ch|rem|lh|rlh|vw|vh|vmin|vmax|vb|vi|svw|svh|lvw|lvh|dvw|dvh|%)?|@?[\w-]+)(\s*([\/\+\*]|(\-\s+))\s*((\d(\.\d)*)+(cm|mm|Q|in|pc|pt|px|em|ex|ch|rem|lh|rlh|vw|vh|vmin|vmax|vb|vi|svw|svh|lvw|lvh|dvw|dvh|%)?|@?[\w-]+))+/g;
  try {
    transformedSource = postcss.parse(css);
  } catch(e) {
    transformedSource = null;
  }
  if (transformedSource) {
    transformedSource.walkRules(rule => {
      rule.each(node => {
        if (
          typeof node.value === "string" &&
          !cssKeyIgnoreList.includes(node.prop) &&
          !cssValueIgnoreList.test(node.value)
        ) {
          let containsMath = node.value.match(mathExpressionRegex);
          if (containsMath !== null) {
            let nodeOriginal = node.value;
            let appliedChanges = false;
            for (let i = 0; i < containsMath.length; i++) {
              let match = containsMath[i];
              if (!node.value.includes(`calc(${match})`)) {
                node.value = node.value.replace(match, `calc(${match})`);
                appliedChanges = true;
              }
            }
            if (appliedChanges) {
              transformedProperties.push({
                property: node.prop,
                valueBefore: nodeOriginal,
                valueAfter: node.value
              });
            }
          }
        }
      });
    });
    let deprecationMessage;
    if (transformedProperties.length > 0) {
      deprecationMessage =
        'Starting from Pulsar v1.107.0, less v4.1.3 is used to transpile less style sheets. ';
      deprecationMessage +=
        'This means that Parens-division is now the default math setting, and all ';
      deprecationMessage +=
        'less style sheets must wrap division within parenthesis. ';
      deprecationMessage +=
        'To prevent breakage with existing style sheets, Pulsar will automatically ';
      deprecationMessage +=
        'wrap any mathematical expressions found unparsed by Less with `calc()`. ';
      deprecationMessage +=
        'Upgrading the values of the following properties:\n\n';
      deprecationMessage +=
        transformedProperties
          .map(prop => `* \`${prop.property}\`: \`${prop.valueBefore}\` => \`${prop.valueAfter}\``)
          .join(`\n\n`) + `\n\n`;
      deprecationMessage +=
        'Please, make sure to upgrade usage of mathematical expressions within ';
      deprecationMessage +=
        'less style sheets.';
    }
    return { source: transformedSource.toString(), deprecationMessage };
  } else {
    return { source: css };
  }
}

================
File: src/styles-element.js
================
const { Emitter, CompositeDisposable } = require('event-kit');
class StylesElement extends HTMLElement {
  constructor() {
    super();
    this.subscriptions = new CompositeDisposable();
    this.emitter = new Emitter();
    this.styleElementClonesByOriginalElement = new WeakMap();
    this.context = null;
  }
  onDidAddStyleElement(callback) {
    this.emitter.on('did-add-style-element', callback);
  }
  onDidRemoveStyleElement(callback) {
    this.emitter.on('did-remove-style-element', callback);
  }
  onDidUpdateStyleElement(callback) {
    this.emitter.on('did-update-style-element', callback);
  }
  connectedCallback() {
    let left;
    this.context =
      (left = this.getAttribute('context')) != null ? left : undefined;
  }
  disconnectedCallback() {
    this.subscriptions.dispose();
    this.subscriptions = new CompositeDisposable();
  }
  static get observedAttributes() {
    return ['context'];
  }
  attributeChangedCallback(attrName) {
    if (attrName === 'context') {
      return this.contextChanged();
    }
  }
  initialize(styleManager) {
    this.styleManager = styleManager;
    if (this.styleManager == null) {
      throw new Error(
        'Must pass a styleManager parameter when initializing a StylesElement'
      );
    }
    this.subscriptions.add(
      this.styleManager.observeStyleElements(this.styleElementAdded.bind(this))
    );
    this.subscriptions.add(
      this.styleManager.onDidRemoveStyleElement(
        this.styleElementRemoved.bind(this)
      )
    );
    this.subscriptions.add(
      this.styleManager.onDidUpdateStyleElement(
        this.styleElementUpdated.bind(this)
      )
    );
  }
  contextChanged() {
    if (this.subscriptions == null) {
      return;
    }
    for (let child of Array.from(Array.prototype.slice.call(this.children))) {
      this.styleElementRemoved(child);
    }
    this.context = this.getAttribute('context');
    for (let styleElement of Array.from(this.styleManager.getStyleElements())) {
      this.styleElementAdded(styleElement);
    }
  }
  styleElementAdded(styleElement) {
    let insertBefore;
    if (!this.styleElementMatchesContext(styleElement)) {
      return;
    }
    const styleElementClone = styleElement.cloneNode(true);
    styleElementClone.sourcePath = styleElement.sourcePath;
    styleElementClone.context = styleElement.context;
    styleElementClone.priority = styleElement.priority;
    this.styleElementClonesByOriginalElement.set(
      styleElement,
      styleElementClone
    );
    const { priority } = styleElement;
    if (priority != null) {
      for (let child of this.children) {
        if (child.priority > priority) {
          insertBefore = child;
          break;
        }
      }
    }
    this.insertBefore(styleElementClone, insertBefore);
    this.emitter.emit('did-add-style-element', styleElementClone);
  }
  styleElementRemoved(styleElement) {
    let left;
    if (!this.styleElementMatchesContext(styleElement)) {
      return;
    }
    const styleElementClone =
      (left = this.styleElementClonesByOriginalElement.get(styleElement)) !=
      null
        ? left
        : styleElement;
    styleElementClone.remove();
    this.emitter.emit('did-remove-style-element', styleElementClone);
  }
  styleElementUpdated(styleElement) {
    if (!this.styleElementMatchesContext(styleElement)) {
      return;
    }
    const styleElementClone = this.styleElementClonesByOriginalElement.get(
      styleElement
    );
    styleElementClone.textContent = styleElement.textContent;
    this.emitter.emit('did-update-style-element', styleElementClone);
  }
  styleElementMatchesContext(styleElement) {
    return this.context == null || styleElement.context === this.context;
  }
}
window.customElements.define('atom-styles', StylesElement);
function createStylesElement() {
  return document.createElement('atom-styles');
}
module.exports = {
  createStylesElement
};

================
File: src/syntax-scope-map.js
================
const parser = require('postcss-selector-parser');
module.exports = class SyntaxScopeMap {
  constructor(resultsBySelector) {
    this.namedScopeTable = {};
    this.anonymousScopeTable = {};
    for (let selector in resultsBySelector) {
      this.addSelector(selector, resultsBySelector[selector]);
    }
    setTableDefaults(this.namedScopeTable, true);
    setTableDefaults(this.anonymousScopeTable, false);
  }
  addSelector(selector, result) {
    parser(parseResult => {
      for (let selectorNode of parseResult.nodes) {
        let currentTable = null;
        let currentIndexValue = null;
        for (let i = selectorNode.nodes.length - 1; i >= 0; i--) {
          const termNode = selectorNode.nodes[i];
          switch (termNode.type) {
            case 'tag':
              if (!currentTable) currentTable = this.namedScopeTable;
              if (!currentTable[termNode.value])
                currentTable[termNode.value] = {};
              currentTable = currentTable[termNode.value];
              if (currentIndexValue != null) {
                if (!currentTable.indices) currentTable.indices = {};
                if (!currentTable.indices[currentIndexValue])
                  currentTable.indices[currentIndexValue] = {};
                currentTable = currentTable.indices[currentIndexValue];
                currentIndexValue = null;
              }
              break;
            case 'string':
              if (!currentTable) currentTable = this.anonymousScopeTable;
              const value = termNode.value.slice(1, -1).replace(/\\"/g, '"');
              if (!currentTable[value]) currentTable[value] = {};
              currentTable = currentTable[value];
              if (currentIndexValue != null) {
                if (!currentTable.indices) currentTable.indices = {};
                if (!currentTable.indices[currentIndexValue])
                  currentTable.indices[currentIndexValue] = {};
                currentTable = currentTable.indices[currentIndexValue];
                currentIndexValue = null;
              }
              break;
            case 'universal':
              if (currentTable) {
                if (!currentTable['*']) currentTable['*'] = {};
                currentTable = currentTable['*'];
              } else {
                if (!this.namedScopeTable['*']) {
                  this.namedScopeTable['*'] = this.anonymousScopeTable[
                    '*'
                  ] = {};
                }
                currentTable = this.namedScopeTable['*'];
              }
              if (currentIndexValue != null) {
                if (!currentTable.indices) currentTable.indices = {};
                if (!currentTable.indices[currentIndexValue])
                  currentTable.indices[currentIndexValue] = {};
                currentTable = currentTable.indices[currentIndexValue];
                currentIndexValue = null;
              }
              break;
            case 'combinator':
              if (currentIndexValue != null) {
                rejectSelector(selector);
              }
              if (termNode.value === '>') {
                if (!currentTable.parents) currentTable.parents = {};
                currentTable = currentTable.parents;
              } else {
                rejectSelector(selector);
              }
              break;
            case 'pseudo':
              if (termNode.value === ':nth-child') {
                currentIndexValue = termNode.nodes[0].nodes[0].value;
              } else {
                rejectSelector(selector);
              }
              break;
            default:
              rejectSelector(selector);
          }
        }
        currentTable.result = result;
      }
    }).process(selector);
  }
  get(nodeTypes, childIndices, leafIsNamed = true) {
    let result;
    let i = nodeTypes.length - 1;
    let currentTable = leafIsNamed
      ? this.namedScopeTable[nodeTypes[i]]
      : this.anonymousScopeTable[nodeTypes[i]];
    if (!currentTable) currentTable = this.namedScopeTable['*'];
    while (currentTable) {
      if (currentTable.indices && currentTable.indices[childIndices[i]]) {
        currentTable = currentTable.indices[childIndices[i]];
      }
      if (currentTable.result != null) {
        result = currentTable.result;
      }
      if (i === 0) break;
      i--;
      currentTable =
        currentTable.parents &&
        (currentTable.parents[nodeTypes[i]] || currentTable.parents['*']);
    }
    return result;
  }
};
function setTableDefaults(table, allowWildcardSelector) {
  const defaultTypeTable = allowWildcardSelector ? table['*'] : null;
  for (let type in table) {
    let typeTable = table[type];
    if (typeTable === defaultTypeTable) continue;
    if (defaultTypeTable) {
      mergeTable(typeTable, defaultTypeTable);
    }
    if (typeTable.parents) {
      setTableDefaults(typeTable.parents, true);
    }
    for (let key in typeTable.indices) {
      const indexTable = typeTable.indices[key];
      mergeTable(indexTable, typeTable, false);
      if (indexTable.parents) {
        setTableDefaults(indexTable.parents, true);
      }
    }
  }
}
function mergeTable(table, defaultTable, mergeIndices = true) {
  if (mergeIndices && defaultTable.indices) {
    if (!table.indices) table.indices = {};
    for (let key in defaultTable.indices) {
      if (!table.indices[key]) table.indices[key] = {};
      mergeTable(table.indices[key], defaultTable.indices[key]);
    }
  }
  if (defaultTable.parents) {
    if (!table.parents) table.parents = {};
    for (let key in defaultTable.parents) {
      if (!table.parents[key]) table.parents[key] = {};
      mergeTable(table.parents[key], defaultTable.parents[key]);
    }
  }
  if (defaultTable.result != null && table.result == null) {
    table.result = defaultTable.result;
  }
}
function rejectSelector(selector) {
  throw new TypeError(`Unsupported selector '${selector}'`);
}

================
File: src/task-bootstrap.js
================
const { userAgent } = process.env;
const [compileCachePath, taskPath] = process.argv.slice(2);
const CompileCache = require('./compile-cache');
CompileCache.setCacheDirectory(compileCachePath);
CompileCache.install(`${process.resourcesPath}`, require);
const setupGlobals = function() {
  global.attachEvent = function() {};
  const console = {
    warn() {
      return global.emit('task:warn', ...arguments);
    },
    log() {
      return global.emit('task:log', ...arguments);
    },
    error() {
      return global.emit('task:error', ...arguments);
    },
    trace() {}
  };
  global.__defineGetter__('console', () => console);
  global.document = {
    createElement() {
      return {
        setAttribute() {},
        getElementsByTagName() {
          return [];
        },
        appendChild() {}
      };
    },
    documentElement: {
      insertBefore() {},
      removeChild() {}
    },
    getElementById() {
      return {};
    },
    createComment() {
      return {};
    },
    createDocumentFragment() {
      return {};
    }
  };
  global.emit = (event, ...args) => process.send({ event, args });
  global.navigator = { userAgent };
  return (global.window = global);
};
const handleEvents = function() {
  process.on('uncaughtException', error =>
    console.error(error.message, error.stack)
  );
  return process.on('message', function({ event, args } = {}) {
    if (event !== 'start') {
      return;
    }
    let isAsync = false;
    const async = function() {
      isAsync = true;
      return result => global.emit('task:completed', result);
    };
    const result = handler.bind({ async })(...args);
    if (!isAsync) {
      return global.emit('task:completed', result);
    }
  });
};
const setupDeprecations = function() {
  const Grim = require('grim');
  return Grim.on('updated', function() {
    const deprecations = Grim.getDeprecations().map(deprecation =>
      deprecation.serialize()
    );
    Grim.clearDeprecations();
    return global.emit('task:deprecations', deprecations);
  });
};
setupGlobals();
handleEvents();
setupDeprecations();
const handler = require(taskPath);

================
File: src/task.js
================
const _ = require('underscore-plus');
const ChildProcess = require('child_process');
const {Emitter} = require('event-kit');
const Grim = require('grim');
module.exports = class Task {
  static once(taskPath, ...args) {
    const task = new Task(taskPath);
    task.once('task:completed', () => task.terminate());
    task.start(...args);
    return task;
  }
  callback = null;
  constructor(taskPath) {
    this.emitter = new Emitter();
    const compileCachePath = require('./compile-cache').getCacheDirectory();
    taskPath = require.resolve(taskPath);
    const env = Object.assign({}, process.env, {userAgent: navigator.userAgent});
    this.childProcess = ChildProcess.fork(require.resolve('./task-bootstrap'), [compileCachePath, taskPath], { env, silent: true});
    this.on("task:log",   (...args) => console.log(...args)  );
    this.on("task:warn",  (...args) => console.warn(...args) );
    this.on("task:error", (...args) => console.error(...args));
    this.on("task:deprecations", (deprecations) => {
      for (let i = 0; i < deprecations.length; i++) {
        Grim.addSerializedDeprecation(deprecations[i]);
      }
    });
    this.on("task:completed", (...args) => {
      if (typeof this.callback === "function") {
        this.callback(...args)
      }
    });
    this.handleEvents();
  }
  handleEvents() {
    this.childProcess.removeAllListeners();
    this.childProcess.on('message', ({event, args}) => {
      if (this.childProcess != null) {
        this.emitter.emit(event, args);
      }
    });
    if (this.childProcess.stdout != null) {
      this.childProcess.stdout.removeAllListeners();
      this.childProcess.stdout.on('data', (data) => console.log(data.toString()));
    }
    if (this.childProcess.stderr != null) {
      this.childProcess.stderr.removeAllListeners();
      this.childProcess.stderr.on('data', (data) => console.error(data.toString()));
    }
  }
  start(...args) {
    const [callback] = args.splice(-1);
    if (this.childProcess == null) {
      throw new Error('Cannot start terminated process');
    }
    this.handleEvents();
    if (_.isFunction(callback)) {
      this.callback = callback;
    } else {
      args.push(callback);
    }
    this.send({event: 'start', args});
    return undefined;
  }
  send(message) {
    if (this.childProcess != null) {
      this.childProcess.send(message);
    } else {
      throw new Error('Cannot send message to terminated process');
    }
    return undefined;
  }
  on(eventName, callback) {
    return this.emitter.on(eventName, (args) => callback(...(args || [])));
  }
  once(eventName, callback) {
    var disposable = this.on(eventName, function (...args) {
      disposable.dispose();
      callback(...args);
    });
  }
  terminate() {
    if (this.childProcess == null) {
      return false;
    }
    this.childProcess.removeAllListeners();
    if (this.childProcess.stdout != null) {
      this.childProcess.stdout.removeAllListeners();
    }
    if (this.childProcess.stderr != null) {
      this.childProcess.stderr.removeAllListeners();
    }
    this.childProcess.kill();
    this.childProcess = null;
    return true;
  }
  cancel() {
    const didForcefullyTerminate = this.terminate();
    if (didForcefullyTerminate) {
      this.emitter.emit('task:cancelled');
    }
    return didForcefullyTerminate;
  }
};

================
File: src/text-editor-component.js
================
const etch = require('etch');
const { Point, Range } = require('text-buffer');
const LineTopIndex = require('line-top-index');
const TextEditor = require('./text-editor');
const { isPairedCharacter } = require('./text-utils');
const electron = require('electron');
const clipboard = electron.clipboard;
const $ = etch.dom;
let TextEditorElement;
const DEFAULT_ROWS_PER_TILE = 6;
const NORMAL_WIDTH_CHARACTER = 'x';
const DOUBLE_WIDTH_CHARACTER = '我';
const HALF_WIDTH_CHARACTER = 'ﾊ';
const KOREAN_CHARACTER = '세';
const NBSP_CHARACTER = '\u00a0';
const ZERO_WIDTH_NBSP_CHARACTER = '\ufeff';
const MOUSE_DRAG_AUTOSCROLL_MARGIN = 40;
const CURSOR_BLINK_RESUME_DELAY = 300;
const CURSOR_BLINK_PERIOD = 800;
function scaleMouseDragAutoscrollDelta(delta) {
  return Math.pow(delta / 3, 3) / 280;
}
module.exports = class TextEditorComponent {
  static setScheduler(scheduler) {
    etch.setScheduler(scheduler);
  }
  static getScheduler() {
    return etch.getScheduler();
  }
  static didUpdateStyles() {
    if (this.attachedComponents) {
      this.attachedComponents.forEach(component => {
        component.didUpdateStyles();
      });
    }
  }
  static didUpdateScrollbarStyles() {
    if (this.attachedComponents) {
      this.attachedComponents.forEach(component => {
        component.didUpdateScrollbarStyles();
      });
    }
  }
  constructor(props) {
    this.props = props;
    if (!props.model) {
      props.model = new TextEditor({
        mini: props.mini,
        readOnly: props.readOnly
      });
    }
    this.props.model.component = this;
    if (props.element) {
      this.element = props.element;
    } else {
      if (!TextEditorElement)
        TextEditorElement = require('./text-editor-element');
      this.element = TextEditorElement.createTextEditorElement();
    }
    this.element.initialize(this);
    this.virtualNode = $('atom-text-editor');
    this.virtualNode.domNode = this.element;
    this.refs = {};
    this.updateSync = this.updateSync.bind(this);
    this.didBlurHiddenInput = this.didBlurHiddenInput.bind(this);
    this.didFocusHiddenInput = this.didFocusHiddenInput.bind(this);
    this.didPaste = this.didPaste.bind(this);
    this.didTextInput = this.didTextInput.bind(this);
    this.didKeydown = this.didKeydown.bind(this);
    this.didKeyup = this.didKeyup.bind(this);
    this.didKeypress = this.didKeypress.bind(this);
    this.didCompositionStart = this.didCompositionStart.bind(this);
    this.didCompositionUpdate = this.didCompositionUpdate.bind(this);
    this.didCompositionEnd = this.didCompositionEnd.bind(this);
    this.updatedSynchronously = this.props.updatedSynchronously;
    this.didScrollDummyScrollbar = this.didScrollDummyScrollbar.bind(this);
    this.didMouseDownOnContent = this.didMouseDownOnContent.bind(this);
    this.debouncedResumeCursorBlinking = debounce(
      this.resumeCursorBlinking.bind(this),
      this.props.cursorBlinkResumeDelay || CURSOR_BLINK_RESUME_DELAY
    );
    this.lineTopIndex = new LineTopIndex();
    this.lineNodesPool = new NodePool();
    this.updateScheduled = false;
    this.suppressUpdates = false;
    this.hasInitialMeasurements = false;
    this.measurements = {
      lineHeight: 0,
      baseCharacterWidth: 0,
      doubleWidthCharacterWidth: 0,
      halfWidthCharacterWidth: 0,
      koreanCharacterWidth: 0,
      gutterContainerWidth: 0,
      lineNumberGutterWidth: 0,
      clientContainerHeight: 0,
      clientContainerWidth: 0,
      verticalScrollbarWidth: 0,
      horizontalScrollbarHeight: 0,
      longestLineWidth: 0
    };
    this.derivedDimensionsCache = {};
    this.visible = false;
    this.cursorsBlinking = false;
    this.cursorsBlinkedOff = false;
    this.nextUpdateOnlyBlinksCursors = null;
    this.linesToMeasure = new Map();
    this.extraRenderedScreenLines = new Map();
    this.horizontalPositionsToMeasure = new Map();
    this.horizontalPixelPositionsByScreenLineId = new Map();
    this.blockDecorationsToMeasure = new Set();
    this.blockDecorationsByElement = new WeakMap();
    this.blockDecorationSentinel = document.createElement('div');
    this.blockDecorationSentinel.style.height = '1px';
    this.heightsByBlockDecoration = new WeakMap();
    this.blockDecorationResizeObserver = new ResizeObserver(
      this.didResizeBlockDecorations.bind(this)
    );
    this.lineComponentsByScreenLineId = new Map();
    this.overlayComponents = new Set();
    this.shouldRenderDummyScrollbars = true;
    this.remeasureScrollbars = false;
    this.pendingAutoscroll = null;
    this.scrollTopPending = false;
    this.scrollLeftPending = false;
    this.scrollTop = 0;
    this.scrollLeft = 0;
    this.previousScrollWidth = 0;
    this.previousScrollHeight = 0;
    this.lastKeydown = null;
    this.lastKeydownBeforeKeypress = null;
    this.accentedCharacterMenuIsOpen = false;
    this.remeasureGutterDimensions = false;
    this.guttersToRender = [this.props.model.getLineNumberGutter()];
    this.guttersVisibility = [this.guttersToRender[0].visible];
    this.idsByTileStartRow = new Map();
    this.nextTileId = 0;
    this.renderedTileStartRows = [];
    this.showLineNumbers = this.props.model.doesShowLineNumbers();
    this.lineNumbersToRender = {
      maxDigits: 2,
      bufferRows: [],
      screenRows: [],
      keys: [],
      softWrappedFlags: [],
      foldableFlags: []
    };
    this.decorationsToRender = {
      lineNumbers: new Map(),
      lines: null,
      highlights: [],
      cursors: [],
      overlays: [],
      customGutter: new Map(),
      blocks: new Map(),
      text: []
    };
    this.decorationsToMeasure = {
      highlights: [],
      cursors: new Map()
    };
    this.textDecorationsByMarker = new Map();
    this.textDecorationBoundaries = [];
    this.pendingScrollTopRow = this.props.initialScrollTopRow;
    this.pendingScrollLeftColumn = this.props.initialScrollLeftColumn;
    this.tabIndex =
      this.props.element && this.props.element.tabIndex
        ? this.props.element.tabIndex
        : -1;
    this.measuredContent = false;
    this.queryGuttersToRender();
    this.queryMaxLineNumberDigits();
    this.observeBlockDecorations();
    this.updateClassList();
    etch.updateSync(this);
  }
  update(props) {
    if (props.model !== this.props.model) {
      this.props.model.component = null;
      props.model.component = this;
    }
    this.props = props;
    this.scheduleUpdate();
  }
  pixelPositionForScreenPosition({ row, column }) {
    const top = this.pixelPositionAfterBlocksForRow(row);
    let left = column === 0 ? 0 : this.pixelLeftForRowAndColumn(row, column);
    if (left == null) {
      this.requestHorizontalMeasurement(row, column);
      this.updateSync();
      left = this.pixelLeftForRowAndColumn(row, column);
    }
    return { top, left };
  }
  scheduleUpdate(nextUpdateOnlyBlinksCursors = false) {
    if (!this.visible) return;
    if (this.suppressUpdates) return;
    this.nextUpdateOnlyBlinksCursors =
      this.nextUpdateOnlyBlinksCursors !== false &&
      nextUpdateOnlyBlinksCursors === true;
    if (this.updatedSynchronously) {
      this.updateSync();
    } else if (!this.updateScheduled) {
      this.updateScheduled = true;
      etch.getScheduler().updateDocument(() => {
        if (this.updateScheduled) this.updateSync(true);
      });
    }
  }
  updateSync(useScheduler = false) {
    if (!this.visible) {
      this.updateScheduled = false;
      return;
    }
    if (
      (this.remeasureCharacterDimensions ||
        this.remeasureAllBlockDecorations) &&
      !this.isVisible()
    ) {
      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise();
      this.updateScheduled = false;
      return;
    }
    const onlyBlinkingCursors = this.nextUpdateOnlyBlinksCursors;
    this.nextUpdateOnlyBlinksCursors = null;
    if (useScheduler && onlyBlinkingCursors) {
      this.refs.cursorsAndInput.updateCursorBlinkSync(this.cursorsBlinkedOff);
      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise();
      this.updateScheduled = false;
      return;
    }
    if (this.remeasureCharacterDimensions) {
      const originalLineHeight = this.getLineHeight();
      const originalBaseCharacterWidth = this.getBaseCharacterWidth();
      const scrollTopRow = this.getScrollTopRow();
      const scrollLeftColumn = this.getScrollLeftColumn();
      this.measureCharacterDimensions();
      this.measureGutterDimensions();
      this.queryLongestLine();
      if (this.getLineHeight() !== originalLineHeight) {
        this.setScrollTopRow(scrollTopRow);
      }
      if (this.getBaseCharacterWidth() !== originalBaseCharacterWidth) {
        this.setScrollLeftColumn(scrollLeftColumn);
      }
      this.remeasureCharacterDimensions = false;
    }
    if (this.isVisible()) this.measureBlockDecorations();
    this.updateSyncBeforeMeasuringContent();
    if (useScheduler === true) {
      const scheduler = etch.getScheduler();
      scheduler.readDocument(() => {
        const restartFrame = this.measureContentDuringUpdateSync();
        scheduler.updateDocument(() => {
          if (restartFrame) {
            this.updateSync(true);
          } else {
            this.updateSyncAfterMeasuringContent();
          }
        });
      });
    } else {
      const restartFrame = this.measureContentDuringUpdateSync();
      if (restartFrame) {
        this.updateSync(false);
      } else {
        this.updateSyncAfterMeasuringContent();
      }
    }
    this.updateScheduled = false;
  }
  measureBlockDecorations() {
    if (this.remeasureAllBlockDecorations) {
      this.remeasureAllBlockDecorations = false;
      const decorations = this.props.model.getDecorations();
      for (let i = 0; i < decorations.length; i++) {
        const decoration = decorations[i];
        const marker = decoration.getMarker();
        if (marker.isValid() && decoration.getProperties().type === 'block') {
          this.blockDecorationsToMeasure.add(decoration);
        }
      }
      if (this.blockDecorationsToMeasure.size > 0) {
        this.updateSyncBeforeMeasuringContent();
      }
    }
    if (this.blockDecorationsToMeasure.size > 0) {
      const { blockDecorationMeasurementArea } = this.refs;
      const sentinelElements = new Set();
      blockDecorationMeasurementArea.appendChild(document.createElement('div'));
      this.blockDecorationsToMeasure.forEach(decoration => {
        const { item } = decoration.getProperties();
        const decorationElement = TextEditor.viewForItem(item);
        if (document.contains(decorationElement)) {
          const parentElement = decorationElement.parentElement;
          if (!decorationElement.previousSibling) {
            const sentinelElement = this.blockDecorationSentinel.cloneNode();
            parentElement.insertBefore(sentinelElement, decorationElement);
            sentinelElements.add(sentinelElement);
          }
          if (!decorationElement.nextSibling) {
            const sentinelElement = this.blockDecorationSentinel.cloneNode();
            parentElement.appendChild(sentinelElement);
            sentinelElements.add(sentinelElement);
          }
          this.didMeasureVisibleBlockDecoration = true;
        } else {
          blockDecorationMeasurementArea.appendChild(
            this.blockDecorationSentinel.cloneNode()
          );
          blockDecorationMeasurementArea.appendChild(decorationElement);
          blockDecorationMeasurementArea.appendChild(
            this.blockDecorationSentinel.cloneNode()
          );
        }
      });
      if (this.resizeBlockDecorationMeasurementsArea) {
        this.resizeBlockDecorationMeasurementsArea = false;
        this.refs.blockDecorationMeasurementArea.style.width =
          this.getScrollWidth() + 'px';
      }
      this.blockDecorationsToMeasure.forEach(decoration => {
        const { item } = decoration.getProperties();
        const decorationElement = TextEditor.viewForItem(item);
        const { previousSibling, nextSibling } = decorationElement;
        const height =
          nextSibling.getBoundingClientRect().top -
          previousSibling.getBoundingClientRect().bottom;
        this.heightsByBlockDecoration.set(decoration, height);
        this.lineTopIndex.resizeBlock(decoration, height);
      });
      sentinelElements.forEach(sentinelElement => sentinelElement.remove());
      while (blockDecorationMeasurementArea.firstChild) {
        blockDecorationMeasurementArea.firstChild.remove();
      }
      this.blockDecorationsToMeasure.clear();
    }
  }
  updateSyncBeforeMeasuringContent() {
    this.measuredContent = false;
    this.derivedDimensionsCache = {};
    this.updateModelSoftWrapColumn();
    if (this.pendingAutoscroll) {
      let { screenRange, options } = this.pendingAutoscroll;
      this.autoscrollVertically(screenRange, options);
      this.requestHorizontalMeasurement(
        screenRange.start.row,
        screenRange.start.column
      );
      this.requestHorizontalMeasurement(
        screenRange.end.row,
        screenRange.end.column
      );
    }
    this.populateVisibleRowRange(this.getRenderedStartRow());
    this.populateVisibleTiles();
    this.queryScreenLinesToRender();
    this.queryLongestLine();
    this.queryLineNumbersToRender();
    this.queryGuttersToRender();
    this.queryDecorationsToRender();
    this.queryExtraScreenLinesToRender();
    this.shouldRenderDummyScrollbars = !this.remeasureScrollbars;
    etch.updateSync(this);
    this.updateClassList();
    this.shouldRenderDummyScrollbars = true;
    this.didMeasureVisibleBlockDecoration = false;
  }
  measureContentDuringUpdateSync() {
    let gutterDimensionsChanged = false;
    if (this.remeasureGutterDimensions) {
      gutterDimensionsChanged = this.measureGutterDimensions();
      this.remeasureGutterDimensions = false;
    }
    const wasHorizontalScrollbarVisible =
      this.canScrollHorizontally() && this.getHorizontalScrollbarHeight() > 0;
    this.measureLongestLineWidth();
    this.measureHorizontalPositions();
    this.updateAbsolutePositionedDecorations();
    const isHorizontalScrollbarVisible =
      this.canScrollHorizontally() && this.getHorizontalScrollbarHeight() > 0;
    if (this.pendingAutoscroll) {
      this.derivedDimensionsCache = {};
      const { screenRange, options } = this.pendingAutoscroll;
      this.autoscrollHorizontally(screenRange, options);
      if (!wasHorizontalScrollbarVisible && isHorizontalScrollbarVisible) {
        this.autoscrollVertically(screenRange, options);
      }
      this.pendingAutoscroll = null;
    }
    this.linesToMeasure.clear();
    this.measuredContent = true;
    return (
      gutterDimensionsChanged ||
      wasHorizontalScrollbarVisible !== isHorizontalScrollbarVisible
    );
  }
  updateSyncAfterMeasuringContent() {
    this.derivedDimensionsCache = {};
    etch.updateSync(this);
    this.currentFrameLineNumberGutterProps = null;
    this.scrollTopPending = false;
    this.scrollLeftPending = false;
    if (this.remeasureScrollbars) {
      this.refs.verticalScrollbar.flushScrollPosition();
      this.refs.horizontalScrollbar.flushScrollPosition();
      this.measureScrollbarDimensions();
      this.remeasureScrollbars = false;
      etch.updateSync(this);
    }
    this.derivedDimensionsCache = {};
    if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise();
  }
  render() {
    const { model } = this.props;
    const style = {};
    if (!model.getAutoHeight() && !model.getAutoWidth()) {
      style.contain = 'size';
    }
    let clientContainerHeight = '100%';
    let clientContainerWidth = '100%';
    if (this.hasInitialMeasurements) {
      if (model.getAutoHeight()) {
        clientContainerHeight =
          this.getContentHeight() + this.getHorizontalScrollbarHeight() + 'px';
      }
      if (model.getAutoWidth()) {
        style.width = 'min-content';
        clientContainerWidth =
          this.getGutterContainerWidth() +
          this.getContentWidth() +
          this.getVerticalScrollbarWidth() +
          'px';
      } else {
        style.width = this.element.style.width;
      }
    }
    let attributes = {};
    if (model.isMini()) {
      attributes.mini = '';
    }
    if (model.isReadOnly()) {
      attributes.readonly = '';
    }
    const dataset = { encoding: model.getEncoding() };
    const grammar = model.getGrammar();
    if (grammar && grammar.scopeName) {
      dataset.grammar = grammar.scopeName.replace(/\./g, ' ');
    }
    return $(
      'atom-text-editor',
      {
        style,
        attributes,
        dataset,
        tabIndex: -1,
        on: { mousewheel: this.didMouseWheel }
      },
      $.div(
        {
          ref: 'clientContainer',
          style: {
            position: 'relative',
            contain: 'strict',
            overflow: 'hidden',
            backgroundColor: 'inherit',
            height: clientContainerHeight,
            width: clientContainerWidth
          }
        },
        this.renderGutterContainer(),
        this.renderScrollContainer()
      ),
      this.renderOverlayDecorations()
    );
  }
  renderGutterContainer() {
    if (this.props.model.isMini()) {
      return null;
    } else {
      return $(GutterContainerComponent, {
        ref: 'gutterContainer',
        key: 'gutterContainer',
        rootComponent: this,
        hasInitialMeasurements: this.hasInitialMeasurements,
        measuredContent: this.measuredContent,
        scrollTop: this.getScrollTop(),
        scrollHeight: this.getScrollHeight(),
        lineNumberGutterWidth: this.getLineNumberGutterWidth(),
        lineHeight: this.getLineHeight(),
        renderedStartRow: this.getRenderedStartRow(),
        renderedEndRow: this.getRenderedEndRow(),
        rowsPerTile: this.getRowsPerTile(),
        guttersToRender: this.guttersToRender,
        decorationsToRender: this.decorationsToRender,
        isLineNumberGutterVisible: this.props.model.isLineNumberGutterVisible(),
        showLineNumbers: this.showLineNumbers,
        lineNumbersToRender: this.lineNumbersToRender,
        didMeasureVisibleBlockDecoration: this.didMeasureVisibleBlockDecoration
      });
    }
  }
  renderScrollContainer() {
    const style = {
      position: 'absolute',
      contain: 'strict',
      overflow: 'hidden',
      top: 0,
      bottom: 0,
      backgroundColor: 'inherit'
    };
    if (this.hasInitialMeasurements) {
      style.left = this.getGutterContainerWidth() + 'px';
      style.width = this.getScrollContainerWidth() + 'px';
    }
    return $.div(
      {
        ref: 'scrollContainer',
        key: 'scrollContainer',
        className: 'scroll-view',
        style
      },
      this.renderContent(),
      this.renderDummyScrollbars()
    );
  }
  renderContent() {
    let style = {
      contain: 'strict',
      overflow: 'hidden',
      backgroundColor: 'inherit'
    };
    if (this.hasInitialMeasurements) {
      style.width = ceilToPhysicalPixelBoundary(this.getScrollWidth()) + 'px';
      style.height = ceilToPhysicalPixelBoundary(this.getScrollHeight()) + 'px';
      style.willChange = 'transform';
      style.transform = `translate(${-roundToPhysicalPixelBoundary(
        this.getScrollLeft()
      )}px, ${-roundToPhysicalPixelBoundary(this.getScrollTop())}px)`;
    }
    return $.div(
      {
        ref: 'content',
        on: { mousedown: this.didMouseDownOnContent },
        style
      },
      this.renderLineTiles(),
      this.renderBlockDecorationMeasurementArea(),
      this.renderCharacterMeasurementLine()
    );
  }
  renderHighlightDecorations() {
    return $(HighlightsComponent, {
      hasInitialMeasurements: this.hasInitialMeasurements,
      highlightDecorations: this.decorationsToRender.highlights.slice(),
      width: this.getScrollWidth(),
      height: this.getScrollHeight(),
      lineHeight: this.getLineHeight()
    });
  }
  renderLineTiles() {
    const style = {
      position: 'absolute',
      contain: 'strict',
      overflow: 'hidden'
    };
    const children = [];
    children.push(this.renderHighlightDecorations());
    if (this.hasInitialMeasurements) {
      const { lineComponentsByScreenLineId } = this;
      const startRow = this.getRenderedStartRow();
      const endRow = this.getRenderedEndRow();
      const rowsPerTile = this.getRowsPerTile();
      const tileWidth = this.getScrollWidth();
      for (let i = 0; i < this.renderedTileStartRows.length; i++) {
        const tileStartRow = this.renderedTileStartRows[i];
        const tileEndRow = Math.min(endRow, tileStartRow + rowsPerTile);
        const tileHeight =
          this.pixelPositionBeforeBlocksForRow(tileEndRow) -
          this.pixelPositionBeforeBlocksForRow(tileStartRow);
        children.push(
          $(LinesTileComponent, {
            key: this.idsByTileStartRow.get(tileStartRow),
            measuredContent: this.measuredContent,
            height: tileHeight,
            width: tileWidth,
            top: this.pixelPositionBeforeBlocksForRow(tileStartRow),
            lineHeight: this.getLineHeight(),
            renderedStartRow: startRow,
            tileStartRow,
            tileEndRow,
            screenLines: this.renderedScreenLines.slice(
              tileStartRow - startRow,
              tileEndRow - startRow
            ),
            lineDecorations: this.decorationsToRender.lines.slice(
              tileStartRow - startRow,
              tileEndRow - startRow
            ),
            textDecorations: this.decorationsToRender.text.slice(
              tileStartRow - startRow,
              tileEndRow - startRow
            ),
            blockDecorations: this.decorationsToRender.blocks.get(tileStartRow),
            displayLayer: this.props.model.displayLayer,
            nodePool: this.lineNodesPool,
            lineComponentsByScreenLineId
          })
        );
      }
      this.extraRenderedScreenLines.forEach((screenLine, screenRow) => {
        if (screenRow < startRow || screenRow >= endRow) {
          children.push(
            $(LineComponent, {
              key: 'extra-' + screenLine.id,
              offScreen: true,
              screenLine,
              screenRow,
              displayLayer: this.props.model.displayLayer,
              nodePool: this.lineNodesPool,
              lineComponentsByScreenLineId
            })
          );
        }
      });
      style.width = this.getScrollWidth() + 'px';
      style.height = this.getScrollHeight() + 'px';
    }
    children.push(this.renderPlaceholderText());
    children.push(this.renderCursorsAndInput());
    return $.div(
      { key: 'lineTiles', ref: 'lineTiles', className: 'lines', style },
      children
    );
  }
  renderCursorsAndInput() {
    return $(CursorsAndInputComponent, {
      ref: 'cursorsAndInput',
      key: 'cursorsAndInput',
      didBlurHiddenInput: this.didBlurHiddenInput,
      didFocusHiddenInput: this.didFocusHiddenInput,
      didTextInput: this.didTextInput,
      didPaste: this.didPaste,
      didKeydown: this.didKeydown,
      didKeyup: this.didKeyup,
      didKeypress: this.didKeypress,
      didCompositionStart: this.didCompositionStart,
      didCompositionUpdate: this.didCompositionUpdate,
      didCompositionEnd: this.didCompositionEnd,
      measuredContent: this.measuredContent,
      lineHeight: this.getLineHeight(),
      scrollHeight: this.getScrollHeight(),
      scrollWidth: this.getScrollWidth(),
      decorationsToRender: this.decorationsToRender,
      cursorsBlinkedOff: this.cursorsBlinkedOff,
      hiddenInputPosition: this.hiddenInputPosition,
      tabIndex: this.tabIndex
    });
  }
  renderPlaceholderText() {
    const { model } = this.props;
    if (model.isEmpty()) {
      const placeholderText = model.getPlaceholderText();
      if (placeholderText != null) {
        return $.div({ className: 'placeholder-text' }, placeholderText);
      }
    }
    return null;
  }
  renderCharacterMeasurementLine() {
    return $.div(
      {
        key: 'characterMeasurementLine',
        ref: 'characterMeasurementLine',
        className: 'line dummy',
        style: { position: 'absolute', visibility: 'hidden' }
      },
      $.span({ ref: 'normalWidthCharacterSpan' }, NORMAL_WIDTH_CHARACTER),
      $.span({ ref: 'doubleWidthCharacterSpan' }, DOUBLE_WIDTH_CHARACTER),
      $.span({ ref: 'halfWidthCharacterSpan' }, HALF_WIDTH_CHARACTER),
      $.span({ ref: 'koreanCharacterSpan' }, KOREAN_CHARACTER)
    );
  }
  renderBlockDecorationMeasurementArea() {
    return $.div({
      ref: 'blockDecorationMeasurementArea',
      key: 'blockDecorationMeasurementArea',
      style: {
        contain: 'strict',
        position: 'absolute',
        visibility: 'hidden',
        width: this.getScrollWidth() + 'px'
      }
    });
  }
  renderDummyScrollbars() {
    if (this.shouldRenderDummyScrollbars && !this.props.model.isMini()) {
      let scrollHeight, scrollTop, horizontalScrollbarHeight;
      let scrollWidth,
        scrollLeft,
        verticalScrollbarWidth,
        forceScrollbarVisible;
      let canScrollHorizontally, canScrollVertically;
      if (this.hasInitialMeasurements) {
        scrollHeight = this.getScrollHeight();
        scrollWidth = this.getScrollWidth();
        scrollTop = this.getScrollTop();
        scrollLeft = this.getScrollLeft();
        canScrollHorizontally = this.canScrollHorizontally();
        canScrollVertically = this.canScrollVertically();
        horizontalScrollbarHeight = this.getHorizontalScrollbarHeight();
        verticalScrollbarWidth = this.getVerticalScrollbarWidth();
        forceScrollbarVisible = this.remeasureScrollbars;
      } else {
        forceScrollbarVisible = true;
      }
      return [
        $(DummyScrollbarComponent, {
          ref: 'verticalScrollbar',
          orientation: 'vertical',
          didScroll: this.didScrollDummyScrollbar,
          didMouseDown: this.didMouseDownOnContent,
          canScroll: canScrollVertically,
          scrollHeight,
          scrollTop,
          horizontalScrollbarHeight,
          forceScrollbarVisible
        }),
        $(DummyScrollbarComponent, {
          ref: 'horizontalScrollbar',
          orientation: 'horizontal',
          didScroll: this.didScrollDummyScrollbar,
          didMouseDown: this.didMouseDownOnContent,
          canScroll: canScrollHorizontally,
          scrollWidth,
          scrollLeft,
          verticalScrollbarWidth,
          forceScrollbarVisible
        }),
        $.div({
          ref: 'scrollbarCorner',
          className: 'scrollbar-corner',
          style: {
            position: 'absolute',
            height: '20px',
            width: '20px',
            bottom: 0,
            right: 0,
            overflow: 'scroll'
          }
        })
      ];
    } else {
      return null;
    }
  }
  renderOverlayDecorations() {
    return this.decorationsToRender.overlays.map(overlayProps =>
      $(
        OverlayComponent,
        Object.assign(
          {
            key: overlayProps.element,
            overlayComponents: this.overlayComponents,
            didResize: overlayComponent => {
              this.updateOverlayToRender(overlayProps);
              overlayComponent.update(overlayProps);
            }
          },
          overlayProps
        )
      )
    );
  }
  updateClassList() {
    const { model } = this.props;
    const oldClassList = this.classList;
    const newClassList = ['editor'];
    if (this.focused) newClassList.push('is-focused');
    if (model.isMini()) newClassList.push('mini');
    for (var i = 0; i < model.selections.length; i++) {
      if (!model.selections[i].isEmpty()) {
        newClassList.push('has-selection');
        break;
      }
    }
    if (oldClassList) {
      for (let i = 0; i < oldClassList.length; i++) {
        const className = oldClassList[i];
        if (!newClassList.includes(className)) {
          this.element.classList.remove(className);
        }
      }
    }
    for (let i = 0; i < newClassList.length; i++) {
      this.element.classList.add(newClassList[i]);
    }
    this.classList = newClassList;
  }
  queryScreenLinesToRender() {
    const { model } = this.props;
    this.renderedScreenLines = model.displayLayer.getScreenLines(
      this.getRenderedStartRow(),
      this.getRenderedEndRow()
    );
  }
  queryLongestLine() {
    const { model } = this.props;
    const longestLineRow = model.getApproximateLongestScreenRow();
    const longestLine = model.screenLineForScreenRow(longestLineRow);
    if (
      longestLine !== this.previousLongestLine ||
      this.remeasureCharacterDimensions
    ) {
      this.requestLineToMeasure(longestLineRow, longestLine);
      this.longestLineToMeasure = longestLine;
      this.previousLongestLine = longestLine;
    }
  }
  queryExtraScreenLinesToRender() {
    this.extraRenderedScreenLines.clear();
    this.linesToMeasure.forEach((screenLine, row) => {
      if (row < this.getRenderedStartRow() || row >= this.getRenderedEndRow()) {
        this.extraRenderedScreenLines.set(row, screenLine);
      }
    });
  }
  queryLineNumbersToRender() {
    const { model } = this.props;
    if (!model.anyLineNumberGutterVisible()) return;
    if (this.showLineNumbers !== model.doesShowLineNumbers()) {
      this.remeasureGutterDimensions = true;
      this.showLineNumbers = model.doesShowLineNumbers();
    }
    this.queryMaxLineNumberDigits();
    const startRow = this.getRenderedStartRow();
    const endRow = this.getRenderedEndRow();
    const renderedRowCount = this.getRenderedRowCount();
    const bufferRows = model.bufferRowsForScreenRows(startRow, endRow);
    const screenRows = new Array(renderedRowCount);
    const keys = new Array(renderedRowCount);
    const foldableFlags = new Array(renderedRowCount);
    const softWrappedFlags = new Array(renderedRowCount);
    let previousBufferRow =
      startRow > 0 ? model.bufferRowForScreenRow(startRow - 1) : -1;
    let softWrapCount = 0;
    for (let row = startRow; row < endRow; row++) {
      const i = row - startRow;
      const bufferRow = bufferRows[i];
      if (bufferRow === previousBufferRow) {
        softWrapCount++;
        softWrappedFlags[i] = true;
        keys[i] = bufferRow + '-' + softWrapCount;
      } else {
        softWrapCount = 0;
        softWrappedFlags[i] = false;
        keys[i] = bufferRow;
      }
      const nextBufferRow = bufferRows[i + 1];
      if (bufferRow !== nextBufferRow) {
        foldableFlags[i] = model.isFoldableAtBufferRow(bufferRow);
      } else {
        foldableFlags[i] = false;
      }
      screenRows[i] = row;
      previousBufferRow = bufferRow;
    }
    bufferRows.pop();
    this.lineNumbersToRender.bufferRows = bufferRows;
    this.lineNumbersToRender.screenRows = screenRows;
    this.lineNumbersToRender.keys = keys;
    this.lineNumbersToRender.foldableFlags = foldableFlags;
    this.lineNumbersToRender.softWrappedFlags = softWrappedFlags;
  }
  queryMaxLineNumberDigits() {
    const { model } = this.props;
    if (model.anyLineNumberGutterVisible()) {
      const maxDigits = Math.max(2, model.getLineCount().toString().length);
      if (maxDigits !== this.lineNumbersToRender.maxDigits) {
        this.remeasureGutterDimensions = true;
        this.lineNumbersToRender.maxDigits = maxDigits;
      }
    }
  }
  renderedScreenLineForRow(row) {
    return (
      this.renderedScreenLines[row - this.getRenderedStartRow()] ||
      this.extraRenderedScreenLines.get(row)
    );
  }
  queryGuttersToRender() {
    const oldGuttersToRender = this.guttersToRender;
    const oldGuttersVisibility = this.guttersVisibility;
    this.guttersToRender = this.props.model.getGutters();
    this.guttersVisibility = this.guttersToRender.map(g => g.visible);
    if (
      !oldGuttersToRender ||
      oldGuttersToRender.length !== this.guttersToRender.length
    ) {
      this.remeasureGutterDimensions = true;
    } else {
      for (let i = 0, length = this.guttersToRender.length; i < length; i++) {
        if (
          this.guttersToRender[i] !== oldGuttersToRender[i] ||
          this.guttersVisibility[i] !== oldGuttersVisibility[i]
        ) {
          this.remeasureGutterDimensions = true;
          break;
        }
      }
    }
  }
  queryDecorationsToRender() {
    this.decorationsToRender.lineNumbers.clear();
    this.decorationsToRender.lines = [];
    this.decorationsToRender.overlays.length = 0;
    this.decorationsToRender.customGutter.clear();
    this.decorationsToRender.blocks = new Map();
    this.decorationsToRender.text = [];
    this.decorationsToMeasure.highlights.length = 0;
    this.decorationsToMeasure.cursors.clear();
    this.textDecorationsByMarker.clear();
    this.textDecorationBoundaries.length = 0;
    const decorationsByMarker = this.props.model.decorationManager.decorationPropertiesByMarkerForScreenRowRange(
      this.getRenderedStartRow(),
      this.getRenderedEndRow()
    );
    decorationsByMarker.forEach((decorations, marker) => {
      const screenRange = marker.getScreenRange();
      const reversed = marker.isReversed();
      for (let i = 0; i < decorations.length; i++) {
        const decoration = decorations[i];
        this.addDecorationToRender(
          decoration.type,
          decoration,
          marker,
          screenRange,
          reversed
        );
      }
    });
    this.populateTextDecorationsToRender();
  }
  addDecorationToRender(type, decoration, marker, screenRange, reversed) {
    if (Array.isArray(type)) {
      for (let i = 0, length = type.length; i < length; i++) {
        this.addDecorationToRender(
          type[i],
          decoration,
          marker,
          screenRange,
          reversed
        );
      }
    } else {
      switch (type) {
        case 'line':
        case 'line-number':
          this.addLineDecorationToRender(
            type,
            decoration,
            screenRange,
            reversed
          );
          break;
        case 'highlight':
          this.addHighlightDecorationToMeasure(
            decoration,
            screenRange,
            marker.id
          );
          break;
        case 'cursor':
          this.addCursorDecorationToMeasure(
            decoration,
            marker,
            screenRange,
            reversed
          );
          break;
        case 'overlay':
          this.addOverlayDecorationToRender(decoration, marker);
          break;
        case 'gutter':
          this.addCustomGutterDecorationToRender(decoration, screenRange);
          break;
        case 'block':
          this.addBlockDecorationToRender(decoration, screenRange, reversed);
          break;
        case 'text':
          this.addTextDecorationToRender(decoration, screenRange, marker);
          break;
      }
    }
  }
  addLineDecorationToRender(type, decoration, screenRange, reversed) {
    let decorationsToRender;
    if (type === 'line') {
      decorationsToRender = this.decorationsToRender.lines;
    } else {
      const gutterName = decoration.gutterName || 'line-number';
      decorationsToRender = this.decorationsToRender.lineNumbers.get(
        gutterName
      );
      if (!decorationsToRender) {
        decorationsToRender = [];
        this.decorationsToRender.lineNumbers.set(
          gutterName,
          decorationsToRender
        );
      }
    }
    let omitLastRow = false;
    if (screenRange.isEmpty()) {
      if (decoration.onlyNonEmpty) return;
    } else {
      if (decoration.onlyEmpty) return;
      if (decoration.omitEmptyLastRow !== false) {
        omitLastRow = screenRange.end.column === 0;
      }
    }
    const renderedStartRow = this.getRenderedStartRow();
    let rangeStartRow = screenRange.start.row;
    let rangeEndRow = screenRange.end.row;
    if (decoration.onlyHead) {
      if (reversed) {
        rangeEndRow = rangeStartRow;
      } else {
        rangeStartRow = rangeEndRow;
      }
    }
    rangeStartRow = Math.max(rangeStartRow, this.getRenderedStartRow());
    rangeEndRow = Math.min(rangeEndRow, this.getRenderedEndRow() - 1);
    for (let row = rangeStartRow; row <= rangeEndRow; row++) {
      if (omitLastRow && row === screenRange.end.row) break;
      const currentClassName = decorationsToRender[row - renderedStartRow];
      const newClassName = currentClassName
        ? currentClassName + ' ' + decoration.class
        : decoration.class;
      decorationsToRender[row - renderedStartRow] = newClassName;
    }
  }
  addHighlightDecorationToMeasure(decoration, screenRange, key) {
    screenRange = constrainRangeToRows(
      screenRange,
      this.getRenderedStartRow(),
      this.getRenderedEndRow()
    );
    if (screenRange.isEmpty()) return;
    const {
      class: className,
      flashRequested,
      flashClass,
      flashDuration
    } = decoration;
    decoration.flashRequested = false;
    this.decorationsToMeasure.highlights.push({
      screenRange,
      key,
      className,
      flashRequested,
      flashClass,
      flashDuration
    });
    this.requestHorizontalMeasurement(
      screenRange.start.row,
      screenRange.start.column
    );
    this.requestHorizontalMeasurement(
      screenRange.end.row,
      screenRange.end.column
    );
  }
  addCursorDecorationToMeasure(decoration, marker, screenRange, reversed) {
    const { model } = this.props;
    if (!model.getShowCursorOnSelection() && !screenRange.isEmpty()) return;
    let decorationToMeasure = this.decorationsToMeasure.cursors.get(marker);
    if (!decorationToMeasure) {
      const isLastCursor = model.getLastCursor().getMarker() === marker;
      const screenPosition = reversed ? screenRange.start : screenRange.end;
      const { row, column } = screenPosition;
      if (row < this.getRenderedStartRow() || row >= this.getRenderedEndRow())
        return;
      this.requestHorizontalMeasurement(row, column);
      let columnWidth = 0;
      if (model.lineLengthForScreenRow(row) > column) {
        columnWidth = 1;
        this.requestHorizontalMeasurement(row, column + 1);
      }
      decorationToMeasure = { screenPosition, columnWidth, isLastCursor };
      this.decorationsToMeasure.cursors.set(marker, decorationToMeasure);
    }
    if (decoration.class) {
      if (decorationToMeasure.className) {
        decorationToMeasure.className += ' ' + decoration.class;
      } else {
        decorationToMeasure.className = decoration.class;
      }
    }
    if (decoration.style) {
      if (decorationToMeasure.style) {
        Object.assign(decorationToMeasure.style, decoration.style);
      } else {
        decorationToMeasure.style = Object.assign({}, decoration.style);
      }
    }
  }
  addOverlayDecorationToRender(decoration, marker) {
    const { class: className, item, position, avoidOverflow } = decoration;
    const element = TextEditor.viewForItem(item);
    const screenPosition =
      position === 'tail'
        ? marker.getTailScreenPosition()
        : marker.getHeadScreenPosition();
    this.requestHorizontalMeasurement(
      screenPosition.row,
      screenPosition.column
    );
    this.decorationsToRender.overlays.push({
      className,
      element,
      avoidOverflow,
      screenPosition
    });
  }
  addCustomGutterDecorationToRender(decoration, screenRange) {
    let decorations = this.decorationsToRender.customGutter.get(
      decoration.gutterName
    );
    if (!decorations) {
      decorations = [];
      this.decorationsToRender.customGutter.set(
        decoration.gutterName,
        decorations
      );
    }
    const top = this.pixelPositionAfterBlocksForRow(screenRange.start.row);
    const height =
      this.pixelPositionBeforeBlocksForRow(screenRange.end.row + 1) - top;
    decorations.push({
      className:
        'decoration' + (decoration.class ? ' ' + decoration.class : ''),
      element: TextEditor.viewForItem(decoration.item),
      top,
      height
    });
  }
  addBlockDecorationToRender(decoration, screenRange, reversed) {
    const { row } = reversed ? screenRange.start : screenRange.end;
    if (row < this.getRenderedStartRow() || row >= this.getRenderedEndRow())
      return;
    const tileStartRow = this.tileStartRowForRow(row);
    const screenLine = this.renderedScreenLines[
      row - this.getRenderedStartRow()
    ];
    let decorationsByScreenLine = this.decorationsToRender.blocks.get(
      tileStartRow
    );
    if (!decorationsByScreenLine) {
      decorationsByScreenLine = new Map();
      this.decorationsToRender.blocks.set(
        tileStartRow,
        decorationsByScreenLine
      );
    }
    let decorations = decorationsByScreenLine.get(screenLine.id);
    if (!decorations) {
      decorations = [];
      decorationsByScreenLine.set(screenLine.id, decorations);
    }
    decorations.push(decoration);
    // Order block decorations by increasing values of their "order" property. Break ties with "id", which mirrors
    // their creation sequence.
    decorations.sort((a, b) =>
      a.order !== b.order ? a.order - b.order : a.id - b.id
    );
  }
  addTextDecorationToRender(decoration, screenRange, marker) {
    if (screenRange.isEmpty()) return;
    let decorationsForMarker = this.textDecorationsByMarker.get(marker);
    if (!decorationsForMarker) {
      decorationsForMarker = [];
      this.textDecorationsByMarker.set(marker, decorationsForMarker);
      this.textDecorationBoundaries.push({
        position: screenRange.start,
        starting: [marker]
      });
      this.textDecorationBoundaries.push({
        position: screenRange.end,
        ending: [marker]
      });
    }
    decorationsForMarker.push(decoration);
  }
  populateTextDecorationsToRender() {
    // Sort all boundaries in ascending order of position
    this.textDecorationBoundaries.sort((a, b) =>
      a.position.compare(b.position)
    );
    // Combine adjacent boundaries with the same position
    for (let i = 0; i < this.textDecorationBoundaries.length; ) {
      const boundary = this.textDecorationBoundaries[i];
      const nextBoundary = this.textDecorationBoundaries[i + 1];
      if (nextBoundary && nextBoundary.position.isEqual(boundary.position)) {
        if (nextBoundary.starting) {
          if (boundary.starting) {
            boundary.starting.push(...nextBoundary.starting);
          } else {
            boundary.starting = nextBoundary.starting;
          }
        }
        if (nextBoundary.ending) {
          if (boundary.ending) {
            boundary.ending.push(...nextBoundary.ending);
          } else {
            boundary.ending = nextBoundary.ending;
          }
        }
        this.textDecorationBoundaries.splice(i + 1, 1);
      } else {
        i++;
      }
    }
    const renderedStartRow = this.getRenderedStartRow();
    const renderedEndRow = this.getRenderedEndRow();
    const containingMarkers = [];
    // Iterate over boundaries to build up text decorations.
    for (let i = 0; i < this.textDecorationBoundaries.length; i++) {
      const boundary = this.textDecorationBoundaries[i];
      // If multiple markers start here, sort them by order of nesting (markers ending later come first)
      if (boundary.starting && boundary.starting.length > 1) {
        boundary.starting.sort((a, b) => a.compare(b));
      }
      // If multiple markers start here, sort them by order of nesting (markers starting earlier come first)
      if (boundary.ending && boundary.ending.length > 1) {
        boundary.ending.sort((a, b) => b.compare(a));
      }
      // Remove markers ending here from containing markers array
      if (boundary.ending) {
        for (let j = boundary.ending.length - 1; j >= 0; j--) {
          containingMarkers.splice(
            containingMarkers.lastIndexOf(boundary.ending[j]),
            1
          );
        }
      }
      // Add markers starting here to containing markers array
      if (boundary.starting) containingMarkers.push(...boundary.starting);
      // Determine desired className and style based on containing markers
      let className, style;
      for (let j = 0; j < containingMarkers.length; j++) {
        const marker = containingMarkers[j];
        const decorations = this.textDecorationsByMarker.get(marker);
        for (let k = 0; k < decorations.length; k++) {
          const decoration = decorations[k];
          if (decoration.class) {
            if (className) {
              className += ' ' + decoration.class;
            } else {
              className = decoration.class;
            }
          }
          if (decoration.style) {
            if (style) {
              Object.assign(style, decoration.style);
            } else {
              style = Object.assign({}, decoration.style);
            }
          }
        }
      }
      // Add decoration start with className/style for current position's column,
      if (boundary.position.row >= renderedStartRow) {
        this.addTextDecorationStart(
          boundary.position.row,
          boundary.position.column,
          className,
          style
        );
      }
      const nextBoundary = this.textDecorationBoundaries[i + 1];
      if (nextBoundary) {
        let row = Math.max(boundary.position.row + 1, renderedStartRow);
        const endRow = Math.min(nextBoundary.position.row, renderedEndRow);
        for (; row < endRow; row++) {
          this.addTextDecorationStart(row, 0, className, style);
        }
        if (
          row === nextBoundary.position.row &&
          nextBoundary.position.column !== 0
        ) {
          this.addTextDecorationStart(row, 0, className, style);
        }
      }
    }
  }
  addTextDecorationStart(row, column, className, style) {
    const renderedStartRow = this.getRenderedStartRow();
    let decorationStarts = this.decorationsToRender.text[
      row - renderedStartRow
    ];
    if (!decorationStarts) {
      decorationStarts = [];
      this.decorationsToRender.text[row - renderedStartRow] = decorationStarts;
    }
    decorationStarts.push({ column, className, style });
  }
  updateAbsolutePositionedDecorations() {
    this.updateHighlightsToRender();
    this.updateCursorsToRender();
    this.updateOverlaysToRender();
  }
  updateHighlightsToRender() {
    this.decorationsToRender.highlights.length = 0;
    for (let i = 0; i < this.decorationsToMeasure.highlights.length; i++) {
      const highlight = this.decorationsToMeasure.highlights[i];
      const { start, end } = highlight.screenRange;
      highlight.startPixelTop = this.pixelPositionAfterBlocksForRow(start.row);
      highlight.startPixelLeft = this.pixelLeftForRowAndColumn(
        start.row,
        start.column
      );
      highlight.endPixelTop =
        this.pixelPositionAfterBlocksForRow(end.row) + this.getLineHeight();
      highlight.endPixelLeft = this.pixelLeftForRowAndColumn(
        end.row,
        end.column
      );
      this.decorationsToRender.highlights.push(highlight);
    }
  }
  updateCursorsToRender() {
    this.decorationsToRender.cursors.length = 0;
    this.decorationsToMeasure.cursors.forEach(cursor => {
      const { screenPosition, className, style } = cursor;
      const { row, column } = screenPosition;
      const pixelTop = this.pixelPositionAfterBlocksForRow(row);
      const pixelLeft = this.pixelLeftForRowAndColumn(row, column);
      let pixelWidth;
      if (cursor.columnWidth === 0) {
        pixelWidth = this.getBaseCharacterWidth();
      } else {
        pixelWidth = this.pixelLeftForRowAndColumn(row, column + 1) - pixelLeft;
      }
      const cursorPosition = {
        pixelTop,
        pixelLeft,
        pixelWidth,
        className,
        style
      };
      this.decorationsToRender.cursors.push(cursorPosition);
      if (cursor.isLastCursor) this.hiddenInputPosition = cursorPosition;
    });
  }
  updateOverlayToRender(decoration) {
    const windowInnerHeight = this.getWindowInnerHeight();
    const windowInnerWidth = this.getWindowInnerWidth();
    const contentClientRect = this.refs.content.getBoundingClientRect();
    const { element, screenPosition, avoidOverflow } = decoration;
    const { row, column } = screenPosition;
    let wrapperTop =
      contentClientRect.top +
      this.pixelPositionAfterBlocksForRow(row) +
      this.getLineHeight();
    let wrapperLeft =
      contentClientRect.left + this.pixelLeftForRowAndColumn(row, column);
    const clientRect = element.getBoundingClientRect();
    if (avoidOverflow !== false) {
      const computedStyle = window.getComputedStyle(element);
      const elementTop = wrapperTop + parseInt(computedStyle.marginTop);
      const elementBottom = elementTop + clientRect.height;
      const flippedElementTop =
        wrapperTop -
        this.getLineHeight() -
        clientRect.height -
        parseInt(computedStyle.marginBottom);
      const elementLeft = wrapperLeft + parseInt(computedStyle.marginLeft);
      const elementRight = elementLeft + clientRect.width;
      if (elementBottom > windowInnerHeight && flippedElementTop >= 0) {
        wrapperTop -= elementTop - flippedElementTop;
      }
      if (elementLeft < 0) {
        wrapperLeft -= elementLeft;
      } else if (elementRight > windowInnerWidth) {
        wrapperLeft -= elementRight - windowInnerWidth;
      }
    }
    decoration.pixelTop = Math.round(wrapperTop);
    decoration.pixelLeft = Math.round(wrapperLeft);
  }
  updateOverlaysToRender() {
    const overlayCount = this.decorationsToRender.overlays.length;
    if (overlayCount === 0) return null;
    for (let i = 0; i < overlayCount; i++) {
      const decoration = this.decorationsToRender.overlays[i];
      this.updateOverlayToRender(decoration);
    }
  }
  didAttach() {
    if (!this.attached) {
      this.attached = true;
      this.intersectionObserver = new IntersectionObserver(entries => {
        const { intersectionRect } = entries[entries.length - 1];
        if (intersectionRect.width > 0 || intersectionRect.height > 0) {
          this.didShow();
        } else {
          this.didHide();
        }
      });
      this.intersectionObserver.observe(this.element);
      this.resizeObserver = new ResizeObserver(this.didResize.bind(this));
      this.resizeObserver.observe(this.element);
      if (this.refs.gutterContainer) {
        this.gutterContainerResizeObserver = new ResizeObserver(
          this.didResizeGutterContainer.bind(this)
        );
        this.gutterContainerResizeObserver.observe(
          this.refs.gutterContainer.element
        );
      }
      this.overlayComponents.forEach(component => component.didAttach());
      if (this.isVisible()) {
        this.didShow();
        if (this.refs.verticalScrollbar)
          this.refs.verticalScrollbar.flushScrollPosition();
        if (this.refs.horizontalScrollbar)
          this.refs.horizontalScrollbar.flushScrollPosition();
      } else {
        this.didHide();
      }
      if (!this.constructor.attachedComponents) {
        this.constructor.attachedComponents = new Set();
      }
      this.constructor.attachedComponents.add(this);
    }
  }
  didDetach() {
    if (this.attached) {
      this.intersectionObserver.disconnect();
      this.resizeObserver.disconnect();
      if (this.gutterContainerResizeObserver)
        this.gutterContainerResizeObserver.disconnect();
      this.overlayComponents.forEach(component => component.didDetach());
      this.didHide();
      this.attached = false;
      this.constructor.attachedComponents.delete(this);
    }
  }
  didShow() {
    if (!this.visible && this.isVisible()) {
      if (!this.hasInitialMeasurements) this.measureDimensions();
      this.visible = true;
      this.props.model.setVisible(true);
      this.resizeBlockDecorationMeasurementsArea = true;
      this.updateSync();
      this.flushPendingLogicalScrollPosition();
    }
  }
  didHide() {
    if (this.visible) {
      this.visible = false;
      this.props.model.setVisible(false);
    }
  }
  didFocus() {
    if (!this.visible) this.didShow();
    if (!this.focused) {
      this.focused = true;
      this.startCursorBlinking();
      this.scheduleUpdate();
    }
    this.getHiddenInput().focus({ preventScroll: true });
  }
  didBlur(event) {
    if (event.relatedTarget === this.getHiddenInput()) {
      event.stopImmediatePropagation();
    }
  }
  didBlurHiddenInput(event) {
    if (
      this.element !== event.relatedTarget &&
      !this.element.contains(event.relatedTarget)
    ) {
      this.focused = false;
      this.stopCursorBlinking();
      this.scheduleUpdate();
      this.element.dispatchEvent(new FocusEvent(event.type, event));
    }
  }
  didFocusHiddenInput() {
    this.refs.scrollContainer.scrollTop = 0;
    this.refs.scrollContainer.scrollLeft = 0;
    if (!this.focused) {
      this.focused = true;
      this.startCursorBlinking();
      this.scheduleUpdate();
    }
  }
  didMouseWheel(event) {
    const scrollSensitivity = this.props.model.getScrollSensitivity() / 100;
    let { wheelDeltaX, wheelDeltaY } = event;
    if (Math.abs(wheelDeltaX) > Math.abs(wheelDeltaY)) {
      wheelDeltaX = wheelDeltaX * scrollSensitivity;
      wheelDeltaY = 0;
    } else {
      wheelDeltaX = 0;
      wheelDeltaY = wheelDeltaY * scrollSensitivity;
    }
    if (this.getPlatform() !== 'darwin' && event.shiftKey) {
      let temp = wheelDeltaX;
      wheelDeltaX = wheelDeltaY;
      wheelDeltaY = temp;
    }
    const scrollLeftChanged =
      wheelDeltaX !== 0 &&
      this.setScrollLeft(this.getScrollLeft() - wheelDeltaX);
    const scrollTopChanged =
      wheelDeltaY !== 0 && this.setScrollTop(this.getScrollTop() - wheelDeltaY);
    if (scrollLeftChanged || scrollTopChanged) {
      event.preventDefault();
      this.updateSync();
    }
  }
  didResize() {
    if (this.isVisible()) {
      const clientContainerWidthChanged = this.measureClientContainerWidth();
      const clientContainerHeightChanged = this.measureClientContainerHeight();
      if (clientContainerWidthChanged || clientContainerHeightChanged) {
        if (clientContainerWidthChanged) {
          this.remeasureAllBlockDecorations = true;
        }
        this.resizeObserver.disconnect();
        this.scheduleUpdate();
        process.nextTick(() => {
          this.resizeObserver.observe(this.element);
        });
      }
    }
  }
  didResizeGutterContainer() {
    if (this.isVisible() && this.measureGutterDimensions()) {
      this.gutterContainerResizeObserver.disconnect();
      this.scheduleUpdate();
      process.nextTick(() => {
        this.gutterContainerResizeObserver.observe(
          this.refs.gutterContainer.element
        );
      });
    }
  }
  didScrollDummyScrollbar() {
    let scrollTopChanged = false;
    let scrollLeftChanged = false;
    if (!this.scrollTopPending) {
      scrollTopChanged = this.setScrollTop(
        this.refs.verticalScrollbar.element.scrollTop
      );
    }
    if (!this.scrollLeftPending) {
      scrollLeftChanged = this.setScrollLeft(
        this.refs.horizontalScrollbar.element.scrollLeft
      );
    }
    if (scrollTopChanged || scrollLeftChanged) this.updateSync();
  }
  didUpdateStyles() {
    this.remeasureCharacterDimensions = true;
    this.horizontalPixelPositionsByScreenLineId.clear();
    this.scheduleUpdate();
  }
  didUpdateScrollbarStyles() {
    if (!this.props.model.isMini()) {
      this.remeasureScrollbars = true;
      this.scheduleUpdate();
    }
  }
  didPaste(event) {
    if (this.getPlatform() === 'linux') event.preventDefault();
  }
  didTextInput(event) {
    if (this.compositionCheckpoint) {
      this.props.model.revertToCheckpoint(this.compositionCheckpoint);
      this.compositionCheckpoint = null;
    }
    if (this.isInputEnabled()) {
      event.stopPropagation();
      if (event.data === ' ') {
        window.setImmediate(() => {
          this.refs.scrollContainer.scrollTop = 0;
          this.refs.scrollContainer.scrollLeft = 0;
        });
      } else {
        event.preventDefault();
      }
      if (this.accentedCharacterMenuIsOpen) {
        this.props.model.selectLeft();
      }
      this.props.model.insertText(event.data, { groupUndo: true });
    }
  }
  didKeydown(event) {
    if (
      this.stopDragging &&
      event.key !== 'Control' &&
      event.key !== 'Alt' &&
      event.key !== 'Meta' &&
      event.key !== 'Shift'
    ) {
      this.stopDragging();
    }
    if (this.lastKeydownBeforeKeypress != null) {
      if (this.lastKeydownBeforeKeypress.code === event.code) {
        this.accentedCharacterMenuIsOpen = true;
      }
      this.lastKeydownBeforeKeypress = null;
    }
    this.lastKeydown = event;
  }
  didKeypress(event) {
    this.lastKeydownBeforeKeypress = this.lastKeydown;
    this.accentedCharacterMenuIsOpen = false;
  }
  didKeyup(event) {
    if (
      this.lastKeydownBeforeKeypress &&
      this.lastKeydownBeforeKeypress.code === event.code
    ) {
      this.lastKeydownBeforeKeypress = null;
    }
  }
  didCompositionStart() {
    if (this.lastKeydown && this.lastKeydown.defaultPrevented) {
      this.getHiddenInput().disabled = true;
      process.nextTick(() => {
        this.getHiddenInput().disabled = false;
        this.getHiddenInput().focus({ preventScroll: true });
      });
      return;
    }
    this.compositionCheckpoint = this.props.model.createCheckpoint();
    if (this.accentedCharacterMenuIsOpen) {
      this.props.model.selectLeft();
    }
  }
  didCompositionUpdate(event) {
    this.props.model.insertText(event.data, { select: true });
  }
  didCompositionEnd(event) {
    event.target.value = '';
  }
  didMouseDownOnContent(event) {
    const { model } = this.props;
    const { target, button, detail, ctrlKey, shiftKey, metaKey } = event;
    const platform = this.getPlatform();
    // Ignore clicks on block decorations.
    if (target) {
      let element = target;
      while (element && element !== this.element) {
        if (this.blockDecorationsByElement.has(element)) {
          return;
        }
        element = element.parentElement;
      }
    }
    const screenPosition = this.screenPositionForMouseEvent(event);
    if (button === 1) {
      model.setCursorScreenPosition(screenPosition, { autoscroll: false });
      // On Linux, pasting happens on middle click. A textInput event with the
      // contents of the selection clipboard will be dispatched by the browser
      // automatically on mouseup if editor.selectionClipboard is set to true.
      if (
        platform === 'linux' &&
        this.isInputEnabled() &&
        atom.config.get('editor.selectionClipboard')
      )
        model.insertText(clipboard.readText('selection'));
      return;
    }
    if (button !== 0) return;
    if (platform === 'darwin' && ctrlKey) return;
    if (target && target.matches('.fold-marker')) {
      const bufferPosition = model.bufferPositionForScreenPosition(
        screenPosition
      );
      model.destroyFoldsContainingBufferPositions([bufferPosition], false);
      return;
    }
    const allowMultiCursor = atom.config.get('editor.multiCursorOnClick');
    const addOrRemoveSelection =
      allowMultiCursor && (metaKey || (ctrlKey && platform !== 'darwin'));
    switch (detail) {
      case 1:
        if (addOrRemoveSelection) {
          const existingSelection = model.getSelectionAtScreenPosition(
            screenPosition
          );
          if (existingSelection) {
            if (model.hasMultipleCursors()) existingSelection.destroy();
          } else {
            model.addCursorAtScreenPosition(screenPosition, {
              autoscroll: false
            });
          }
        } else {
          if (shiftKey) {
            model.selectToScreenPosition(screenPosition, { autoscroll: false });
          } else {
            model.setCursorScreenPosition(screenPosition, {
              autoscroll: false
            });
          }
        }
        break;
      case 2:
        if (addOrRemoveSelection)
          model.addCursorAtScreenPosition(screenPosition, {
            autoscroll: false
          });
        model.getLastSelection().selectWord({ autoscroll: false });
        break;
      case 3:
        if (addOrRemoveSelection)
          model.addCursorAtScreenPosition(screenPosition, {
            autoscroll: false
          });
        model.getLastSelection().selectLine(null, { autoscroll: false });
        break;
    }
    this.handleMouseDragUntilMouseUp({
      didDrag: event => {
        this.autoscrollOnMouseDrag(event);
        const screenPosition = this.screenPositionForMouseEvent(event);
        model.selectToScreenPosition(screenPosition, {
          suppressSelectionMerge: true,
          autoscroll: false
        });
        this.updateSync();
      },
      didStopDragging: () => {
        model.finalizeSelections();
        model.mergeIntersectingSelections();
        this.updateSync();
      }
    });
  }
  didMouseDownOnLineNumberGutter(event) {
    const { model } = this.props;
    const { target, button, ctrlKey, shiftKey, metaKey } = event;
    if (button !== 0) return;
    const clickedScreenRow = this.screenPositionForMouseEvent(event).row;
    const startBufferRow = model.bufferPositionForScreenPosition([
      clickedScreenRow,
      0
    ]).row;
    if (
      target &&
      (target.matches('.foldable .icon-right') ||
        target.matches('.folded .icon-right'))
    ) {
      model.toggleFoldAtBufferRow(startBufferRow);
      return;
    }
    const addOrRemoveSelection =
      metaKey || (ctrlKey && this.getPlatform() !== 'darwin');
    const endBufferRow = model.bufferPositionForScreenPosition([
      clickedScreenRow,
      Infinity
    ]).row;
    const clickedLineBufferRange = Range(
      Point(startBufferRow, 0),
      Point(endBufferRow + 1, 0)
    );
    let initialBufferRange;
    if (shiftKey) {
      const lastSelection = model.getLastSelection();
      initialBufferRange = lastSelection.getBufferRange();
      lastSelection.setBufferRange(
        initialBufferRange.union(clickedLineBufferRange),
        {
          reversed: clickedScreenRow < lastSelection.getScreenRange().start.row,
          autoscroll: false,
          preserveFolds: true,
          suppressSelectionMerge: true
        }
      );
    } else {
      initialBufferRange = clickedLineBufferRange;
      if (addOrRemoveSelection) {
        model.addSelectionForBufferRange(clickedLineBufferRange, {
          autoscroll: false,
          preserveFolds: true
        });
      } else {
        model.setSelectedBufferRange(clickedLineBufferRange, {
          autoscroll: false,
          preserveFolds: true
        });
      }
    }
    const initialScreenRange = model.screenRangeForBufferRange(
      initialBufferRange
    );
    this.handleMouseDragUntilMouseUp({
      didDrag: event => {
        this.autoscrollOnMouseDrag(event, true);
        const dragRow = this.screenPositionForMouseEvent(event).row;
        const draggedLineScreenRange = Range(
          Point(dragRow, 0),
          Point(dragRow + 1, 0)
        );
        model
          .getLastSelection()
          .setScreenRange(draggedLineScreenRange.union(initialScreenRange), {
            reversed: dragRow < initialScreenRange.start.row,
            autoscroll: false,
            preserveFolds: true
          });
        this.updateSync();
      },
      didStopDragging: () => {
        model.mergeIntersectingSelections();
        this.updateSync();
      }
    });
  }
  handleMouseDragUntilMouseUp({ didDrag, didStopDragging }) {
    let dragging = false;
    let lastMousemoveEvent;
    const animationFrameLoop = () => {
      window.requestAnimationFrame(() => {
        if (dragging && this.visible) {
          didDrag(lastMousemoveEvent);
          animationFrameLoop();
        }
      });
    };
    function didMouseMove(event) {
      lastMousemoveEvent = event;
      if (!dragging) {
        dragging = true;
        animationFrameLoop();
      }
    }
    function didMouseUp() {
      this.stopDragging = null;
      window.removeEventListener('mousemove', didMouseMove);
      window.removeEventListener('mouseup', didMouseUp, { capture: true });
      if (dragging) {
        dragging = false;
        didStopDragging();
      }
    }
    window.addEventListener('mousemove', didMouseMove);
    window.addEventListener('mouseup', didMouseUp, { capture: true });
    this.stopDragging = didMouseUp;
  }
  autoscrollOnMouseDrag({ clientX, clientY }, verticalOnly = false) {
    let {
      top,
      bottom,
      left,
      right
    } = this.refs.scrollContainer.getBoundingClientRect();
    top += MOUSE_DRAG_AUTOSCROLL_MARGIN;
    bottom -= MOUSE_DRAG_AUTOSCROLL_MARGIN;
    left += MOUSE_DRAG_AUTOSCROLL_MARGIN;
    right -= MOUSE_DRAG_AUTOSCROLL_MARGIN;
    let yDelta, yDirection;
    if (clientY < top) {
      yDelta = top - clientY;
      yDirection = -1;
    } else if (clientY > bottom) {
      yDelta = clientY - bottom;
      yDirection = 1;
    }
    let xDelta, xDirection;
    if (clientX < left) {
      xDelta = left - clientX;
      xDirection = -1;
    } else if (clientX > right) {
      xDelta = clientX - right;
      xDirection = 1;
    }
    let scrolled = false;
    if (yDelta != null) {
      const scaledDelta = scaleMouseDragAutoscrollDelta(yDelta) * yDirection;
      scrolled = this.setScrollTop(this.getScrollTop() + scaledDelta);
    }
    if (!verticalOnly && xDelta != null) {
      const scaledDelta = scaleMouseDragAutoscrollDelta(xDelta) * xDirection;
      scrolled = this.setScrollLeft(this.getScrollLeft() + scaledDelta);
    }
    if (scrolled) this.updateSync();
  }
  screenPositionForMouseEvent(event) {
    return this.screenPositionForPixelPosition(
      this.pixelPositionForMouseEvent(event)
    );
  }
  pixelPositionForMouseEvent({ clientX, clientY }) {
    const scrollContainerRect = this.refs.scrollContainer.getBoundingClientRect();
    clientX = Math.min(
      scrollContainerRect.right,
      Math.max(scrollContainerRect.left, clientX)
    );
    clientY = Math.min(
      scrollContainerRect.bottom,
      Math.max(scrollContainerRect.top, clientY)
    );
    const linesRect = this.refs.lineTiles.getBoundingClientRect();
    return {
      top: clientY - linesRect.top,
      left: clientX - linesRect.left
    };
  }
  didUpdateSelections() {
    this.pauseCursorBlinking();
    this.scheduleUpdate();
  }
  pauseCursorBlinking() {
    this.stopCursorBlinking();
    this.debouncedResumeCursorBlinking();
  }
  resumeCursorBlinking() {
    this.cursorsBlinkedOff = true;
    this.startCursorBlinking();
  }
  stopCursorBlinking() {
    if (this.cursorsBlinking) {
      this.cursorsBlinkedOff = false;
      this.cursorsBlinking = false;
      window.clearInterval(this.cursorBlinkIntervalHandle);
      this.cursorBlinkIntervalHandle = null;
      this.scheduleUpdate();
    }
  }
  startCursorBlinking() {
    if (!this.cursorsBlinking) {
      this.cursorBlinkIntervalHandle = window.setInterval(() => {
        this.cursorsBlinkedOff = !this.cursorsBlinkedOff;
        this.scheduleUpdate(true);
      }, (this.props.cursorBlinkPeriod || CURSOR_BLINK_PERIOD) / 2);
      this.cursorsBlinking = true;
      this.scheduleUpdate(true);
    }
  }
  didRequestAutoscroll(autoscroll) {
    this.pendingAutoscroll = autoscroll;
    this.scheduleUpdate();
  }
  flushPendingLogicalScrollPosition() {
    let changedScrollTop = false;
    if (this.pendingScrollTopRow > 0) {
      changedScrollTop = this.setScrollTopRow(this.pendingScrollTopRow, false);
      this.pendingScrollTopRow = null;
    }
    let changedScrollLeft = false;
    if (this.pendingScrollLeftColumn > 0) {
      changedScrollLeft = this.setScrollLeftColumn(
        this.pendingScrollLeftColumn,
        false
      );
      this.pendingScrollLeftColumn = null;
    }
    if (changedScrollTop || changedScrollLeft) {
      this.updateSync();
    }
  }
  autoscrollVertically(screenRange, options) {
    const screenRangeTop = this.pixelPositionAfterBlocksForRow(
      screenRange.start.row
    );
    const screenRangeBottom =
      this.pixelPositionAfterBlocksForRow(screenRange.end.row) +
      this.getLineHeight();
    const verticalScrollMargin = this.getVerticalAutoscrollMargin();
    let desiredScrollTop, desiredScrollBottom;
    if (options && options.center) {
      const desiredScrollCenter = (screenRangeTop + screenRangeBottom) / 2;
      desiredScrollTop =
        desiredScrollCenter - this.getScrollContainerClientHeight() / 2;
      desiredScrollBottom =
        desiredScrollCenter + this.getScrollContainerClientHeight() / 2;
    } else {
      desiredScrollTop = screenRangeTop - verticalScrollMargin;
      desiredScrollBottom = screenRangeBottom + verticalScrollMargin;
    }
    if (!options || options.reversed !== false) {
      if (desiredScrollBottom > this.getScrollBottom()) {
        this.setScrollBottom(desiredScrollBottom);
      }
      if (desiredScrollTop < this.getScrollTop()) {
        this.setScrollTop(desiredScrollTop);
      }
    } else {
      if (desiredScrollTop < this.getScrollTop()) {
        this.setScrollTop(desiredScrollTop);
      }
      if (desiredScrollBottom > this.getScrollBottom()) {
        this.setScrollBottom(desiredScrollBottom);
      }
    }
    return false;
  }
  autoscrollHorizontally(screenRange, options) {
    const horizontalScrollMargin = this.getHorizontalAutoscrollMargin();
    const gutterContainerWidth = this.getGutterContainerWidth();
    let left =
      this.pixelLeftForRowAndColumn(
        screenRange.start.row,
        screenRange.start.column
      ) + gutterContainerWidth;
    let right =
      this.pixelLeftForRowAndColumn(
        screenRange.end.row,
        screenRange.end.column
      ) + gutterContainerWidth;
    const desiredScrollLeft = Math.max(
      0,
      left - horizontalScrollMargin - gutterContainerWidth
    );
    const desiredScrollRight = Math.min(
      this.getScrollWidth(),
      right + horizontalScrollMargin
    );
    if (!options || options.reversed !== false) {
      if (desiredScrollRight > this.getScrollRight()) {
        this.setScrollRight(desiredScrollRight);
      }
      if (desiredScrollLeft < this.getScrollLeft()) {
        this.setScrollLeft(desiredScrollLeft);
      }
    } else {
      if (desiredScrollLeft < this.getScrollLeft()) {
        this.setScrollLeft(desiredScrollLeft);
      }
      if (desiredScrollRight > this.getScrollRight()) {
        this.setScrollRight(desiredScrollRight);
      }
    }
  }
  getVerticalAutoscrollMargin() {
    const maxMarginInLines = Math.floor(
      (this.getScrollContainerClientHeight() / this.getLineHeight() - 1) / 2
    );
    const marginInLines = Math.min(
      this.props.model.verticalScrollMargin,
      maxMarginInLines
    );
    return marginInLines * this.getLineHeight();
  }
  getHorizontalAutoscrollMargin() {
    const maxMarginInBaseCharacters = Math.floor(
      (this.getScrollContainerClientWidth() / this.getBaseCharacterWidth() -
        1) /
        2
    );
    const marginInBaseCharacters = Math.min(
      this.props.model.horizontalScrollMargin,
      maxMarginInBaseCharacters
    );
    return marginInBaseCharacters * this.getBaseCharacterWidth();
  }
  updateModelSoftWrapColumn() {
    const { model } = this.props;
    const newEditorWidthInChars = this.getScrollContainerClientWidthInBaseCharacters();
    if (newEditorWidthInChars !== model.getEditorWidthInChars()) {
      this.suppressUpdates = true;
      const renderedStartRow = this.getRenderedStartRow();
      this.props.model.setEditorWidthInChars(newEditorWidthInChars);
      this.populateVisibleRowRange(renderedStartRow);
      this.props.model.setEditorWidthInChars(
        this.getScrollContainerClientWidthInBaseCharacters()
      );
      this.derivedDimensionsCache = {};
      this.suppressUpdates = false;
    }
  }
  measureDimensions() {
    this.measureCharacterDimensions();
    this.measureGutterDimensions();
    this.measureClientContainerHeight();
    this.measureClientContainerWidth();
    this.measureScrollbarDimensions();
    this.hasInitialMeasurements = true;
  }
  measureCharacterDimensions() {
    this.measurements.lineHeight = Math.max(
      1,
      this.refs.characterMeasurementLine.getBoundingClientRect().height
    );
    this.measurements.baseCharacterWidth = this.refs.normalWidthCharacterSpan.getBoundingClientRect().width;
    this.measurements.doubleWidthCharacterWidth = this.refs.doubleWidthCharacterSpan.getBoundingClientRect().width;
    this.measurements.halfWidthCharacterWidth = this.refs.halfWidthCharacterSpan.getBoundingClientRect().width;
    this.measurements.koreanCharacterWidth = this.refs.koreanCharacterSpan.getBoundingClientRect().width;
    this.props.model.setLineHeightInPixels(this.measurements.lineHeight);
    this.props.model.setDefaultCharWidth(
      this.measurements.baseCharacterWidth,
      this.measurements.doubleWidthCharacterWidth,
      this.measurements.halfWidthCharacterWidth,
      this.measurements.koreanCharacterWidth
    );
    this.lineTopIndex.setDefaultLineHeight(this.measurements.lineHeight);
  }
  measureGutterDimensions() {
    let dimensionsChanged = false;
    if (this.refs.gutterContainer) {
      const gutterContainerWidth = this.refs.gutterContainer.element
        .offsetWidth;
      if (gutterContainerWidth !== this.measurements.gutterContainerWidth) {
        dimensionsChanged = true;
        this.measurements.gutterContainerWidth = gutterContainerWidth;
      }
    } else {
      this.measurements.gutterContainerWidth = 0;
    }
    if (
      this.refs.gutterContainer &&
      this.refs.gutterContainer.refs.lineNumberGutter
    ) {
      const lineNumberGutterWidth = this.refs.gutterContainer.refs
        .lineNumberGutter.element.offsetWidth;
      if (lineNumberGutterWidth !== this.measurements.lineNumberGutterWidth) {
        dimensionsChanged = true;
        this.measurements.lineNumberGutterWidth = lineNumberGutterWidth;
      }
    } else {
      this.measurements.lineNumberGutterWidth = 0;
    }
    return dimensionsChanged;
  }
  measureClientContainerHeight() {
    const clientContainerHeight = this.refs.clientContainer.offsetHeight;
    if (clientContainerHeight !== this.measurements.clientContainerHeight) {
      this.measurements.clientContainerHeight = clientContainerHeight;
      return true;
    } else {
      return false;
    }
  }
  measureClientContainerWidth() {
    const clientContainerWidth = this.refs.clientContainer.offsetWidth;
    if (clientContainerWidth !== this.measurements.clientContainerWidth) {
      this.measurements.clientContainerWidth = clientContainerWidth;
      return true;
    } else {
      return false;
    }
  }
  measureScrollbarDimensions() {
    if (this.props.model.isMini()) {
      this.measurements.verticalScrollbarWidth = 0;
      this.measurements.horizontalScrollbarHeight = 0;
    } else {
      this.measurements.verticalScrollbarWidth = this.refs.verticalScrollbar.getRealScrollbarWidth();
      this.measurements.horizontalScrollbarHeight = this.refs.horizontalScrollbar.getRealScrollbarHeight();
    }
  }
  measureLongestLineWidth() {
    if (this.longestLineToMeasure) {
      const lineComponent = this.lineComponentsByScreenLineId.get(
        this.longestLineToMeasure.id
      );
      this.measurements.longestLineWidth =
        lineComponent.element.firstChild.offsetWidth;
      this.longestLineToMeasure = null;
    }
  }
  requestLineToMeasure(row, screenLine) {
    this.linesToMeasure.set(row, screenLine);
  }
  requestHorizontalMeasurement(row, column) {
    if (column === 0) return;
    const screenLine = this.props.model.screenLineForScreenRow(row);
    if (screenLine) {
      this.requestLineToMeasure(row, screenLine);
      let columns = this.horizontalPositionsToMeasure.get(row);
      if (columns == null) {
        columns = [];
        this.horizontalPositionsToMeasure.set(row, columns);
      }
      columns.push(column);
    }
  }
  measureHorizontalPositions() {
    this.horizontalPositionsToMeasure.forEach((columnsToMeasure, row) => {
      columnsToMeasure.sort((a, b) => a - b);
      const screenLine = this.renderedScreenLineForRow(row);
      const lineComponent = this.lineComponentsByScreenLineId.get(
        screenLine.id
      );
      if (!lineComponent) {
        const error = new Error(
          'Requested measurement of a line component that is not currently rendered'
        );
        error.metadata = {
          row,
          columnsToMeasure,
          renderedScreenLineIds: this.renderedScreenLines.map(line => line.id),
          extraRenderedScreenLineIds: Array.from(
            this.extraRenderedScreenLines.keys()
          ),
          lineComponentScreenLineIds: Array.from(
            this.lineComponentsByScreenLineId.keys()
          ),
          renderedStartRow: this.getRenderedStartRow(),
          renderedEndRow: this.getRenderedEndRow(),
          requestedScreenLineId: screenLine.id
        };
        throw error;
      }
      const lineNode = lineComponent.element;
      const textNodes = lineComponent.textNodes;
      let positionsForLine = this.horizontalPixelPositionsByScreenLineId.get(
        screenLine.id
      );
      if (positionsForLine == null) {
        positionsForLine = new Map();
        this.horizontalPixelPositionsByScreenLineId.set(
          screenLine.id,
          positionsForLine
        );
      }
      this.measureHorizontalPositionsOnLine(
        lineNode,
        textNodes,
        columnsToMeasure,
        positionsForLine
      );
    });
    this.horizontalPositionsToMeasure.clear();
  }
  measureHorizontalPositionsOnLine(
    lineNode,
    textNodes,
    columnsToMeasure,
    positions
  ) {
    let lineNodeClientLeft = -1;
    let textNodeStartColumn = 0;
    let textNodesIndex = 0;
    let lastTextNodeRight = null;
    columnLoop: for (
      let columnsIndex = 0;
      columnsIndex < columnsToMeasure.length;
      columnsIndex++
    ) {
      const nextColumnToMeasure = columnsToMeasure[columnsIndex];
      while (textNodesIndex < textNodes.length) {
        if (nextColumnToMeasure === 0) {
          positions.set(0, 0);
          continue columnLoop;
        }
        if (positions.has(nextColumnToMeasure)) continue columnLoop;
        const textNode = textNodes[textNodesIndex];
        const textNodeEndColumn =
          textNodeStartColumn + textNode.textContent.length;
        if (nextColumnToMeasure < textNodeEndColumn) {
          let clientPixelPosition;
          if (nextColumnToMeasure === textNodeStartColumn) {
            clientPixelPosition = clientRectForRange(textNode, 0, 1).left;
          } else {
            clientPixelPosition = clientRectForRange(
              textNode,
              0,
              nextColumnToMeasure - textNodeStartColumn
            ).right;
          }
          if (lineNodeClientLeft === -1) {
            lineNodeClientLeft = lineNode.getBoundingClientRect().left;
          }
          positions.set(
            nextColumnToMeasure,
            Math.round(clientPixelPosition - lineNodeClientLeft)
          );
          continue columnLoop;
        } else {
          textNodesIndex++;
          textNodeStartColumn = textNodeEndColumn;
        }
      }
      if (lastTextNodeRight == null) {
        const lastTextNode = textNodes[textNodes.length - 1];
        lastTextNodeRight = clientRectForRange(
          lastTextNode,
          0,
          lastTextNode.textContent.length
        ).right;
      }
      if (lineNodeClientLeft === -1) {
        lineNodeClientLeft = lineNode.getBoundingClientRect().left;
      }
      positions.set(
        nextColumnToMeasure,
        Math.round(lastTextNodeRight - lineNodeClientLeft)
      );
    }
  }
  rowForPixelPosition(pixelPosition) {
    return Math.max(0, this.lineTopIndex.rowForPixelPosition(pixelPosition));
  }
  heightForBlockDecorationsBeforeRow(row) {
    return (
      this.pixelPositionAfterBlocksForRow(row) -
      this.pixelPositionBeforeBlocksForRow(row)
    );
  }
  heightForBlockDecorationsAfterRow(row) {
    const currentRowBottom =
      this.pixelPositionAfterBlocksForRow(row) + this.getLineHeight();
    const nextRowTop = this.pixelPositionBeforeBlocksForRow(row + 1);
    return nextRowTop - currentRowBottom;
  }
  pixelPositionBeforeBlocksForRow(row) {
    return this.lineTopIndex.pixelPositionBeforeBlocksForRow(row);
  }
  pixelPositionAfterBlocksForRow(row) {
    return this.lineTopIndex.pixelPositionAfterBlocksForRow(row);
  }
  pixelLeftForRowAndColumn(row, column) {
    if (column === 0) return 0;
    const screenLine = this.renderedScreenLineForRow(row);
    if (screenLine) {
      const horizontalPositionsByColumn = this.horizontalPixelPositionsByScreenLineId.get(
        screenLine.id
      );
      if (horizontalPositionsByColumn) {
        return horizontalPositionsByColumn.get(column);
      }
    }
  }
  screenPositionForPixelPosition({ top, left }) {
    const { model } = this.props;
    const row = Math.min(
      this.rowForPixelPosition(top),
      model.getApproximateScreenLineCount() - 1
    );
    let screenLine = this.renderedScreenLineForRow(row);
    if (!screenLine) {
      this.requestLineToMeasure(row, model.screenLineForScreenRow(row));
      this.updateSyncBeforeMeasuringContent();
      this.measureContentDuringUpdateSync();
      screenLine = this.renderedScreenLineForRow(row);
    }
    const linesClientLeft = this.refs.lineTiles.getBoundingClientRect().left;
    const targetClientLeft = linesClientLeft + Math.max(0, left);
    const { textNodes } = this.lineComponentsByScreenLineId.get(screenLine.id);
    let containingTextNodeIndex;
    {
      let low = 0;
      let high = textNodes.length - 1;
      while (low <= high) {
        const mid = low + ((high - low) >> 1);
        const textNode = textNodes[mid];
        const textNodeRect = clientRectForRange(textNode, 0, textNode.length);
        if (targetClientLeft < textNodeRect.left) {
          high = mid - 1;
          containingTextNodeIndex = Math.max(0, mid - 1);
        } else if (targetClientLeft > textNodeRect.right) {
          low = mid + 1;
          containingTextNodeIndex = Math.min(textNodes.length - 1, mid + 1);
        } else {
          containingTextNodeIndex = mid;
          break;
        }
      }
    }
    const containingTextNode = textNodes[containingTextNodeIndex];
    let characterIndex = 0;
    {
      let low = 0;
      let high = containingTextNode.length - 1;
      while (low <= high) {
        const charIndex = low + ((high - low) >> 1);
        const nextCharIndex = isPairedCharacter(
          containingTextNode.textContent,
          charIndex
        )
          ? charIndex + 2
          : charIndex + 1;
        const rangeRect = clientRectForRange(
          containingTextNode,
          charIndex,
          nextCharIndex
        );
        if (targetClientLeft < rangeRect.left) {
          high = charIndex - 1;
          characterIndex = Math.max(0, charIndex - 1);
        } else if (targetClientLeft > rangeRect.right) {
          low = nextCharIndex;
          characterIndex = Math.min(
            containingTextNode.textContent.length,
            nextCharIndex
          );
        } else {
          if (targetClientLeft <= (rangeRect.left + rangeRect.right) / 2) {
            characterIndex = charIndex;
          } else {
            characterIndex = nextCharIndex;
          }
          break;
        }
      }
    }
    let textNodeStartColumn = 0;
    for (let i = 0; i < containingTextNodeIndex; i++) {
      textNodeStartColumn = textNodeStartColumn + textNodes[i].length;
    }
    const column = textNodeStartColumn + characterIndex;
    return Point(row, column);
  }
  didResetDisplayLayer() {
    this.spliceLineTopIndex(0, Infinity, Infinity);
    this.scheduleUpdate();
  }
  didChangeDisplayLayer(changes) {
    for (let i = 0; i < changes.length; i++) {
      const { oldRange, newRange } = changes[i];
      this.spliceLineTopIndex(
        newRange.start.row,
        oldRange.end.row - oldRange.start.row,
        newRange.end.row - newRange.start.row
      );
    }
    this.scheduleUpdate();
  }
  didChangeSelectionRange() {
    const { model } = this.props;
    if (this.getPlatform() === 'linux') {
      if (this.selectionClipboardImmediateId) {
        clearImmediate(this.selectionClipboardImmediateId);
      }
      this.selectionClipboardImmediateId = setImmediate(() => {
        this.selectionClipboardImmediateId = null;
        if (model.isDestroyed()) return;
        const selectedText = model.getSelectedText();
        if (selectedText) {
          electron.ipcRenderer.send(
            'write-text-to-selection-clipboard',
            selectedText
          );
        }
      });
    }
  }
  observeBlockDecorations() {
    const { model } = this.props;
    const decorations = model.getDecorations({ type: 'block' });
    for (let i = 0; i < decorations.length; i++) {
      this.addBlockDecoration(decorations[i]);
    }
  }
  addBlockDecoration(decoration, subscribeToChanges = true) {
    const marker = decoration.getMarker();
    const { item, position } = decoration.getProperties();
    const element = TextEditor.viewForItem(item);
    if (marker.isValid()) {
      const row = marker.getHeadScreenPosition().row;
      this.lineTopIndex.insertBlock(decoration, row, 0, position === 'after');
      this.blockDecorationsToMeasure.add(decoration);
      this.blockDecorationsByElement.set(element, decoration);
      this.blockDecorationResizeObserver.observe(element);
      this.scheduleUpdate();
    }
    if (subscribeToChanges) {
      let wasValid = marker.isValid();
      const didUpdateDisposable = marker.bufferMarker.onDidChange(
        ({ textChanged }) => {
          const isValid = marker.isValid();
          if (wasValid && !isValid) {
            wasValid = false;
            this.blockDecorationsToMeasure.delete(decoration);
            this.heightsByBlockDecoration.delete(decoration);
            this.blockDecorationsByElement.delete(element);
            this.blockDecorationResizeObserver.unobserve(element);
            this.lineTopIndex.removeBlock(decoration);
            this.scheduleUpdate();
          } else if (!wasValid && isValid) {
            wasValid = true;
            this.addBlockDecoration(decoration, false);
          } else if (isValid && !textChanged) {
            this.lineTopIndex.moveBlock(
              decoration,
              marker.getHeadScreenPosition().row
            );
            this.scheduleUpdate();
          }
        }
      );
      const didDestroyDisposable = decoration.onDidDestroy(() => {
        didUpdateDisposable.dispose();
        didDestroyDisposable.dispose();
        if (wasValid) {
          wasValid = false;
          this.blockDecorationsToMeasure.delete(decoration);
          this.heightsByBlockDecoration.delete(decoration);
          this.blockDecorationsByElement.delete(element);
          this.blockDecorationResizeObserver.unobserve(element);
          this.lineTopIndex.removeBlock(decoration);
          this.scheduleUpdate();
        }
      });
    }
  }
  didResizeBlockDecorations(entries) {
    if (!this.visible) return;
    for (let i = 0; i < entries.length; i++) {
      const { target, contentRect } = entries[i];
      const decoration = this.blockDecorationsByElement.get(target);
      const previousHeight = this.heightsByBlockDecoration.get(decoration);
      if (
        this.element.contains(target) &&
        contentRect.height !== previousHeight
      ) {
        this.invalidateBlockDecorationDimensions(decoration);
      }
    }
  }
  invalidateBlockDecorationDimensions(decoration) {
    this.blockDecorationsToMeasure.add(decoration);
    this.scheduleUpdate();
  }
  spliceLineTopIndex(startRow, oldExtent, newExtent) {
    const invalidatedBlockDecorations = this.lineTopIndex.splice(
      startRow,
      oldExtent,
      newExtent
    );
    invalidatedBlockDecorations.forEach(decoration => {
      const newPosition = decoration.getMarker().getHeadScreenPosition();
      this.lineTopIndex.moveBlock(decoration, newPosition.row);
    });
  }
  isVisible() {
    return this.element.offsetWidth > 0 || this.element.offsetHeight > 0;
  }
  getWindowInnerHeight() {
    return window.innerHeight;
  }
  getWindowInnerWidth() {
    return window.innerWidth;
  }
  getLineHeight() {
    return this.measurements.lineHeight;
  }
  getBaseCharacterWidth() {
    return this.measurements.baseCharacterWidth;
  }
  getLongestLineWidth() {
    return this.measurements.longestLineWidth;
  }
  getClientContainerHeight() {
    return this.measurements.clientContainerHeight;
  }
  getClientContainerWidth() {
    return this.measurements.clientContainerWidth;
  }
  getScrollContainerWidth() {
    if (this.props.model.getAutoWidth()) {
      return this.getScrollWidth();
    } else {
      return this.getClientContainerWidth() - this.getGutterContainerWidth();
    }
  }
  getScrollContainerHeight() {
    if (this.props.model.getAutoHeight()) {
      return this.getScrollHeight() + this.getHorizontalScrollbarHeight();
    } else {
      return this.getClientContainerHeight();
    }
  }
  getScrollContainerClientWidth() {
    return this.getScrollContainerWidth() - this.getVerticalScrollbarWidth();
  }
  getScrollContainerClientHeight() {
    return (
      this.getScrollContainerHeight() - this.getHorizontalScrollbarHeight()
    );
  }
  canScrollVertically() {
    const { model } = this.props;
    if (model.isMini()) return false;
    if (model.getAutoHeight()) return false;
    return this.getContentHeight() > this.getScrollContainerClientHeight();
  }
  canScrollHorizontally() {
    const { model } = this.props;
    if (model.isMini()) return false;
    if (model.getAutoWidth()) return false;
    if (model.isSoftWrapped()) return false;
    return this.getContentWidth() > this.getScrollContainerClientWidth();
  }
  getScrollHeight() {
    if (this.props.model.getScrollPastEnd()) {
      return (
        this.getContentHeight() +
        Math.max(
          3 * this.getLineHeight(),
          this.getScrollContainerClientHeight() - 3 * this.getLineHeight()
        )
      );
    } else if (this.props.model.getAutoHeight()) {
      return this.getContentHeight();
    } else {
      return Math.max(
        this.getContentHeight(),
        this.getScrollContainerClientHeight()
      );
    }
  }
  getScrollWidth() {
    const { model } = this.props;
    if (model.isSoftWrapped()) {
      return this.getScrollContainerClientWidth();
    } else if (model.getAutoWidth()) {
      return this.getContentWidth();
    } else {
      return Math.max(
        this.getContentWidth(),
        this.getScrollContainerClientWidth()
      );
    }
  }
  getContentHeight() {
    return this.pixelPositionAfterBlocksForRow(
      this.props.model.getApproximateScreenLineCount()
    );
  }
  getContentWidth() {
    return Math.ceil(this.getLongestLineWidth() + this.getBaseCharacterWidth());
  }
  getScrollContainerClientWidthInBaseCharacters() {
    return Math.floor(
      this.getScrollContainerClientWidth() / this.getBaseCharacterWidth()
    );
  }
  getGutterContainerWidth() {
    return this.measurements.gutterContainerWidth;
  }
  getLineNumberGutterWidth() {
    return this.measurements.lineNumberGutterWidth;
  }
  getVerticalScrollbarWidth() {
    return this.measurements.verticalScrollbarWidth;
  }
  getHorizontalScrollbarHeight() {
    return this.measurements.horizontalScrollbarHeight;
  }
  getRowsPerTile() {
    return this.props.rowsPerTile || DEFAULT_ROWS_PER_TILE;
  }
  tileStartRowForRow(row) {
    return row - (row % this.getRowsPerTile());
  }
  getRenderedStartRow() {
    if (this.derivedDimensionsCache.renderedStartRow == null) {
      this.derivedDimensionsCache.renderedStartRow = this.tileStartRowForRow(
        this.getFirstVisibleRow()
      );
    }
    return this.derivedDimensionsCache.renderedStartRow;
  }
  getRenderedEndRow() {
    if (this.derivedDimensionsCache.renderedEndRow == null) {
      this.derivedDimensionsCache.renderedEndRow = Math.min(
        this.props.model.getApproximateScreenLineCount(),
        this.getRenderedStartRow() +
          this.getVisibleTileCount() * this.getRowsPerTile()
      );
    }
    return this.derivedDimensionsCache.renderedEndRow;
  }
  getRenderedRowCount() {
    if (this.derivedDimensionsCache.renderedRowCount == null) {
      this.derivedDimensionsCache.renderedRowCount = Math.max(
        0,
        this.getRenderedEndRow() - this.getRenderedStartRow()
      );
    }
    return this.derivedDimensionsCache.renderedRowCount;
  }
  getRenderedTileCount() {
    if (this.derivedDimensionsCache.renderedTileCount == null) {
      this.derivedDimensionsCache.renderedTileCount = Math.ceil(
        this.getRenderedRowCount() / this.getRowsPerTile()
      );
    }
    return this.derivedDimensionsCache.renderedTileCount;
  }
  getFirstVisibleRow() {
    if (this.derivedDimensionsCache.firstVisibleRow == null) {
      this.derivedDimensionsCache.firstVisibleRow = this.rowForPixelPosition(
        this.getScrollTop()
      );
    }
    return this.derivedDimensionsCache.firstVisibleRow;
  }
  getLastVisibleRow() {
    if (this.derivedDimensionsCache.lastVisibleRow == null) {
      this.derivedDimensionsCache.lastVisibleRow = Math.min(
        this.props.model.getApproximateScreenLineCount() - 1,
        this.rowForPixelPosition(this.getScrollBottom())
      );
    }
    return this.derivedDimensionsCache.lastVisibleRow;
  }
  getVisibleTileCount() {
    if (this.derivedDimensionsCache.visibleTileCount == null) {
      const editorHeightInTiles =
        this.getScrollContainerHeight() /
        this.getLineHeight() /
        this.getRowsPerTile();
      this.derivedDimensionsCache.visibleTileCount =
        Math.ceil(editorHeightInTiles) + 1;
    }
    return this.derivedDimensionsCache.visibleTileCount;
  }
  getFirstVisibleColumn() {
    return Math.floor(this.getScrollLeft() / this.getBaseCharacterWidth());
  }
  getScrollTop() {
    this.scrollTop = Math.min(this.getMaxScrollTop(), this.scrollTop);
    return this.scrollTop;
  }
  setScrollTop(scrollTop) {
    if (Number.isNaN(scrollTop) || scrollTop == null) return false;
    scrollTop = roundToPhysicalPixelBoundary(
      Math.max(0, Math.min(this.getMaxScrollTop(), scrollTop))
    );
    if (scrollTop !== this.scrollTop) {
      this.derivedDimensionsCache = {};
      this.scrollTopPending = true;
      this.scrollTop = scrollTop;
      this.element.emitter.emit('did-change-scroll-top', scrollTop);
      return true;
    } else {
      return false;
    }
  }
  getMaxScrollTop() {
    return Math.round(
      Math.max(
        0,
        this.getScrollHeight() - this.getScrollContainerClientHeight()
      )
    );
  }
  getScrollBottom() {
    return this.getScrollTop() + this.getScrollContainerClientHeight();
  }
  setScrollBottom(scrollBottom) {
    return this.setScrollTop(
      scrollBottom - this.getScrollContainerClientHeight()
    );
  }
  getScrollLeft() {
    return this.scrollLeft;
  }
  setScrollLeft(scrollLeft) {
    if (Number.isNaN(scrollLeft) || scrollLeft == null) return false;
    scrollLeft = roundToPhysicalPixelBoundary(
      Math.max(0, Math.min(this.getMaxScrollLeft(), scrollLeft))
    );
    if (scrollLeft !== this.scrollLeft) {
      this.scrollLeftPending = true;
      this.scrollLeft = scrollLeft;
      this.element.emitter.emit('did-change-scroll-left', scrollLeft);
      return true;
    } else {
      return false;
    }
  }
  getMaxScrollLeft() {
    return Math.round(
      Math.max(0, this.getScrollWidth() - this.getScrollContainerClientWidth())
    );
  }
  getScrollRight() {
    return this.getScrollLeft() + this.getScrollContainerClientWidth();
  }
  setScrollRight(scrollRight) {
    return this.setScrollLeft(
      scrollRight - this.getScrollContainerClientWidth()
    );
  }
  setScrollTopRow(scrollTopRow, scheduleUpdate = true) {
    if (this.hasInitialMeasurements) {
      const didScroll = this.setScrollTop(
        this.pixelPositionBeforeBlocksForRow(scrollTopRow)
      );
      if (didScroll && scheduleUpdate) {
        this.scheduleUpdate();
      }
      return didScroll;
    } else {
      this.pendingScrollTopRow = scrollTopRow;
      return false;
    }
  }
  getScrollTopRow() {
    if (this.hasInitialMeasurements) {
      return this.rowForPixelPosition(this.getScrollTop());
    } else {
      return this.pendingScrollTopRow || 0;
    }
  }
  setScrollLeftColumn(scrollLeftColumn, scheduleUpdate = true) {
    if (this.hasInitialMeasurements && this.getLongestLineWidth() != null) {
      const didScroll = this.setScrollLeft(
        scrollLeftColumn * this.getBaseCharacterWidth()
      );
      if (didScroll && scheduleUpdate) {
        this.scheduleUpdate();
      }
      return didScroll;
    } else {
      this.pendingScrollLeftColumn = scrollLeftColumn;
      return false;
    }
  }
  getScrollLeftColumn() {
    if (this.hasInitialMeasurements && this.getLongestLineWidth() != null) {
      return Math.round(this.getScrollLeft() / this.getBaseCharacterWidth());
    } else {
      return this.pendingScrollLeftColumn || 0;
    }
  }
  populateVisibleRowRange(renderedStartRow) {
    const { model } = this.props;
    const previousScreenLineCount = model.getApproximateScreenLineCount();
    const renderedEndRow =
      renderedStartRow + this.getVisibleTileCount() * this.getRowsPerTile();
    this.props.model.displayLayer.populateSpatialIndexIfNeeded(
      Infinity,
      renderedEndRow
    );
    if (model.getApproximateScreenLineCount() !== previousScreenLineCount) {
      this.derivedDimensionsCache = {};
    }
  }
  populateVisibleTiles() {
    const startRow = this.getRenderedStartRow();
    const endRow = this.getRenderedEndRow();
    const freeTileIds = [];
    for (let i = 0; i < this.renderedTileStartRows.length; i++) {
      const tileStartRow = this.renderedTileStartRows[i];
      if (tileStartRow < startRow || tileStartRow >= endRow) {
        const tileId = this.idsByTileStartRow.get(tileStartRow);
        freeTileIds.push(tileId);
        this.idsByTileStartRow.delete(tileStartRow);
      }
    }
    const rowsPerTile = this.getRowsPerTile();
    this.renderedTileStartRows.length = this.getRenderedTileCount();
    for (
      let tileStartRow = startRow, i = 0;
      tileStartRow < endRow;
      tileStartRow = tileStartRow + rowsPerTile, i++
    ) {
      this.renderedTileStartRows[i] = tileStartRow;
      if (!this.idsByTileStartRow.has(tileStartRow)) {
        if (freeTileIds.length > 0) {
          this.idsByTileStartRow.set(tileStartRow, freeTileIds.shift());
        } else {
          this.idsByTileStartRow.set(tileStartRow, this.nextTileId++);
        }
      }
    }
    this.renderedTileStartRows.sort(
      (a, b) => this.idsByTileStartRow.get(a) - this.idsByTileStartRow.get(b)
    );
  }
  getNextUpdatePromise() {
    if (!this.nextUpdatePromise) {
      this.nextUpdatePromise = new Promise(resolve => {
        this.resolveNextUpdatePromise = () => {
          this.nextUpdatePromise = null;
          this.resolveNextUpdatePromise = null;
          resolve();
        };
      });
    }
    return this.nextUpdatePromise;
  }
  setInputEnabled(inputEnabled) {
    this.props.model.update({ keyboardInputEnabled: inputEnabled });
  }
  isInputEnabled() {
    return (
      !this.props.model.isReadOnly() &&
      this.props.model.isKeyboardInputEnabled()
    );
  }
  getHiddenInput() {
    return this.refs.cursorsAndInput.refs.hiddenInput;
  }
  getPlatform() {
    return this.props.platform || process.platform;
  }
  getChromeVersion() {
    return this.props.chromeVersion || parseInt(process.versions.chrome);
  }
};
class DummyScrollbarComponent {
  constructor(props) {
    this.props = props;
    etch.initialize(this);
  }
  update(newProps) {
    const oldProps = this.props;
    this.props = newProps;
    etch.updateSync(this);
    const shouldFlushScrollPosition =
      newProps.scrollTop !== oldProps.scrollTop ||
      newProps.scrollLeft !== oldProps.scrollLeft;
    if (shouldFlushScrollPosition) this.flushScrollPosition();
  }
  flushScrollPosition() {
    if (this.props.orientation === 'horizontal') {
      this.element.scrollLeft = this.props.scrollLeft;
    } else {
      this.element.scrollTop = this.props.scrollTop;
    }
  }
  render() {
    const {
      orientation,
      scrollWidth,
      scrollHeight,
      verticalScrollbarWidth,
      horizontalScrollbarHeight,
      canScroll,
      forceScrollbarVisible,
      didScroll
    } = this.props;
    const outerStyle = {
      position: 'absolute',
      contain: 'content',
      zIndex: 1,
      willChange: 'transform'
    };
    if (!canScroll) outerStyle.visibility = 'hidden';
    const innerStyle = {};
    if (orientation === 'horizontal') {
      let right = verticalScrollbarWidth || 0;
      outerStyle.bottom = 0;
      outerStyle.left = 0;
      outerStyle.right = right + 'px';
      outerStyle.height = '15px';
      outerStyle.overflowY = 'hidden';
      outerStyle.overflowX = forceScrollbarVisible ? 'scroll' : 'auto';
      outerStyle.cursor = 'default';
      innerStyle.height = '15px';
      innerStyle.width = (scrollWidth || 0) + 'px';
    } else {
      let bottom = horizontalScrollbarHeight || 0;
      outerStyle.right = 0;
      outerStyle.top = 0;
      outerStyle.bottom = bottom + 'px';
      outerStyle.width = '15px';
      outerStyle.overflowX = 'hidden';
      outerStyle.overflowY = forceScrollbarVisible ? 'scroll' : 'auto';
      outerStyle.cursor = 'default';
      innerStyle.width = '15px';
      innerStyle.height = (scrollHeight || 0) + 'px';
    }
    return $.div(
      {
        className: `${orientation}-scrollbar`,
        style: outerStyle,
        on: {
          scroll: didScroll,
          mousedown: this.didMouseDown
        }
      },
      $.div({ style: innerStyle })
    );
  }
  didMouseDown(event) {
    let { bottom, right } = this.element.getBoundingClientRect();
    const clickedOnScrollbar =
      this.props.orientation === 'horizontal'
        ? event.clientY >= bottom - this.getRealScrollbarHeight()
        : event.clientX >= right - this.getRealScrollbarWidth();
    if (!clickedOnScrollbar) this.props.didMouseDown(event);
  }
  getRealScrollbarWidth() {
    return this.element.offsetWidth - this.element.clientWidth;
  }
  getRealScrollbarHeight() {
    return this.element.offsetHeight - this.element.clientHeight;
  }
}
class GutterContainerComponent {
  constructor(props) {
    this.props = props;
    etch.initialize(this);
  }
  update(props) {
    if (this.shouldUpdate(props)) {
      this.props = props;
      etch.updateSync(this);
    }
  }
  shouldUpdate(props) {
    return (
      !props.measuredContent ||
      props.lineNumberGutterWidth !== this.props.lineNumberGutterWidth
    );
  }
  render() {
    const {
      hasInitialMeasurements,
      scrollTop,
      scrollHeight,
      guttersToRender,
      decorationsToRender
    } = this.props;
    const innerStyle = {
      willChange: 'transform',
      display: 'flex'
    };
    if (hasInitialMeasurements) {
      innerStyle.transform = `translateY(${-roundToPhysicalPixelBoundary(
        scrollTop
      )}px)`;
    }
    return $.div(
      {
        ref: 'gutterContainer',
        key: 'gutterContainer',
        className: 'gutter-container',
        style: {
          position: 'relative',
          zIndex: 1,
          backgroundColor: 'inherit'
        }
      },
      $.div(
        { style: innerStyle },
        guttersToRender.map(gutter => {
          if (gutter.type === 'line-number') {
            return this.renderLineNumberGutter(gutter);
          } else {
            return $(CustomGutterComponent, {
              key: gutter,
              element: gutter.getElement(),
              name: gutter.name,
              visible: gutter.isVisible(),
              height: scrollHeight,
              decorations: decorationsToRender.customGutter.get(gutter.name)
            });
          }
        })
      )
    );
  }
  renderLineNumberGutter(gutter) {
    const {
      rootComponent,
      showLineNumbers,
      hasInitialMeasurements,
      lineNumbersToRender,
      renderedStartRow,
      renderedEndRow,
      rowsPerTile,
      decorationsToRender,
      didMeasureVisibleBlockDecoration,
      scrollHeight,
      lineNumberGutterWidth,
      lineHeight
    } = this.props;
    if (!gutter.isVisible()) {
      return null;
    }
    const oneTrueLineNumberGutter = gutter.name === 'line-number';
    const ref = oneTrueLineNumberGutter ? 'lineNumberGutter' : undefined;
    const width = oneTrueLineNumberGutter ? lineNumberGutterWidth : undefined;
    if (hasInitialMeasurements) {
      const {
        maxDigits,
        keys,
        bufferRows,
        screenRows,
        softWrappedFlags,
        foldableFlags
      } = lineNumbersToRender;
      return $(LineNumberGutterComponent, {
        ref,
        element: gutter.getElement(),
        name: gutter.name,
        className: gutter.className,
        labelFn: gutter.labelFn,
        onMouseDown: gutter.onMouseDown,
        onMouseMove: gutter.onMouseMove,
        rootComponent: rootComponent,
        startRow: renderedStartRow,
        endRow: renderedEndRow,
        rowsPerTile: rowsPerTile,
        maxDigits: maxDigits,
        keys: keys,
        bufferRows: bufferRows,
        screenRows: screenRows,
        softWrappedFlags: softWrappedFlags,
        foldableFlags: foldableFlags,
        decorations: decorationsToRender.lineNumbers.get(gutter.name) || [],
        blockDecorations: decorationsToRender.blocks,
        didMeasureVisibleBlockDecoration: didMeasureVisibleBlockDecoration,
        height: scrollHeight,
        width,
        lineHeight: lineHeight,
        showLineNumbers
      });
    } else {
      return $(LineNumberGutterComponent, {
        ref,
        element: gutter.getElement(),
        name: gutter.name,
        className: gutter.className,
        onMouseDown: gutter.onMouseDown,
        onMouseMove: gutter.onMouseMove,
        maxDigits: lineNumbersToRender.maxDigits,
        showLineNumbers
      });
    }
  }
}
class LineNumberGutterComponent {
  constructor(props) {
    this.props = props;
    this.element = this.props.element;
    this.virtualNode = $.div(null);
    this.virtualNode.domNode = this.element;
    this.nodePool = new NodePool();
    etch.updateSync(this);
  }
  update(newProps) {
    if (this.shouldUpdate(newProps)) {
      this.props = newProps;
      etch.updateSync(this);
    }
  }
  render() {
    const {
      rootComponent,
      showLineNumbers,
      height,
      width,
      startRow,
      endRow,
      rowsPerTile,
      maxDigits,
      keys,
      bufferRows,
      screenRows,
      softWrappedFlags,
      foldableFlags,
      decorations,
      className
    } = this.props;
    let children = null;
    if (bufferRows) {
      children = new Array(rootComponent.renderedTileStartRows.length);
      for (let i = 0; i < rootComponent.renderedTileStartRows.length; i++) {
        const tileStartRow = rootComponent.renderedTileStartRows[i];
        const tileEndRow = Math.min(endRow, tileStartRow + rowsPerTile);
        const tileChildren = new Array(tileEndRow - tileStartRow);
        for (let row = tileStartRow; row < tileEndRow; row++) {
          const indexInTile = row - tileStartRow;
          const j = row - startRow;
          const key = keys[j];
          const softWrapped = softWrappedFlags[j];
          const foldable = foldableFlags[j];
          const bufferRow = bufferRows[j];
          const screenRow = screenRows[j];
          let className = 'line-number';
          if (foldable) className = className + ' foldable';
          const decorationsForRow = decorations[row - startRow];
          if (decorationsForRow)
            className = className + ' ' + decorationsForRow;
          let number = null;
          if (showLineNumbers) {
            if (this.props.labelFn == null) {
              number = softWrapped ? '•' : bufferRow + 1;
              number =
                NBSP_CHARACTER.repeat(maxDigits - number.length) + number;
            } else {
              number = this.props.labelFn({
                bufferRow,
                screenRow,
                foldable,
                softWrapped,
                maxDigits
              });
            }
          }
          let marginTop = rootComponent.heightForBlockDecorationsBeforeRow(row);
          if (indexInTile > 0)
            marginTop += rootComponent.heightForBlockDecorationsAfterRow(
              row - 1
            );
          tileChildren[row - tileStartRow] = $(LineNumberComponent, {
            key,
            className,
            width,
            bufferRow,
            screenRow,
            number,
            marginTop,
            nodePool: this.nodePool
          });
        }
        const tileTop = rootComponent.pixelPositionBeforeBlocksForRow(
          tileStartRow
        );
        const tileBottom = rootComponent.pixelPositionBeforeBlocksForRow(
          tileEndRow
        );
        const tileHeight = tileBottom - tileTop;
        const tileWidth = width != null && width > 0 ? width + 'px' : '';
        children[i] = $.div(
          {
            key: rootComponent.idsByTileStartRow.get(tileStartRow),
            style: {
              contain: 'layout style',
              position: 'absolute',
              top: 0,
              height: tileHeight + 'px',
              width: tileWidth,
              transform: `translateY(${tileTop}px)`
            }
          },
          ...tileChildren
        );
      }
    }
    let rootClassName = 'gutter line-numbers';
    if (className) {
      rootClassName += ' ' + className;
    }
    return $.div(
      {
        className: rootClassName,
        attributes: { 'gutter-name': this.props.name },
        style: {
          position: 'relative',
          height: ceilToPhysicalPixelBoundary(height) + 'px'
        },
        on: {
          mousedown: this.didMouseDown,
          mousemove: this.didMouseMove
        }
      },
      $.div(
        {
          key: 'placeholder',
          className: 'line-number dummy',
          style: { visibility: 'hidden' }
        },
        showLineNumbers ? '0'.repeat(maxDigits) : null,
        $.div({ className: 'icon-right' })
      ),
      children
    );
  }
  shouldUpdate(newProps) {
    const oldProps = this.props;
    if (oldProps.showLineNumbers !== newProps.showLineNumbers) return true;
    if (oldProps.height !== newProps.height) return true;
    if (oldProps.width !== newProps.width) return true;
    if (oldProps.lineHeight !== newProps.lineHeight) return true;
    if (oldProps.startRow !== newProps.startRow) return true;
    if (oldProps.endRow !== newProps.endRow) return true;
    if (oldProps.rowsPerTile !== newProps.rowsPerTile) return true;
    if (oldProps.maxDigits !== newProps.maxDigits) return true;
    if (oldProps.labelFn !== newProps.labelFn) return true;
    if (oldProps.className !== newProps.className) return true;
    if (newProps.didMeasureVisibleBlockDecoration) return true;
    if (!arraysEqual(oldProps.keys, newProps.keys)) return true;
    if (!arraysEqual(oldProps.bufferRows, newProps.bufferRows)) return true;
    if (!arraysEqual(oldProps.foldableFlags, newProps.foldableFlags))
      return true;
    if (!arraysEqual(oldProps.decorations, newProps.decorations)) return true;
    let oldTileStartRow = oldProps.startRow;
    let newTileStartRow = newProps.startRow;
    while (
      oldTileStartRow < oldProps.endRow ||
      newTileStartRow < newProps.endRow
    ) {
      let oldTileBlockDecorations = oldProps.blockDecorations.get(
        oldTileStartRow
      );
      let newTileBlockDecorations = newProps.blockDecorations.get(
        newTileStartRow
      );
      if (oldTileBlockDecorations && newTileBlockDecorations) {
        if (oldTileBlockDecorations.size !== newTileBlockDecorations.size)
          return true;
        let blockDecorationsChanged = false;
        oldTileBlockDecorations.forEach((oldDecorations, screenLineId) => {
          if (!blockDecorationsChanged) {
            const newDecorations = newTileBlockDecorations.get(screenLineId);
            blockDecorationsChanged =
              newDecorations == null ||
              !arraysEqual(oldDecorations, newDecorations);
          }
        });
        if (blockDecorationsChanged) return true;
        newTileBlockDecorations.forEach((newDecorations, screenLineId) => {
          if (!blockDecorationsChanged) {
            const oldDecorations = oldTileBlockDecorations.get(screenLineId);
            blockDecorationsChanged = oldDecorations == null;
          }
        });
        if (blockDecorationsChanged) return true;
      } else if (oldTileBlockDecorations) {
        return true;
      } else if (newTileBlockDecorations) {
        return true;
      }
      oldTileStartRow += oldProps.rowsPerTile;
      newTileStartRow += newProps.rowsPerTile;
    }
    return false;
  }
  didMouseDown(event) {
    if (this.props.onMouseDown == null) {
      this.props.rootComponent.didMouseDownOnLineNumberGutter(event);
    } else {
      const { bufferRow, screenRow } = event.target.dataset;
      this.props.onMouseDown({
        bufferRow: parseInt(bufferRow, 10),
        screenRow: parseInt(screenRow, 10),
        domEvent: event
      });
    }
  }
  didMouseMove(event) {
    if (this.props.onMouseMove != null) {
      const { bufferRow, screenRow } = event.target.dataset;
      this.props.onMouseMove({
        bufferRow: parseInt(bufferRow, 10),
        screenRow: parseInt(screenRow, 10),
        domEvent: event
      });
    }
  }
}
class LineNumberComponent {
  constructor(props) {
    const {
      className,
      width,
      marginTop,
      bufferRow,
      screenRow,
      number,
      nodePool
    } = props;
    this.props = props;
    const style = {};
    if (width != null && width > 0) style.width = width + 'px';
    if (marginTop != null && marginTop > 0) style.marginTop = marginTop + 'px';
    this.element = nodePool.getElement('DIV', className, style);
    this.element.dataset.bufferRow = bufferRow;
    this.element.dataset.screenRow = screenRow;
    if (number) this.element.appendChild(nodePool.getTextNode(number));
    this.element.appendChild(nodePool.getElement('DIV', 'icon-right', null));
  }
  destroy() {
    this.element.remove();
    this.props.nodePool.release(this.element);
  }
  update(props) {
    const {
      nodePool,
      className,
      width,
      marginTop,
      bufferRow,
      screenRow,
      number
    } = props;
    if (this.props.bufferRow !== bufferRow)
      this.element.dataset.bufferRow = bufferRow;
    if (this.props.screenRow !== screenRow)
      this.element.dataset.screenRow = screenRow;
    if (this.props.className !== className) this.element.className = className;
    if (this.props.width !== width) {
      if (width != null && width > 0) {
        this.element.style.width = width + 'px';
      } else {
        this.element.style.width = '';
      }
    }
    if (this.props.marginTop !== marginTop) {
      if (marginTop != null && marginTop > 0) {
        this.element.style.marginTop = marginTop + 'px';
      } else {
        this.element.style.marginTop = '';
      }
    }
    if (this.props.number !== number) {
      if (this.props.number != null) {
        const numberNode = this.element.firstChild;
        numberNode.remove();
        nodePool.release(numberNode);
      }
      if (number != null) {
        this.element.insertBefore(
          nodePool.getTextNode(number),
          this.element.firstChild
        );
      }
    }
    this.props = props;
  }
}
class CustomGutterComponent {
  constructor(props) {
    this.props = props;
    this.element = this.props.element;
    this.virtualNode = $.div(null);
    this.virtualNode.domNode = this.element;
    etch.updateSync(this);
  }
  update(props) {
    this.props = props;
    etch.updateSync(this);
  }
  destroy() {
    etch.destroy(this);
  }
  render() {
    let className = 'gutter';
    if (this.props.className) {
      className += ' ' + this.props.className;
    }
    return $.div(
      {
        className,
        attributes: { 'gutter-name': this.props.name },
        style: {
          display: this.props.visible ? '' : 'none'
        }
      },
      $.div(
        {
          className: 'custom-decorations',
          style: { height: this.props.height + 'px' }
        },
        this.renderDecorations()
      )
    );
  }
  renderDecorations() {
    if (!this.props.decorations) return null;
    return this.props.decorations.map(({ className, element, top, height }) => {
      return $(CustomGutterDecorationComponent, {
        className,
        element,
        top,
        height
      });
    });
  }
}
class CustomGutterDecorationComponent {
  constructor(props) {
    this.props = props;
    this.element = document.createElement('div');
    const { top, height, className, element } = this.props;
    this.element.style.position = 'absolute';
    this.element.style.top = top + 'px';
    this.element.style.height = height + 'px';
    if (className != null) this.element.className = className;
    if (element != null) {
      this.element.appendChild(element);
      element.style.height = height + 'px';
    }
  }
  update(newProps) {
    const oldProps = this.props;
    this.props = newProps;
    if (newProps.top !== oldProps.top)
      this.element.style.top = newProps.top + 'px';
    if (newProps.height !== oldProps.height) {
      this.element.style.height = newProps.height + 'px';
      if (newProps.element)
        newProps.element.style.height = newProps.height + 'px';
    }
    if (newProps.className !== oldProps.className)
      this.element.className = newProps.className || '';
    if (newProps.element !== oldProps.element) {
      if (this.element.firstChild) this.element.firstChild.remove();
      if (newProps.element != null) {
        this.element.appendChild(newProps.element);
        newProps.element.style.height = newProps.height + 'px';
      }
    }
  }
}
class CursorsAndInputComponent {
  constructor(props) {
    this.props = props;
    etch.initialize(this);
  }
  update(props) {
    if (props.measuredContent) {
      this.props = props;
      etch.updateSync(this);
    }
  }
  updateCursorBlinkSync(cursorsBlinkedOff) {
    this.props.cursorsBlinkedOff = cursorsBlinkedOff;
    const className = this.getCursorsClassName();
    this.refs.cursors.className = className;
    this.virtualNode.props.className = className;
  }
  render() {
    const {
      lineHeight,
      decorationsToRender,
      scrollHeight,
      scrollWidth
    } = this.props;
    const className = this.getCursorsClassName();
    const cursorHeight = lineHeight + 'px';
    const children = [this.renderHiddenInput()];
    for (let i = 0; i < decorationsToRender.cursors.length; i++) {
      const {
        pixelLeft,
        pixelTop,
        pixelWidth,
        className: extraCursorClassName,
        style: extraCursorStyle
      } = decorationsToRender.cursors[i];
      let cursorClassName = 'cursor';
      if (extraCursorClassName) cursorClassName += ' ' + extraCursorClassName;
      const cursorStyle = {
        height: cursorHeight,
        width: Math.min(pixelWidth, scrollWidth - pixelLeft) + 'px',
        transform: `translate(${pixelLeft}px, ${pixelTop}px)`
      };
      if (extraCursorStyle) Object.assign(cursorStyle, extraCursorStyle);
      children.push(
        $.div({
          className: cursorClassName,
          style: cursorStyle
        })
      );
    }
    return $.div(
      {
        key: 'cursors',
        ref: 'cursors',
        className,
        style: {
          position: 'absolute',
          contain: 'strict',
          zIndex: 1,
          width: scrollWidth + 'px',
          height: scrollHeight + 'px',
          pointerEvents: 'none',
          userSelect: 'none'
        }
      },
      children
    );
  }
  getCursorsClassName() {
    return this.props.cursorsBlinkedOff ? 'cursors blink-off' : 'cursors';
  }
  renderHiddenInput() {
    const {
      lineHeight,
      hiddenInputPosition,
      didBlurHiddenInput,
      didFocusHiddenInput,
      didPaste,
      didTextInput,
      didKeydown,
      didKeyup,
      didKeypress,
      didCompositionStart,
      didCompositionUpdate,
      didCompositionEnd,
      tabIndex
    } = this.props;
    let top, left;
    if (hiddenInputPosition) {
      top = hiddenInputPosition.pixelTop;
      left = hiddenInputPosition.pixelLeft;
    } else {
      top = 0;
      left = 0;
    }
    return $.input({
      ref: 'hiddenInput',
      key: 'hiddenInput',
      className: 'hidden-input',
      on: {
        blur: didBlurHiddenInput,
        focus: didFocusHiddenInput,
        paste: didPaste,
        textInput: didTextInput,
        keydown: didKeydown,
        keyup: didKeyup,
        keypress: didKeypress,
        compositionstart: didCompositionStart,
        compositionupdate: didCompositionUpdate,
        compositionend: didCompositionEnd
      },
      tabIndex: tabIndex,
      style: {
        position: 'absolute',
        width: '1px',
        height: lineHeight + 'px',
        top: top + 'px',
        left: left + 'px',
        opacity: 0,
        padding: 0,
        border: 0
      }
    });
  }
}
class LinesTileComponent {
  constructor(props) {
    this.props = props;
    etch.initialize(this);
    this.createLines();
    this.updateBlockDecorations({}, props);
  }
  update(newProps) {
    if (this.shouldUpdate(newProps)) {
      const oldProps = this.props;
      this.props = newProps;
      etch.updateSync(this);
      if (!newProps.measuredContent) {
        this.updateLines(oldProps, newProps);
        this.updateBlockDecorations(oldProps, newProps);
      }
    }
  }
  destroy() {
    for (let i = 0; i < this.lineComponents.length; i++) {
      this.lineComponents[i].destroy();
    }
    this.lineComponents.length = 0;
    return etch.destroy(this);
  }
  render() {
    const { height, width, top } = this.props;
    return $.div(
      {
        style: {
          contain: 'layout style',
          position: 'absolute',
          height: height + 'px',
          width: width + 'px',
          transform: `translateY(${top}px)`
        }
      }
    );
  }
  createLines() {
    const {
      tileStartRow,
      screenLines,
      lineDecorations,
      textDecorations,
      nodePool,
      displayLayer,
      lineComponentsByScreenLineId
    } = this.props;
    this.lineComponents = [];
    for (let i = 0, length = screenLines.length; i < length; i++) {
      const component = new LineComponent({
        screenLine: screenLines[i],
        screenRow: tileStartRow + i,
        lineDecoration: lineDecorations[i],
        textDecorations: textDecorations[i],
        displayLayer,
        nodePool,
        lineComponentsByScreenLineId
      });
      this.element.appendChild(component.element);
      this.lineComponents.push(component);
    }
  }
  updateLines(oldProps, newProps) {
    const {
      screenLines,
      tileStartRow,
      lineDecorations,
      textDecorations,
      nodePool,
      displayLayer,
      lineComponentsByScreenLineId
    } = newProps;
    const oldScreenLines = oldProps.screenLines;
    const newScreenLines = screenLines;
    const oldScreenLinesEndIndex = oldScreenLines.length;
    const newScreenLinesEndIndex = newScreenLines.length;
    let oldScreenLineIndex = 0;
    let newScreenLineIndex = 0;
    let lineComponentIndex = 0;
    while (
      oldScreenLineIndex < oldScreenLinesEndIndex ||
      newScreenLineIndex < newScreenLinesEndIndex
    ) {
      const oldScreenLine = oldScreenLines[oldScreenLineIndex];
      const newScreenLine = newScreenLines[newScreenLineIndex];
      if (oldScreenLineIndex >= oldScreenLinesEndIndex) {
        var newScreenLineComponent = new LineComponent({
          screenLine: newScreenLine,
          screenRow: tileStartRow + newScreenLineIndex,
          lineDecoration: lineDecorations[newScreenLineIndex],
          textDecorations: textDecorations[newScreenLineIndex],
          displayLayer,
          nodePool,
          lineComponentsByScreenLineId
        });
        this.element.appendChild(newScreenLineComponent.element);
        this.lineComponents.push(newScreenLineComponent);
        newScreenLineIndex++;
        lineComponentIndex++;
      } else if (newScreenLineIndex >= newScreenLinesEndIndex) {
        this.lineComponents[lineComponentIndex].destroy();
        this.lineComponents.splice(lineComponentIndex, 1);
        oldScreenLineIndex++;
      } else if (oldScreenLine === newScreenLine) {
        const lineComponent = this.lineComponents[lineComponentIndex];
        lineComponent.update({
          screenRow: tileStartRow + newScreenLineIndex,
          lineDecoration: lineDecorations[newScreenLineIndex],
          textDecorations: textDecorations[newScreenLineIndex]
        });
        oldScreenLineIndex++;
        newScreenLineIndex++;
        lineComponentIndex++;
      } else {
        const oldScreenLineIndexInNewScreenLines = newScreenLines.indexOf(
          oldScreenLine
        );
        const newScreenLineIndexInOldScreenLines = oldScreenLines.indexOf(
          newScreenLine
        );
        if (
          newScreenLineIndex < oldScreenLineIndexInNewScreenLines &&
          oldScreenLineIndexInNewScreenLines < newScreenLinesEndIndex
        ) {
          const newScreenLineComponents = [];
          while (newScreenLineIndex < oldScreenLineIndexInNewScreenLines) {
            var newScreenLineComponent = new LineComponent({
              screenLine: newScreenLines[newScreenLineIndex],
              screenRow: tileStartRow + newScreenLineIndex,
              lineDecoration: lineDecorations[newScreenLineIndex],
              textDecorations: textDecorations[newScreenLineIndex],
              displayLayer,
              nodePool,
              lineComponentsByScreenLineId
            });
            this.element.insertBefore(
              newScreenLineComponent.element,
              this.getFirstElementForScreenLine(oldProps, oldScreenLine)
            );
            newScreenLineComponents.push(newScreenLineComponent);
            newScreenLineIndex++;
          }
          this.lineComponents.splice(
            lineComponentIndex,
            0,
            ...newScreenLineComponents
          );
          lineComponentIndex =
            lineComponentIndex + newScreenLineComponents.length;
        } else if (
          oldScreenLineIndex < newScreenLineIndexInOldScreenLines &&
          newScreenLineIndexInOldScreenLines < oldScreenLinesEndIndex
        ) {
          while (oldScreenLineIndex < newScreenLineIndexInOldScreenLines) {
            this.lineComponents[lineComponentIndex].destroy();
            this.lineComponents.splice(lineComponentIndex, 1);
            oldScreenLineIndex++;
          }
        } else {
          const oldScreenLineComponent = this.lineComponents[
            lineComponentIndex
          ];
          var newScreenLineComponent = new LineComponent({
            screenLine: newScreenLines[newScreenLineIndex],
            screenRow: tileStartRow + newScreenLineIndex,
            lineDecoration: lineDecorations[newScreenLineIndex],
            textDecorations: textDecorations[newScreenLineIndex],
            displayLayer,
            nodePool,
            lineComponentsByScreenLineId
          });
          this.element.insertBefore(
            newScreenLineComponent.element,
            oldScreenLineComponent.element
          );
          oldScreenLineComponent.destroy();
          this.lineComponents[lineComponentIndex] = newScreenLineComponent;
          oldScreenLineIndex++;
          newScreenLineIndex++;
          lineComponentIndex++;
        }
      }
    }
  }
  getFirstElementForScreenLine(oldProps, screenLine) {
    const blockDecorations = oldProps.blockDecorations
      ? oldProps.blockDecorations.get(screenLine.id)
      : null;
    if (blockDecorations) {
      const blockDecorationElementsBeforeOldScreenLine = [];
      for (let i = 0; i < blockDecorations.length; i++) {
        const decoration = blockDecorations[i];
        if (decoration.position !== 'after') {
          blockDecorationElementsBeforeOldScreenLine.push(
            TextEditor.viewForItem(decoration.item)
          );
        }
      }
      for (
        let i = 0;
        i < blockDecorationElementsBeforeOldScreenLine.length;
        i++
      ) {
        const blockDecorationElement =
          blockDecorationElementsBeforeOldScreenLine[i];
        if (
          !blockDecorationElementsBeforeOldScreenLine.includes(
            blockDecorationElement.previousSibling
          )
        ) {
          return blockDecorationElement;
        }
      }
    }
    return oldProps.lineComponentsByScreenLineId.get(screenLine.id).element;
  }
  updateBlockDecorations(oldProps, newProps) {
    const { blockDecorations, lineComponentsByScreenLineId } = newProps;
    if (oldProps.blockDecorations) {
      oldProps.blockDecorations.forEach((oldDecorations, screenLineId) => {
        const newDecorations = newProps.blockDecorations
          ? newProps.blockDecorations.get(screenLineId)
          : null;
        for (let i = 0; i < oldDecorations.length; i++) {
          const oldDecoration = oldDecorations[i];
          if (newDecorations && newDecorations.includes(oldDecoration))
            continue;
          const element = TextEditor.viewForItem(oldDecoration.item);
          if (element.parentElement !== this.element) continue;
          element.remove();
        }
      });
    }
    if (blockDecorations) {
      blockDecorations.forEach((newDecorations, screenLineId) => {
        const oldDecorations = oldProps.blockDecorations
          ? oldProps.blockDecorations.get(screenLineId)
          : null;
        const lineNode = lineComponentsByScreenLineId.get(screenLineId).element;
        let lastAfter = lineNode;
        for (let i = 0; i < newDecorations.length; i++) {
          const newDecoration = newDecorations[i];
          const element = TextEditor.viewForItem(newDecoration.item);
          if (oldDecorations && oldDecorations.includes(newDecoration)) {
            if (newDecoration.position === 'after') {
              lastAfter = element;
            }
            continue;
          }
          if (newDecoration.position === 'after') {
            this.element.insertBefore(element, lastAfter.nextSibling);
            lastAfter = element;
          } else {
            this.element.insertBefore(element, lineNode);
          }
        }
      });
    }
  }
  shouldUpdate(newProps) {
    const oldProps = this.props;
    if (oldProps.top !== newProps.top) return true;
    if (oldProps.height !== newProps.height) return true;
    if (oldProps.width !== newProps.width) return true;
    if (oldProps.lineHeight !== newProps.lineHeight) return true;
    if (oldProps.tileStartRow !== newProps.tileStartRow) return true;
    if (oldProps.tileEndRow !== newProps.tileEndRow) return true;
    if (!arraysEqual(oldProps.screenLines, newProps.screenLines)) return true;
    if (!arraysEqual(oldProps.lineDecorations, newProps.lineDecorations))
      return true;
    if (oldProps.blockDecorations && newProps.blockDecorations) {
      if (oldProps.blockDecorations.size !== newProps.blockDecorations.size)
        return true;
      let blockDecorationsChanged = false;
      oldProps.blockDecorations.forEach((oldDecorations, screenLineId) => {
        if (!blockDecorationsChanged) {
          const newDecorations = newProps.blockDecorations.get(screenLineId);
          blockDecorationsChanged =
            newDecorations == null ||
            !arraysEqual(oldDecorations, newDecorations);
        }
      });
      if (blockDecorationsChanged) return true;
      newProps.blockDecorations.forEach((newDecorations, screenLineId) => {
        if (!blockDecorationsChanged) {
          const oldDecorations = oldProps.blockDecorations.get(screenLineId);
          blockDecorationsChanged = oldDecorations == null;
        }
      });
      if (blockDecorationsChanged) return true;
    } else if (oldProps.blockDecorations) {
      return true;
    } else if (newProps.blockDecorations) {
      return true;
    }
    if (oldProps.textDecorations.length !== newProps.textDecorations.length)
      return true;
    for (let i = 0; i < oldProps.textDecorations.length; i++) {
      if (
        !textDecorationsEqual(
          oldProps.textDecorations[i],
          newProps.textDecorations[i]
        )
      )
        return true;
    }
    return false;
  }
}
class LineComponent {
  constructor(props) {
    const {
      nodePool,
      screenRow,
      screenLine,
      lineComponentsByScreenLineId,
      offScreen
    } = props;
    this.props = props;
    this.element = nodePool.getElement('DIV', this.buildClassName(), null);
    this.element.dataset.screenRow = screenRow;
    this.textNodes = [];
    if (offScreen) {
      this.element.style.position = 'absolute';
      this.element.style.visibility = 'hidden';
      this.element.dataset.offScreen = true;
    }
    this.appendContents();
    lineComponentsByScreenLineId.set(screenLine.id, this);
  }
  update(newProps) {
    if (this.props.lineDecoration !== newProps.lineDecoration) {
      this.props.lineDecoration = newProps.lineDecoration;
      this.element.className = this.buildClassName();
    }
    if (this.props.screenRow !== newProps.screenRow) {
      this.props.screenRow = newProps.screenRow;
      this.element.dataset.screenRow = newProps.screenRow;
    }
    if (
      !textDecorationsEqual(
        this.props.textDecorations,
        newProps.textDecorations
      )
    ) {
      this.props.textDecorations = newProps.textDecorations;
      this.element.firstChild.remove();
      this.appendContents();
    }
  }
  destroy() {
    const { nodePool, lineComponentsByScreenLineId, screenLine } = this.props;
    if (lineComponentsByScreenLineId.get(screenLine.id) === this) {
      lineComponentsByScreenLineId.delete(screenLine.id);
    }
    this.element.remove();
    nodePool.release(this.element);
  }
  appendContents() {
    const { displayLayer, nodePool, screenLine, textDecorations } = this.props;
    this.textNodes.length = 0;
    const { lineText, tags } = screenLine;
    let openScopeNode = nodePool.getElement('SPAN', null, null);
    this.element.appendChild(openScopeNode);
    let decorationIndex = 0;
    let column = 0;
    let activeClassName = null;
    let activeStyle = null;
    let nextDecoration = textDecorations
      ? textDecorations[decorationIndex]
      : null;
    if (nextDecoration && nextDecoration.column === 0) {
      column = nextDecoration.column;
      activeClassName = nextDecoration.className;
      activeStyle = nextDecoration.style;
      nextDecoration = textDecorations[++decorationIndex];
    }
    for (let i = 0; i < tags.length; i++) {
      const tag = tags[i];
      if (tag !== 0) {
        if (displayLayer.isCloseTag(tag)) {
          openScopeNode = openScopeNode.parentElement;
        } else if (displayLayer.isOpenTag(tag)) {
          const newScopeNode = nodePool.getElement(
            'SPAN',
            displayLayer.classNameForTag(tag),
            null
          );
          openScopeNode.appendChild(newScopeNode);
          openScopeNode = newScopeNode;
        } else {
          const nextTokenColumn = column + tag;
          while (nextDecoration && nextDecoration.column <= nextTokenColumn) {
            const text = lineText.substring(column, nextDecoration.column);
            this.appendTextNode(
              openScopeNode,
              text,
              activeClassName,
              activeStyle
            );
            column = nextDecoration.column;
            activeClassName = nextDecoration.className;
            activeStyle = nextDecoration.style;
            nextDecoration = textDecorations[++decorationIndex];
          }
          if (column < nextTokenColumn) {
            const text = lineText.substring(column, nextTokenColumn);
            this.appendTextNode(
              openScopeNode,
              text,
              activeClassName,
              activeStyle
            );
            column = nextTokenColumn;
          }
        }
      }
    }
    if (column === 0) {
      const textNode = nodePool.getTextNode(' ');
      this.element.appendChild(textNode);
      this.textNodes.push(textNode);
    }
    if (lineText.endsWith(displayLayer.foldCharacter)) {
      const textNode = nodePool.getTextNode(ZERO_WIDTH_NBSP_CHARACTER);
      this.element.appendChild(textNode);
      this.textNodes.push(textNode);
    }
  }
  appendTextNode(openScopeNode, text, activeClassName, activeStyle) {
    const { nodePool } = this.props;
    if (activeClassName || activeStyle) {
      const decorationNode = nodePool.getElement(
        'SPAN',
        activeClassName,
        activeStyle
      );
      openScopeNode.appendChild(decorationNode);
      openScopeNode = decorationNode;
    }
    const textNode = nodePool.getTextNode(text);
    openScopeNode.appendChild(textNode);
    this.textNodes.push(textNode);
  }
  buildClassName() {
    const { lineDecoration } = this.props;
    let className = 'line';
    if (lineDecoration != null) className = className + ' ' + lineDecoration;
    return className;
  }
}
class HighlightsComponent {
  constructor(props) {
    this.props = {};
    this.element = document.createElement('div');
    this.element.className = 'highlights';
    this.element.style.contain = 'strict';
    this.element.style.position = 'absolute';
    this.element.style.overflow = 'hidden';
    this.element.style.userSelect = 'none';
    this.highlightComponentsByKey = new Map();
    this.update(props);
  }
  destroy() {
    this.highlightComponentsByKey.forEach(highlightComponent => {
      highlightComponent.destroy();
    });
    this.highlightComponentsByKey.clear();
  }
  update(newProps) {
    if (this.shouldUpdate(newProps)) {
      this.props = newProps;
      const { height, width, lineHeight, highlightDecorations } = this.props;
      this.element.style.height = height + 'px';
      this.element.style.width = width + 'px';
      const visibleHighlightDecorations = new Set();
      if (highlightDecorations) {
        for (let i = 0; i < highlightDecorations.length; i++) {
          const highlightDecoration = highlightDecorations[i];
          const highlightProps = Object.assign(
            { lineHeight },
            highlightDecorations[i]
          );
          let highlightComponent = this.highlightComponentsByKey.get(
            highlightDecoration.key
          );
          if (highlightComponent) {
            highlightComponent.update(highlightProps);
          } else {
            highlightComponent = new HighlightComponent(highlightProps);
            this.element.appendChild(highlightComponent.element);
            this.highlightComponentsByKey.set(
              highlightDecoration.key,
              highlightComponent
            );
          }
          highlightDecorations[i].flashRequested = false;
          visibleHighlightDecorations.add(highlightDecoration.key);
        }
      }
      this.highlightComponentsByKey.forEach((highlightComponent, key) => {
        if (!visibleHighlightDecorations.has(key)) {
          highlightComponent.destroy();
          this.highlightComponentsByKey.delete(key);
        }
      });
    }
  }
  shouldUpdate(newProps) {
    const oldProps = this.props;
    if (!newProps.hasInitialMeasurements) return false;
    if (oldProps.width !== newProps.width) return true;
    if (oldProps.height !== newProps.height) return true;
    if (oldProps.lineHeight !== newProps.lineHeight) return true;
    if (!oldProps.highlightDecorations && newProps.highlightDecorations)
      return true;
    if (oldProps.highlightDecorations && !newProps.highlightDecorations)
      return true;
    if (oldProps.highlightDecorations && newProps.highlightDecorations) {
      if (
        oldProps.highlightDecorations.length !==
        newProps.highlightDecorations.length
      )
        return true;
      for (
        let i = 0, length = oldProps.highlightDecorations.length;
        i < length;
        i++
      ) {
        const oldHighlight = oldProps.highlightDecorations[i];
        const newHighlight = newProps.highlightDecorations[i];
        if (oldHighlight.className !== newHighlight.className) return true;
        if (newHighlight.flashRequested) return true;
        if (oldHighlight.startPixelTop !== newHighlight.startPixelTop)
          return true;
        if (oldHighlight.startPixelLeft !== newHighlight.startPixelLeft)
          return true;
        if (oldHighlight.endPixelTop !== newHighlight.endPixelTop) return true;
        if (oldHighlight.endPixelLeft !== newHighlight.endPixelLeft)
          return true;
        if (!oldHighlight.screenRange.isEqual(newHighlight.screenRange))
          return true;
      }
    }
  }
}
class HighlightComponent {
  constructor(props) {
    this.props = props;
    etch.initialize(this);
    if (this.props.flashRequested) this.performFlash();
  }
  destroy() {
    if (this.timeoutsByClassName) {
      this.timeoutsByClassName.forEach(timeout => {
        window.clearTimeout(timeout);
      });
      this.timeoutsByClassName.clear();
    }
    return etch.destroy(this);
  }
  update(newProps) {
    this.props = newProps;
    etch.updateSync(this);
    if (newProps.flashRequested) this.performFlash();
  }
  performFlash() {
    const { flashClass, flashDuration } = this.props;
    if (!this.timeoutsByClassName) this.timeoutsByClassName = new Map();
    if (this.timeoutsByClassName.has(flashClass)) {
      window.clearTimeout(this.timeoutsByClassName.get(flashClass));
      this.timeoutsByClassName.delete(flashClass);
      this.element.classList.remove(flashClass);
      requestAnimationFrame(() => this.performFlash());
    } else {
      this.element.classList.add(flashClass);
      this.timeoutsByClassName.set(
        flashClass,
        window.setTimeout(() => {
          this.element.classList.remove(flashClass);
        }, flashDuration)
      );
    }
  }
  render() {
    const {
      className,
      screenRange,
      lineHeight,
      startPixelTop,
      startPixelLeft,
      endPixelTop,
      endPixelLeft
    } = this.props;
    const regionClassName = 'region ' + className;
    let children;
    if (screenRange.start.row === screenRange.end.row) {
      children = $.div({
        className: regionClassName,
        style: {
          position: 'absolute',
          boxSizing: 'border-box',
          top: startPixelTop + 'px',
          left: startPixelLeft + 'px',
          width: endPixelLeft - startPixelLeft + 'px',
          height: lineHeight + 'px'
        }
      });
    } else {
      children = [];
      children.push(
        $.div({
          className: regionClassName,
          style: {
            position: 'absolute',
            boxSizing: 'border-box',
            top: startPixelTop + 'px',
            left: startPixelLeft + 'px',
            right: 0,
            height: lineHeight + 'px'
          }
        })
      );
      if (screenRange.end.row - screenRange.start.row > 1) {
        children.push(
          $.div({
            className: regionClassName,
            style: {
              position: 'absolute',
              boxSizing: 'border-box',
              top: startPixelTop + lineHeight + 'px',
              left: 0,
              right: 0,
              height: endPixelTop - startPixelTop - lineHeight * 2 + 'px'
            }
          })
        );
      }
      if (endPixelLeft > 0) {
        children.push(
          $.div({
            className: regionClassName,
            style: {
              position: 'absolute',
              boxSizing: 'border-box',
              top: endPixelTop - lineHeight + 'px',
              left: 0,
              width: endPixelLeft + 'px',
              height: lineHeight + 'px'
            }
          })
        );
      }
    }
    return $.div({ className: 'highlight ' + className }, children);
  }
}
class OverlayComponent {
  constructor(props) {
    this.props = props;
    this.element = document.createElement('atom-overlay');
    if (this.props.className != null)
      this.element.classList.add(this.props.className);
    this.element.appendChild(this.props.element);
    this.element.style.position = 'fixed';
    this.element.style.zIndex = 4;
    this.element.style.top = (this.props.pixelTop || 0) + 'px';
    this.element.style.left = (this.props.pixelLeft || 0) + 'px';
    this.currentContentRect = null;
    this.resizeObserver = new ResizeObserver(entries => {
      const { contentRect } = entries[0];
      if (
        this.currentContentRect &&
        (this.currentContentRect.width !== contentRect.width ||
          this.currentContentRect.height !== contentRect.height)
      ) {
        this.resizeObserver.disconnect();
        this.props.didResize(this);
        process.nextTick(() => {
          this.resizeObserver.observe(this.props.element);
        });
      }
      this.currentContentRect = contentRect;
    });
    this.didAttach();
    this.props.overlayComponents.add(this);
  }
  destroy() {
    this.props.overlayComponents.delete(this);
    this.didDetach();
  }
  getNextUpdatePromise() {
    if (!this.nextUpdatePromise) {
      this.nextUpdatePromise = new Promise(resolve => {
        this.resolveNextUpdatePromise = () => {
          this.nextUpdatePromise = null;
          this.resolveNextUpdatePromise = null;
          resolve();
        };
      });
    }
    return this.nextUpdatePromise;
  }
  update(newProps) {
    const oldProps = this.props;
    this.props = Object.assign({}, oldProps, newProps);
    if (this.props.pixelTop != null)
      this.element.style.top = this.props.pixelTop + 'px';
    if (this.props.pixelLeft != null)
      this.element.style.left = this.props.pixelLeft + 'px';
    if (newProps.className !== oldProps.className) {
      if (oldProps.className != null)
        this.element.classList.remove(oldProps.className);
      if (newProps.className != null)
        this.element.classList.add(newProps.className);
    }
    if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise();
  }
  didAttach() {
    this.resizeObserver.observe(this.props.element);
  }
  didDetach() {
    this.resizeObserver.disconnect();
  }
}
let rangeForMeasurement;
function clientRectForRange(textNode, startIndex, endIndex) {
  if (!rangeForMeasurement) rangeForMeasurement = document.createRange();
  rangeForMeasurement.setStart(textNode, startIndex);
  rangeForMeasurement.setEnd(textNode, endIndex);
  return rangeForMeasurement.getBoundingClientRect();
}
function textDecorationsEqual(oldDecorations, newDecorations) {
  if (!oldDecorations && newDecorations) return false;
  if (oldDecorations && !newDecorations) return false;
  if (oldDecorations && newDecorations) {
    if (oldDecorations.length !== newDecorations.length) return false;
    for (let j = 0; j < oldDecorations.length; j++) {
      if (oldDecorations[j].column !== newDecorations[j].column) return false;
      if (oldDecorations[j].className !== newDecorations[j].className)
        return false;
      if (!objectsEqual(oldDecorations[j].style, newDecorations[j].style))
        return false;
    }
  }
  return true;
}
function arraysEqual(a, b) {
  if (a.length !== b.length) return false;
  for (let i = 0, length = a.length; i < length; i++) {
    if (a[i] !== b[i]) return false;
  }
  return true;
}
function objectsEqual(a, b) {
  if (!a && b) return false;
  if (a && !b) return false;
  if (a && b) {
    for (const key in a) {
      if (a[key] !== b[key]) return false;
    }
    for (const key in b) {
      if (a[key] !== b[key]) return false;
    }
  }
  return true;
}
function constrainRangeToRows(range, startRow, endRow) {
  if (range.start.row < startRow || range.end.row >= endRow) {
    range = range.copy();
    if (range.start.row < startRow) {
      range.start.row = startRow;
      range.start.column = 0;
    }
    if (range.end.row >= endRow) {
      range.end.row = endRow;
      range.end.column = 0;
    }
  }
  return range;
}
function debounce(fn, wait) {
  let timestamp, timeout;
  function later() {
    const last = Date.now() - timestamp;
    if (last < wait && last >= 0) {
      timeout = setTimeout(later, wait - last);
    } else {
      timeout = null;
      fn();
    }
  }
  return function () {
    timestamp = Date.now();
    if (!timeout) timeout = setTimeout(later, wait);
  };
}
class NodePool {
  constructor() {
    this.elementsByType = {};
    this.textNodes = [];
  }
  getElement(type, className, style) {
    let element;
    const elementsByDepth = this.elementsByType[type];
    if (elementsByDepth) {
      while (elementsByDepth.length > 0) {
        const elements = elementsByDepth[elementsByDepth.length - 1];
        if (elements && elements.length > 0) {
          element = elements.pop();
          if (elements.length === 0) elementsByDepth.pop();
          break;
        } else {
          elementsByDepth.pop();
        }
      }
    }
    if (element) {
      element.className = className || '';
      element.attributeStyleMap.forEach((value, key) => {
        if (!style || style[key] == null) element.style[key] = '';
      });
      if (style) Object.assign(element.style, style);
      for (const key in element.dataset) delete element.dataset[key];
      while (element.firstChild) element.firstChild.remove();
      return element;
    } else {
      const newElement = document.createElement(type);
      if (className) newElement.className = className;
      if (style) Object.assign(newElement.style, style);
      return newElement;
    }
  }
  getTextNode(text) {
    if (this.textNodes.length > 0) {
      const node = this.textNodes.pop();
      node.textContent = text;
      return node;
    } else {
      return document.createTextNode(text);
    }
  }
  release(node, depth = 0) {
    const { nodeName } = node;
    if (nodeName === '#text') {
      this.textNodes.push(node);
    } else {
      let elementsByDepth = this.elementsByType[nodeName];
      if (!elementsByDepth) {
        elementsByDepth = [];
        this.elementsByType[nodeName] = elementsByDepth;
      }
      let elements = elementsByDepth[depth];
      if (!elements) {
        elements = [];
        elementsByDepth[depth] = elements;
      }
      elements.push(node);
      for (let i = 0; i < node.childNodes.length; i++) {
        this.release(node.childNodes[i], depth + 1);
      }
    }
  }
}
function roundToPhysicalPixelBoundary(virtualPixelPosition) {
  const virtualPixelsPerPhysicalPixel = 1 / window.devicePixelRatio;
  return (
    Math.round(virtualPixelPosition / virtualPixelsPerPhysicalPixel) *
    virtualPixelsPerPhysicalPixel
  );
}
function ceilToPhysicalPixelBoundary(virtualPixelPosition) {
  const virtualPixelsPerPhysicalPixel = 1 / window.devicePixelRatio;
  return (
    Math.ceil(virtualPixelPosition / virtualPixelsPerPhysicalPixel) *
    virtualPixelsPerPhysicalPixel
  );
}

================
File: src/text-editor-element.js
================
const { Emitter, Range } = require('atom');
const Grim = require('grim');
const TextEditorComponent = require('./text-editor-component');
const dedent = require('dedent');
class TextEditorElement extends HTMLElement {
  initialize(component) {
    this.component = component;
    return this;
  }
  get shadowRoot() {
    Grim.deprecate(dedent`
      The contents of \`atom-text-editor\` elements are no longer encapsulated
      within a shadow DOM boundary. Please, stop using \`shadowRoot\` and access
      the editor contents directly instead.
    `);
    return this;
  }
  get rootElement() {
    Grim.deprecate(dedent`
      The contents of \`atom-text-editor\` elements are no longer encapsulated
      within a shadow DOM boundary. Please, stop using \`rootElement\` and access
      the editor contents directly instead.
    `);
    return this;
  }
  constructor() {
    super();
    this.emitter = new Emitter();
    this.initialText = this.textContent;
    if (this.tabIndex == null) this.tabIndex = -1;
    this.addEventListener('focus', event =>
      this.getComponent().didFocus(event)
    );
    this.addEventListener('blur', event => this.getComponent().didBlur(event));
  }
  connectedCallback() {
    this.getComponent().didAttach();
    this.emitter.emit('did-attach');
  }
  disconnectedCallback() {
    this.emitter.emit('did-detach');
    this.getComponent().didDetach();
  }
  static get observedAttributes() {
    return ['mini', 'placeholder-text', 'gutter-hidden', 'readonly'];
  }
  attributeChangedCallback(name, oldValue, newValue) {
    if (this.component) {
      switch (name) {
        case 'mini':
          this.getModel().update({ mini: newValue != null });
          break;
        case 'placeholder-text':
          this.getModel().update({ placeholderText: newValue });
          break;
        case 'gutter-hidden':
          this.getModel().update({ lineNumberGutterVisible: newValue == null });
          break;
        case 'readonly':
          this.getModel().update({ readOnly: newValue != null });
          break;
      }
    }
  }
  // Extended: Get a promise that resolves the next time the element's DOM
  // is updated in any way.
  //
  // This can be useful when you've made a change to the model and need to
  // be sure this change has been flushed to the DOM.
  //
  // Returns a {Promise}.
  getNextUpdatePromise() {
    return this.getComponent().getNextUpdatePromise();
  }
  getModel() {
    return this.getComponent().props.model;
  }
  setModel(model) {
    this.getComponent().update({ model });
    this.updateModelFromAttributes();
  }
  updateModelFromAttributes() {
    const props = { mini: this.hasAttribute('mini') };
    if (this.hasAttribute('placeholder-text'))
      props.placeholderText = this.getAttribute('placeholder-text');
    if (this.hasAttribute('gutter-hidden'))
      props.lineNumberGutterVisible = false;
    this.getModel().update(props);
    if (this.initialText) this.getModel().setText(this.initialText);
  }
  onDidAttach(callback) {
    return this.emitter.on('did-attach', callback);
  }
  onDidDetach(callback) {
    return this.emitter.on('did-detach', callback);
  }
  measureDimensions() {
    this.getComponent().measureDimensions();
  }
  setWidth(width) {
    this.style.width =
      this.getComponent().getGutterContainerWidth() + width + 'px';
  }
  getWidth() {
    return this.getComponent().getScrollContainerWidth();
  }
  setHeight(height) {
    this.style.height = height + 'px';
  }
  getHeight() {
    return this.getComponent().getScrollContainerHeight();
  }
  onDidChangeScrollLeft(callback) {
    return this.emitter.on('did-change-scroll-left', callback);
  }
  onDidChangeScrollTop(callback) {
    return this.emitter.on('did-change-scroll-top', callback);
  }
  // Deprecated: get the width of an `x` character displayed in this element.
  getDefaultCharacterWidth() {
    return this.getComponent().getBaseCharacterWidth();
  }
  getBaseCharacterWidth() {
    return this.getComponent().getBaseCharacterWidth();
  }
  getMaxScrollTop() {
    return this.getComponent().getMaxScrollTop();
  }
  getScrollHeight() {
    return this.getComponent().getScrollHeight();
  }
  getScrollWidth() {
    return this.getComponent().getScrollWidth();
  }
  getVerticalScrollbarWidth() {
    return this.getComponent().getVerticalScrollbarWidth();
  }
  getHorizontalScrollbarHeight() {
    return this.getComponent().getHorizontalScrollbarHeight();
  }
  getScrollTop() {
    return this.getComponent().getScrollTop();
  }
  setScrollTop(scrollTop) {
    const component = this.getComponent();
    component.setScrollTop(scrollTop);
    component.scheduleUpdate();
  }
  getScrollBottom() {
    return this.getComponent().getScrollBottom();
  }
  setScrollBottom(scrollBottom) {
    return this.getComponent().setScrollBottom(scrollBottom);
  }
  getScrollLeft() {
    return this.getComponent().getScrollLeft();
  }
  setScrollLeft(scrollLeft) {
    const component = this.getComponent();
    component.setScrollLeft(scrollLeft);
    component.scheduleUpdate();
  }
  getScrollRight() {
    return this.getComponent().getScrollRight();
  }
  setScrollRight(scrollRight) {
    return this.getComponent().setScrollRight(scrollRight);
  }
  scrollToTop() {
    this.setScrollTop(0);
  }
  scrollToBottom() {
    this.setScrollTop(Infinity);
  }
  hasFocus() {
    return this.getComponent().focused;
  }
  pixelPositionForBufferPosition(bufferPosition) {
    const screenPosition = this.getModel().screenPositionForBufferPosition(
      bufferPosition
    );
    return this.getComponent().pixelPositionForScreenPosition(screenPosition);
  }
  pixelPositionForScreenPosition(screenPosition) {
    screenPosition = this.getModel().clipScreenPosition(screenPosition);
    return this.getComponent().pixelPositionForScreenPosition(screenPosition);
  }
  screenPositionForPixelPosition(pixelPosition) {
    return this.getComponent().screenPositionForPixelPosition(pixelPosition);
  }
  pixelRectForScreenRange(range) {
    range = Range.fromObject(range);
    const start = this.pixelPositionForScreenPosition(range.start);
    const end = this.pixelPositionForScreenPosition(range.end);
    const lineHeight = this.getComponent().getLineHeight();
    return {
      top: start.top,
      left: start.left,
      height: end.top + lineHeight - start.top,
      width: end.left - start.left
    };
  }
  pixelRangeForScreenRange(range) {
    range = Range.fromObject(range);
    return {
      start: this.pixelPositionForScreenPosition(range.start),
      end: this.pixelPositionForScreenPosition(range.end)
    };
  }
  getComponent() {
    if (!this.component) {
      this.component = new TextEditorComponent({
        element: this,
        mini: this.hasAttribute('mini'),
        updatedSynchronously: this.updatedSynchronously,
        readOnly: this.hasAttribute('readonly')
      });
      this.updateModelFromAttributes();
    }
    return this.component;
  }
  setUpdatedSynchronously(updatedSynchronously) {
    this.updatedSynchronously = updatedSynchronously;
    if (this.component)
      this.component.updatedSynchronously = updatedSynchronously;
    return updatedSynchronously;
  }
  isUpdatedSynchronously() {
    return this.component
      ? this.component.updatedSynchronously
      : this.updatedSynchronously;
  }
  invalidateBlockDecorationDimensions() {
    this.getComponent().invalidateBlockDecorationDimensions(...arguments);
  }
  setFirstVisibleScreenRow(row) {
    this.getModel().setFirstVisibleScreenRow(row);
  }
  getFirstVisibleScreenRow() {
    return this.getModel().getFirstVisibleScreenRow();
  }
  getLastVisibleScreenRow() {
    return this.getModel().getLastVisibleScreenRow();
  }
  getVisibleRowRange() {
    return this.getModel().getVisibleRowRange();
  }
  intersectsVisibleRowRange(startRow, endRow) {
    return !(
      endRow <= this.getFirstVisibleScreenRow() ||
      this.getLastVisibleScreenRow() <= startRow
    );
  }
  selectionIntersectsVisibleRowRange(selection) {
    const { start, end } = selection.getScreenRange();
    return this.intersectsVisibleRowRange(start.row, end.row + 1);
  }
  setFirstVisibleScreenColumn(column) {
    return this.getModel().setFirstVisibleScreenColumn(column);
  }
  getFirstVisibleScreenColumn() {
    return this.getModel().getFirstVisibleScreenColumn();
  }
  static createTextEditorElement() {
    return document.createElement('atom-text-editor');
  }
}
window.customElements.define('atom-text-editor', TextEditorElement);
module.exports = TextEditorElement;

================
File: src/text-editor-registry.js
================
const _ = require('underscore-plus');
const { Emitter, Disposable, CompositeDisposable } = require('event-kit');
const TextEditor = require('./text-editor');
const ScopeDescriptor = require('./scope-descriptor');
const EDITOR_PARAMS_BY_SETTING_KEY = [
  ['core.fileEncoding', 'encoding'],
  ['editor.atomicSoftTabs', 'atomicSoftTabs'],
  ['editor.showInvisibles', 'showInvisibles'],
  ['editor.tabLength', 'tabLength'],
  ['editor.invisibles', 'invisibles'],
  ['editor.showCursorOnSelection', 'showCursorOnSelection'],
  ['editor.showIndentGuide', 'showIndentGuide'],
  ['editor.showLineNumbers', 'showLineNumbers'],
  ['editor.softWrap', 'softWrapped'],
  ['editor.softWrapHangingIndent', 'softWrapHangingIndentLength'],
  ['editor.softWrapAtPreferredLineLength', 'softWrapAtPreferredLineLength'],
  ['editor.preferredLineLength', 'preferredLineLength'],
  ['editor.maxScreenLineLength', 'maxScreenLineLength'],
  ['editor.autoIndent', 'autoIndent'],
  ['editor.autoIndentOnPaste', 'autoIndentOnPaste'],
  ['editor.scrollPastEnd', 'scrollPastEnd'],
  ['editor.undoGroupingInterval', 'undoGroupingInterval'],
  ['editor.scrollSensitivity', 'scrollSensitivity']
];
module.exports = class TextEditorRegistry {
  constructor({ config, assert, packageManager }) {
    this.config = config;
    this.assert = assert;
    this.packageManager = packageManager;
    this.clear();
  }
  deserialize(state) {
    this.editorGrammarOverrides = state.editorGrammarOverrides;
  }
  serialize() {
    return {
      editorGrammarOverrides: Object.assign({}, this.editorGrammarOverrides)
    };
  }
  clear() {
    if (this.subscriptions) {
      this.subscriptions.dispose();
    }
    this.subscriptions = new CompositeDisposable();
    this.editors = new Set();
    this.emitter = new Emitter();
    this.scopesWithConfigSubscriptions = new Set();
    this.editorsWithMaintainedConfig = new Set();
    this.editorsWithMaintainedGrammar = new Set();
    this.editorGrammarOverrides = {};
    this.editorGrammarScores = new WeakMap();
  }
  destroy() {
    this.subscriptions.dispose();
    this.editorsWithMaintainedConfig = null;
  }
  add(editor) {
    this.editors.add(editor);
    editor.registered = true;
    this.emitter.emit('did-add-editor', editor);
    return new Disposable(() => this.remove(editor));
  }
  build(params) {
    params = Object.assign({ assert: this.assert }, params);
    let scope = null;
    if (params.buffer) {
      const { grammar } = params.buffer.getLanguageMode();
      if (grammar) {
        scope = new ScopeDescriptor({ scopes: [grammar.scopeName] });
      }
    }
    Object.assign(params, this.textEditorParamsForScope(scope));
    return new TextEditor(params);
  }
  remove(editor) {
    const removed = this.editors.delete(editor);
    editor.registered = false;
    return removed;
  }
  getActiveTextEditor() {
    for (let ed of this.editors) {
      if (ed.getElement() === document.activeElement) {
        return ed;
      } else {
        let editorElement = ed.getElement();
        let current = document.activeElement;
        while (current) {
          if (current === editorElement) {
            return ed;
          }
          current = current.parentNode;
        }
      }
    }
    return null;
  }
  observe(callback) {
    this.editors.forEach(callback);
    return this.emitter.on('did-add-editor', callback);
  }
  maintainConfig(editor) {
    if (this.editorsWithMaintainedConfig.has(editor)) {
      return new Disposable(noop);
    }
    this.editorsWithMaintainedConfig.add(editor);
    this.updateAndMonitorEditorSettings(editor);
    const languageChangeSubscription = editor.buffer.onDidChangeLanguageMode(
      (newLanguageMode, oldLanguageMode) => {
        this.updateAndMonitorEditorSettings(editor, oldLanguageMode);
      }
    );
    this.subscriptions.add(languageChangeSubscription);
    const updateTabTypes = () => {
      const configOptions = { scope: editor.getRootScopeDescriptor() };
      editor.setSoftTabs(
        shouldEditorUseSoftTabs(
          editor,
          this.config.get('editor.tabType', configOptions),
          this.config.get('editor.softTabs', configOptions)
        )
      );
    };
    updateTabTypes();
    const tokenizeSubscription = editor.onDidTokenize(updateTabTypes);
    this.subscriptions.add(tokenizeSubscription);
    return new Disposable(() => {
      this.editorsWithMaintainedConfig.delete(editor);
      tokenizeSubscription.dispose();
      languageChangeSubscription.dispose();
      this.subscriptions.remove(languageChangeSubscription);
      this.subscriptions.remove(tokenizeSubscription);
    });
  }
  maintainGrammar(editor) {
    atom.grammars.maintainLanguageMode(editor.getBuffer());
  }
  setGrammarOverride(editor, languageId) {
    atom.grammars.assignLanguageMode(editor.getBuffer(), languageId);
  }
  getGrammarOverride(editor) {
    return atom.grammars.getAssignedLanguageId(editor.getBuffer());
  }
  clearGrammarOverride(editor) {
    atom.grammars.autoAssignLanguageMode(editor.getBuffer());
  }
  async updateAndMonitorEditorSettings(editor, oldLanguageMode) {
    await this.packageManager.getActivatePromise();
    this.updateEditorSettingsForLanguageMode(editor, oldLanguageMode);
    this.subscribeToSettingsForEditorScope(editor);
  }
  updateEditorSettingsForLanguageMode(editor, oldLanguageMode) {
    const newLanguageMode = editor.buffer.getLanguageMode();
    if (oldLanguageMode) {
      const newSettings = this.textEditorParamsForScope(
        newLanguageMode.rootScopeDescriptor
      );
      const oldSettings = this.textEditorParamsForScope(
        oldLanguageMode.rootScopeDescriptor
      );
      const updatedSettings = {};
      for (const [, paramName] of EDITOR_PARAMS_BY_SETTING_KEY) {
        if (!_.isEqual(newSettings[paramName], oldSettings[paramName])) {
          updatedSettings[paramName] = newSettings[paramName];
        }
      }
      if (_.size(updatedSettings) > 0) {
        editor.update(updatedSettings);
      }
    } else {
      editor.update(
        this.textEditorParamsForScope(newLanguageMode.rootScopeDescriptor)
      );
    }
  }
  subscribeToSettingsForEditorScope(editor) {
    if (!this.editorsWithMaintainedConfig) return;
    const scopeDescriptor = editor.getRootScopeDescriptor();
    const scopeChain = scopeDescriptor.getScopeChain();
    if (!this.scopesWithConfigSubscriptions.has(scopeChain)) {
      this.scopesWithConfigSubscriptions.add(scopeChain);
      const configOptions = { scope: scopeDescriptor };
      for (const [settingKey, paramName] of EDITOR_PARAMS_BY_SETTING_KEY) {
        this.subscriptions.add(
          this.config.onDidChange(settingKey, configOptions, ({ newValue }) => {
            this.editorsWithMaintainedConfig.forEach(editor => {
              if (editor.getRootScopeDescriptor().isEqual(scopeDescriptor)) {
                editor.update({ [paramName]: newValue });
              }
            });
          })
        );
      }
      const updateTabTypes = () => {
        const tabType = this.config.get('editor.tabType', configOptions);
        const softTabs = this.config.get('editor.softTabs', configOptions);
        this.editorsWithMaintainedConfig.forEach(editor => {
          if (editor.getRootScopeDescriptor().isEqual(scopeDescriptor)) {
            editor.setSoftTabs(
              shouldEditorUseSoftTabs(editor, tabType, softTabs)
            );
          }
        });
      };
      this.subscriptions.add(
        this.config.onDidChange(
          'editor.tabType',
          configOptions,
          updateTabTypes
        ),
        this.config.onDidChange(
          'editor.softTabs',
          configOptions,
          updateTabTypes
        )
      );
    }
  }
  textEditorParamsForScope(scopeDescriptor) {
    const result = {};
    const configOptions = { scope: scopeDescriptor };
    for (const [settingKey, paramName] of EDITOR_PARAMS_BY_SETTING_KEY) {
      result[paramName] = this.config.get(settingKey, configOptions);
    }
    return result;
  }
};
function shouldEditorUseSoftTabs(editor, tabType, softTabs) {
  switch (tabType) {
    case 'hard':
      return false;
    case 'soft':
      return true;
    case 'auto':
      switch (editor.usesSoftTabs()) {
        case true:
          return true;
        case false:
          return false;
        default:
          return softTabs;
      }
  }
}
function noop() {}

================
File: src/text-editor.js
================
const _ = require('underscore-plus');
const path = require('path');
const fs = require('fs-plus');
const Grim = require('grim');
const dedent = require('dedent');
const { CompositeDisposable, Disposable, Emitter } = require('event-kit');
const TextBuffer = require('text-buffer');
const { Point, Range } = TextBuffer;
const DecorationManager = require('./decoration-manager');
const Cursor = require('./cursor');
const Selection = require('./selection');
const NullGrammar = require('./null-grammar');
const TextMateLanguageMode = require('./text-mate-language-mode');
const ScopeDescriptor = require('./scope-descriptor');
const TextMateScopeSelector = require('second-mate').ScopeSelector;
const GutterContainer = require('./gutter-container');
let TextEditorComponent = null;
let TextEditorElement = null;
const {
  isDoubleWidthCharacter,
  isHalfWidthCharacter,
  isKoreanCharacter,
  isWrapBoundary
} = require('./text-utils');
const SERIALIZATION_VERSION = 1;
const NON_WHITESPACE_REGEXP = /\S/;
const ZERO_WIDTH_NBSP = '\ufeff';
let nextId = 0;
const DEFAULT_NON_WORD_CHARACTERS = '/\\()"\':,.;<>~!@#$%^&*|+=[]{}`?-…';
module.exports = class TextEditor {
  static setClipboard(clipboard) {
    this.clipboard = clipboard;
  }
  static setScheduler(scheduler) {
    if (TextEditorComponent == null) {
      TextEditorComponent = require('./text-editor-component');
    }
    return TextEditorComponent.setScheduler(scheduler);
  }
  static didUpdateStyles() {
    if (TextEditorComponent == null) {
      TextEditorComponent = require('./text-editor-component');
    }
    return TextEditorComponent.didUpdateStyles();
  }
  static didUpdateScrollbarStyles() {
    if (TextEditorComponent == null) {
      TextEditorComponent = require('./text-editor-component');
    }
    return TextEditorComponent.didUpdateScrollbarStyles();
  }
  static viewForItem(item) {
    return item.element || item;
  }
  static deserialize(state, atomEnvironment) {
    if (state.version !== SERIALIZATION_VERSION) return null;
    let bufferId = state.tokenizedBuffer
      ? state.tokenizedBuffer.bufferId
      : state.bufferId;
    try {
      state.buffer = atomEnvironment.project.bufferForIdSync(bufferId);
      if (!state.buffer) return null;
    } catch (error) {
      if (error.syscall === 'read') {
        return;
      } else {
        throw error;
      }
    }
    state.assert = atomEnvironment.assert.bind(atomEnvironment);
    delete state.readOnly;
    state.readOnly = state.readOnly2;
    delete state.readOnly2;
    const editor = new TextEditor(state);
    if (state.registered) {
      const disposable = atomEnvironment.textEditors.add(editor);
      editor.onDidDestroy(() => disposable.dispose());
    }
    return editor;
  }
  constructor(params = {}) {
    if (this.constructor.clipboard == null) {
      throw new Error(
        'Must call TextEditor.setClipboard at least once before creating TextEditor instances'
      );
    }
    this.id = params.id != null ? params.id : nextId++;
    if (this.id >= nextId) {
      nextId = this.id + 1;
    }
    this.initialScrollTopRow = params.initialScrollTopRow;
    this.initialScrollLeftColumn = params.initialScrollLeftColumn;
    this.decorationManager = params.decorationManager;
    this.selectionsMarkerLayer = params.selectionsMarkerLayer;
    this.mini = params.mini != null ? params.mini : false;
    this.keyboardInputEnabled =
      params.keyboardInputEnabled != null ? params.keyboardInputEnabled : true;
    this.readOnly = params.readOnly != null ? params.readOnly : false;
    this.placeholderText = params.placeholderText;
    this.showLineNumbers = params.showLineNumbers;
    this.assert = params.assert || (condition => condition);
    this.showInvisibles =
      params.showInvisibles != null ? params.showInvisibles : true;
    this.autoHeight = params.autoHeight;
    this.autoWidth = params.autoWidth;
    this.scrollPastEnd =
      params.scrollPastEnd != null ? params.scrollPastEnd : false;
    this.scrollSensitivity =
      params.scrollSensitivity != null ? params.scrollSensitivity : 40;
    this.editorWidthInChars = params.editorWidthInChars;
    this.invisibles = params.invisibles;
    this.showIndentGuide = params.showIndentGuide;
    this.softWrapped = params.softWrapped;
    this.softWrapAtPreferredLineLength = params.softWrapAtPreferredLineLength;
    this.preferredLineLength = params.preferredLineLength;
    this.showCursorOnSelection =
      params.showCursorOnSelection != null
        ? params.showCursorOnSelection
        : true;
    this.maxScreenLineLength = params.maxScreenLineLength;
    this.softTabs = params.softTabs != null ? params.softTabs : true;
    this.autoIndent = params.autoIndent != null ? params.autoIndent : true;
    this.autoIndentOnPaste =
      params.autoIndentOnPaste != null ? params.autoIndentOnPaste : true;
    this.undoGroupingInterval =
      params.undoGroupingInterval != null ? params.undoGroupingInterval : 300;
    this.softWrapped = params.softWrapped != null ? params.softWrapped : false;
    this.softWrapAtPreferredLineLength =
      params.softWrapAtPreferredLineLength != null
        ? params.softWrapAtPreferredLineLength
        : false;
    this.preferredLineLength =
      params.preferredLineLength != null ? params.preferredLineLength : 80;
    this.maxScreenLineLength =
      params.maxScreenLineLength != null ? params.maxScreenLineLength : 500;
    this.showLineNumbers =
      params.showLineNumbers != null ? params.showLineNumbers : true;
    const { tabLength = 2 } = params;
    this.alive = true;
    this.doBackgroundWork = this.doBackgroundWork.bind(this);
    this.serializationVersion = 1;
    this.suppressSelectionMerging = false;
    this.selectionFlashDuration = 500;
    this.gutterContainer = null;
    this.verticalScrollMargin = 2;
    this.horizontalScrollMargin = 6;
    this.lineHeightInPixels = null;
    this.defaultCharWidth = null;
    this.height = null;
    this.width = null;
    this.registered = false;
    this.atomicSoftTabs = true;
    this.emitter = new Emitter();
    this.disposables = new CompositeDisposable();
    this.cursors = [];
    this.cursorsByMarkerId = new Map();
    this.selections = [];
    this.hasTerminatedPendingState = false;
    if (params.buffer) {
      this.buffer = params.buffer;
    } else {
      this.buffer = new TextBuffer({
        shouldDestroyOnFileDelete() {
          return atom.config.get('core.closeDeletedFileTabs');
        }
      });
      this.buffer.setLanguageMode(
        new TextMateLanguageMode({ buffer: this.buffer, config: atom.config })
      );
    }
    const languageMode = this.buffer.getLanguageMode();
    this.languageModeSubscription =
      languageMode.onDidTokenize &&
      languageMode.onDidTokenize(() => {
        this.emitter.emit('did-tokenize');
      });
    if (this.languageModeSubscription)
      this.disposables.add(this.languageModeSubscription);
    if (params.displayLayer) {
      this.displayLayer = params.displayLayer;
    } else {
      const displayLayerParams = {
        invisibles: this.getInvisibles(),
        softWrapColumn: this.getSoftWrapColumn(),
        showIndentGuides: this.doesShowIndentGuide(),
        atomicSoftTabs:
          params.atomicSoftTabs != null ? params.atomicSoftTabs : true,
        tabLength,
        ratioForCharacter: this.ratioForCharacter.bind(this),
        isWrapBoundary,
        foldCharacter: ZERO_WIDTH_NBSP,
        softWrapHangingIndent:
          params.softWrapHangingIndentLength != null
            ? params.softWrapHangingIndentLength
            : 0
      };
      this.displayLayer = this.buffer.getDisplayLayer(params.displayLayerId);
      if (this.displayLayer) {
        this.displayLayer.reset(displayLayerParams);
        this.selectionsMarkerLayer = this.displayLayer.getMarkerLayer(
          params.selectionsMarkerLayerId
        );
      } else {
        this.displayLayer = this.buffer.addDisplayLayer(displayLayerParams);
      }
    }
    this.backgroundWorkHandle = requestIdleCallback(this.doBackgroundWork);
    this.disposables.add(
      new Disposable(() => {
        if (this.backgroundWorkHandle != null)
          return cancelIdleCallback(this.backgroundWorkHandle);
      })
    );
    this.defaultMarkerLayer = this.displayLayer.addMarkerLayer();
    if (!this.selectionsMarkerLayer) {
      this.selectionsMarkerLayer = this.addMarkerLayer({
        maintainHistory: true,
        persistent: true,
        role: 'selections'
      });
    }
    this.decorationManager = new DecorationManager(this);
    this.decorateMarkerLayer(this.selectionsMarkerLayer, { type: 'cursor' });
    if (!this.isMini()) this.decorateCursorLine();
    this.decorateMarkerLayer(this.displayLayer.foldsMarkerLayer, {
      type: 'line-number',
      class: 'folded'
    });
    for (let marker of this.selectionsMarkerLayer.getMarkers()) {
      this.addSelection(marker);
    }
    this.subscribeToBuffer();
    this.subscribeToDisplayLayer();
    if (this.cursors.length === 0 && !params.suppressCursorCreation) {
      const initialLine = Math.max(parseInt(params.initialLine) || 0, 0);
      const initialColumn = Math.max(parseInt(params.initialColumn) || 0, 0);
      this.addCursorAtBufferPosition([initialLine, initialColumn]);
    }
    this.gutterContainer = new GutterContainer(this);
    this.lineNumberGutter = this.gutterContainer.addGutter({
      name: 'line-number',
      type: 'line-number',
      priority: 0,
      visible: params.lineNumberGutterVisible
    });
  }
  get element() {
    return this.getElement();
  }
  get editorElement() {
    Grim.deprecate(dedent`\
      \`TextEditor.prototype.editorElement\` has always been private, but now
      it is gone. Reading the \`editorElement\` property still returns a
      reference to the editor element but this field will be removed in a
      later version of Pulsar, so we recommend using the \`element\` property instead.\
    `);
    return this.getElement();
  }
  get displayBuffer() {
    Grim.deprecate(dedent`\
      \`TextEditor.prototype.displayBuffer\` has always been private, but now
      it is gone. Reading the \`displayBuffer\` property now returns a reference
      to the containing \`TextEditor\`, which now provides *some* of the API of
      the defunct \`DisplayBuffer\` class.\
    `);
    return this;
  }
  get languageMode() {
    return this.buffer.getLanguageMode();
  }
  get tokenizedBuffer() {
    return this.buffer.getLanguageMode();
  }
  get rowsPerPage() {
    return this.getRowsPerPage();
  }
  decorateCursorLine() {
    this.cursorLineDecorations = [
      this.decorateMarkerLayer(this.selectionsMarkerLayer, {
        type: 'line',
        class: 'cursor-line',
        onlyEmpty: true
      }),
      this.decorateMarkerLayer(this.selectionsMarkerLayer, {
        type: 'line-number',
        class: 'cursor-line'
      }),
      this.decorateMarkerLayer(this.selectionsMarkerLayer, {
        type: 'line-number',
        class: 'cursor-line-no-selection',
        onlyHead: true,
        onlyEmpty: true
      })
    ];
  }
  doBackgroundWork(deadline) {
    const previousLongestRow = this.getApproximateLongestScreenRow();
    if (this.displayLayer.doBackgroundWork(deadline)) {
      this.backgroundWorkHandle = requestIdleCallback(this.doBackgroundWork);
    } else {
      this.backgroundWorkHandle = null;
    }
    if (
      this.component &&
      this.getApproximateLongestScreenRow() !== previousLongestRow
    ) {
      this.component.scheduleUpdate();
    }
  }
  update(params) {
    const displayLayerParams = {};
    for (let param of Object.keys(params)) {
      const value = params[param];
      switch (param) {
        case 'autoIndent':
          this.updateAutoIndent(value, false);
          break;
        case 'autoIndentOnPaste':
          this.updateAutoIndentOnPaste(value, false);
          break;
        case 'undoGroupingInterval':
          this.updateUndoGroupingInterval(value, false);
          break;
        case 'scrollSensitivity':
          this.updateScrollSensitivity(value, false);
          break;
        case 'encoding':
          this.updateEncoding(value, false);
          break;
        case 'softTabs':
          this.updateSoftTabs(value, false);
          break;
        case 'atomicSoftTabs':
          this.updateAtomicSoftTabs(value, false, displayLayerParams);
          break;
        case 'tabLength':
          this.updateTabLength(value, false, displayLayerParams);
          break;
        case 'softWrapped':
          this.updateSoftWrapped(value, false, displayLayerParams);
          break;
        case 'softWrapHangingIndentLength':
          this.updateSoftWrapHangingIndentLength(
            value,
            false,
            displayLayerParams
          );
          break;
        case 'softWrapAtPreferredLineLength':
          this.updateSoftWrapAtPreferredLineLength(
            value,
            false,
            displayLayerParams
          );
          break;
        case 'preferredLineLength':
          this.updatePreferredLineLength(value, false, displayLayerParams);
          break;
        case 'maxScreenLineLength':
          this.updateMaxScreenLineLength(value, false, displayLayerParams);
          break;
        case 'mini':
          this.updateMini(value, false, displayLayerParams);
          break;
        case 'readOnly':
          this.updateReadOnly(value, false);
          break;
        case 'keyboardInputEnabled':
          this.updateKeyboardInputEnabled(value, false);
          break;
        case 'placeholderText':
          this.updatePlaceholderText(value, false);
          break;
        case 'lineNumberGutterVisible':
          this.updateLineNumberGutterVisible(value, false);
          break;
        case 'showIndentGuide':
          this.updateShowIndentGuide(value, false, displayLayerParams);
          break;
        case 'showLineNumbers':
          this.updateShowLineNumbers(value, false);
          break;
        case 'showInvisibles':
          this.updateShowInvisibles(value, false, displayLayerParams);
          break;
        case 'invisibles':
          this.updateInvisibles(value, false, displayLayerParams);
          break;
        case 'editorWidthInChars':
          this.updateEditorWidthInChars(value, false, displayLayerParams);
          break;
        case 'width':
          this.updateWidth(value, false, displayLayerParams);
          break;
        case 'scrollPastEnd':
          this.updateScrollPastEnd(value, false);
          break;
        case 'autoHeight':
          this.updateAutoHight(value, false);
          break;
        case 'autoWidth':
          this.updateAutoWidth(value, false);
          break;
        case 'showCursorOnSelection':
          this.updateShowCursorOnSelection(value, false);
          break;
        default:
          if (param !== 'ref' && param !== 'key') {
            throw new TypeError(`Invalid TextEditor parameter: '${param}'`);
          }
      }
    }
    return this.finishUpdate(displayLayerParams);
  }
  finishUpdate(displayLayerParams = {}) {
    this.displayLayer.reset(displayLayerParams);
    if (this.component) {
      return this.component.getNextUpdatePromise();
    } else {
      return Promise.resolve();
    }
  }
  updateAutoIndent(value, finish) {
    this.autoIndent = value;
    if (finish) this.finishUpdate();
  }
  updateAutoIndentOnPaste(value, finish) {
    this.autoIndentOnPaste = value;
    if (finish) this.finishUpdate();
  }
  updateUndoGroupingInterval(value, finish) {
    this.undoGroupingInterval = value;
    if (finish) this.finishUpdate();
  }
  updateScrollSensitivity(value, finish) {
    this.scrollSensitivity = value;
    if (finish) this.finishUpdate();
  }
  updateEncoding(value, finish) {
    this.buffer.setEncoding(value);
    if (finish) this.finishUpdate();
  }
  updateSoftTabs(value, finish) {
    if (value !== this.softTabs) {
      this.softTabs = value;
    }
    if (finish) this.finishUpdate();
  }
  updateAtomicSoftTabs(value, finish, displayLayerParams = {}) {
    if (value !== this.displayLayer.atomicSoftTabs) {
      displayLayerParams.atomicSoftTabs = value;
    }
    if (finish) this.finishUpdate(displayLayerParams);
  }
  updateTabLength(value, finish, displayLayerParams = {}) {
    if (value > 0 && value !== this.displayLayer.tabLength) {
      displayLayerParams.tabLength = value;
    }
    if (finish) this.finishUpdate(displayLayerParams);
  }
  updateSoftWrapped(value, finish, displayLayerParams = {}) {
    if (value !== this.softWrapped) {
      this.softWrapped = value;
      displayLayerParams.softWrapColumn = this.getSoftWrapColumn();
      this.emitter.emit('did-change-soft-wrapped', this.isSoftWrapped());
    }
    if (finish) this.finishUpdate(displayLayerParams);
  }
  updateSoftWrapHangingIndentLength(value, finish, displayLayerParams = {}) {
    if (value !== this.displayLayer.softWrapHangingIndent) {
      displayLayerParams.softWrapHangingIndent = value;
    }
    if (finish) this.finishUpdate(displayLayerParams);
  }
  updateSoftWrapAtPreferredLineLength(value, finish, displayLayerParams = {}) {
    if (value !== this.softWrapAtPreferredLineLength) {
      this.softWrapAtPreferredLineLength = value;
      displayLayerParams.softWrapColumn = this.getSoftWrapColumn();
    }
    if (finish) this.finishUpdate(displayLayerParams);
  }
  updatePreferredLineLength(value, finish, displayLayerParams = {}) {
    if (value !== this.preferredLineLength) {
      this.preferredLineLength = value;
      displayLayerParams.softWrapColumn = this.getSoftWrapColumn();
    }
    if (finish) this.finishUpdate(displayLayerParams);
  }
  updateMaxScreenLineLength(value, finish, displayLayerParams = {}) {
    if (value !== this.maxScreenLineLength) {
      this.maxScreenLineLength = value;
      displayLayerParams.softWrapColumn = this.getSoftWrapColumn();
    }
    if (finish) this.finishUpdate(displayLayerParams);
  }
  updateMini(value, finish, displayLayerParams = {}) {
    if (value !== this.mini) {
      this.mini = value;
      this.emitter.emit('did-change-mini', value);
      displayLayerParams.invisibles = this.getInvisibles();
      displayLayerParams.softWrapColumn = this.getSoftWrapColumn();
      displayLayerParams.showIndentGuides = this.doesShowIndentGuide();
      if (this.mini) {
        for (let decoration of this.cursorLineDecorations) {
          decoration.destroy();
        }
        this.cursorLineDecorations = null;
      } else {
        this.decorateCursorLine();
      }
      if (this.component != null) {
        this.component.scheduleUpdate();
      }
    }
    if (finish) this.finishUpdate(displayLayerParams);
  }
  updateReadOnly(value, finish) {
    if (value !== this.readOnly) {
      this.readOnly = value;
      if (this.component != null) {
        this.component.scheduleUpdate();
      }
    }
    if (finish) this.finishUpdate();
  }
  updateKeyboardInputEnabled(value, finish) {
    if (value !== this.keyboardInputEnabled) {
      this.keyboardInputEnabled = value;
      if (this.component != null) {
        this.component.scheduleUpdate();
      }
    }
    if (finish) this.finishUpdate();
  }
  updatePlaceholderText(value, finish) {
    if (value !== this.placeholderText) {
      this.placeholderText = value;
      this.emitter.emit('did-change-placeholder-text', value);
    }
    if (finish) this.finishUpdate();
  }
  updateLineNumberGutterVisible(value, finish) {
    if (value !== this.lineNumberGutterVisible) {
      if (value) {
        this.lineNumberGutter.show();
      } else {
        this.lineNumberGutter.hide();
      }
      this.emitter.emit(
        'did-change-line-number-gutter-visible',
        this.lineNumberGutter.isVisible()
      );
    }
    if (finish) this.finishUpdate();
  }
  updateShowIndentGuide(value, finish, displayLayerParams = {}) {
    if (value !== this.showIndentGuide) {
      this.showIndentGuide = value;
      displayLayerParams.showIndentGuides = this.doesShowIndentGuide();
    }
    if (finish) this.finishUpdate(displayLayerParams);
  }
  updateShowLineNumbers(value, finish) {
    if (value !== this.showLineNumbers) {
      this.showLineNumbers = value;
      if (this.component != null) {
        this.component.scheduleUpdate();
      }
    }
    if (finish) this.finishUpdate();
  }
  updateShowInvisibles(value, finish, displayLayerParams = {}) {
    if (value !== this.showInvisibles) {
      this.showInvisibles = value;
      displayLayerParams.invisibles = this.getInvisibles();
    }
    if (finish) this.finishUpdate(displayLayerParams);
  }
  updateInvisibles(value, finish, displayLayerParams = {}) {
    if (!_.isEqual(value, this.invisibles)) {
      this.invisibles = value;
      displayLayerParams.invisibles = this.getInvisibles();
    }
    if (finish) this.finishUpdate(displayLayerParams);
  }
  updateEditorWidthInChars(value, finish, displayLayerParams = {}) {
    if (value > 0 && value !== this.editorWidthInChars) {
      this.editorWidthInChars = value;
      displayLayerParams.softWrapColumn = this.getSoftWrapColumn();
    }
    if (finish) this.finishUpdate(displayLayerParams);
  }
  updateWidth(value, finish, displayLayerParams = {}) {
    if (value !== this.width) {
      this.width = value;
      displayLayerParams.softWrapColumn = this.getSoftWrapColumn();
    }
    if (finish) this.finishUpdate(displayLayerParams);
  }
  updateScrollPastEnd(value, finish) {
    if (value !== this.scrollPastEnd) {
      this.scrollPastEnd = value;
      if (this.component) this.component.scheduleUpdate();
    }
    if (finish) this.finishUpdate();
  }
  updateAutoHight(value, finish) {
    if (value !== this.autoHeight) {
      this.autoHeight = value;
    }
    if (finish) this.finishUpdate();
  }
  updateAutoWidth(value, finish) {
    if (value !== this.autoWidth) {
      this.autoWidth = value;
    }
    if (finish) this.finishUpdate();
  }
  updateShowCursorOnSelection(value, finish) {
    if (value !== this.showCursorOnSelection) {
      this.showCursorOnSelection = value;
      if (this.component) this.component.scheduleUpdate();
    }
    if (finish) this.finishUpdate();
  }
  scheduleComponentUpdate() {
    if (this.component) this.component.scheduleUpdate();
  }
  serialize() {
    return {
      deserializer: 'TextEditor',
      version: SERIALIZATION_VERSION,
      displayLayerId: this.displayLayer.id,
      selectionsMarkerLayerId: this.selectionsMarkerLayer.id,
      initialScrollTopRow: this.getScrollTopRow(),
      initialScrollLeftColumn: this.getScrollLeftColumn(),
      tabLength: this.displayLayer.tabLength,
      atomicSoftTabs: this.displayLayer.atomicSoftTabs,
      softWrapHangingIndentLength: this.displayLayer.softWrapHangingIndent,
      id: this.id,
      bufferId: this.buffer.id,
      softTabs: this.softTabs,
      softWrapped: this.softWrapped,
      softWrapAtPreferredLineLength: this.softWrapAtPreferredLineLength,
      preferredLineLength: this.preferredLineLength,
      mini: this.mini,
      readOnly2: this.readOnly, // readOnly encompassed both readOnly and keyboardInputEnabled
      keyboardInputEnabled: this.keyboardInputEnabled,
      editorWidthInChars: this.editorWidthInChars,
      width: this.width,
      maxScreenLineLength: this.maxScreenLineLength,
      registered: this.registered,
      invisibles: this.invisibles,
      showInvisibles: this.showInvisibles,
      showIndentGuide: this.showIndentGuide,
      autoHeight: this.autoHeight,
      autoWidth: this.autoWidth
    };
  }
  subscribeToBuffer() {
    this.buffer.retain();
    this.disposables.add(
      this.buffer.onDidChangeLanguageMode(
        this.handleLanguageModeChange.bind(this)
      )
    );
    this.disposables.add(
      this.buffer.onDidChangePath(() => {
        this.emitter.emit('did-change-title', this.getTitle());
        this.emitter.emit('did-change-path', this.getPath());
      })
    );
    this.disposables.add(
      this.buffer.onDidChangeEncoding(() => {
        this.emitter.emit('did-change-encoding', this.getEncoding());
      })
    );
    this.disposables.add(this.buffer.onDidDestroy(() => this.destroy()));
    this.disposables.add(
      this.buffer.onDidChangeModified(() => {
        if (!this.hasTerminatedPendingState && this.buffer.isModified())
          this.terminatePendingState();
      })
    );
  }
  terminatePendingState() {
    if (!this.hasTerminatedPendingState)
      this.emitter.emit('did-terminate-pending-state');
    this.hasTerminatedPendingState = true;
  }
  onDidTerminatePendingState(callback) {
    return this.emitter.on('did-terminate-pending-state', callback);
  }
  subscribeToDisplayLayer() {
    this.disposables.add(
      this.displayLayer.onDidChange(changes => {
        this.mergeIntersectingSelections();
        if (this.component) this.component.didChangeDisplayLayer(changes);
        this.emitter.emit(
          'did-change',
          changes.map(change => new ChangeEvent(change))
        );
      })
    );
    this.disposables.add(
      this.displayLayer.onDidReset(() => {
        this.mergeIntersectingSelections();
        if (this.component) this.component.didResetDisplayLayer();
        this.emitter.emit('did-change', {});
      })
    );
    this.disposables.add(
      this.selectionsMarkerLayer.onDidCreateMarker(this.addSelection.bind(this))
    );
    return this.disposables.add(
      this.selectionsMarkerLayer.onDidUpdate(() =>
        this.component != null
          ? this.component.didUpdateSelections()
          : undefined
      )
    );
  }
  destroy() {
    if (!this.alive) return;
    this.alive = false;
    this.disposables.dispose();
    this.displayLayer.destroy();
    for (let selection of this.selections.slice()) {
      selection.destroy();
    }
    this.buffer.release();
    this.gutterContainer.destroy();
    this.emitter.emit('did-destroy');
    this.emitter.clear();
    if (this.component) this.component.element.component = null;
    this.component = null;
    this.lineNumberGutter.element = null;
  }
  isAlive() {
    return this.alive;
  }
  isDestroyed() {
    return !this.alive;
  }
  /*
  Section: Event Subscription
  */
  // Essential: Calls your `callback` when the buffer's title has changed.
  onDidChangeTitle(callback) {
    return this.emitter.on('did-change-title', callback);
  }
  onDidChangePath(callback) {
    return this.emitter.on('did-change-path', callback);
  }
  onDidChange(callback) {
    return this.emitter.on('did-change', callback);
  }
  onDidStopChanging(callback) {
    return this.getBuffer().onDidStopChanging(callback);
  }
  onDidChangeCursorPosition(callback) {
    return this.emitter.on('did-change-cursor-position', callback);
  }
  onDidChangeSelectionRange(callback) {
    return this.emitter.on('did-change-selection-range', callback);
  }
  onDidChangeSoftWrapped(callback) {
    return this.emitter.on('did-change-soft-wrapped', callback);
  }
  onDidChangeEncoding(callback) {
    return this.emitter.on('did-change-encoding', callback);
  }
  observeGrammar(callback) {
    callback(this.getGrammar());
    return this.onDidChangeGrammar(callback);
  }
  onDidChangeGrammar(callback) {
    return this.buffer.onDidChangeLanguageMode(() => {
      callback(this.buffer.getLanguageMode().grammar);
    });
  }
  onDidChangeModified(callback) {
    return this.getBuffer().onDidChangeModified(callback);
  }
  onDidConflict(callback) {
    return this.getBuffer().onDidConflict(callback);
  }
  onWillInsertText(callback) {
    return this.emitter.on('will-insert-text', callback);
  }
  onDidInsertText(callback) {
    return this.emitter.on('did-insert-text', callback);
  }
  onDidSave(callback) {
    return this.getBuffer().onDidSave(callback);
  }
  onDidDestroy(callback) {
    return this.emitter.once('did-destroy', callback);
  }
  observeCursors(callback) {
    this.getCursors().forEach(callback);
    return this.onDidAddCursor(callback);
  }
  onDidAddCursor(callback) {
    return this.emitter.on('did-add-cursor', callback);
  }
  onDidRemoveCursor(callback) {
    return this.emitter.on('did-remove-cursor', callback);
  }
  observeSelections(callback) {
    this.getSelections().forEach(callback);
    return this.onDidAddSelection(callback);
  }
  onDidAddSelection(callback) {
    return this.emitter.on('did-add-selection', callback);
  }
  onDidRemoveSelection(callback) {
    return this.emitter.on('did-remove-selection', callback);
  }
  observeDecorations(callback) {
    return this.decorationManager.observeDecorations(callback);
  }
  onDidAddDecoration(callback) {
    return this.decorationManager.onDidAddDecoration(callback);
  }
  onDidRemoveDecoration(callback) {
    return this.decorationManager.onDidRemoveDecoration(callback);
  }
  didAddDecoration(decoration) {
    if (this.component && decoration.isType('block')) {
      this.component.addBlockDecoration(decoration);
    }
  }
  onDidChangePlaceholderText(callback) {
    return this.emitter.on('did-change-placeholder-text', callback);
  }
  onDidChangeScrollTop(callback) {
    Grim.deprecate(
      'This is now a view method. Call TextEditorElement::onDidChangeScrollTop instead.'
    );
    return this.getElement().onDidChangeScrollTop(callback);
  }
  onDidChangeScrollLeft(callback) {
    Grim.deprecate(
      'This is now a view method. Call TextEditorElement::onDidChangeScrollLeft instead.'
    );
    return this.getElement().onDidChangeScrollLeft(callback);
  }
  onDidRequestAutoscroll(callback) {
    return this.emitter.on('did-request-autoscroll', callback);
  }
  onDidChangeIcon(callback) {
    return this.emitter.on('did-change-icon', callback);
  }
  onDidUpdateDecorations(callback) {
    return this.decorationManager.onDidUpdateDecorations(callback);
  }
  getURI() {
    return this.buffer.getUri();
  }
  copy() {
    const displayLayer = this.displayLayer.copy();
    const selectionsMarkerLayer = displayLayer.getMarkerLayer(
      this.buffer.getMarkerLayer(this.selectionsMarkerLayer.id).copy().id
    );
    const softTabs = this.getSoftTabs();
    return new TextEditor({
      buffer: this.buffer,
      selectionsMarkerLayer,
      softTabs,
      suppressCursorCreation: true,
      tabLength: this.getTabLength(),
      initialScrollTopRow: this.getScrollTopRow(),
      initialScrollLeftColumn: this.getScrollLeftColumn(),
      assert: this.assert,
      displayLayer,
      grammar: this.getGrammar(),
      autoWidth: this.autoWidth,
      autoHeight: this.autoHeight,
      showCursorOnSelection: this.showCursorOnSelection
    });
  }
  setVisible(visible) {
    if (visible) {
      const languageMode = this.buffer.getLanguageMode();
      if (languageMode.startTokenizing) languageMode.startTokenizing();
    }
  }
  setMini(mini) {
    this.updateMini(mini, true);
  }
  isMini() {
    return this.mini;
  }
  setReadOnly(readOnly) {
    this.updateReadOnly(readOnly, true);
  }
  isReadOnly() {
    return this.readOnly;
  }
  enableKeyboardInput(enabled) {
    this.updateKeyboardInputEnabled(enabled, true);
  }
  isKeyboardInputEnabled() {
    return this.keyboardInputEnabled;
  }
  onDidChangeMini(callback) {
    return this.emitter.on('did-change-mini', callback);
  }
  setLineNumberGutterVisible(lineNumberGutterVisible) {
    this.updateLineNumberGutterVisible(lineNumberGutterVisible, true);
  }
  isLineNumberGutterVisible() {
    return this.lineNumberGutter.isVisible();
  }
  anyLineNumberGutterVisible() {
    return this.getGutters().some(
      gutter => gutter.type === 'line-number' && gutter.visible
    );
  }
  onDidChangeLineNumberGutterVisible(callback) {
    return this.emitter.on('did-change-line-number-gutter-visible', callback);
  }
  observeGutters(callback) {
    return this.gutterContainer.observeGutters(callback);
  }
  onDidAddGutter(callback) {
    return this.gutterContainer.onDidAddGutter(callback);
  }
  onDidRemoveGutter(callback) {
    return this.gutterContainer.onDidRemoveGutter(callback);
  }
  setEditorWidthInChars(editorWidthInChars) {
    this.updateEditorWidthInChars(editorWidthInChars, true);
  }
  getEditorWidthInChars() {
    if (this.width != null && this.defaultCharWidth > 0) {
      return Math.max(0, Math.floor(this.width / this.defaultCharWidth));
    } else {
      return this.editorWidthInChars;
    }
  }
  getBuffer() {
    return this.buffer;
  }
  getTitle() {
    return this.getFileName() || 'untitled';
  }
  getLongTitle() {
    if (this.getPath()) {
      const fileName = this.getFileName();
      let myPathSegments;
      const openEditorPathSegmentsWithSameFilename = [];
      for (const textEditor of atom.workspace.getTextEditors()) {
        if (textEditor.getFileName() === fileName) {
          const pathSegments = fs
            .tildify(textEditor.getDirectoryPath())
            .split(path.sep);
          openEditorPathSegmentsWithSameFilename.push(pathSegments);
          if (textEditor === this) myPathSegments = pathSegments;
        }
      }
      if (
        !myPathSegments ||
        openEditorPathSegmentsWithSameFilename.length === 1
      )
        return fileName;
      let commonPathSegmentCount;
      for (let i = 0, { length } = myPathSegments; i < length; i++) {
        const myPathSegment = myPathSegments[i];
        if (
          openEditorPathSegmentsWithSameFilename.some(
            segments =>
              segments.length === i + 1 || segments[i] !== myPathSegment
          )
        ) {
          commonPathSegmentCount = i;
          break;
        }
      }
      return `${fileName} \u2014 ${path.join(
        ...myPathSegments.slice(commonPathSegmentCount)
      )}`;
    } else {
      return 'untitled';
    }
  }
  getPath() {
    return this.buffer.getPath();
  }
  getFileName() {
    const fullPath = this.getPath();
    if (fullPath) return path.basename(fullPath);
  }
  getDirectoryPath() {
    const fullPath = this.getPath();
    if (fullPath) return path.dirname(fullPath);
  }
  getEncoding() {
    return this.buffer.getEncoding();
  }
  setEncoding(encoding) {
    this.buffer.setEncoding(encoding);
  }
  isModified() {
    return this.buffer.isModified();
  }
  isEmpty() {
    return this.buffer.isEmpty();
  }
  save() {
    return this.buffer.save();
  }
  saveAs(filePath) {
    return this.buffer.saveAs(filePath);
  }
  shouldPromptToSave({ windowCloseRequested, projectHasPaths } = {}) {
    if (
      windowCloseRequested &&
      projectHasPaths &&
      atom.stateStore.isConnected()
    ) {
      return this.buffer.isInConflict();
    } else {
      return this.isModified() && !this.buffer.hasMultipleEditors();
    }
  }
  getSaveDialogOptions() {
    return {};
  }
  getText() {
    return this.buffer.getText();
  }
  getTextInBufferRange(range) {
    return this.buffer.getTextInRange(range);
  }
  getLineCount() {
    return this.buffer.getLineCount();
  }
  getScreenLineCount() {
    return this.displayLayer.getScreenLineCount();
  }
  getApproximateScreenLineCount() {
    return this.displayLayer.getApproximateScreenLineCount();
  }
  getLastBufferRow() {
    return this.buffer.getLastRow();
  }
  getLastScreenRow() {
    return this.getScreenLineCount() - 1;
  }
  lineTextForBufferRow(bufferRow) {
    return this.buffer.lineForRow(bufferRow);
  }
  lineTextForScreenRow(screenRow) {
    const screenLine = this.screenLineForScreenRow(screenRow);
    if (screenLine) return screenLine.lineText;
  }
  logScreenLines(start = 0, end = this.getLastScreenRow()) {
    for (let row = start; row <= end; row++) {
      const line = this.lineTextForScreenRow(row);
      console.log(row, this.bufferRowForScreenRow(row), line, line.length);
    }
  }
  tokensForScreenRow(screenRow) {
    const tokens = [];
    let lineTextIndex = 0;
    const currentTokenScopes = [];
    const { lineText, tags } = this.screenLineForScreenRow(screenRow);
    for (const tag of tags) {
      if (this.displayLayer.isOpenTag(tag)) {
        currentTokenScopes.push(this.displayLayer.classNameForTag(tag));
      } else if (this.displayLayer.isCloseTag(tag)) {
        currentTokenScopes.pop();
      } else if (tag === 0) {
        continue;
      } else {
        tokens.push({
          text: lineText.substr(lineTextIndex, tag),
          scopes: currentTokenScopes.slice()
        });
        lineTextIndex += tag;
      }
    }
    return tokens;
  }
  screenLineForScreenRow(screenRow) {
    return this.displayLayer.getScreenLine(screenRow);
  }
  bufferRowForScreenRow(screenRow) {
    return this.displayLayer.translateScreenPosition(Point(screenRow, 0)).row;
  }
  bufferRowsForScreenRows(startScreenRow, endScreenRow) {
    return this.displayLayer.bufferRowsForScreenRows(
      startScreenRow,
      endScreenRow + 1
    );
  }
  screenRowForBufferRow(row) {
    return this.displayLayer.translateBufferPosition(Point(row, 0)).row;
  }
  getRightmostScreenPosition() {
    return this.displayLayer.getRightmostScreenPosition();
  }
  getApproximateRightmostScreenPosition() {
    return this.displayLayer.getApproximateRightmostScreenPosition();
  }
  getMaxScreenLineLength() {
    return this.getRightmostScreenPosition().column;
  }
  getLongestScreenRow() {
    return this.getRightmostScreenPosition().row;
  }
  getApproximateLongestScreenRow() {
    return this.getApproximateRightmostScreenPosition().row;
  }
  lineLengthForScreenRow(screenRow) {
    return this.displayLayer.lineLengthForScreenRow(screenRow);
  }
  bufferRangeForBufferRow(row, options) {
    return this.buffer.rangeForRow(row, options && options.includeNewline);
  }
  getTextInRange(range) {
    return this.buffer.getTextInRange(range);
  }
  isBufferRowBlank(bufferRow) {
    return this.buffer.isRowBlank(bufferRow);
  }
  nextNonBlankBufferRow(bufferRow) {
    return this.buffer.nextNonBlankRow(bufferRow);
  }
  getEofBufferPosition() {
    return this.buffer.getEndPosition();
  }
  getCurrentParagraphBufferRange() {
    return this.getLastCursor().getCurrentParagraphBufferRange();
  }
  setText(text, options = {}) {
    if (!this.ensureWritable('setText', options)) return;
    return this.buffer.setText(text);
  }
  setTextInBufferRange(range, text, options = {}) {
    if (!this.ensureWritable('setTextInBufferRange', options)) return;
    return this.getBuffer().setTextInRange(range, text, options);
  }
  insertText(text, options = {}) {
    if (!this.ensureWritable('insertText', options)) return;
    if (!this.emitWillInsertTextEvent(text)) return false;
    let groupLastChanges = false;
    if (options.undo === 'skip') {
      options = Object.assign({}, options);
      delete options.undo;
      groupLastChanges = true;
    }
    const groupingInterval = options.groupUndo ? this.undoGroupingInterval : 0;
    if (options.autoIndentNewline == null)
      options.autoIndentNewline = this.shouldAutoIndent();
    if (options.autoDecreaseIndent == null)
      options.autoDecreaseIndent = this.shouldAutoIndent();
    const result = this.mutateSelectedText(selection => {
      const range = selection.insertText(text, options);
      const didInsertEvent = { text, range };
      this.emitter.emit('did-insert-text', didInsertEvent);
      return range;
    }, groupingInterval);
    if (groupLastChanges) this.buffer.groupLastChanges();
    if (options.autoIndent || options.autoIndentNewline || options.autoDecreaseIndent) {
      this.scheduleIndentAdjustment();
    }
    return result;
  }
  insertNewline(options = {}) {
    return this.insertText('\n', options);
  }
  delete(options = {}) {
    if (!this.ensureWritable('delete', options)) return;
    return this.mutateSelectedText(selection => selection.delete(options));
  }
  backspace(options = {}) {
    if (!this.ensureWritable('backspace', options)) return;
    return this.mutateSelectedText(selection => selection.backspace(options));
  }
  mutateSelectedText(fn, groupingInterval = 0) {
    return this.mergeIntersectingSelections(() => {
      return this.transact(groupingInterval, () => {
        return this.getSelectionsOrderedByBufferPosition().map(
          (selection, index) => fn(selection, index)
        );
      });
    });
  }
  moveLineUp(options = {}) {
    if (!this.ensureWritable('moveLineUp', options)) return;
    const selections = this.getSelectedBufferRanges().sort((a, b) =>
      a.compare(b)
    );
    if (selections[0].start.row === 0) return;
    if (
      selections[selections.length - 1].start.row === this.getLastBufferRow() &&
      this.buffer.getLastLine() === ''
    )
      return;
    this.transact(() => {
      const newSelectionRanges = [];
      while (selections.length > 0) {
        // Find selections spanning a contiguous set of lines
        const selection = selections.shift();
        const selectionsToMove = [selection];
        while (
          selection.end.row ===
          (selections[0] != null ? selections[0].start.row : undefined)
        ) {
          selectionsToMove.push(selections[0]);
          selection.end.row = selections[0].end.row;
          selections.shift();
        }
        // Compute the buffer range spanned by all these selections, expanding it
        // so that it includes any folded region that intersects them.
        let startRow = selection.start.row;
        let endRow = selection.end.row;
        if (
          selection.end.row > selection.start.row &&
          selection.end.column === 0
        ) {
          // Don't move the last line of a multi-line selection if the selection ends at column 0
          endRow--;
        }
        startRow = this.displayLayer.findBoundaryPrecedingBufferRow(startRow);
        endRow = this.displayLayer.findBoundaryFollowingBufferRow(endRow + 1);
        const linesRange = new Range(Point(startRow, 0), Point(endRow, 0));
        const precedingRow = this.displayLayer.findBoundaryPrecedingBufferRow(
          startRow - 1
        );
        const insertDelta = linesRange.start.row - precedingRow;
        const rangesToRefold = this.displayLayer
          .destroyFoldsIntersectingBufferRange(linesRange)
          .map(range => range.translate([-insertDelta, 0]));
        let lines = this.buffer.getTextInRange(linesRange);
        if (lines[lines.length - 1] !== '\n') {
          lines += this.buffer.lineEndingForRow(linesRange.end.row - 2);
        }
        this.buffer.delete(linesRange);
        this.buffer.insert([precedingRow, 0], lines);
        for (let rangeToRefold of rangesToRefold) {
          this.displayLayer.foldBufferRange(rangeToRefold);
        }
        for (const selectionToMove of selectionsToMove) {
          newSelectionRanges.push(selectionToMove.translate([-insertDelta, 0]));
        }
      }
      this.setSelectedBufferRanges(newSelectionRanges, {
        autoscroll: false,
        preserveFolds: true
      });
      if (this.shouldAutoIndent()) this.autoIndentSelectedRows();
      this.scrollToBufferPosition([newSelectionRanges[0].start.row, 0]);
    });
  }
  moveLineDown(options = {}) {
    if (!this.ensureWritable('moveLineDown', options)) return;
    const selections = this.getSelectedBufferRanges();
    selections.sort((a, b) => b.compare(a));
    this.transact(() => {
      this.consolidateSelections();
      const newSelectionRanges = [];
      while (selections.length > 0) {
        const selection = selections.shift();
        const selectionsToMove = [selection];
        while (
          selection.start.row ===
          (selections[0] != null ? selections[0].end.row : undefined)
        ) {
          selectionsToMove.push(selections[0]);
          selection.start.row = selections[0].start.row;
          selections.shift();
        }
        let startRow = selection.start.row;
        let endRow = selection.end.row;
        if (
          selection.end.row > selection.start.row &&
          selection.end.column === 0
        ) {
          endRow--;
        }
        startRow = this.displayLayer.findBoundaryPrecedingBufferRow(startRow);
        endRow = this.displayLayer.findBoundaryFollowingBufferRow(endRow + 1);
        const linesRange = new Range(Point(startRow, 0), Point(endRow, 0));
        const followingRow = Math.min(
          this.buffer.getLineCount(),
          this.displayLayer.findBoundaryFollowingBufferRow(endRow + 1)
        );
        const insertDelta = followingRow - linesRange.end.row;
        const rangesToRefold = this.displayLayer
          .destroyFoldsIntersectingBufferRange(linesRange)
          .map(range => range.translate([insertDelta, 0]));
        let lines = this.buffer.getTextInRange(linesRange);
        if (followingRow - 1 === this.buffer.getLastRow()) {
          lines = `\n${lines}`;
        }
        this.buffer.insert([followingRow, 0], lines);
        this.buffer.delete(linesRange);
        for (let rangeToRefold of rangesToRefold) {
          this.displayLayer.foldBufferRange(rangeToRefold);
        }
        for (const selectionToMove of selectionsToMove) {
          newSelectionRanges.push(selectionToMove.translate([insertDelta, 0]));
        }
      }
      this.setSelectedBufferRanges(newSelectionRanges, {
        autoscroll: false,
        preserveFolds: true
      });
      if (this.shouldAutoIndent()) this.autoIndentSelectedRows();
      this.scrollToBufferPosition([newSelectionRanges[0].start.row - 1, 0]);
    });
  }
  moveSelectionLeft(options = {}) {
    if (!this.ensureWritable('moveSelectionLeft', options)) return;
    const selections = this.getSelectedBufferRanges();
    const noSelectionAtStartOfLine = selections.every(
      selection => selection.start.column !== 0
    );
    const translationDelta = [0, -1];
    const translatedRanges = [];
    if (noSelectionAtStartOfLine) {
      this.transact(() => {
        for (let selection of selections) {
          const charToLeftOfSelection = new Range(
            selection.start.translate(translationDelta),
            selection.start
          );
          const charTextToLeftOfSelection = this.buffer.getTextInRange(
            charToLeftOfSelection
          );
          this.buffer.insert(selection.end, charTextToLeftOfSelection);
          this.buffer.delete(charToLeftOfSelection);
          translatedRanges.push(selection.translate(translationDelta));
        }
        this.setSelectedBufferRanges(translatedRanges);
      });
    }
  }
  moveSelectionRight(options = {}) {
    if (!this.ensureWritable('moveSelectionRight', options)) return;
    const selections = this.getSelectedBufferRanges();
    const noSelectionAtEndOfLine = selections.every(selection => {
      return (
        selection.end.column !== this.buffer.lineLengthForRow(selection.end.row)
      );
    });
    const translationDelta = [0, 1];
    const translatedRanges = [];
    if (noSelectionAtEndOfLine) {
      this.transact(() => {
        for (let selection of selections) {
          const charToRightOfSelection = new Range(
            selection.end,
            selection.end.translate(translationDelta)
          );
          const charTextToRightOfSelection = this.buffer.getTextInRange(
            charToRightOfSelection
          );
          this.buffer.delete(charToRightOfSelection);
          this.buffer.insert(selection.start, charTextToRightOfSelection);
          translatedRanges.push(selection.translate(translationDelta));
        }
        this.setSelectedBufferRanges(translatedRanges);
      });
    }
  }
  duplicateLines(options = {}) {
    if (!this.ensureWritable('duplicateLines', options)) return;
    this.transact(() => {
      const selections = this.getSelectionsOrderedByBufferPosition();
      const previousSelectionRanges = [];
      let i = selections.length - 1;
      while (i >= 0) {
        const j = i;
        previousSelectionRanges[i] = selections[i].getBufferRange();
        if (selections[i].isEmpty()) {
          const { start } = selections[i].getScreenRange();
          selections[i].setScreenRange([[start.row, 0], [start.row + 1, 0]], {
            preserveFolds: true
          });
        }
        let [startRow, endRow] = selections[i].getBufferRowRange();
        endRow++;
        while (i > 0) {
          const [
            previousSelectionStartRow,
            previousSelectionEndRow
          ] = selections[i - 1].getBufferRowRange();
          if (previousSelectionEndRow === startRow) {
            startRow = previousSelectionStartRow;
            previousSelectionRanges[i - 1] = selections[i - 1].getBufferRange();
            i--;
          } else {
            break;
          }
        }
        const intersectingFolds = this.displayLayer.foldsIntersectingBufferRange(
          [[startRow, 0], [endRow, 0]]
        );
        let textToDuplicate = this.getTextInBufferRange([
          [startRow, 0],
          [endRow, 0]
        ]);
        if (endRow > this.getLastBufferRow())
          textToDuplicate = `\n${textToDuplicate}`;
        this.buffer.insert([endRow, 0], textToDuplicate);
        const insertedRowCount = endRow - startRow;
        for (let k = i; k <= j; k++) {
          selections[k].setBufferRange(
            previousSelectionRanges[k].translate([insertedRowCount, 0])
          );
        }
        for (const fold of intersectingFolds) {
          const foldRange = this.displayLayer.bufferRangeForFold(fold);
          this.displayLayer.foldBufferRange(
            foldRange.translate([insertedRowCount, 0])
          );
        }
        i--;
      }
    });
  }
  replaceSelectedText(options, fn) {
    this.mutateSelectedText(selection => {
      selection.getBufferRange();
      if (options && options.selectWordIfEmpty && selection.isEmpty()) {
        selection.selectWord();
      }
      const text = selection.getText();
      selection.deleteSelectedText();
      const range = selection.insertText(fn(text));
      selection.setBufferRange(range);
    });
  }
  splitSelectionsIntoLines() {
    this.mergeIntersectingSelections(() => {
      for (const selection of this.getSelections()) {
        const range = selection.getBufferRange();
        if (range.isSingleLine()) continue;
        const { start, end } = range;
        this.addSelectionForBufferRange([start, [start.row, Infinity]]);
        let { row } = start;
        while (++row < end.row) {
          this.addSelectionForBufferRange([[row, 0], [row, Infinity]]);
        }
        if (end.column !== 0)
          this.addSelectionForBufferRange([
            [end.row, 0],
            [end.row, end.column]
          ]);
        selection.destroy();
      }
    });
  }
  transpose(options = {}) {
    if (!this.ensureWritable('transpose', options)) return;
    this.mutateSelectedText(selection => {
      if (selection.isEmpty()) {
        selection.selectRight();
        const text = selection.getText();
        selection.delete();
        selection.cursor.moveLeft();
        selection.insertText(text);
      } else {
        selection.insertText(
          selection
            .getText()
            .split('')
            .reverse()
            .join('')
        );
      }
    });
  }
  // Extended: Convert the selected text to upper case.
  //
  // For each selection, if the selection is empty, converts the containing word
  // to upper case. Otherwise convert the selected text to upper case.
  //
  // * `options` (optional) {Object}
  //   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify a read-only editor. (default: false)
  upperCase(options = {}) {
    if (!this.ensureWritable('upperCase', options)) return;
    this.replaceSelectedText({ selectWordIfEmpty: true }, text =>
      text.toUpperCase(options)
    );
  }
  lowerCase(options = {}) {
    if (!this.ensureWritable('lowerCase', options)) return;
    this.replaceSelectedText({ selectWordIfEmpty: true }, text =>
      text.toLowerCase(options)
    );
  }
  toggleLineCommentsInSelection(options = {}) {
    if (!this.ensureWritable('toggleLineCommentsInSelection', options)) return;
    this.mutateSelectedText(selection => selection.toggleLineComments(options));
  }
  joinLines(options = {}) {
    if (!this.ensureWritable('joinLines', options)) return;
    this.mutateSelectedText(selection => selection.joinLines());
  }
  insertNewlineBelow(options = {}) {
    if (!this.ensureWritable('insertNewlineBelow', options)) return;
    this.transact(() => {
      this.moveToEndOfLine();
      this.insertNewline(options);
    });
  }
  insertNewlineAbove(options = {}) {
    if (!this.ensureWritable('insertNewlineAbove', options)) return;
    this.transact(() => {
      const bufferRow = this.getCursorBufferPosition().row;
      const indentLevel = this.indentationForBufferRow(bufferRow);
      const onFirstLine = bufferRow === 0;
      this.moveToBeginningOfLine();
      this.moveLeft();
      this.insertNewline(options);
      if (
        this.shouldAutoIndent() &&
        this.indentationForBufferRow(bufferRow) < indentLevel
      ) {
        this.setIndentationForBufferRow(bufferRow, indentLevel);
      }
      if (onFirstLine) {
        this.moveUp();
        this.moveToEndOfLine();
      }
    });
  }
  deleteToBeginningOfWord(options = {}) {
    if (!this.ensureWritable('deleteToBeginningOfWord', options)) return;
    this.mutateSelectedText(selection =>
      selection.deleteToBeginningOfWord(options)
    );
  }
  deleteToPreviousWordBoundary(options = {}) {
    if (!this.ensureWritable('deleteToPreviousWordBoundary', options)) return;
    this.mutateSelectedText(selection =>
      selection.deleteToPreviousWordBoundary(options)
    );
  }
  deleteToNextWordBoundary(options = {}) {
    if (!this.ensureWritable('deleteToNextWordBoundary', options)) return;
    this.mutateSelectedText(selection =>
      selection.deleteToNextWordBoundary(options)
    );
  }
  deleteToBeginningOfSubword(options = {}) {
    if (!this.ensureWritable('deleteToBeginningOfSubword', options)) return;
    this.mutateSelectedText(selection =>
      selection.deleteToBeginningOfSubword(options)
    );
  }
  deleteToEndOfSubword(options = {}) {
    if (!this.ensureWritable('deleteToEndOfSubword', options)) return;
    this.mutateSelectedText(selection =>
      selection.deleteToEndOfSubword(options)
    );
  }
  deleteToBeginningOfLine(options = {}) {
    if (!this.ensureWritable('deleteToBeginningOfLine', options)) return;
    this.mutateSelectedText(selection =>
      selection.deleteToBeginningOfLine(options)
    );
  }
  deleteToEndOfLine(options = {}) {
    if (!this.ensureWritable('deleteToEndOfLine', options)) return;
    this.mutateSelectedText(selection => selection.deleteToEndOfLine(options));
  }
  deleteToEndOfWord(options = {}) {
    if (!this.ensureWritable('deleteToEndOfWord', options)) return;
    this.mutateSelectedText(selection => selection.deleteToEndOfWord(options));
  }
  deleteLine(options = {}) {
    if (!this.ensureWritable('deleteLine', options)) return;
    this.mergeSelectionsOnSameRows();
    this.mutateSelectedText(selection => selection.deleteLine(options));
  }
  ensureWritable(methodName, opts) {
    if (!opts.bypassReadOnly && this.isReadOnly()) {
      if (atom.inDevMode() || atom.inSpecMode()) {
        const e = new Error('Attempt to mutate a read-only TextEditor');
        e.detail =
          `Your package is attempting to call ${methodName} on an editor that has been marked read-only. ` +
          'Pass {bypassReadOnly: true} to modify it anyway, or test editors with .isReadOnly() before attempting ' +
          'modifications.';
        throw e;
      }
      return false;
    }
    return true;
  }
  undo(options = {}) {
    if (!this.ensureWritable('undo', options)) return;
    this.avoidMergingSelections(() =>
      this.buffer.undo({ selectionsMarkerLayer: this.selectionsMarkerLayer })
    );
    this.getLastSelection().autoscroll();
  }
  redo(options = {}) {
    if (!this.ensureWritable('redo', options)) return;
    this.avoidMergingSelections(() =>
      this.buffer.redo({ selectionsMarkerLayer: this.selectionsMarkerLayer })
    );
    this.getLastSelection().autoscroll();
  }
  transact(groupingInterval, fn) {
    const options = { selectionsMarkerLayer: this.selectionsMarkerLayer };
    if (typeof groupingInterval === 'function') {
      fn = groupingInterval;
    } else {
      options.groupingInterval = groupingInterval;
    }
    return this.buffer.transact(options, fn);
  }
  abortTransaction() {
    return this.buffer.abortTransaction();
  }
  createCheckpoint() {
    return this.buffer.createCheckpoint({
      selectionsMarkerLayer: this.selectionsMarkerLayer
    });
  }
  revertToCheckpoint(checkpoint) {
    return this.buffer.revertToCheckpoint(checkpoint);
  }
  groupChangesSinceCheckpoint(checkpoint) {
    return this.buffer.groupChangesSinceCheckpoint(checkpoint, {
      selectionsMarkerLayer: this.selectionsMarkerLayer
    });
  }
  screenPositionForBufferPosition(bufferPosition, options) {
    if (options && options.clip) {
      Grim.deprecate(
        'The `clip` parameter has been deprecated and will be removed soon. Please, use `clipDirection` instead.'
      );
      if (options.clipDirection) options.clipDirection = options.clip;
    }
    if (options && options.wrapAtSoftNewlines != null) {
      Grim.deprecate(
        "The `wrapAtSoftNewlines` parameter has been deprecated and will be removed soon. Please, use `clipDirection: 'forward'` instead."
      );
      if (options.clipDirection)
        options.clipDirection = options.wrapAtSoftNewlines
          ? 'forward'
          : 'backward';
    }
    if (options && options.wrapBeyondNewlines != null) {
      Grim.deprecate(
        "The `wrapBeyondNewlines` parameter has been deprecated and will be removed soon. Please, use `clipDirection: 'forward'` instead."
      );
      if (options.clipDirection)
        options.clipDirection = options.wrapBeyondNewlines
          ? 'forward'
          : 'backward';
    }
    return this.displayLayer.translateBufferPosition(bufferPosition, options);
  }
  bufferPositionForScreenPosition(screenPosition, options) {
    if (options && options.clip) {
      Grim.deprecate(
        'The `clip` parameter has been deprecated and will be removed soon. Please, use `clipDirection` instead.'
      );
      if (options.clipDirection) options.clipDirection = options.clip;
    }
    if (options && options.wrapAtSoftNewlines != null) {
      Grim.deprecate(
        "The `wrapAtSoftNewlines` parameter has been deprecated and will be removed soon. Please, use `clipDirection: 'forward'` instead."
      );
      if (options.clipDirection)
        options.clipDirection = options.wrapAtSoftNewlines
          ? 'forward'
          : 'backward';
    }
    if (options && options.wrapBeyondNewlines != null) {
      Grim.deprecate(
        "The `wrapBeyondNewlines` parameter has been deprecated and will be removed soon. Please, use `clipDirection: 'forward'` instead."
      );
      if (options.clipDirection)
        options.clipDirection = options.wrapBeyondNewlines
          ? 'forward'
          : 'backward';
    }
    return this.displayLayer.translateScreenPosition(screenPosition, options);
  }
  screenRangeForBufferRange(bufferRange, options) {
    bufferRange = Range.fromObject(bufferRange);
    const start = this.screenPositionForBufferPosition(
      bufferRange.start,
      options
    );
    const end = this.screenPositionForBufferPosition(bufferRange.end, options);
    return new Range(start, end);
  }
  bufferRangeForScreenRange(screenRange) {
    screenRange = Range.fromObject(screenRange);
    const start = this.bufferPositionForScreenPosition(screenRange.start);
    const end = this.bufferPositionForScreenPosition(screenRange.end);
    return new Range(start, end);
  }
  clipBufferPosition(bufferPosition) {
    return this.buffer.clipPosition(bufferPosition);
  }
  clipBufferRange(range) {
    return this.buffer.clipRange(range);
  }
  clipScreenPosition(screenPosition, options) {
    if (options && options.clip) {
      Grim.deprecate(
        'The `clip` parameter has been deprecated and will be removed soon. Please, use `clipDirection` instead.'
      );
      if (options.clipDirection) options.clipDirection = options.clip;
    }
    if (options && options.wrapAtSoftNewlines != null) {
      Grim.deprecate(
        "The `wrapAtSoftNewlines` parameter has been deprecated and will be removed soon. Please, use `clipDirection: 'forward'` instead."
      );
      if (options.clipDirection)
        options.clipDirection = options.wrapAtSoftNewlines
          ? 'forward'
          : 'backward';
    }
    if (options && options.wrapBeyondNewlines != null) {
      Grim.deprecate(
        "The `wrapBeyondNewlines` parameter has been deprecated and will be removed soon. Please, use `clipDirection: 'forward'` instead."
      );
      if (options.clipDirection)
        options.clipDirection = options.wrapBeyondNewlines
          ? 'forward'
          : 'backward';
    }
    return this.displayLayer.clipScreenPosition(screenPosition, options);
  }
  clipScreenRange(screenRange, options) {
    screenRange = Range.fromObject(screenRange);
    const start = this.displayLayer.clipScreenPosition(
      screenRange.start,
      options
    );
    const end = this.displayLayer.clipScreenPosition(screenRange.end, options);
    return Range(start, end);
  }
  decorateMarker(marker, decorationParams) {
    return this.decorationManager.decorateMarker(marker, decorationParams);
  }
  decorateMarkerLayer(markerLayer, decorationParams) {
    return this.decorationManager.decorateMarkerLayer(
      markerLayer,
      decorationParams
    );
  }
  decorationsForScreenRowRange(startScreenRow, endScreenRow) {
    return this.decorationManager.decorationsForScreenRowRange(
      startScreenRow,
      endScreenRow
    );
  }
  decorationsStateForScreenRowRange(startScreenRow, endScreenRow) {
    return this.decorationManager.decorationsStateForScreenRowRange(
      startScreenRow,
      endScreenRow
    );
  }
  getDecorations(propertyFilter) {
    return this.decorationManager.getDecorations(propertyFilter);
  }
  getLineDecorations(propertyFilter) {
    return this.decorationManager.getLineDecorations(propertyFilter);
  }
  getLineNumberDecorations(propertyFilter) {
    return this.decorationManager.getLineNumberDecorations(propertyFilter);
  }
  getHighlightDecorations(propertyFilter) {
    return this.decorationManager.getHighlightDecorations(propertyFilter);
  }
  getOverlayDecorations(propertyFilter) {
    return this.decorationManager.getOverlayDecorations(propertyFilter);
  }
  markBufferRange(bufferRange, options) {
    return this.defaultMarkerLayer.markBufferRange(bufferRange, options);
  }
  markScreenRange(screenRange, options) {
    return this.defaultMarkerLayer.markScreenRange(screenRange, options);
  }
  markBufferPosition(bufferPosition, options) {
    return this.defaultMarkerLayer.markBufferPosition(bufferPosition, options);
  }
  markScreenPosition(screenPosition, options) {
    return this.defaultMarkerLayer.markScreenPosition(screenPosition, options);
  }
  findMarkers(params) {
    return this.defaultMarkerLayer.findMarkers(params);
  }
  getMarker(id) {
    return this.defaultMarkerLayer.getMarker(id);
  }
  getMarkers() {
    return this.defaultMarkerLayer.getMarkers();
  }
  getMarkerCount() {
    return this.defaultMarkerLayer.getMarkerCount();
  }
  destroyMarker(id) {
    const marker = this.getMarker(id);
    if (marker) marker.destroy();
  }
  addMarkerLayer(options) {
    return this.displayLayer.addMarkerLayer(options);
  }
  getMarkerLayer(id) {
    return this.displayLayer.getMarkerLayer(id);
  }
  getDefaultMarkerLayer() {
    return this.defaultMarkerLayer;
  }
  getCursorBufferPosition() {
    return this.getLastCursor().getBufferPosition();
  }
  getCursorBufferPositions() {
    return this.getCursors().map(cursor => cursor.getBufferPosition());
  }
  setCursorBufferPosition(position, options) {
    return this.moveCursors(cursor =>
      cursor.setBufferPosition(position, options)
    );
  }
  getCursorAtScreenPosition(position) {
    const selection = this.getSelectionAtScreenPosition(position);
    if (selection && selection.getHeadScreenPosition().isEqual(position)) {
      return selection.cursor;
    }
  }
  getCursorScreenPosition() {
    return this.getLastCursor().getScreenPosition();
  }
  getCursorScreenPositions() {
    return this.getCursors().map(cursor => cursor.getScreenPosition());
  }
  setCursorScreenPosition(position, options) {
    if (options && options.clip) {
      Grim.deprecate(
        'The `clip` parameter has been deprecated and will be removed soon. Please, use `clipDirection` instead.'
      );
      if (options.clipDirection) options.clipDirection = options.clip;
    }
    if (options && options.wrapAtSoftNewlines != null) {
      Grim.deprecate(
        "The `wrapAtSoftNewlines` parameter has been deprecated and will be removed soon. Please, use `clipDirection: 'forward'` instead."
      );
      if (options.clipDirection)
        options.clipDirection = options.wrapAtSoftNewlines
          ? 'forward'
          : 'backward';
    }
    if (options && options.wrapBeyondNewlines != null) {
      Grim.deprecate(
        "The `wrapBeyondNewlines` parameter has been deprecated and will be removed soon. Please, use `clipDirection: 'forward'` instead."
      );
      if (options.clipDirection)
        options.clipDirection = options.wrapBeyondNewlines
          ? 'forward'
          : 'backward';
    }
    return this.moveCursors(cursor =>
      cursor.setScreenPosition(position, options)
    );
  }
  addCursorAtBufferPosition(bufferPosition, options) {
    this.selectionsMarkerLayer.markBufferPosition(bufferPosition, {
      invalidate: 'never'
    });
    if (!options || options.autoscroll !== false)
      this.getLastSelection().cursor.autoscroll();
    return this.getLastSelection().cursor;
  }
  addCursorAtScreenPosition(screenPosition, options) {
    this.selectionsMarkerLayer.markScreenPosition(screenPosition, {
      invalidate: 'never'
    });
    if (!options || options.autoscroll !== false)
      this.getLastSelection().cursor.autoscroll();
    return this.getLastSelection().cursor;
  }
  hasMultipleCursors() {
    return this.getCursors().length > 1;
  }
  moveUp(lineCount) {
    return this.moveCursors(cursor =>
      cursor.moveUp(lineCount, { moveToEndOfSelection: true })
    );
  }
  moveDown(lineCount) {
    return this.moveCursors(cursor =>
      cursor.moveDown(lineCount, { moveToEndOfSelection: true })
    );
  }
  moveLeft(columnCount) {
    return this.moveCursors(cursor =>
      cursor.moveLeft(columnCount, { moveToEndOfSelection: true })
    );
  }
  moveRight(columnCount) {
    return this.moveCursors(cursor =>
      cursor.moveRight(columnCount, { moveToEndOfSelection: true })
    );
  }
  moveToBeginningOfLine() {
    return this.moveCursors(cursor => cursor.moveToBeginningOfLine());
  }
  moveToBeginningOfScreenLine() {
    return this.moveCursors(cursor => cursor.moveToBeginningOfScreenLine());
  }
  moveToFirstCharacterOfLine() {
    return this.moveCursors(cursor => cursor.moveToFirstCharacterOfLine());
  }
  moveToEndOfLine() {
    return this.moveCursors(cursor => cursor.moveToEndOfLine());
  }
  moveToEndOfScreenLine() {
    return this.moveCursors(cursor => cursor.moveToEndOfScreenLine());
  }
  moveToBeginningOfWord() {
    return this.moveCursors(cursor => cursor.moveToBeginningOfWord());
  }
  moveToEndOfWord() {
    return this.moveCursors(cursor => cursor.moveToEndOfWord());
  }
  moveToTop() {
    return this.moveCursors(cursor => cursor.moveToTop());
  }
  moveToBottom() {
    return this.moveCursors(cursor => cursor.moveToBottom());
  }
  moveToBeginningOfNextWord() {
    return this.moveCursors(cursor => cursor.moveToBeginningOfNextWord());
  }
  moveToPreviousWordBoundary() {
    return this.moveCursors(cursor => cursor.moveToPreviousWordBoundary());
  }
  moveToNextWordBoundary() {
    return this.moveCursors(cursor => cursor.moveToNextWordBoundary());
  }
  moveToPreviousSubwordBoundary() {
    return this.moveCursors(cursor => cursor.moveToPreviousSubwordBoundary());
  }
  moveToNextSubwordBoundary() {
    return this.moveCursors(cursor => cursor.moveToNextSubwordBoundary());
  }
  moveToBeginningOfNextParagraph() {
    return this.moveCursors(cursor => cursor.moveToBeginningOfNextParagraph());
  }
  moveToBeginningOfPreviousParagraph() {
    return this.moveCursors(cursor =>
      cursor.moveToBeginningOfPreviousParagraph()
    );
  }
  getLastCursor() {
    this.createLastSelectionIfNeeded();
    return _.last(this.cursors);
  }
  getWordUnderCursor(options) {
    return this.getTextInBufferRange(
      this.getLastCursor().getCurrentWordBufferRange(options)
    );
  }
  getCursors() {
    this.createLastSelectionIfNeeded();
    return this.cursors.slice();
  }
  getCursorsOrderedByBufferPosition() {
    return this.getCursors().sort((a, b) => a.compare(b));
  }
  cursorsForScreenRowRange(startScreenRow, endScreenRow) {
    const cursors = [];
    for (let marker of this.selectionsMarkerLayer.findMarkers({
      intersectsScreenRowRange: [startScreenRow, endScreenRow]
    })) {
      const cursor = this.cursorsByMarkerId.get(marker.id);
      if (cursor) cursors.push(cursor);
    }
    return cursors;
  }
  addCursor(marker) {
    const cursor = new Cursor({
      editor: this,
      marker,
      showCursorOnSelection: this.showCursorOnSelection
    });
    this.cursors.push(cursor);
    this.cursorsByMarkerId.set(marker.id, cursor);
    return cursor;
  }
  moveCursors(fn) {
    return this.transact(() => {
      this.getCursors().forEach(fn);
      return this.mergeCursors();
    });
  }
  cursorMoved(event) {
    return this.emitter.emit('did-change-cursor-position', event);
  }
  mergeCursors() {
    const positions = {};
    for (let cursor of this.getCursors()) {
      const position = cursor.getBufferPosition().toString();
      if (positions.hasOwnProperty(position)) {
        cursor.destroy();
      } else {
        positions[position] = true;
      }
    }
  }
  getSelectedText() {
    return this.getLastSelection().getText();
  }
  getSelectedBufferRange() {
    return this.getLastSelection().getBufferRange();
  }
  getSelectedBufferRanges() {
    return this.getSelections().map(selection => selection.getBufferRange());
  }
  setSelectedBufferRange(bufferRange, options) {
    return this.setSelectedBufferRanges([bufferRange], options);
  }
  setSelectedBufferRanges(bufferRanges, options = {}) {
    if (!bufferRanges.length)
      throw new Error('Passed an empty array to setSelectedBufferRanges');
    const selections = this.getSelections();
    for (let selection of selections.slice(bufferRanges.length)) {
      selection.destroy();
    }
    this.mergeIntersectingSelections(options, () => {
      for (let i = 0; i < bufferRanges.length; i++) {
        let bufferRange = bufferRanges[i];
        bufferRange = Range.fromObject(bufferRange);
        if (selections[i]) {
          selections[i].setBufferRange(bufferRange, options);
        } else {
          this.addSelectionForBufferRange(bufferRange, options);
        }
      }
    });
  }
  getSelectedScreenRange() {
    return this.getLastSelection().getScreenRange();
  }
  getSelectedScreenRanges() {
    return this.getSelections().map(selection => selection.getScreenRange());
  }
  setSelectedScreenRange(screenRange, options) {
    return this.setSelectedBufferRange(
      this.bufferRangeForScreenRange(screenRange, options),
      options
    );
  }
  setSelectedScreenRanges(screenRanges, options = {}) {
    if (!screenRanges.length)
      throw new Error('Passed an empty array to setSelectedScreenRanges');
    const selections = this.getSelections();
    for (let selection of selections.slice(screenRanges.length)) {
      selection.destroy();
    }
    this.mergeIntersectingSelections(options, () => {
      for (let i = 0; i < screenRanges.length; i++) {
        let screenRange = screenRanges[i];
        screenRange = Range.fromObject(screenRange);
        if (selections[i]) {
          selections[i].setScreenRange(screenRange, options);
        } else {
          this.addSelectionForScreenRange(screenRange, options);
        }
      }
    });
  }
  addSelectionForBufferRange(bufferRange, options = {}) {
    bufferRange = Range.fromObject(bufferRange);
    if (!options.preserveFolds) {
      this.displayLayer.destroyFoldsContainingBufferPositions(
        [bufferRange.start, bufferRange.end],
        true
      );
    }
    this.selectionsMarkerLayer.markBufferRange(bufferRange, {
      invalidate: 'never',
      reversed: options.reversed != null ? options.reversed : false
    });
    if (options.autoscroll !== false) this.getLastSelection().autoscroll();
    return this.getLastSelection();
  }
  addSelectionForScreenRange(screenRange, options = {}) {
    return this.addSelectionForBufferRange(
      this.bufferRangeForScreenRange(screenRange),
      options
    );
  }
  selectToBufferPosition(position) {
    const lastSelection = this.getLastSelection();
    lastSelection.selectToBufferPosition(position);
    return this.mergeIntersectingSelections({
      reversed: lastSelection.isReversed()
    });
  }
  selectToScreenPosition(position, options) {
    const lastSelection = this.getLastSelection();
    lastSelection.selectToScreenPosition(position, options);
    if (!options || !options.suppressSelectionMerge) {
      return this.mergeIntersectingSelections({
        reversed: lastSelection.isReversed()
      });
    }
  }
  selectUp(rowCount) {
    return this.expandSelectionsBackward(selection =>
      selection.selectUp(rowCount)
    );
  }
  selectDown(rowCount) {
    return this.expandSelectionsForward(selection =>
      selection.selectDown(rowCount)
    );
  }
  selectLeft(columnCount) {
    return this.expandSelectionsBackward(selection =>
      selection.selectLeft(columnCount)
    );
  }
  selectRight(columnCount) {
    return this.expandSelectionsForward(selection =>
      selection.selectRight(columnCount)
    );
  }
  selectToTop() {
    return this.expandSelectionsBackward(selection => selection.selectToTop());
  }
  selectToBottom() {
    return this.expandSelectionsForward(selection =>
      selection.selectToBottom()
    );
  }
  selectAll() {
    return this.expandSelectionsForward(selection => selection.selectAll());
  }
  selectToBeginningOfLine() {
    return this.expandSelectionsBackward(selection =>
      selection.selectToBeginningOfLine()
    );
  }
  selectToFirstCharacterOfLine() {
    return this.expandSelectionsBackward(selection =>
      selection.selectToFirstCharacterOfLine()
    );
  }
  selectToEndOfLine() {
    return this.expandSelectionsForward(selection =>
      selection.selectToEndOfLine()
    );
  }
  selectToBeginningOfWord() {
    return this.expandSelectionsBackward(selection =>
      selection.selectToBeginningOfWord()
    );
  }
  selectToEndOfWord() {
    return this.expandSelectionsForward(selection =>
      selection.selectToEndOfWord()
    );
  }
  selectToPreviousSubwordBoundary() {
    return this.expandSelectionsBackward(selection =>
      selection.selectToPreviousSubwordBoundary()
    );
  }
  selectToNextSubwordBoundary() {
    return this.expandSelectionsForward(selection =>
      selection.selectToNextSubwordBoundary()
    );
  }
  selectLinesContainingCursors() {
    return this.expandSelectionsForward(selection => selection.selectLine());
  }
  selectWordsContainingCursors() {
    return this.expandSelectionsForward(selection => selection.selectWord());
  }
  selectToPreviousWordBoundary() {
    return this.expandSelectionsBackward(selection =>
      selection.selectToPreviousWordBoundary()
    );
  }
  selectToNextWordBoundary() {
    return this.expandSelectionsForward(selection =>
      selection.selectToNextWordBoundary()
    );
  }
  selectToBeginningOfNextWord() {
    return this.expandSelectionsForward(selection =>
      selection.selectToBeginningOfNextWord()
    );
  }
  selectToBeginningOfNextParagraph() {
    return this.expandSelectionsForward(selection =>
      selection.selectToBeginningOfNextParagraph()
    );
  }
  selectToBeginningOfPreviousParagraph() {
    return this.expandSelectionsBackward(selection =>
      selection.selectToBeginningOfPreviousParagraph()
    );
  }
  selectLargerSyntaxNode() {
    const languageMode = this.buffer.getLanguageMode();
    if (!languageMode.getRangeForSyntaxNodeContainingRange) return;
    this.expandSelectionsForward(selection => {
      const currentRange = selection.getBufferRange();
      const newRange = languageMode.getRangeForSyntaxNodeContainingRange(
        currentRange
      );
      if (newRange) {
        if (!selection._rangeStack) selection._rangeStack = [];
        selection._rangeStack.push(currentRange);
        selection.setBufferRange(newRange);
      }
    });
  }
  selectSmallerSyntaxNode() {
    this.expandSelectionsForward(selection => {
      if (selection._rangeStack) {
        const lastRange =
          selection._rangeStack[selection._rangeStack.length - 1];
        if (lastRange && selection.getBufferRange().containsRange(lastRange)) {
          selection._rangeStack.length--;
          selection.setBufferRange(lastRange);
        }
      }
    });
  }
  selectMarker(marker) {
    if (marker.isValid()) {
      const range = marker.getBufferRange();
      this.setSelectedBufferRange(range);
      return range;
    }
  }
  getLastSelection() {
    this.createLastSelectionIfNeeded();
    return _.last(this.selections);
  }
  getSelectionAtScreenPosition(position) {
    const markers = this.selectionsMarkerLayer.findMarkers({
      containsScreenPosition: position
    });
    if (markers.length > 0)
      return this.cursorsByMarkerId.get(markers[0].id).selection;
  }
  getSelections() {
    this.createLastSelectionIfNeeded();
    return this.selections.slice();
  }
  getSelectionsOrderedByBufferPosition() {
    return this.getSelections().sort((a, b) => a.compare(b));
  }
  selectionIntersectsBufferRange(bufferRange) {
    return this.getSelections().some(selection =>
      selection.intersectsBufferRange(bufferRange)
    );
  }
  addSelectionBelow() {
    return this.expandSelectionsForward(selection =>
      selection.addSelectionBelow()
    );
  }
  addSelectionAbove() {
    return this.expandSelectionsBackward(selection =>
      selection.addSelectionAbove()
    );
  }
  expandSelectionsForward(fn) {
    this.mergeIntersectingSelections(() => this.getSelections().forEach(fn));
  }
  expandSelectionsBackward(fn) {
    this.mergeIntersectingSelections({ reversed: true }, () =>
      this.getSelections().forEach(fn)
    );
  }
  finalizeSelections() {
    for (let selection of this.getSelections()) {
      selection.finalize();
    }
  }
  selectionsForScreenRows(startRow, endRow) {
    return this.getSelections().filter(selection =>
      selection.intersectsScreenRowRange(startRow, endRow)
    );
  }
  mergeIntersectingSelections(...args) {
    return this.mergeSelections(
      ...args,
      (previousSelection, currentSelection) => {
        const exclusive =
          !currentSelection.isEmpty() && !previousSelection.isEmpty();
        return previousSelection.intersectsWith(currentSelection, exclusive);
      }
    );
  }
  mergeSelectionsOnSameRows(...args) {
    return this.mergeSelections(
      ...args,
      (previousSelection, currentSelection) => {
        const screenRange = currentSelection.getScreenRange();
        return previousSelection.intersectsScreenRowRange(
          screenRange.start.row,
          screenRange.end.row
        );
      }
    );
  }
  avoidMergingSelections(...args) {
    return this.mergeSelections(...args, () => false);
  }
  mergeSelections(...args) {
    const mergePredicate = args.pop();
    let fn = args.pop();
    let options = args.pop();
    if (typeof fn !== 'function') {
      options = fn;
      fn = () => {};
    }
    if (this.suppressSelectionMerging) return fn();
    this.suppressSelectionMerging = true;
    const result = fn();
    this.suppressSelectionMerging = false;
    const selections = this.getSelectionsOrderedByBufferPosition();
    let lastSelection = selections.shift();
    for (const selection of selections) {
      if (mergePredicate(lastSelection, selection)) {
        lastSelection.merge(selection, options);
      } else {
        lastSelection = selection;
      }
    }
    return result;
  }
  addSelection(marker, options = {}) {
    const cursor = this.addCursor(marker);
    let selection = new Selection(
      Object.assign({ editor: this, marker, cursor }, options)
    );
    this.selections.push(selection);
    const selectionBufferRange = selection.getBufferRange();
    this.mergeIntersectingSelections({ preserveFolds: options.preserveFolds });
    if (selection.destroyed) {
      for (selection of this.getSelections()) {
        if (selection.intersectsBufferRange(selectionBufferRange))
          return selection;
      }
    } else {
      this.emitter.emit('did-add-cursor', cursor);
      this.emitter.emit('did-add-selection', selection);
      return selection;
    }
  }
  removeSelection(selection) {
    _.remove(this.cursors, selection.cursor);
    _.remove(this.selections, selection);
    this.cursorsByMarkerId.delete(selection.cursor.marker.id);
    this.emitter.emit('did-remove-cursor', selection.cursor);
    return this.emitter.emit('did-remove-selection', selection);
  }
  clearSelections(options) {
    this.consolidateSelections();
    this.getLastSelection().clear(options);
  }
  consolidateSelections() {
    const selections = this.getSelections();
    if (selections.length > 1) {
      for (let selection of selections.slice(1, selections.length)) {
        selection.destroy();
      }
      selections[0].autoscroll({ center: true });
      return true;
    } else {
      return false;
    }
  }
  selectionRangeChanged(event) {
    if (this.component) this.component.didChangeSelectionRange();
    this.emitter.emit('did-change-selection-range', event);
  }
  createLastSelectionIfNeeded() {
    if (this.selections.length === 0) {
      this.addSelectionForBufferRange([[0, 0], [0, 0]], {
        autoscroll: false,
        preserveFolds: true
      });
    }
  }
  scan(regex, options = {}, iterator) {
    if (_.isFunction(options)) {
      iterator = options;
      options = {};
    }
    return this.buffer.scan(regex, options, iterator);
  }
  scanInBufferRange(regex, range, iterator) {
    return this.buffer.scanInRange(regex, range, iterator);
  }
  backwardsScanInBufferRange(regex, range, iterator) {
    return this.buffer.backwardsScanInRange(regex, range, iterator);
  }
  getSoftTabs() {
    return this.softTabs;
  }
  setSoftTabs(softTabs) {
    this.softTabs = softTabs;
    this.updateSoftTabs(this.softTabs, true);
  }
  hasAtomicSoftTabs() {
    return this.displayLayer.atomicSoftTabs;
  }
  toggleSoftTabs() {
    this.setSoftTabs(!this.getSoftTabs());
  }
  getTabLength() {
    return this.displayLayer.tabLength;
  }
  setTabLength(tabLength) {
    this.updateTabLength(tabLength, true);
  }
  getInvisibles() {
    if (!this.mini && this.showInvisibles && this.invisibles != null) {
      return this.invisibles;
    } else {
      return {};
    }
  }
  doesShowIndentGuide() {
    return this.showIndentGuide && !this.mini;
  }
  getSoftWrapHangingIndentLength() {
    return this.displayLayer.softWrapHangingIndent;
  }
  usesSoftTabs() {
    const languageMode = this.buffer.getLanguageMode();
    const hasIsRowCommented = languageMode.isRowCommented;
    for (
      let bufferRow = 0, end = Math.min(1000, this.buffer.getLastRow());
      bufferRow <= end;
      bufferRow++
    ) {
      if (hasIsRowCommented && languageMode.isRowCommented(bufferRow)) continue;
      const line = this.buffer.lineForRow(bufferRow);
      if (line[0] === ' ') return true;
      if (line[0] === '\t') return false;
    }
  }
  getTabText() {
    return this.buildIndentString(1);
  }
  normalizeTabsInBufferRange(bufferRange) {
    if (!this.getSoftTabs()) {
      return;
    }
    return this.scanInBufferRange(/\t/g, bufferRange, ({ replace }) =>
      replace(this.getTabText())
    );
  }
  isSoftWrapped() {
    return this.softWrapped;
  }
  setSoftWrapped(softWrapped) {
    this.updateSoftWrapped(softWrapped, true);
    return this.isSoftWrapped();
  }
  getPreferredLineLength() {
    return this.preferredLineLength;
  }
  toggleSoftWrapped() {
    return this.setSoftWrapped(!this.isSoftWrapped());
  }
  getSoftWrapColumn() {
    if (this.isSoftWrapped() && !this.mini) {
      if (this.softWrapAtPreferredLineLength) {
        return Math.min(this.getEditorWidthInChars(), this.preferredLineLength);
      } else {
        return this.getEditorWidthInChars();
      }
    } else {
      return this.maxScreenLineLength;
    }
  }
  indentationForBufferRow(bufferRow) {
    return this.indentLevelForLine(this.lineTextForBufferRow(bufferRow));
  }
  setIndentationForBufferRow(
    bufferRow,
    newLevel,
    { preserveLeadingWhitespace } = {}
  ) {
    let endColumn;
    if (preserveLeadingWhitespace) {
      endColumn = 0;
    } else {
      endColumn = this.lineTextForBufferRow(bufferRow).match(/^\s*/)[0].length;
    }
    const newIndentString = this.buildIndentString(newLevel);
    return this.buffer.setTextInRange(
      [[bufferRow, 0], [bufferRow, endColumn]],
      newIndentString
    );
  }
  indentSelectedRows(options = {}) {
    if (!this.ensureWritable('indentSelectedRows', options)) return;
    return this.mutateSelectedText(selection =>
      selection.indentSelectedRows(options)
    );
  }
  outdentSelectedRows(options = {}) {
    if (!this.ensureWritable('outdentSelectedRows', options)) return;
    return this.mutateSelectedText(selection =>
      selection.outdentSelectedRows(options)
    );
  }
  indentLevelForLine(line) {
    const tabLength = this.getTabLength();
    let indentLength = 0;
    for (let i = 0, { length } = line; i < length; i++) {
      const char = line[i];
      if (char === '\t') {
        indentLength += tabLength - (indentLength % tabLength);
      } else if (char === ' ') {
        indentLength++;
      } else {
        break;
      }
    }
    return indentLength / tabLength;
  }
  autoIndentSelectedRows(options = {}) {
    if (!this.ensureWritable('autoIndentSelectedRows', options)) return;
    return this.mutateSelectedText(selection =>
      selection.autoIndentSelectedRows(options)
    );
  }
  indent(options = {}) {
    if (!this.ensureWritable('indent', options)) return;
    if (options.autoIndent == null)
      options.autoIndent = this.shouldAutoIndent();
    this.mutateSelectedText(selection => selection.indent(options));
  }
  buildIndentString(level, column = 0) {
    if (this.getSoftTabs()) {
      const tabStopViolation = column % this.getTabLength();
      return _.multiplyString(
        ' ',
        Math.floor(level * this.getTabLength()) - tabStopViolation
      );
    } else {
      const excessWhitespace = _.multiplyString(
        ' ',
        Math.round((level - Math.floor(level)) * this.getTabLength())
      );
      return _.multiplyString('\t', Math.floor(level)) + excessWhitespace;
    }
  }
  getGrammar() {
    const languageMode = this.buffer.getLanguageMode();
    return (
      (languageMode.getGrammar && languageMode.getGrammar()) || NullGrammar
    );
  }
  setGrammar(grammar) {
    const buffer = this.getBuffer();
    buffer.setLanguageMode(
      atom.grammars.languageModeForGrammarAndBuffer(grammar, buffer)
    );
  }
  onDidTokenize(callback) {
    return this.emitter.on('did-tokenize', callback);
  }
  getRootScopeDescriptor() {
    return this.buffer.getLanguageMode().rootScopeDescriptor;
  }
  scopeDescriptorForBufferPosition(bufferPosition) {
    const languageMode = this.buffer.getLanguageMode();
    return languageMode.scopeDescriptorForPosition
      ? languageMode.scopeDescriptorForPosition(bufferPosition)
      : new ScopeDescriptor({ scopes: ['text'] });
  }
  syntaxTreeScopeDescriptorForBufferPosition(bufferPosition) {
    const languageMode = this.buffer.getLanguageMode();
    return languageMode.syntaxTreeScopeDescriptorForPosition
      ? languageMode.syntaxTreeScopeDescriptorForPosition(bufferPosition)
      : this.scopeDescriptorForBufferPosition(bufferPosition);
  }
  bufferRangeForScopeAtCursor(scopeSelector) {
    return this.bufferRangeForScopeAtPosition(
      scopeSelector,
      this.getCursorBufferPosition()
    );
  }
  bufferRangeForScopeAtPosition(scopeSelector, bufferPosition) {
    return this.buffer
      .getLanguageMode()
      .bufferRangeForScopeAtPosition(scopeSelector, bufferPosition);
  }
  isBufferRowCommented(bufferRow) {
    const match = this.lineTextForBufferRow(bufferRow).match(/\S/);
    if (match) {
      if (!this.commentScopeSelector)
        this.commentScopeSelector = new TextMateScopeSelector('comment.*');
      return this.commentScopeSelector.matches(
        this.scopeDescriptorForBufferPosition([bufferRow, match.index]).scopes
      );
    }
  }
  getCursorScope() {
    return this.getLastCursor().getScopeDescriptor();
  }
  getCursorSyntaxTreeScope() {
    return this.getLastCursor().getSyntaxTreeScopeDescriptor();
  }
  tokenForBufferPosition(bufferPosition) {
    return this.buffer.getLanguageMode().tokenForPosition(bufferPosition);
  }
  copySelectedText() {
    let maintainClipboard = false;
    for (let selection of this.getSelectionsOrderedByBufferPosition()) {
      if (selection.isEmpty()) {
        const previousRange = selection.getBufferRange();
        selection.selectLine();
        selection.copy(maintainClipboard, true);
        selection.setBufferRange(previousRange);
      } else {
        selection.copy(maintainClipboard, false);
      }
      maintainClipboard = true;
    }
  }
  copyOnlySelectedText() {
    let maintainClipboard = false;
    for (let selection of this.getSelectionsOrderedByBufferPosition()) {
      if (!selection.isEmpty()) {
        selection.copy(maintainClipboard, false);
        maintainClipboard = true;
      }
    }
  }
  cutSelectedText(options = {}) {
    if (!this.ensureWritable('cutSelectedText', options)) return;
    let maintainClipboard = false;
    this.mutateSelectedText(selection => {
      if (selection.isEmpty()) {
        selection.selectLine();
        selection.cut(maintainClipboard, true, options.bypassReadOnly);
      } else {
        selection.cut(maintainClipboard, false, options.bypassReadOnly);
      }
      maintainClipboard = true;
    });
  }
  pasteText(options = {}) {
    if (!this.ensureWritable('parseText', options)) return;
    options = Object.assign({}, options);
    let {
      text: clipboardText,
      metadata
    } = this.constructor.clipboard.readWithMetadata();
    if (!this.emitWillInsertTextEvent(clipboardText)) return false;
    let languageMode = this.buffer.getLanguageMode();
    if (!metadata) metadata = {};
    if (options.autoIndent == null)
      options.autoIndent = this.shouldAutoIndentOnPaste();
    this.mutateSelectedText((selection, index) => {
      let fullLine, indentBasis, text;
      if (
        metadata.selections &&
        metadata.selections.length === this.getSelections().length
      ) {
        ({ text, indentBasis, fullLine } = metadata.selections[index]);
      } else {
        ({ indentBasis, fullLine } = metadata);
        text = clipboardText;
      }
      if (
        indentBasis != null &&
        (text.includes('\n') ||
          !selection.cursor.hasPrecedingCharactersOnLine())
      ) {
        options.indentBasis = indentBasis;
      } else {
        options.indentBasis = null;
      }
      let range;
      if (fullLine && selection.isEmpty()) {
        const oldPosition = selection.getBufferRange().start;
        selection.setBufferRange([[oldPosition.row, 0], [oldPosition.row, 0]]);
        range = selection.insertText(text, options);
        const newPosition = oldPosition.translate([1, 0]);
        selection.setBufferRange([newPosition, newPosition]);
      } else {
        range = selection.insertText(text, options);
      }
      if (languageMode.atTransactionEnd && options.autoIndent && text.includes('\n')) {
        languageMode.atTransactionEnd().then(({ range }) => {
          let marker = this.markBufferRange(range);
          let endRow = range.end.row;
          if (range.end.column === 0) endRow--;
          let checkpoint = this.buffer.createCheckpoint();
          this.autoIndentBufferRows(
            range.start.row,
            endRow,
            { ...options, isPastedText: true }
          );
          if (this.buffer.getChangesSinceCheckpoint(checkpoint).length > 0) {
            this.buffer.groupLastChanges();
          }
          range = marker.getBufferRange();
          text = this.buffer.getTextInRange(range);
          this.emitter.emit('did-insert-text', { text, range });
        });
      } else {
        this.emitter.emit('did-insert-text', { text, range });
      }
    });
  }
  cutToEndOfLine(options = {}) {
    if (!this.ensureWritable('cutToEndOfLine', options)) return;
    let maintainClipboard = false;
    this.mutateSelectedText(selection => {
      selection.cutToEndOfLine(maintainClipboard, options);
      maintainClipboard = true;
    });
  }
  cutToEndOfBufferLine(options = {}) {
    if (!this.ensureWritable('cutToEndOfBufferLine', options)) return;
    let maintainClipboard = false;
    this.mutateSelectedText(selection => {
      selection.cutToEndOfBufferLine(maintainClipboard, options);
      maintainClipboard = true;
    });
  }
  foldCurrentRow() {
    const { row } = this.getCursorBufferPosition();
    const languageMode = this.buffer.getLanguageMode();
    const range =
      languageMode.getFoldableRangeContainingPoint &&
      languageMode.getFoldableRangeContainingPoint(
        Point(row, Infinity),
        this.getTabLength()
      );
    if (range) return this.displayLayer.foldBufferRange(range);
  }
  unfoldCurrentRow() {
    const { row } = this.getCursorBufferPosition();
    return this.displayLayer.destroyFoldsContainingBufferPositions(
      [Point(row, Infinity)],
      false
    );
  }
  foldBufferRow(bufferRow) {
    let position = Point(bufferRow, Infinity);
    const languageMode = this.buffer.getLanguageMode();
    while (true) {
      const foldableRange =
        languageMode.getFoldableRangeContainingPoint &&
        languageMode.getFoldableRangeContainingPoint(
          position,
          this.getTabLength()
        );
      if (foldableRange) {
        const existingFolds = this.displayLayer.foldsIntersectingBufferRange(
          Range(foldableRange.start, foldableRange.start)
        );
        if (existingFolds.length === 0) {
          this.displayLayer.foldBufferRange(foldableRange);
        } else {
          const firstExistingFoldRange = this.displayLayer.bufferRangeForFold(
            existingFolds[0]
          );
          if (firstExistingFoldRange.start.isLessThan(position)) {
            position = Point(firstExistingFoldRange.start.row, 0);
            continue;
          }
        }
      }
      break;
    }
  }
  unfoldBufferRow(bufferRow) {
    const position = Point(bufferRow, Infinity);
    return this.displayLayer.destroyFoldsContainingBufferPositions([position]);
  }
  foldSelectedLines() {
    for (let selection of this.selections) {
      selection.fold();
    }
  }
  foldAll() {
    const languageMode = this.buffer.getLanguageMode();
    const foldableRanges =
      languageMode.getFoldableRanges &&
      languageMode.getFoldableRanges(this.getTabLength());
    this.displayLayer.destroyAllFolds();
    for (let range of foldableRanges || []) {
      this.displayLayer.foldBufferRange(range);
    }
  }
  unfoldAll() {
    const result = this.displayLayer.destroyAllFolds();
    if (result.length > 0) this.scrollToCursorPosition();
    return result;
  }
  foldAllAtIndentLevel(level) {
    const languageMode = this.buffer.getLanguageMode();
    const foldableRanges =
      languageMode.getFoldableRangesAtIndentLevel &&
      languageMode.getFoldableRangesAtIndentLevel(level, this.getTabLength());
    this.displayLayer.destroyAllFolds();
    for (let range of foldableRanges || []) {
      this.displayLayer.foldBufferRange(range);
    }
  }
  isFoldableAtBufferRow(bufferRow) {
    const languageMode = this.buffer.getLanguageMode();
    return (
      languageMode.isFoldableAtRow && languageMode.isFoldableAtRow(bufferRow)
    );
  }
  isFoldableAtScreenRow(screenRow) {
    return this.isFoldableAtBufferRow(this.bufferRowForScreenRow(screenRow));
  }
  toggleFoldAtBufferRow(bufferRow) {
    if (this.isFoldedAtBufferRow(bufferRow)) {
      return this.unfoldBufferRow(bufferRow);
    } else {
      return this.foldBufferRow(bufferRow);
    }
  }
  isFoldedAtCursorRow() {
    return this.isFoldedAtBufferRow(this.getCursorBufferPosition().row);
  }
  isFoldedAtBufferRow(bufferRow) {
    const range = Range(
      Point(bufferRow, 0),
      Point(bufferRow, this.buffer.lineLengthForRow(bufferRow))
    );
    return this.displayLayer.foldsIntersectingBufferRange(range).length > 0;
  }
  isFoldedAtScreenRow(screenRow) {
    return this.isFoldedAtBufferRow(this.bufferRowForScreenRow(screenRow));
  }
  foldBufferRowRange(startRow, endRow) {
    return this.foldBufferRange(
      Range(Point(startRow, Infinity), Point(endRow, Infinity))
    );
  }
  foldBufferRange(range) {
    return this.displayLayer.foldBufferRange(range);
  }
  destroyFoldsIntersectingBufferRange(bufferRange) {
    return this.displayLayer.destroyFoldsIntersectingBufferRange(bufferRange);
  }
  destroyFoldsContainingBufferPositions(bufferPositions, excludeEndpoints) {
    return this.displayLayer.destroyFoldsContainingBufferPositions(
      bufferPositions,
      excludeEndpoints
    );
  }
  addGutter(options) {
    return this.gutterContainer.addGutter(options);
  }
  getGutters() {
    return this.gutterContainer.getGutters();
  }
  getLineNumberGutter() {
    return this.lineNumberGutter;
  }
  gutterWithName(name) {
    return this.gutterContainer.gutterWithName(name);
  }
  scrollToCursorPosition(options) {
    this.getLastCursor().autoscroll({
      center: options && options.center !== false
    });
  }
  scrollToBufferPosition(bufferPosition, options) {
    return this.scrollToScreenPosition(
      this.screenPositionForBufferPosition(bufferPosition),
      options
    );
  }
  scrollToScreenPosition(screenPosition, options) {
    this.scrollToScreenRange(
      new Range(screenPosition, screenPosition),
      options
    );
  }
  scrollToTop() {
    Grim.deprecate(
      'This is now a view method. Call TextEditorElement::scrollToTop instead.'
    );
    this.getElement().scrollToTop();
  }
  scrollToBottom() {
    Grim.deprecate(
      'This is now a view method. Call TextEditorElement::scrollToTop instead.'
    );
    this.getElement().scrollToBottom();
  }
  scrollToScreenRange(screenRange, options = {}) {
    if (options.clip !== false) screenRange = this.clipScreenRange(screenRange);
    const scrollEvent = { screenRange, options };
    if (this.component) this.component.didRequestAutoscroll(scrollEvent);
    this.emitter.emit('did-request-autoscroll', scrollEvent);
  }
  getHorizontalScrollbarHeight() {
    Grim.deprecate(
      'This is now a view method. Call TextEditorElement::getHorizontalScrollbarHeight instead.'
    );
    return this.getElement().getHorizontalScrollbarHeight();
  }
  getVerticalScrollbarWidth() {
    Grim.deprecate(
      'This is now a view method. Call TextEditorElement::getVerticalScrollbarWidth instead.'
    );
    return this.getElement().getVerticalScrollbarWidth();
  }
  pageUp() {
    this.moveUp(this.getRowsPerPage());
  }
  pageDown() {
    this.moveDown(this.getRowsPerPage());
  }
  selectPageUp() {
    this.selectUp(this.getRowsPerPage());
  }
  selectPageDown() {
    this.selectDown(this.getRowsPerPage());
  }
  getRowsPerPage() {
    if (this.component) {
      const clientHeight = this.component.getScrollContainerClientHeight();
      const lineHeight = this.component.getLineHeight();
      return Math.max(1, Math.ceil(clientHeight / lineHeight));
    } else {
      return 1;
    }
  }
  shouldAutoIndent() {
    return this.autoIndent;
  }
  shouldAutoIndentOnPaste() {
    return this.autoIndentOnPaste;
  }
  getScrollPastEnd() {
    if (this.getAutoHeight()) {
      return false;
    } else {
      return this.scrollPastEnd;
    }
  }
  getScrollSensitivity() {
    return this.scrollSensitivity;
  }
  getShowCursorOnSelection() {
    return this.showCursorOnSelection;
  }
  doesShowLineNumbers() {
    return this.showLineNumbers;
  }
  getUndoGroupingInterval() {
    return this.undoGroupingInterval;
  }
  getNonWordCharacters(position) {
    const languageMode = this.buffer.getLanguageMode();
    return (
      (languageMode.getNonWordCharacters &&
        languageMode.getNonWordCharacters(position || Point(0, 0))) ||
      DEFAULT_NON_WORD_CHARACTERS
    );
  }
  handleLanguageModeChange() {
    this.unfoldAll();
    if (this.languageModeSubscription) {
      this.languageModeSubscription.dispose();
      this.disposables.remove(this.languageModeSubscription);
    }
    const languageMode = this.buffer.getLanguageMode();
    if (
      this.component &&
      this.component.visible &&
      languageMode.startTokenizing
    ) {
      languageMode.startTokenizing();
    }
    this.languageModeSubscription =
      languageMode.onDidTokenize &&
      languageMode.onDidTokenize(() => {
        this.emitter.emit('did-tokenize');
      });
    if (this.languageModeSubscription)
      this.disposables.add(this.languageModeSubscription);
    this.emitter.emit('did-change-grammar', languageMode.grammar);
  }
  getElement() {
    if (!this.component) {
      if (!TextEditorComponent)
        TextEditorComponent = require('./text-editor-component');
      if (!TextEditorElement)
        TextEditorElement = require('./text-editor-element');
      this.component = new TextEditorComponent({
        model: this,
        updatedSynchronously: TextEditorElement.prototype.updatedSynchronously,
        initialScrollTopRow: this.initialScrollTopRow,
        initialScrollLeftColumn: this.initialScrollLeftColumn
      });
    }
    return this.component.element;
  }
  getAllowedLocations() {
    return ['center'];
  }
  getPlaceholderText() {
    return this.placeholderText;
  }
  setPlaceholderText(placeholderText) {
    this.updatePlaceholderText(placeholderText, true);
  }
  pixelPositionForBufferPosition(bufferPosition) {
    Grim.deprecate(
      'This method is deprecated on the model layer. Use `TextEditorElement::pixelPositionForBufferPosition` instead'
    );
    return this.getElement().pixelPositionForBufferPosition(bufferPosition);
  }
  pixelPositionForScreenPosition(screenPosition) {
    Grim.deprecate(
      'This method is deprecated on the model layer. Use `TextEditorElement::pixelPositionForScreenPosition` instead'
    );
    return this.getElement().pixelPositionForScreenPosition(screenPosition);
  }
  getVerticalScrollMargin() {
    const maxScrollMargin = Math.floor(
      (this.height / this.getLineHeightInPixels() - 1) / 2
    );
    return Math.min(this.verticalScrollMargin, maxScrollMargin);
  }
  setVerticalScrollMargin(verticalScrollMargin) {
    this.verticalScrollMargin = verticalScrollMargin;
    return this.verticalScrollMargin;
  }
  getHorizontalScrollMargin() {
    return Math.min(
      this.horizontalScrollMargin,
      Math.floor((this.width / this.getDefaultCharWidth() - 1) / 2)
    );
  }
  setHorizontalScrollMargin(horizontalScrollMargin) {
    this.horizontalScrollMargin = horizontalScrollMargin;
    return this.horizontalScrollMargin;
  }
  getLineHeightInPixels() {
    return this.lineHeightInPixels;
  }
  setLineHeightInPixels(lineHeightInPixels) {
    this.lineHeightInPixels = lineHeightInPixels;
    return this.lineHeightInPixels;
  }
  getKoreanCharWidth() {
    return this.koreanCharWidth;
  }
  getHalfWidthCharWidth() {
    return this.halfWidthCharWidth;
  }
  getDoubleWidthCharWidth() {
    return this.doubleWidthCharWidth;
  }
  getDefaultCharWidth() {
    return this.defaultCharWidth;
  }
  ratioForCharacter(character) {
    if (isKoreanCharacter(character)) {
      return this.getKoreanCharWidth() / this.getDefaultCharWidth();
    } else if (isHalfWidthCharacter(character)) {
      return this.getHalfWidthCharWidth() / this.getDefaultCharWidth();
    } else if (isDoubleWidthCharacter(character)) {
      return this.getDoubleWidthCharWidth() / this.getDefaultCharWidth();
    } else {
      return 1;
    }
  }
  setDefaultCharWidth(
    defaultCharWidth,
    doubleWidthCharWidth,
    halfWidthCharWidth,
    koreanCharWidth
  ) {
    if (doubleWidthCharWidth == null) {
      doubleWidthCharWidth = defaultCharWidth;
    }
    if (halfWidthCharWidth == null) {
      halfWidthCharWidth = defaultCharWidth;
    }
    if (koreanCharWidth == null) {
      koreanCharWidth = defaultCharWidth;
    }
    if (
      defaultCharWidth !== this.defaultCharWidth ||
      (doubleWidthCharWidth !== this.doubleWidthCharWidth &&
        halfWidthCharWidth !== this.halfWidthCharWidth &&
        koreanCharWidth !== this.koreanCharWidth)
    ) {
      this.defaultCharWidth = defaultCharWidth;
      this.doubleWidthCharWidth = doubleWidthCharWidth;
      this.halfWidthCharWidth = halfWidthCharWidth;
      this.koreanCharWidth = koreanCharWidth;
      if (this.isSoftWrapped()) {
        this.displayLayer.reset({
          softWrapColumn: this.getSoftWrapColumn()
        });
      }
    }
    return defaultCharWidth;
  }
  setHeight(height) {
    Grim.deprecate(
      'This is now a view method. Call TextEditorElement::setHeight instead.'
    );
    this.getElement().setHeight(height);
  }
  getHeight() {
    Grim.deprecate(
      'This is now a view method. Call TextEditorElement::getHeight instead.'
    );
    return this.getElement().getHeight();
  }
  getAutoHeight() {
    return this.autoHeight != null ? this.autoHeight : true;
  }
  getAutoWidth() {
    return this.autoWidth != null ? this.autoWidth : false;
  }
  setWidth(width) {
    Grim.deprecate(
      'This is now a view method. Call TextEditorElement::setWidth instead.'
    );
    this.getElement().setWidth(width);
  }
  getWidth() {
    Grim.deprecate(
      'This is now a view method. Call TextEditorElement::getWidth instead.'
    );
    return this.getElement().getWidth();
  }
  setFirstVisibleScreenRow(screenRow) {
    this.setScrollTopRow(screenRow);
  }
  getFirstVisibleScreenRow() {
    return this.getElement().component.getFirstVisibleRow();
  }
  getLastVisibleScreenRow() {
    return this.getElement().component.getLastVisibleRow();
  }
  getVisibleRowRange() {
    return [this.getFirstVisibleScreenRow(), this.getLastVisibleScreenRow()];
  }
  setFirstVisibleScreenColumn(column) {
    return this.setScrollLeftColumn(column);
  }
  getFirstVisibleScreenColumn() {
    return this.getElement().component.getFirstVisibleColumn();
  }
  getScrollTop() {
    Grim.deprecate(
      'This is now a view method. Call TextEditorElement::getScrollTop instead.'
    );
    return this.getElement().getScrollTop();
  }
  setScrollTop(scrollTop) {
    Grim.deprecate(
      'This is now a view method. Call TextEditorElement::setScrollTop instead.'
    );
    this.getElement().setScrollTop(scrollTop);
  }
  getScrollBottom() {
    Grim.deprecate(
      'This is now a view method. Call TextEditorElement::getScrollBottom instead.'
    );
    return this.getElement().getScrollBottom();
  }
  setScrollBottom(scrollBottom) {
    Grim.deprecate(
      'This is now a view method. Call TextEditorElement::setScrollBottom instead.'
    );
    this.getElement().setScrollBottom(scrollBottom);
  }
  getScrollLeft() {
    Grim.deprecate(
      'This is now a view method. Call TextEditorElement::getScrollLeft instead.'
    );
    return this.getElement().getScrollLeft();
  }
  setScrollLeft(scrollLeft) {
    Grim.deprecate(
      'This is now a view method. Call TextEditorElement::setScrollLeft instead.'
    );
    this.getElement().setScrollLeft(scrollLeft);
  }
  getScrollRight() {
    Grim.deprecate(
      'This is now a view method. Call TextEditorElement::getScrollRight instead.'
    );
    return this.getElement().getScrollRight();
  }
  setScrollRight(scrollRight) {
    Grim.deprecate(
      'This is now a view method. Call TextEditorElement::setScrollRight instead.'
    );
    this.getElement().setScrollRight(scrollRight);
  }
  getScrollHeight() {
    Grim.deprecate(
      'This is now a view method. Call TextEditorElement::getScrollHeight instead.'
    );
    return this.getElement().getScrollHeight();
  }
  getScrollWidth() {
    Grim.deprecate(
      'This is now a view method. Call TextEditorElement::getScrollWidth instead.'
    );
    return this.getElement().getScrollWidth();
  }
  getMaxScrollTop() {
    Grim.deprecate(
      'This is now a view method. Call TextEditorElement::getMaxScrollTop instead.'
    );
    return this.getElement().getMaxScrollTop();
  }
  getScrollTopRow() {
    return this.getElement().component.getScrollTopRow();
  }
  setScrollTopRow(scrollTopRow) {
    this.getElement().component.setScrollTopRow(scrollTopRow);
  }
  getScrollLeftColumn() {
    return this.getElement().component.getScrollLeftColumn();
  }
  setScrollLeftColumn(scrollLeftColumn) {
    this.getElement().component.setScrollLeftColumn(scrollLeftColumn);
  }
  intersectsVisibleRowRange(startRow, endRow) {
    Grim.deprecate(
      'This is now a view method. Call TextEditorElement::intersectsVisibleRowRange instead.'
    );
    return this.getElement().intersectsVisibleRowRange(startRow, endRow);
  }
  selectionIntersectsVisibleRowRange(selection) {
    Grim.deprecate(
      'This is now a view method. Call TextEditorElement::selectionIntersectsVisibleRowRange instead.'
    );
    return this.getElement().selectionIntersectsVisibleRowRange(selection);
  }
  screenPositionForPixelPosition(pixelPosition) {
    Grim.deprecate(
      'This is now a view method. Call TextEditorElement::screenPositionForPixelPosition instead.'
    );
    return this.getElement().screenPositionForPixelPosition(pixelPosition);
  }
  pixelRectForScreenRange(screenRange) {
    Grim.deprecate(
      'This is now a view method. Call TextEditorElement::pixelRectForScreenRange instead.'
    );
    return this.getElement().pixelRectForScreenRange(screenRange);
  }
  inspect() {
    return `<TextEditor ${this.id}>`;
  }
  emitWillInsertTextEvent(text) {
    let result = true;
    const cancel = () => {
      result = false;
    };
    this.emitter.emit('will-insert-text', { cancel, text });
    return result;
  }
  suggestedIndentForBufferRow(bufferRow, options) {
    const languageMode = this.buffer.getLanguageMode();
    return (
      languageMode.suggestedIndentForBufferRow &&
      languageMode.suggestedIndentForBufferRow(
        bufferRow,
        this.getTabLength(),
        options
      )
    );
  }
  autoIndentBufferRow(bufferRow, options) {
    const indentLevel = this.suggestedIndentForBufferRow(bufferRow, options);
    if (indentLevel?.then) {
      indentLevel.then(indentLevel => {
        if (typeof indentLevel === 'number') {
          this.setIndentationForBufferRow(bufferRow, indentLevel, options);
          this.buffer.groupLastChanges();
        } else if (indentLevel === undefined) {
          this.scheduleIndentAdjustment(true);
        }
      });
    } else if (typeof indentLevel === 'number') {
      return this.setIndentationForBufferRow(bufferRow, indentLevel, options);
    }
  }
  autoIndentBufferRows(startRow, endRow, options = {}) {
    const languageMode = this.buffer.getLanguageMode();
    let lastRowIndented = startRow - 1;
    if (languageMode.suggestedIndentForBufferRows) {
      let indents = languageMode.suggestedIndentForBufferRows(
        startRow, endRow, this.getTabLength(), options);
      if (indents !== null) {
        this.transact(() => {
          for (let [row, indent] of indents) {
            this.setIndentationForBufferRow(row, indent);
            lastRowIndented = row;
          }
        });
        if (lastRowIndented === endRow) { return; }
      }
      if (options.isPastedText) {
        return;
      }
    }
    let row = lastRowIndented + 1;
    while (row <= endRow) {
      this.autoIndentBufferRow(row);
      row++;
    }
  }
  autoDecreaseIndentForBufferRow(bufferRow) {
    const languageMode = this.buffer.getLanguageMode();
    if (!languageMode.suggestedIndentForEditedBufferRow) { return; }
    let indentLevel = languageMode.suggestedIndentForEditedBufferRow(
      bufferRow,
      this.getTabLength()
    );
    if (indentLevel?.then) {
      indentLevel.then(indentLevel => {
        if (typeof indentLevel === 'number') {
          this.setIndentationForBufferRow(bufferRow, indentLevel);
          this.buffer.groupLastChanges();
        }
      });
    } else {
      if (indentLevel != null)
        this.setIndentationForBufferRow(bufferRow, indentLevel);
    }
  }
  scheduleIndentAdjustment(force = false) {
    if (this.didAdjustIndent) return;
    if (this.autoIndentAtTransactionEndPromise && !force) return;
    let languageMode = this.buffer.getLanguageMode();
    if (!languageMode.atTransactionEnd) return;
    if (!languageMode.useAsyncParsing || !languageMode.useAsyncIndent) return;
    let promise = languageMode.atTransactionEnd().then(
      ({ range, autoIndentRequests }) => {
        if (!range || this.didAdjustIndent) return;
        if (autoIndentRequests === 0 && !force) return;
        this.transact(() => (
          this.autoIndentBufferRows(range.start.row, range.end.row)
        ));
        this.buffer.groupLastChanges();
        this.didAdjustIndent = true;
      }
    );
    this.autoIndentAtTransactionEndPromise = promise.finally(() => {
      this.autoIndentAtTransactionEndPromise = null;
      this.didAdjustIndent = false;
    });
  }
  toggleLineCommentForBufferRow(row) {
    this.toggleLineCommentsForBufferRows(row, row);
  }
  toggleLineCommentsForBufferRows(start, end, options = {}) {
    const languageMode = this.buffer.getLanguageMode();
    let { commentStartString, commentEndString } =
      (languageMode.commentStringsForPosition &&
        languageMode.commentStringsForPosition(new Point(start, 0))) ||
      {};
    if (!commentStartString) return;
    commentStartString = commentStartString.trim();
    if (commentEndString) {
      commentEndString = commentEndString.trim();
      const startDelimiterColumnRange = columnRangeForStartDelimiter(
        this.buffer.lineForRow(start),
        commentStartString
      );
      if (startDelimiterColumnRange) {
        const endDelimiterColumnRange = columnRangeForEndDelimiter(
          this.buffer.lineForRow(end),
          commentEndString
        );
        if (endDelimiterColumnRange) {
          this.buffer.transact(() => {
            this.buffer.delete([
              [end, endDelimiterColumnRange[0]],
              [end, endDelimiterColumnRange[1]]
            ]);
            this.buffer.delete([
              [start, startDelimiterColumnRange[0]],
              [start, startDelimiterColumnRange[1]]
            ]);
          });
        }
      } else {
        this.buffer.transact(() => {
          const indentLength = this.buffer.lineForRow(start).match(/^\s*/)[0]
            .length;
          this.buffer.insert([start, indentLength], commentStartString + ' ');
          this.buffer.insert(
            [end, this.buffer.lineLengthForRow(end)],
            ' ' + commentEndString
          );
          if (options.correctSelection && options.selection) {
            const endLineLength = this.buffer.lineLengthForRow(end);
            const oldRange = options.selection.getBufferRange();
            if (oldRange.isEmpty()) {
              if (oldRange.start.column === endLineLength) {
                const endCol = endLineLength - commentEndString.length - 1;
                options.selection.setBufferRange(
                  [[end, endCol], [end, endCol]],
                  { autoscroll: false }
                );
              }
            } else {
              const startDelta =
                oldRange.start.column === indentLength
                  ? [0, commentStartString.length + 1]
                  : [0, 0];
              const endDelta =
                oldRange.end.column === endLineLength
                  ? [0, -commentEndString.length - 1]
                  : [0, 0];
              options.selection.setBufferRange(
                oldRange.translate(startDelta, endDelta),
                { autoscroll: false }
              );
            }
          }
        });
      }
    } else {
      let hasCommentedLines = false;
      let hasUncommentedLines = false;
      for (let row = start; row <= end; row++) {
        const line = this.buffer.lineForRow(row);
        if (NON_WHITESPACE_REGEXP.test(line)) {
          if (columnRangeForStartDelimiter(line, commentStartString)) {
            hasCommentedLines = true;
          } else {
            hasUncommentedLines = true;
          }
        }
      }
      const shouldUncomment = hasCommentedLines && !hasUncommentedLines;
      if (shouldUncomment) {
        for (let row = start; row <= end; row++) {
          const columnRange = columnRangeForStartDelimiter(
            this.buffer.lineForRow(row),
            commentStartString
          );
          if (columnRange)
            this.buffer.delete([[row, columnRange[0]], [row, columnRange[1]]]);
        }
      } else {
        let minIndentLevel = Infinity;
        let minBlankIndentLevel = Infinity;
        for (let row = start; row <= end; row++) {
          const line = this.buffer.lineForRow(row);
          const indentLevel = this.indentLevelForLine(line);
          if (NON_WHITESPACE_REGEXP.test(line)) {
            if (indentLevel < minIndentLevel) minIndentLevel = indentLevel;
          } else {
            if (indentLevel < minBlankIndentLevel)
              minBlankIndentLevel = indentLevel;
          }
        }
        minIndentLevel = Number.isFinite(minIndentLevel)
          ? minIndentLevel
          : Number.isFinite(minBlankIndentLevel)
          ? minBlankIndentLevel
          : 0;
        const indentString = this.buildIndentString(minIndentLevel);
        for (let row = start; row <= end; row++) {
          const line = this.buffer.lineForRow(row);
          if (NON_WHITESPACE_REGEXP.test(line)) {
            const indentColumn = columnForIndentLevel(
              line,
              minIndentLevel,
              this.getTabLength()
            );
            this.buffer.insert(
              Point(row, indentColumn),
              commentStartString + ' '
            );
          } else {
            this.buffer.setTextInRange(
              new Range(new Point(row, 0), new Point(row, Infinity)),
              indentString + commentStartString + ' '
            );
          }
        }
      }
    }
  }
  getCommentDelimitersForBufferPosition(point) {
    point = Point.fromObject(point);
    const languageMode = this.buffer.getLanguageMode();
    let {
      commentStartString,
      commentEndString,
      commentDelimiters
    } = languageMode.commentStringsForPosition(point);
    if (commentDelimiters) {
      return commentDelimiters;
    } else {
      if (commentStartString && commentEndString) {
        return { block: [commentStartString.trim(), commentEndString.trim()] };
      } else if (commentStartString && !commentEndString) {
        return { line: commentStartString.trim() };
      } else {
        return null;
      }
    }
  }
  rowRangeForParagraphAtBufferRow(bufferRow) {
    if (!NON_WHITESPACE_REGEXP.test(this.lineTextForBufferRow(bufferRow)))
      return;
    const languageMode = this.buffer.getLanguageMode();
    const isCommented = languageMode.isRowCommented(bufferRow);
    let startRow = bufferRow;
    while (startRow > 0) {
      if (!NON_WHITESPACE_REGEXP.test(this.lineTextForBufferRow(startRow - 1)))
        break;
      if (languageMode.isRowCommented(startRow - 1) !== isCommented) break;
      startRow--;
    }
    let endRow = bufferRow;
    const rowCount = this.getLineCount();
    while (endRow + 1 < rowCount) {
      if (!NON_WHITESPACE_REGEXP.test(this.lineTextForBufferRow(endRow + 1)))
        break;
      if (languageMode.isRowCommented(endRow + 1) !== isCommented) break;
      endRow++;
    }
    return new Range(
      new Point(startRow, 0),
      new Point(endRow, this.buffer.lineLengthForRow(endRow))
    );
  }
};
function columnForIndentLevel(line, indentLevel, tabLength) {
  let column = 0;
  let indentLength = 0;
  const goalIndentLength = indentLevel * tabLength;
  while (indentLength < goalIndentLength) {
    const char = line[column];
    if (char === '\t') {
      indentLength += tabLength - (indentLength % tabLength);
    } else if (char === ' ') {
      indentLength++;
    } else {
      break;
    }
    column++;
  }
  return column;
}
function columnRangeForStartDelimiter(line, delimiter) {
  const startColumn = line.search(NON_WHITESPACE_REGEXP);
  if (startColumn === -1) return null;
  if (!line.startsWith(delimiter, startColumn)) return null;
  let endColumn = startColumn + delimiter.length;
  if (line[endColumn] === ' ') endColumn++;
  return [startColumn, endColumn];
}
function columnRangeForEndDelimiter(line, delimiter) {
  let startColumn = line.lastIndexOf(delimiter);
  if (startColumn === -1) return null;
  const endColumn = startColumn + delimiter.length;
  if (NON_WHITESPACE_REGEXP.test(line.slice(endColumn))) return null;
  if (line[startColumn - 1] === ' ') startColumn--;
  return [startColumn, endColumn];
}
class ChangeEvent {
  constructor({ oldRange, newRange }) {
    this.oldRange = oldRange;
    this.newRange = newRange;
  }
  get start() {
    return this.newRange.start;
  }
  get oldExtent() {
    return this.oldRange.getExtent();
  }
  get newExtent() {
    return this.newRange.getExtent();
  }
}

================
File: src/text-mate-language-mode.js
================
const _ = require('underscore-plus');
const { CompositeDisposable, Emitter } = require('event-kit');
const { Point, Range } = require('text-buffer');
const TokenizedLine = require('./tokenized-line');
const TokenIterator = require('./token-iterator');
const ScopeDescriptor = require('./scope-descriptor');
const NullGrammar = require('./null-grammar');
const { OnigScanner } = require('second-mate');
const {
  toFirstMateScopeId,
  fromFirstMateScopeId
} = require('./first-mate-helpers');
const { selectorMatchesAnyScope } = require('./selectors');
const { normalizeDelimiters, commentStringsFromDelimiters } = require('./comment-utils.js');
const NON_WHITESPACE_REGEX = /\S/;
let nextId = 0;
const prefixedScopes = new Map();
class TextMateLanguageMode {
  constructor(params) {
    this.emitter = new Emitter();
    this.disposables = new CompositeDisposable();
    this.tokenIterator = new TokenIterator(this);
    this.regexesByPattern = {};
    this.alive = true;
    this.tokenizationStarted = false;
    this.id = params.id != null ? params.id : nextId++;
    this.buffer = params.buffer;
    this.largeFileMode = params.largeFileMode;
    this.config = params.config ?? atom.config;
    this.largeFileMode =
      params.largeFileMode != null
        ? params.largeFileMode
        : this.buffer.buffer.getLength() >= 2 * 1024 * 1024;
    this.grammar = params.grammar || NullGrammar;
    this.rootScopeDescriptor = new ScopeDescriptor({
      scopes: [this.grammar.scopeName]
    });
    this.disposables.add(
      this.grammar.onDidUpdate(() => this.retokenizeLines())
    );
    this.retokenizeLines();
  }
  destroy() {
    if (!this.alive) return;
    this.alive = false;
    this.disposables.dispose();
    this.tokenizedLines.length = 0;
  }
  isAlive() {
    return this.alive;
  }
  isDestroyed() {
    return !this.alive;
  }
  getGrammar() {
    return this.grammar;
  }
  getLanguageId() {
    return this.grammar.scopeName;
  }
  getNonWordCharacters(position) {
    const scope = this.scopeDescriptorForPosition(position);
    return this.config.get('editor.nonWordCharacters', { scope });
  }
  suggestedIndentForBufferRow(bufferRow, tabLength, options) {
    const line = this.buffer.lineForRow(bufferRow);
    const tokenizedLine = this.tokenizedLineForRow(bufferRow);
    const iterator = tokenizedLine.getTokenIterator();
    iterator.next();
    const scopeDescriptor = new ScopeDescriptor({
      scopes: iterator.getScopes()
    });
    return this._suggestedIndentForLineWithScopeAtBufferRow(
      bufferRow,
      line,
      scopeDescriptor,
      tabLength,
      options
    );
  }
  suggestedIndentForLineAtBufferRow(bufferRow, line, tabLength) {
    const tokenizedLine = this.buildTokenizedLineForRowWithText(
      bufferRow,
      line
    );
    const iterator = tokenizedLine.getTokenIterator();
    iterator.next();
    const scopeDescriptor = new ScopeDescriptor({
      scopes: iterator.getScopes()
    });
    return this._suggestedIndentForLineWithScopeAtBufferRow(
      bufferRow,
      line,
      scopeDescriptor,
      tabLength
    );
  }
  suggestedIndentForEditedBufferRow(bufferRow, tabLength) {
    const line = this.buffer.lineForRow(bufferRow);
    const currentIndentLevel = this.indentLevelForLine(line, tabLength);
    if (currentIndentLevel === 0) return;
    const scopeDescriptor = this.scopeDescriptorForPosition(
      new Point(bufferRow, 0)
    );
    const decreaseIndentRegex = this.decreaseIndentRegexForScopeDescriptor(
      scopeDescriptor
    );
    if (!decreaseIndentRegex) return;
    if (!decreaseIndentRegex.findNextMatchSync(line)) return;
    const precedingRow = this.buffer.previousNonBlankRow(bufferRow);
    if (precedingRow == null) return;
    const precedingLine = this.buffer.lineForRow(precedingRow);
    let desiredIndentLevel = this.indentLevelForLine(precedingLine, tabLength);
    const increaseIndentRegex = this.increaseIndentRegexForScopeDescriptor(
      scopeDescriptor
    );
    if (increaseIndentRegex) {
      if (!increaseIndentRegex.findNextMatchSync(precedingLine)) desiredIndentLevel -= 1;
    }
    const decreaseNextIndentRegex = this.decreaseNextIndentRegexForScopeDescriptor(
      scopeDescriptor
    );
    if (decreaseNextIndentRegex) {
      if (decreaseNextIndentRegex.findNextMatchSync(precedingLine))
        desiredIndentLevel -= 1;
    }
    if (desiredIndentLevel < 0) return 0;
    if (desiredIndentLevel >= currentIndentLevel) return;
    return desiredIndentLevel;
  }
  _suggestedIndentForLineWithScopeAtBufferRow(
    bufferRow,
    line,
    scopeDescriptor,
    tabLength,
    options
  ) {
    const increaseIndentRegex = this.increaseIndentRegexForScopeDescriptor(
      scopeDescriptor
    );
    const decreaseIndentRegex = this.decreaseIndentRegexForScopeDescriptor(
      scopeDescriptor
    );
    const decreaseNextIndentRegex = this.decreaseNextIndentRegexForScopeDescriptor(
      scopeDescriptor
    );
    let precedingRow;
    if (!options || options.skipBlankLines !== false) {
      precedingRow = this.buffer.previousNonBlankRow(bufferRow);
      if (precedingRow == null) return 0;
    } else {
      precedingRow = bufferRow - 1;
      if (precedingRow < 0) return 0;
    }
    const precedingLine = this.buffer.lineForRow(precedingRow);
    let desiredIndentLevel = this.indentLevelForLine(precedingLine, tabLength);
    if (!increaseIndentRegex) return desiredIndentLevel;
    if (!this.isRowCommented(precedingRow)) {
      if (increaseIndentRegex && increaseIndentRegex.findNextMatchSync(precedingLine))
        desiredIndentLevel += 1;
      if (
        decreaseNextIndentRegex &&
        decreaseNextIndentRegex.findNextMatchSync(precedingLine)
      )
        desiredIndentLevel -= 1;
    }
    if (!this.buffer.isRowBlank(precedingRow)) {
      if (decreaseIndentRegex && decreaseIndentRegex.findNextMatchSync(line))
        desiredIndentLevel -= 1;
    }
    return Math.max(desiredIndentLevel, 0);
  }
  commentStringsForPosition(position) {
    const scope = this.scopeDescriptorForPosition(position);
    const commentStartEntries = this.config.getAll('editor.commentStart', {
      scope
    });
    const commentEndEntries = this.config.getAll('editor.commentEnd', {
      scope
    });
    const commentStartEntry = commentStartEntries[0];
    const commentEndEntry = commentEndEntries.find(entry => {
      return entry.scopeSelector === commentStartEntry.scopeSelector;
    });
    const commentDelimiters = this.config.get('editor.commentDelimiters', { scope });
    if (commentStartEntry) {
      return {
        commentStartString: commentStartEntry && commentStartEntry.value,
        commentEndString: commentEndEntry && commentEndEntry.value,
        commentDelimiters: commentDelimiters && normalizeDelimiters(commentDelimiters)
      };
    } else if (commentDelimiters) {
      return commentStringsFromDelimiters(commentDelimiters);
    }
  }
  buildHighlightIterator() {
    return new TextMateHighlightIterator(this);
  }
  classNameForScopeId(id) {
    const scope = this.grammar.scopeForId(toFirstMateScopeId(id));
    if (scope) {
      let prefixedScope = prefixedScopes.get(scope);
      if (prefixedScope) {
        return prefixedScope;
      } else {
        prefixedScope = `syntax--${scope.replace(/\./g, ' syntax--')}`;
        prefixedScopes.set(scope, prefixedScope);
        return prefixedScope;
      }
    } else {
      return null;
    }
  }
  getInvalidatedRanges() {
    return [];
  }
  onDidChangeHighlighting(fn) {
    return this.emitter.on('did-change-highlighting', fn);
  }
  onDidTokenize(callback) {
    return this.emitter.on('did-tokenize', callback);
  }
  getGrammarSelectionContent() {
    return this.buffer.getTextInRange([[0, 0], [10, 0]]);
  }
  updateForInjection(grammar) {
    if (!grammar.injectionSelector) return;
    for (const tokenizedLine of this.tokenizedLines) {
      if (tokenizedLine) {
        for (let token of tokenizedLine.tokens) {
          if (grammar.injectionSelector.matches(token.scopes)) {
            this.retokenizeLines();
            return;
          }
        }
      }
    }
  }
  retokenizeLines() {
    if (!this.alive) return;
    this.fullyTokenized = false;
    this.tokenizedLines = new Array(this.buffer.getLineCount());
    this.invalidRows = [];
    if (this.largeFileMode || this.grammar.name === 'Null Grammar') {
      this.markTokenizationComplete();
    } else {
      this.invalidateRow(0);
    }
  }
  startTokenizing() {
    this.tokenizationStarted = true;
    if (this.grammar.name !== 'Null Grammar' && !this.largeFileMode) {
      this.tokenizeInBackground();
    }
  }
  tokenizeInBackground() {
    if (!this.tokenizationStarted || this.pendingChunk || !this.alive) return;
    this.pendingChunk = true;
    _.defer(() => {
      this.pendingChunk = false;
      if (this.isAlive() && this.buffer.isAlive()) this.tokenizeNextChunk();
    });
  }
  tokenizeNextChunk() {
    let rowsRemaining = this.chunkSize;
    while (this.firstInvalidRow() != null && rowsRemaining > 0) {
      let endRow, filledRegion;
      const startRow = this.invalidRows.shift();
      const lastRow = this.buffer.getLastRow();
      if (startRow > lastRow) continue;
      let row = startRow;
      while (true) {
        const previousStack = this.stackForRow(row);
        this.tokenizedLines[row] = this.buildTokenizedLineForRow(
          row,
          this.stackForRow(row - 1),
          this.openScopesForRow(row)
        );
        if (--rowsRemaining === 0) {
          filledRegion = false;
          endRow = row;
          break;
        }
        if (
          row === lastRow ||
          _.isEqual(this.stackForRow(row), previousStack)
        ) {
          filledRegion = true;
          endRow = row;
          break;
        }
        row++;
      }
      this.validateRow(endRow);
      if (!filledRegion) this.invalidateRow(endRow + 1);
      this.emitter.emit(
        'did-change-highlighting',
        Range(Point(startRow, 0), Point(endRow + 1, 0))
      );
    }
    if (this.firstInvalidRow() != null) {
      this.tokenizeInBackground();
    } else {
      this.markTokenizationComplete();
    }
  }
  markTokenizationComplete() {
    if (!this.fullyTokenized) {
      this.emitter.emit('did-tokenize');
    }
    this.fullyTokenized = true;
  }
  firstInvalidRow() {
    return this.invalidRows[0];
  }
  validateRow(row) {
    while (this.invalidRows[0] <= row) this.invalidRows.shift();
  }
  invalidateRow(row) {
    this.invalidRows.push(row);
    this.invalidRows.sort((a, b) => a - b);
    this.tokenizeInBackground();
  }
  updateInvalidRows(start, end, delta) {
    this.invalidRows = this.invalidRows.map(row => {
      if (row < start) {
        return row;
      } else if (start <= row && row <= end) {
        return end + delta + 1;
      } else if (row > end) {
        return row + delta;
      }
    });
  }
  bufferDidChange(e) {
    this.changeCount = this.buffer.changeCount;
    const { oldRange, newRange } = e;
    const start = oldRange.start.row;
    const end = oldRange.end.row;
    const delta = newRange.end.row - oldRange.end.row;
    const oldLineCount = oldRange.end.row - oldRange.start.row + 1;
    const newLineCount = newRange.end.row - newRange.start.row + 1;
    this.updateInvalidRows(start, end, delta);
    const previousEndStack = this.stackForRow(end);
    if (this.largeFileMode || this.grammar.name === 'Null Grammar') {
      _.spliceWithArray(
        this.tokenizedLines,
        start,
        oldLineCount,
        new Array(newLineCount)
      );
    } else {
      const newTokenizedLines = this.buildTokenizedLinesForRows(
        start,
        end + delta,
        this.stackForRow(start - 1),
        this.openScopesForRow(start)
      );
      _.spliceWithArray(
        this.tokenizedLines,
        start,
        oldLineCount,
        newTokenizedLines
      );
      const newEndStack = this.stackForRow(end + delta);
      if (newEndStack && !_.isEqual(newEndStack, previousEndStack)) {
        this.invalidateRow(end + delta + 1);
      }
    }
  }
  bufferDidFinishTransaction() {}
  isFoldableAtRow(row) {
    return this.endRowForFoldAtRow(row, 1, true) != null;
  }
  buildTokenizedLinesForRows(
    startRow,
    endRow,
    startingStack,
    startingopenScopes
  ) {
    let ruleStack = startingStack;
    let openScopes = startingopenScopes;
    const stopTokenizingAt = startRow + this.chunkSize;
    const tokenizedLines = [];
    for (let row = startRow, end = endRow; row <= end; row++) {
      let tokenizedLine;
      if ((ruleStack || row === 0) && row < stopTokenizingAt) {
        tokenizedLine = this.buildTokenizedLineForRow(
          row,
          ruleStack,
          openScopes
        );
        ruleStack = tokenizedLine.ruleStack;
        openScopes = this.scopesFromTags(openScopes, tokenizedLine.tags);
      }
      tokenizedLines.push(tokenizedLine);
    }
    if (endRow >= stopTokenizingAt) {
      this.invalidateRow(stopTokenizingAt);
      this.tokenizeInBackground();
    }
    return tokenizedLines;
  }
  buildTokenizedLineForRow(row, ruleStack, openScopes) {
    return this.buildTokenizedLineForRowWithText(
      row,
      this.buffer.lineForRow(row),
      ruleStack,
      openScopes
    );
  }
  buildTokenizedLineForRowWithText(
    row,
    text,
    currentRuleStack = this.stackForRow(row - 1),
    openScopes = this.openScopesForRow(row)
  ) {
    const lineEnding = this.buffer.lineEndingForRow(row);
    const { tags, ruleStack } = this.grammar.tokenizeLine(
      text,
      currentRuleStack,
      row === 0,
      false
    );
    return new TokenizedLine({
      openScopes,
      text,
      tags,
      ruleStack,
      lineEnding,
      tokenIterator: this.tokenIterator,
      grammar: this.grammar
    });
  }
  tokenizedLineForRow(bufferRow) {
    if (bufferRow >= 0 && bufferRow <= this.buffer.getLastRow()) {
      const tokenizedLine = this.tokenizedLines[bufferRow];
      if (tokenizedLine) {
        return tokenizedLine;
      } else {
        const text = this.buffer.lineForRow(bufferRow);
        const lineEnding = this.buffer.lineEndingForRow(bufferRow);
        const tags = [
          this.grammar.startIdForScope(this.grammar.scopeName),
          text.length,
          this.grammar.endIdForScope(this.grammar.scopeName)
        ];
        this.tokenizedLines[bufferRow] = new TokenizedLine({
          openScopes: [],
          text,
          tags,
          lineEnding,
          tokenIterator: this.tokenIterator,
          grammar: this.grammar
        });
        return this.tokenizedLines[bufferRow];
      }
    }
  }
  tokenizedLinesForRows(startRow, endRow) {
    const result = [];
    for (let row = startRow, end = endRow; row <= end; row++) {
      result.push(this.tokenizedLineForRow(row));
    }
    return result;
  }
  stackForRow(bufferRow) {
    return (
      this.tokenizedLines[bufferRow] && this.tokenizedLines[bufferRow].ruleStack
    );
  }
  openScopesForRow(bufferRow) {
    const precedingLine = this.tokenizedLines[bufferRow - 1];
    if (precedingLine) {
      return this.scopesFromTags(precedingLine.openScopes, precedingLine.tags);
    } else {
      return [];
    }
  }
  scopesFromTags(startingScopes, tags) {
    const scopes = startingScopes.slice();
    for (const tag of tags) {
      if (tag < 0) {
        if (tag % 2 === -1) {
          scopes.push(tag);
        } else {
          const matchingStartTag = tag + 1;
          while (true) {
            if (scopes.pop() === matchingStartTag) break;
            if (scopes.length === 0) {
              break;
            }
          }
        }
      }
    }
    return scopes;
  }
  indentLevelForLine(line, tabLength) {
    let indentLength = 0;
    for (let i = 0, { length } = line; i < length; i++) {
      const char = line[i];
      if (char === '\t') {
        indentLength += tabLength - (indentLength % tabLength);
      } else if (char === ' ') {
        indentLength++;
      } else {
        break;
      }
    }
    return indentLength / tabLength;
  }
  scopeDescriptorForPosition(position) {
    let scopes;
    const { row, column } = this.buffer.clipPosition(
      Point.fromObject(position)
    );
    const iterator = this.tokenizedLineForRow(row).getTokenIterator();
    while (iterator.next()) {
      if (iterator.getBufferEnd() > column) {
        scopes = iterator.getScopes();
        break;
      }
    }
    if (!scopes) {
      scopes = iterator.getScopes();
      scopes.push(...iterator.getScopeEnds().reverse());
    }
    return new ScopeDescriptor({ scopes });
  }
  tokenForPosition(position) {
    const { row, column } = Point.fromObject(position);
    return this.tokenizedLineForRow(row).tokenAtBufferColumn(column);
  }
  tokenStartPositionForPosition(position) {
    let { row, column } = Point.fromObject(position);
    column = this.tokenizedLineForRow(row).tokenStartColumnForBufferColumn(
      column
    );
    return new Point(row, column);
  }
  bufferRangeForScopeAtPosition(selector, position) {
    let endColumn, tag, tokenIndex;
    position = Point.fromObject(position);
    const { openScopes, tags } = this.tokenizedLineForRow(position.row);
    const scopes = openScopes.map(tag => this.grammar.scopeForId(tag));
    let startColumn = 0;
    for (tokenIndex = 0; tokenIndex < tags.length; tokenIndex++) {
      tag = tags[tokenIndex];
      if (tag < 0) {
        if (tag % 2 === -1) {
          scopes.push(this.grammar.scopeForId(tag));
        } else {
          scopes.pop();
        }
      } else {
        endColumn = startColumn + tag;
        if (endColumn >= position.column) {
          break;
        } else {
          startColumn = endColumn;
        }
      }
    }
    if (!selectorMatchesAnyScope(selector, scopes)) return;
    const startScopes = scopes.slice();
    for (
      let startTokenIndex = tokenIndex - 1;
      startTokenIndex >= 0;
      startTokenIndex--
    ) {
      tag = tags[startTokenIndex];
      if (tag < 0) {
        if (tag % 2 === -1) {
          startScopes.pop();
        } else {
          startScopes.push(this.grammar.scopeForId(tag));
        }
      } else {
        if (!selectorMatchesAnyScope(selector, startScopes)) {
          break;
        }
        startColumn -= tag;
      }
    }
    const endScopes = scopes.slice();
    for (
      let endTokenIndex = tokenIndex + 1, end = tags.length;
      endTokenIndex < end;
      endTokenIndex++
    ) {
      tag = tags[endTokenIndex];
      if (tag < 0) {
        if (tag % 2 === -1) {
          endScopes.push(this.grammar.scopeForId(tag));
        } else {
          endScopes.pop();
        }
      } else {
        if (!selectorMatchesAnyScope(selector, endScopes)) {
          break;
        }
        endColumn += tag;
      }
    }
    return new Range(
      new Point(position.row, startColumn),
      new Point(position.row, endColumn)
    );
  }
  isRowCommented(row) {
    return this.tokenizedLines[row] && this.tokenizedLines[row].isComment();
  }
  getFoldableRangeContainingPoint(point, tabLength) {
    if (point.column >= this.buffer.lineLengthForRow(point.row)) {
      const endRow = this.endRowForFoldAtRow(point.row, tabLength);
      if (endRow != null) {
        return Range(Point(point.row, Infinity), Point(endRow, Infinity));
      }
    }
    for (let row = point.row - 1; row >= 0; row--) {
      const endRow = this.endRowForFoldAtRow(row, tabLength);
      if (endRow != null && endRow >= point.row) {
        return Range(Point(row, Infinity), Point(endRow, Infinity));
      }
    }
    return null;
  }
  getFoldableRangesAtIndentLevel(indentLevel, tabLength) {
    const result = [];
    let row = 0;
    const lineCount = this.buffer.getLineCount();
    while (row < lineCount) {
      if (
        this.indentLevelForLine(this.buffer.lineForRow(row), tabLength) ===
        indentLevel
      ) {
        const endRow = this.endRowForFoldAtRow(row, tabLength);
        if (endRow != null) {
          result.push(Range(Point(row, Infinity), Point(endRow, Infinity)));
          row = endRow + 1;
          continue;
        }
      }
      row++;
    }
    return result;
  }
  getFoldableRanges(tabLength) {
    const result = [];
    let row = 0;
    const lineCount = this.buffer.getLineCount();
    while (row < lineCount) {
      const endRow = this.endRowForFoldAtRow(row, tabLength);
      if (endRow != null) {
        result.push(Range(Point(row, Infinity), Point(endRow, Infinity)));
      }
      row++;
    }
    return result;
  }
  endRowForFoldAtRow(row, tabLength, existenceOnly = false) {
    if (this.isRowCommented(row)) {
      return this.endRowForCommentFoldAtRow(row, existenceOnly);
    } else {
      return this.endRowForCodeFoldAtRow(row, tabLength, existenceOnly);
    }
  }
  endRowForCommentFoldAtRow(row, existenceOnly) {
    if (this.isRowCommented(row - 1)) return;
    let endRow;
    for (
      let nextRow = row + 1, end = this.buffer.getLineCount();
      nextRow < end;
      nextRow++
    ) {
      if (!this.isRowCommented(nextRow)) break;
      endRow = nextRow;
      if (existenceOnly) break;
    }
    return endRow;
  }
  endRowForCodeFoldAtRow(row, tabLength, existenceOnly) {
    let foldEndRow;
    const line = this.buffer.lineForRow(row);
    if (!NON_WHITESPACE_REGEX.test(line)) return;
    const startIndentLevel = this.indentLevelForLine(line, tabLength);
    const scopeDescriptor = this.scopeDescriptorForPosition([row, 0]);
    const foldEndRegex = this.foldEndRegexForScopeDescriptor(scopeDescriptor);
    for (
      let nextRow = row + 1, end = this.buffer.getLineCount();
      nextRow < end;
      nextRow++
    ) {
      const line = this.buffer.lineForRow(nextRow);
      if (!NON_WHITESPACE_REGEX.test(line)) continue;
      const indentation = this.indentLevelForLine(line, tabLength);
      if (indentation < startIndentLevel) {
        break;
      } else if (indentation === startIndentLevel) {
        if (foldEndRegex && foldEndRegex.findNextMatchSync(line)) foldEndRow = nextRow;
        break;
      }
      foldEndRow = nextRow;
      if (existenceOnly) break;
    }
    return foldEndRow;
  }
  increaseIndentRegexForScopeDescriptor(scope) {
    return this.regexForPattern(
      this.config.get('editor.increaseIndentPattern', { scope })
    );
  }
  decreaseIndentRegexForScopeDescriptor(scope) {
    return this.regexForPattern(
      this.config.get('editor.decreaseIndentPattern', { scope })
    );
  }
  decreaseNextIndentRegexForScopeDescriptor(scope) {
    return this.regexForPattern(
      this.config.get('editor.decreaseNextIndentPattern', { scope })
    );
  }
  foldEndRegexForScopeDescriptor(scope) {
    return this.regexForPattern(
      this.config.get('editor.foldEndPattern', { scope })
    );
  }
  regexForPattern(pattern) {
    if (pattern) {
      if (!this.regexesByPattern[pattern]) {
        this.regexesByPattern[pattern] = new OnigScanner([pattern]);
      }
      return this.regexesByPattern[pattern];
    }
  }
  logLines(start = 0, end = this.buffer.getLastRow()) {
    for (let row = start; row <= end; row++) {
      const line = this.tokenizedLines[row].text;
      console.log(row, line, line.length);
    }
  }
}
TextMateLanguageMode.prototype.chunkSize = 50;
class TextMateHighlightIterator {
  constructor(languageMode) {
    this.languageMode = languageMode;
    this.openScopeIds = null;
    this.closeScopeIds = null;
  }
  seek(position) {
    this.openScopeIds = [];
    this.closeScopeIds = [];
    this.tagIndex = null;
    const currentLine = this.languageMode.tokenizedLineForRow(position.row);
    this.currentLineTags = currentLine.tags;
    this.currentLineLength = currentLine.text.length;
    const containingScopeIds = currentLine.openScopes.map(id =>
      fromFirstMateScopeId(id)
    );
    let currentColumn = 0;
    for (let index = 0; index < this.currentLineTags.length; index++) {
      const tag = this.currentLineTags[index];
      if (tag >= 0) {
        if (currentColumn >= position.column) {
          this.tagIndex = index;
          break;
        } else {
          currentColumn += tag;
          while (this.closeScopeIds.length > 0) {
            this.closeScopeIds.shift();
            containingScopeIds.pop();
          }
          while (this.openScopeIds.length > 0) {
            const openTag = this.openScopeIds.shift();
            containingScopeIds.push(openTag);
          }
        }
      } else {
        const scopeId = fromFirstMateScopeId(tag);
        if ((tag & 1) === 0) {
          if (this.openScopeIds.length > 0) {
            if (currentColumn >= position.column) {
              this.tagIndex = index;
              break;
            } else {
              while (this.closeScopeIds.length > 0) {
                this.closeScopeIds.shift();
                containingScopeIds.pop();
              }
              while (this.openScopeIds.length > 0) {
                const openTag = this.openScopeIds.shift();
                containingScopeIds.push(openTag);
              }
            }
          }
          this.closeScopeIds.push(scopeId);
        } else {
          this.openScopeIds.push(scopeId);
        }
      }
    }
    if (this.tagIndex == null) {
      this.tagIndex = this.currentLineTags.length;
    }
    this.position = Point(
      position.row,
      Math.min(this.currentLineLength, currentColumn)
    );
    return containingScopeIds;
  }
  moveToSuccessor() {
    this.openScopeIds = [];
    this.closeScopeIds = [];
    while (true) {
      if (this.tagIndex === this.currentLineTags.length) {
        if (this.isAtTagBoundary()) {
          break;
        } else if (!this.moveToNextLine()) {
          return false;
        }
      } else {
        const tag = this.currentLineTags[this.tagIndex];
        if (tag >= 0) {
          if (this.isAtTagBoundary()) {
            break;
          } else {
            this.position = Point(
              this.position.row,
              Math.min(
                this.currentLineLength,
                this.position.column + this.currentLineTags[this.tagIndex]
              )
            );
          }
        } else {
          const scopeId = fromFirstMateScopeId(tag);
          if ((tag & 1) === 0) {
            if (this.openScopeIds.length > 0) {
              break;
            } else {
              this.closeScopeIds.push(scopeId);
            }
          } else {
            this.openScopeIds.push(scopeId);
          }
        }
        this.tagIndex++;
      }
    }
    return true;
  }
  getPosition() {
    return this.position;
  }
  getCloseScopeIds() {
    return this.closeScopeIds.slice();
  }
  getOpenScopeIds() {
    return this.openScopeIds.slice();
  }
  moveToNextLine() {
    this.position = Point(this.position.row + 1, 0);
    const tokenizedLine = this.languageMode.tokenizedLineForRow(
      this.position.row
    );
    if (tokenizedLine == null) {
      return false;
    } else {
      this.currentLineTags = tokenizedLine.tags;
      this.currentLineLength = tokenizedLine.text.length;
      this.tagIndex = 0;
      return true;
    }
  }
  isAtTagBoundary() {
    return this.closeScopeIds.length > 0 || this.openScopeIds.length > 0;
  }
}
TextMateLanguageMode.TextMateHighlightIterator = TextMateHighlightIterator;
module.exports = TextMateLanguageMode;

================
File: src/text-utils.js
================
const isHighSurrogate = charCode => charCode >= 0xd800 && charCode <= 0xdbff;
const isLowSurrogate = charCode => charCode >= 0xdc00 && charCode <= 0xdfff;
const isVariationSelector = charCode =>
  charCode >= 0xfe00 && charCode <= 0xfe0f;
const isCombiningCharacter = charCode =>
  (charCode >= 0x0300 && charCode <= 0x036f) ||
  (charCode >= 0x1ab0 && charCode <= 0x1aff) ||
  (charCode >= 0x1dc0 && charCode <= 0x1dff) ||
  (charCode >= 0x20d0 && charCode <= 0x20ff) ||
  (charCode >= 0xfe20 && charCode <= 0xfe2f);
const isSurrogatePair = (charCodeA, charCodeB) =>
  isHighSurrogate(charCodeA) && isLowSurrogate(charCodeB);
const isVariationSequence = (charCodeA, charCodeB) =>
  !isVariationSelector(charCodeA) && isVariationSelector(charCodeB);
const isCombinedCharacter = (charCodeA, charCodeB) =>
  !isCombiningCharacter(charCodeA) && isCombiningCharacter(charCodeB);
const isPairedCharacter = (string, index = 0) => {
  const charCodeA = string.charCodeAt(index);
  const charCodeB = string.charCodeAt(index + 1);
  return (
    isSurrogatePair(charCodeA, charCodeB) ||
    isVariationSequence(charCodeA, charCodeB) ||
    isCombinedCharacter(charCodeA, charCodeB)
  );
};
const IsJapaneseKanaCharacter = charCode =>
  charCode >= 0x3000 && charCode <= 0x30ff;
const isCJKUnifiedIdeograph = charCode =>
  charCode >= 0x4e00 && charCode <= 0x9fff;
const isFullWidthForm = charCode =>
  (charCode >= 0xff01 && charCode <= 0xff5e) ||
  (charCode >= 0xffe0 && charCode <= 0xffe6);
const isDoubleWidthCharacter = character => {
  const charCode = character.charCodeAt(0);
  return (
    IsJapaneseKanaCharacter(charCode) ||
    isCJKUnifiedIdeograph(charCode) ||
    isFullWidthForm(charCode)
  );
};
const isHalfWidthCharacter = character => {
  const charCode = character.charCodeAt(0);
  return (
    (charCode >= 0xff65 && charCode <= 0xffdc) ||
    (charCode >= 0xffe8 && charCode <= 0xffee)
  );
};
const isKoreanCharacter = character => {
  const charCode = character.charCodeAt(0);
  return (
    (charCode >= 0xac00 && charCode <= 0xd7a3) ||
    (charCode >= 0x1100 && charCode <= 0x11ff) ||
    (charCode >= 0x3130 && charCode <= 0x318f) ||
    (charCode >= 0xa960 && charCode <= 0xa97f) ||
    (charCode >= 0xd7b0 && charCode <= 0xd7ff)
  );
};
const isCJKCharacter = character =>
  isDoubleWidthCharacter(character) ||
  isHalfWidthCharacter(character) ||
  isKoreanCharacter(character);
const isWordStart = (previousCharacter, character) =>
  (previousCharacter === ' ' ||
    previousCharacter === '\t' ||
    previousCharacter === '-' ||
    previousCharacter === '/') &&
  (character !== ' ' && character !== '\t');
const isWrapBoundary = (previousCharacter, character) =>
  isWordStart(previousCharacter, character) || isCJKCharacter(character);
const hasPairedCharacter = string => {
  let index = 0;
  while (index < string.length) {
    if (isPairedCharacter(string, index)) {
      return true;
    }
    index++;
  }
  return false;
};
module.exports = {
  isPairedCharacter,
  hasPairedCharacter,
  isDoubleWidthCharacter,
  isHalfWidthCharacter,
  isKoreanCharacter,
  isWrapBoundary
};

================
File: src/theme-manager.js
================
const path = require('path');
const _ = require('underscore-plus');
const { Emitter, CompositeDisposable } = require('event-kit');
const { File } = require('pathwatcher');
const fs = require('fs-plus');
const LessCompileCache = require('./less-compile-cache');
const Color = require('./color');
module.exports = class ThemeManager {
  constructor({
    packageManager,
    config,
    styleManager,
    notificationManager,
    viewRegistry,
    applicationDelegate
  }) {
    this.applicationDelegate = applicationDelegate;
    this.packageManager = packageManager;
    this.config = config;
    this.styleManager = styleManager;
    this.notificationManager = notificationManager;
    this.viewRegistry = viewRegistry;
    this.emitter = new Emitter();
    this.styleSheetDisposablesBySourcePath = {};
    this.lessCache = null;
    this.initialLoadComplete = false;
    this.packageManager.registerPackageActivator(this, ['theme']);
    this.packageManager.onDidActivateInitialPackages(() => {
      this.onDidChangeActiveThemes(() =>
        this.packageManager.reloadActivePackageStyleSheets()
      );
    });
  }
  initialize({ resourcePath, configDirPath, safeMode, devMode }) {
    this.resourcePath = resourcePath;
    this.configDirPath = configDirPath;
    this.safeMode = safeMode;
    this.lessSourcesByRelativeFilePath = null;
    if (devMode || typeof snapshotAuxiliaryData === 'undefined') {
      this.lessSourcesByRelativeFilePath = {};
      this.importedFilePathsByRelativeImportPath = {};
    } else {
      this.lessSourcesByRelativeFilePath =
        snapshotAuxiliaryData.lessSourcesByRelativeFilePath;
      this.importedFilePathsByRelativeImportPath =
        snapshotAuxiliaryData.importedFilePathsByRelativeImportPath;
    }
  }
  onDidChangeActiveThemes(callback) {
    return this.emitter.on('did-change-active-themes', callback);
  }
  getAvailableNames() {
    return this.getLoadedNames();
  }
  getLoadedThemeNames() {
    return this.getLoadedThemes().map(theme => theme.name);
  }
  getLoadedThemes() {
    return this.packageManager
      .getLoadedPackages()
      .filter(pack => pack.isTheme());
  }
  getActiveThemeNames() {
    return this.getActiveThemes().map(theme => theme.name);
  }
  getActiveThemes() {
    return this.packageManager
      .getActivePackages()
      .filter(pack => pack.isTheme());
  }
  activatePackages() {
    return this.activateThemes();
  }
  warnForNonExistentThemes() {
    let themeNames = this.config.get('core.themes') || [];
    if (!Array.isArray(themeNames)) {
      themeNames = [themeNames];
    }
    for (let themeName of themeNames) {
      if (
        !themeName ||
        typeof themeName !== 'string' ||
        !this.packageManager.resolvePackagePath(themeName)
      ) {
        console.warn(`Enabled theme '${themeName}' is not installed.`);
      }
    }
  }
  getEnabledThemeNames() {
    let themeNames = this.config.get('core.themes') || [];
    if (!Array.isArray(themeNames)) {
      themeNames = [themeNames];
    }
    themeNames = themeNames.filter(
      themeName =>
        typeof themeName === 'string' &&
        this.packageManager.resolvePackagePath(themeName)
    );
    if (themeNames.length < 2) {
      const builtInThemeNames = [
        'atom-dark-syntax',
        'atom-dark-ui',
        'atom-light-syntax',
        'atom-light-ui',
        'base16-tomorrow-dark-theme',
        'base16-tomorrow-light-theme',
        'solarized-dark-syntax',
        'solarized-light-syntax'
      ];
      themeNames = _.intersection(themeNames, builtInThemeNames);
      if (themeNames.length === 0) {
        themeNames = ['one-dark-syntax', 'one-dark-ui'];
      } else if (themeNames.length === 1) {
        if (themeNames[0].endsWith('-ui')) {
          themeNames.unshift('one-dark-syntax');
        } else {
          themeNames.push('one-dark-ui');
        }
      }
    }
    return themeNames.reverse();
  }
  requireStylesheet(
    stylesheetPath,
    priority,
    skipDeprecatedSelectorsTransformation,
    skipDeprecatedMathUsageTransformation
  ) {
    let fullPath = this.resolveStylesheet(stylesheetPath);
    if (fullPath) {
      const content = this.loadStylesheet(fullPath);
      return this.applyStylesheet(
        fullPath,
        content,
        priority,
        skipDeprecatedSelectorsTransformation,
        skipDeprecatedMathUsageTransformation
      );
    } else {
      throw new Error(`Could not find a file at path '${stylesheetPath}'`);
    }
  }
  unwatchUserStylesheet() {
    if (this.userStylesheetSubscriptions != null)
      this.userStylesheetSubscriptions.dispose();
    this.userStylesheetSubscriptions = null;
    this.userStylesheetFile = null;
    if (this.userStyleSheetDisposable != null)
      this.userStyleSheetDisposable.dispose();
    this.userStyleSheetDisposable = null;
  }
  loadUserStylesheet() {
    this.unwatchUserStylesheet();
    const userStylesheetPath = this.styleManager.getUserStyleSheetPath();
    if (!fs.isFileSync(userStylesheetPath)) {
      return;
    }
    try {
      this.userStylesheetFile = new File(userStylesheetPath);
      this.userStylesheetSubscriptions = new CompositeDisposable();
      const reloadStylesheet = () => this.loadUserStylesheet();
      this.userStylesheetSubscriptions.add(
        this.userStylesheetFile.onDidChange(reloadStylesheet)
      );
      this.userStylesheetSubscriptions.add(
        this.userStylesheetFile.onDidRename(reloadStylesheet)
      );
      this.userStylesheetSubscriptions.add(
        this.userStylesheetFile.onDidDelete(reloadStylesheet)
      );
    } catch (error) {
      const message = `\
Unable to watch path: \`${path.basename(userStylesheetPath)}\`. Make sure
you have permissions to \`${userStylesheetPath}\`.
On linux there are currently problems with watch sizes. See
[this document][watches] for more info.
[watches]:https://pulsar-edit.dev/docs/atom-archive/hacking-atom/#typeerror-unable-to-watch-path
`;
      this.notificationManager.addError(message, { dismissable: true });
    }
    let userStylesheetContents;
    try {
      userStylesheetContents = this.loadStylesheet(userStylesheetPath, true);
    } catch (error) {
      return;
    }
    this.userStyleSheetDisposable = this.styleManager.addStyleSheet(
      userStylesheetContents,
      { sourcePath: userStylesheetPath, priority: 2 }
    );
  }
  loadBaseStylesheets() {
    this.reloadBaseStylesheets();
  }
  reloadBaseStylesheets() {
    this.requireStylesheet('../static/atom', -2, true);
  }
  stylesheetElementForId(id) {
    const escapedId = id.replace(/\\/g, '\\\\');
    return document.head.querySelector(
      `atom-styles style[source-path="${escapedId}"]`
    );
  }
  resolveStylesheet(stylesheetPath) {
    if (path.extname(stylesheetPath).length > 0) {
      return fs.resolveOnLoadPath(stylesheetPath);
    } else {
      return fs.resolveOnLoadPath(stylesheetPath, ['css', 'less']);
    }
  }
  loadStylesheet(stylesheetPath, importFallbackVariables) {
    if (path.extname(stylesheetPath) === '.less') {
      return this.loadLessStylesheet(stylesheetPath, importFallbackVariables);
    } else {
      return fs.readFileSync(stylesheetPath, 'utf8');
    }
  }
  loadLessStylesheet(lessStylesheetPath, importFallbackVariables = false) {
    if (this.lessCache == null) {
      this.lessCache = new LessCompileCache({
        resourcePath: this.resourcePath,
        lessSourcesByRelativeFilePath: this.lessSourcesByRelativeFilePath,
        importedFilePathsByRelativeImportPath: this
          .importedFilePathsByRelativeImportPath,
        importPaths: this.getImportPaths()
      });
    }
    try {
      if (importFallbackVariables) {
        const baseVarImports = `\
@import "variables/ui-variables";
@import "variables/syntax-variables";\
`;
        const relativeFilePath = path.relative(
          this.resourcePath,
          lessStylesheetPath
        );
        const lessSource = this.lessSourcesByRelativeFilePath[relativeFilePath];
        let content, digest;
        if (lessSource != null) {
          ({ content } = lessSource);
          ({ digest } = lessSource);
        } else {
          content =
            baseVarImports + '\n' + fs.readFileSync(lessStylesheetPath, 'utf8');
          digest = null;
        }
        return this.lessCache.cssForFile(lessStylesheetPath, content, digest);
      } else {
        return this.lessCache.read(lessStylesheetPath);
      }
    } catch (error) {
      let detail, message;
      error.less = true;
      if (error.line != null) {
        if (importFallbackVariables) {
          error.line -= 2;
        }
        message = `Error compiling Less stylesheet: \`${lessStylesheetPath}\``;
        detail = `Line number: ${error.line}\n${error.message}`;
      } else {
        message = `Error loading Less stylesheet: \`${lessStylesheetPath}\``;
        detail = error.message;
      }
      this.notificationManager.addError(message, { detail, dismissable: true });
      throw error;
    }
  }
  removeStylesheet(stylesheetPath) {
    if (this.styleSheetDisposablesBySourcePath[stylesheetPath] != null) {
      this.styleSheetDisposablesBySourcePath[stylesheetPath].dispose();
    }
  }
  applyStylesheet(path, text, priority, skipDeprecatedSelectorsTransformation, skipDeprecatedMathUsageTransformation) {
    this.styleSheetDisposablesBySourcePath[
      path
    ] = this.styleManager.addStyleSheet(text, {
      priority,
      skipDeprecatedSelectorsTransformation,
      skipDeprecatedMathUsageTransformation,
      sourcePath: path
    });
    return this.styleSheetDisposablesBySourcePath[path];
  }
  refreshWindowTheme() {
    let bgColor = Color.parse(getComputedStyle(document.documentElement).backgroundColor);
    let luminosity = 0.2126 * bgColor.red + 0.7152 * bgColor.green + 0.0722 * bgColor.blue;
    if (luminosity < 40) {
      this.applicationDelegate.setWindowTheme("dark");
    } else {
      this.applicationDelegate.setWindowTheme("light");
    }
  }
  activateThemes() {
    return new Promise(resolve => {
      this.config.observe('core.themes', () => {
        this.deactivateThemes().then(() => {
          this.warnForNonExistentThemes();
          this.refreshLessCache();
          const promises = [];
          for (const themeName of this.getEnabledThemeNames()) {
            if (this.packageManager.resolvePackagePath(themeName)) {
              promises.push(this.packageManager.activatePackage(themeName));
            } else {
              console.warn(
                `Failed to activate theme '${themeName}' because it isn't installed.`
              );
            }
          }
          return Promise.all(promises).then(() => {
            this.addActiveThemeClasses();
            this.refreshLessCache();
            this.loadUserStylesheet();
            this.reloadBaseStylesheets();
            if (this.config.get("editor.syncWindowThemeWithPulsarTheme")) {
              this.refreshWindowTheme();
            }
            this.initialLoadComplete = true;
            this.emitter.emit('did-change-active-themes');
            resolve();
          });
        });
      });
    });
  }
  deactivateThemes() {
    this.removeActiveThemeClasses();
    this.unwatchUserStylesheet();
    const results = this.getActiveThemes().map(pack =>
      this.packageManager.deactivatePackage(pack.name)
    );
    return Promise.all(
      results.filter(r => r != null && typeof r.then === 'function')
    );
  }
  isInitialLoadComplete() {
    return this.initialLoadComplete;
  }
  addActiveThemeClasses() {
    const workspaceElement = this.viewRegistry.getView(this.workspace);
    if (workspaceElement) {
      for (const pack of this.getActiveThemes()) {
        workspaceElement.classList.add(`theme-${pack.name}`);
      }
    }
  }
  removeActiveThemeClasses() {
    const workspaceElement = this.viewRegistry.getView(this.workspace);
    for (const pack of this.getActiveThemes()) {
      workspaceElement.classList.remove(`theme-${pack.name}`);
    }
  }
  refreshLessCache() {
    if (this.lessCache) this.lessCache.setImportPaths(this.getImportPaths());
  }
  getImportPaths() {
    let themePaths;
    const activeThemes = this.getActiveThemes();
    if (activeThemes.length > 0) {
      themePaths = activeThemes
        .filter(theme => theme)
        .map(theme => theme.getStylesheetsPath());
    } else {
      themePaths = [];
      for (const themeName of this.getEnabledThemeNames()) {
        const themePath = this.packageManager.resolvePackagePath(themeName);
        if (themePath) {
          const deprecatedPath = path.join(themePath, 'stylesheets');
          if (fs.isDirectorySync(deprecatedPath)) {
            themePaths.push(deprecatedPath);
          } else {
            themePaths.push(path.join(themePath, 'styles'));
          }
        }
      }
    }
    return themePaths.filter(themePath => fs.isDirectorySync(themePath));
  }
};

================
File: src/theme-package.js
================
const path = require('path');
const Package = require('./package');
module.exports = class ThemePackage extends Package {
  getType() {
    return 'theme';
  }
  getStyleSheetPriority() {
    return 1;
  }
  enable() {
    this.config.unshiftAtKeyPath('core.themes', this.name);
  }
  disable() {
    this.config.removeAtKeyPath('core.themes', this.name);
  }
  preload() {
    this.loadTime = 0;
    this.configSchemaRegisteredOnLoad = this.registerConfigSchemaFromMetadata();
  }
  finishLoading() {
    this.path = path.join(this.packageManager.resourcePath, this.path);
  }
  load() {
    this.loadTime = 0;
    this.configSchemaRegisteredOnLoad = this.registerConfigSchemaFromMetadata();
    return this;
  }
  activate() {
    if (this.activationPromise == null) {
      this.activationPromise = new Promise((resolve, reject) => {
        this.resolveActivationPromise = resolve;
        this.rejectActivationPromise = reject;
        this.measure('activateTime', () => {
          try {
            this.loadStylesheets();
            this.activateNow();
          } catch (error) {
            this.handleError(
              `Failed to activate the ${this.name} theme`,
              error
            );
          }
        });
      });
    }
    return this.activationPromise;
  }
};

================
File: src/title-bar.js
================
module.exports = class TitleBar {
  constructor({ workspace, themes, applicationDelegate }) {
    this.dblclickHandler = this.dblclickHandler.bind(this);
    this.workspace = workspace;
    this.themes = themes;
    this.applicationDelegate = applicationDelegate;
    this.element = document.createElement('div');
    this.element.classList.add('title-bar');
    this.titleElement = document.createElement('div');
    this.titleElement.classList.add('title');
    this.element.appendChild(this.titleElement);
    this.element.addEventListener('dblclick', this.dblclickHandler);
    this.workspace.onDidChangeWindowTitle(() => this.updateTitle());
    this.themes.onDidChangeActiveThemes(() => this.updateWindowSheetOffset());
    this.updateTitle();
    this.updateWindowSheetOffset();
  }
  dblclickHandler() {
    switch (
      this.applicationDelegate.getUserDefault(
        'AppleActionOnDoubleClick',
        'string'
      )
    ) {
      case 'Minimize':
        this.applicationDelegate.minimizeWindow();
        break;
      case 'Maximize':
        if (this.applicationDelegate.isWindowMaximized()) {
          this.applicationDelegate.unmaximizeWindow();
        } else {
          this.applicationDelegate.maximizeWindow();
        }
        break;
    }
  }
  updateTitle() {
    this.titleElement.textContent = document.title;
  }
  updateWindowSheetOffset() {
    this.applicationDelegate
      .getCurrentWindow()
      .setSheetOffset(this.element.offsetHeight);
  }
};

================
File: src/token-iterator.js
================
module.exports = class TokenIterator {
  constructor(languageMode) {
    this.languageMode = languageMode;
  }
  reset(line) {
    this.line = line;
    this.index = null;
    this.startColumn = 0;
    this.endColumn = 0;
    this.scopes = this.line.openScopes.map(id =>
      this.languageMode.grammar.scopeForId(id)
    );
    this.scopeStarts = this.scopes.slice();
    this.scopeEnds = [];
    return this;
  }
  next() {
    const { tags } = this.line;
    if (this.index != null) {
      this.startColumn = this.endColumn;
      this.scopeEnds.length = 0;
      this.scopeStarts.length = 0;
      this.index++;
    } else {
      this.index = 0;
    }
    while (this.index < tags.length) {
      const tag = tags[this.index];
      if (tag < 0) {
        const scope = this.languageMode.grammar.scopeForId(tag);
        if (tag % 2 === 0) {
          if (this.scopeStarts[this.scopeStarts.length - 1] === scope) {
            this.scopeStarts.pop();
          } else {
            this.scopeEnds.push(scope);
          }
          this.scopes.pop();
        } else {
          this.scopeStarts.push(scope);
          this.scopes.push(scope);
        }
        this.index++;
      } else {
        this.endColumn += tag;
        this.text = this.line.text.substring(this.startColumn, this.endColumn);
        return true;
      }
    }
    return false;
  }
  getScopes() {
    return this.scopes;
  }
  getScopeStarts() {
    return this.scopeStarts;
  }
  getScopeEnds() {
    return this.scopeEnds;
  }
  getText() {
    return this.text;
  }
  getBufferStart() {
    return this.startColumn;
  }
  getBufferEnd() {
    return this.endColumn;
  }
};

================
File: src/token.js
================
const _ = require('underscore-plus');
const StartDotRegex = /^\.?/;
module.exports = class Token {
  constructor(properties) {
    this.value = properties.value;
    this.scopes = properties.scopes;
  }
  isEqual(other) {
    return this.value === other.value && _.isEqual(this.scopes, other.scopes);
  }
  isBracket() {
    return /^meta\.brace\b/.test(_.last(this.scopes));
  }
  matchesScopeSelector(selector) {
    let targetClasses = selector.replace(StartDotRegex, '').split('.');
    return _.any(this.scopes, (scope) => {
      let scopeClasses = scope.split('.');
      return _.isSubset(targetClasses, scopeClasses);
    });
  }
};

================
File: src/tokenized-line.js
================
const Token = require('./token');
const CommentScopeRegex = /(\b|\.)comment/;
var idCounter = 1;
const TokenizedLine = class TokenizedLine {
  constructor(properties) {
    var tokens;
    this.id = idCounter++;
    if (properties == null) {
      return;
    }
    this.openScopes    = properties.openScopes;
    this.text          = properties.text;
    this.tags          = properties.tags;
    this.ruleStack     = properties.ruleStack;
    this.tokenIterator = properties.tokenIterator;
    this.grammar       = properties.grammar;
    this.cachedTokens  = properties.tokens;
  }
  getTokenIterator() {
    return this.tokenIterator.reset(this);
  }
  tokenAtBufferColumn(bufferColumn) {
    return this.tokens[this.tokenIndexAtBufferColumn(bufferColumn)];
  }
  tokenIndexAtBufferColumn(bufferColumn) {
    let column = 0;
    var index;
    for (index = 0; index < this.tokens.length; ++index) {
      let token = this.tokens[index];
      column += token.value.length;
      if (column > bufferColumn) {
        return index;
      }
    }
    return index - 1;
  }
  tokenStartColumnForBufferColumn(bufferColumn) {
    let delta = 0;
    for (let i = 0; i < this.tokens.length; i++) {
      const token = this.tokens[i];
      const nextDelta = delta + token.bufferDelta;
      if (nextDelta > bufferColumn) {
        break;
      }
      delta = nextDelta;
    }
    return delta;
  }
  isComment() {
    if (this.isCommentLine != null) {
      return this.isCommentLine;
    }
    this.isCommentLine = false;
    for (let tag  of this.openScopes) {
      if (this.isCommentOpenTag(tag)) {
        this.isCommentLine = true;
        return this.isCommentLine;
      }
    }
    let startIndex = 0;
    for (let tag of this.tags) {
      if (tag > 0) {
        if (!isWhitespaceOnly(this.text.substr(startIndex, tag))) {
          break;
        }
        startIndex += tag;
      }
      if (this.isCommentOpenTag(tag)) {
        this.isCommentLine = true;
        return this.isCommentLine;
      }
    }
    return this.isCommentLine;
  }
  isCommentOpenTag(tag) {
    if (tag < 0 && (tag & 1) === 1) {
      const scope = this.grammar.scopeForId(tag);
      if (CommentScopeRegex.test(scope)) {
        return true;
      }
    }
    return false;
  }
  tokenAtIndex(index) {
    return this.tokens[index];
  }
  getTokenCount() {
    let count = 0;
    for (let tag of this.tag) {
      if (tag >= 0) {
        count++;
      }
    }
    return count;
  }
};
Object.defineProperty(TokenizedLine.prototype, 'tokens', {
  get: function() {
    if (this.cachedTokens) {
      return this.cachedTokens;
    } else {
      const iterator = this.getTokenIterator();
      const tokens = [];
      while (iterator.next()) {
        tokens.push(new Token({
          value: iterator.getText(),
          scopes: iterator.getScopes().slice()
        }));
      }
      return tokens;
    }
  }
});
var isWhitespaceOnly = function(text) {
  for (let i = 0; i < text.length; i++) {
    let char = text[i];
    if (char !== '\t' && char !== ' ') {
      return false;
    }
  }
  return true;
};
module.exports = TokenizedLine;

================
File: src/tooltip-manager.js
================
const _ = require('underscore-plus');
const { Disposable, CompositeDisposable } = require('event-kit');
let Tooltip = null;
module.exports = class TooltipManager {
  constructor({ keymapManager, viewRegistry }) {
    this.defaults = {
      trigger: 'hover',
      container: 'body',
      html: true,
      placement: 'auto top',
      viewportPadding: 2
    };
    this.hoverDefaults = {
      delay: { show: 1000, hide: 100 }
    };
    this.keymapManager = keymapManager;
    this.viewRegistry = viewRegistry;
    this.tooltips = new Map();
  }
  add(target, options) {
    if (target.jquery) {
      const disposable = new CompositeDisposable();
      for (let i = 0; i < target.length; i++) {
        disposable.add(this.add(target[i], options));
      }
      return disposable;
    }
    if (Tooltip == null) {
      Tooltip = require('./tooltip');
    }
    const { keyBindingCommand, keyBindingTarget } = options;
    if (keyBindingCommand != null) {
      const bindings = this.keymapManager.findKeyBindings({
        command: keyBindingCommand,
        target: keyBindingTarget
      });
      const keystroke = getKeystroke(bindings);
      if (options.title != null && keystroke != null) {
        options.title += ` ${getKeystroke(bindings)}`;
      } else if (keystroke != null) {
        options.title = getKeystroke(bindings);
      }
    }
    delete options.selector;
    options = _.defaults(options, this.defaults);
    if (options.trigger === 'hover') {
      options = _.defaults(options, this.hoverDefaults);
    }
    const tooltip = new Tooltip(target, options, this.viewRegistry);
    if (!this.tooltips.has(target)) {
      this.tooltips.set(target, []);
    }
    this.tooltips.get(target).push(tooltip);
    const hideTooltip = function() {
      tooltip.leave({ currentTarget: target });
      tooltip.hide();
    };
    window.addEventListener('resize', hideTooltip);
    const disposable = new Disposable(() => {
      window.removeEventListener('resize', hideTooltip);
      hideTooltip();
      tooltip.destroy();
      if (this.tooltips.has(target)) {
        const tooltipsForTarget = this.tooltips.get(target);
        const index = tooltipsForTarget.indexOf(tooltip);
        if (index !== -1) {
          tooltipsForTarget.splice(index, 1);
        }
        if (tooltipsForTarget.length === 0) {
          this.tooltips.delete(target);
        }
      }
    });
    return disposable;
  }
  findTooltips(target) {
    if (this.tooltips.has(target)) {
      return this.tooltips.get(target).slice();
    } else {
      return [];
    }
  }
};
function humanizeKeystrokes(keystroke) {
  let keystrokes = keystroke.split(' ');
  keystrokes = keystrokes.map(stroke => _.humanizeKeystroke(stroke));
  return keystrokes.join(' ');
}
function getKeystroke(bindings) {
  if (bindings && bindings.length) {
    return `<span class="keystroke">${humanizeKeystrokes(
      bindings[0].keystrokes
    )}</span>`;
  }
}

================
File: src/tooltip.js
================
'use strict';
const EventKit = require('event-kit');
const tooltipComponentsByElement = new WeakMap();
const listen = require('./delegated-listener');
let followThroughTimer = null;
const Tooltip = function(element, options, viewRegistry) {
  this.options = null;
  this.enabled = null;
  this.timeout = null;
  this.hoverState = null;
  this.element = null;
  this.inState = null;
  this.viewRegistry = viewRegistry;
  this.init(element, options);
};
Tooltip.VERSION = '3.3.5';
Tooltip.FOLLOW_THROUGH_DURATION = 300;
Tooltip.DEFAULTS = {
  animation: true,
  placement: 'top',
  selector: false,
  template:
    '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
  trigger: 'hover focus',
  title: '',
  delay: 0,
  html: false,
  container: false,
  viewport: {
    selector: 'body',
    padding: 0
  }
};
Tooltip.prototype.init = function(element, options) {
  this.enabled = true;
  this.element = element;
  this.options = this.getOptions(options);
  this.disposables = new EventKit.CompositeDisposable();
  this.mutationObserver = new MutationObserver(this.handleMutations.bind(this));
  if (this.options.viewport) {
    if (typeof this.options.viewport === 'function') {
      this.viewport = this.options.viewport.call(this, this.element);
    } else {
      this.viewport = document.querySelector(
        this.options.viewport.selector || this.options.viewport
      );
    }
  }
  this.inState = { click: false, hover: false, focus: false };
  if (this.element instanceof document.constructor && !this.options.selector) {
    throw new Error(
      '`selector` option must be specified when initializing tooltip on the window.document object!'
    );
  }
  const triggers = this.options.trigger.split(' ');
  for (let i = triggers.length; i--; ) {
    var trigger = triggers[i];
    if (trigger === 'click') {
      this.disposables.add(
        listen(
          this.element,
          'click',
          this.options.selector,
          this.toggle.bind(this)
        )
      );
      this.hideOnClickOutsideOfTooltip = event => {
        const tooltipElement = this.getTooltipElement();
        if (tooltipElement === event.target) return;
        if (tooltipElement.contains(event.target)) return;
        if (this.element === event.target) return;
        if (this.element.contains(event.target)) return;
        this.hide();
      };
    } else if (trigger === 'manual') {
      this.show();
    } else {
      let eventIn, eventOut;
      if (trigger === 'hover') {
        this.hideOnKeydownOutsideOfTooltip = () => this.hide();
        if (this.options.selector) {
          eventIn = 'mouseover';
          eventOut = 'mouseout';
        } else {
          eventIn = 'mouseenter';
          eventOut = 'mouseleave';
        }
      } else {
        eventIn = 'focusin';
        eventOut = 'focusout';
      }
      this.disposables.add(
        listen(
          this.element,
          eventIn,
          this.options.selector,
          this.enter.bind(this)
        )
      );
      this.disposables.add(
        listen(
          this.element,
          eventOut,
          this.options.selector,
          this.leave.bind(this)
        )
      );
    }
  }
  this.options.selector
    ? (this._options = extend({}, this.options, {
        trigger: 'manual',
        selector: ''
      }))
    : this.fixTitle();
};
Tooltip.prototype.startObservingMutations = function() {
  this.mutationObserver.observe(this.getTooltipElement(), {
    attributes: true,
    childList: true,
    characterData: true,
    subtree: true
  });
};
Tooltip.prototype.stopObservingMutations = function() {
  this.mutationObserver.disconnect();
};
Tooltip.prototype.handleMutations = function() {
  window.requestAnimationFrame(
    function() {
      this.stopObservingMutations();
      this.recalculatePosition();
      this.startObservingMutations();
    }.bind(this)
  );
};
Tooltip.prototype.getDefaults = function() {
  return Tooltip.DEFAULTS;
};
Tooltip.prototype.getOptions = function(options) {
  options = extend({}, this.getDefaults(), options);
  if (options.delay && typeof options.delay === 'number') {
    options.delay = {
      show: options.delay,
      hide: options.delay
    };
  }
  return options;
};
Tooltip.prototype.getDelegateOptions = function() {
  const options = {};
  const defaults = this.getDefaults();
  if (this._options) {
    for (const key of Object.getOwnPropertyNames(this._options)) {
      const value = this._options[key];
      if (defaults[key] !== value) options[key] = value;
    }
  }
  return options;
};
Tooltip.prototype.enter = function(event) {
  if (event) {
    if (event.currentTarget !== this.element) {
      this.getDelegateComponent(event.currentTarget).enter(event);
      return;
    }
    this.inState[event.type === 'focusin' ? 'focus' : 'hover'] = true;
  }
  if (
    this.getTooltipElement().classList.contains('in') ||
    this.hoverState === 'in'
  ) {
    this.hoverState = 'in';
    return;
  }
  clearTimeout(this.timeout);
  this.hoverState = 'in';
  if (!this.options.delay || !this.options.delay.show || followThroughTimer) {
    return this.show();
  }
  this.timeout = setTimeout(
    function() {
      if (this.hoverState === 'in') this.show();
    }.bind(this),
    this.options.delay.show
  );
};
Tooltip.prototype.isInStateTrue = function() {
  for (const key in this.inState) {
    if (this.inState[key]) return true;
  }
  return false;
};
Tooltip.prototype.leave = function(event) {
  if (event) {
    if (event.currentTarget !== this.element) {
      this.getDelegateComponent(event.currentTarget).leave(event);
      return;
    }
    this.inState[event.type === 'focusout' ? 'focus' : 'hover'] = false;
  }
  if (this.isInStateTrue()) return;
  clearTimeout(this.timeout);
  this.hoverState = 'out';
  if (!this.options.delay || !this.options.delay.hide) return this.hide();
  this.timeout = setTimeout(
    function() {
      if (this.hoverState === 'out') this.hide();
    }.bind(this),
    this.options.delay.hide
  );
};
Tooltip.prototype.show = function() {
  if (this.hasContent() && this.enabled) {
    if (this.hideOnClickOutsideOfTooltip) {
      window.addEventListener('click', this.hideOnClickOutsideOfTooltip, {
        capture: true
      });
    }
    if (this.hideOnKeydownOutsideOfTooltip) {
      window.addEventListener(
        'keydown',
        this.hideOnKeydownOutsideOfTooltip,
        true
      );
    }
    const tip = this.getTooltipElement();
    this.startObservingMutations();
    const tipId = this.getUID('tooltip');
    this.setContent();
    tip.setAttribute('id', tipId);
    this.element.setAttribute('aria-describedby', tipId);
    if (this.options.animation) tip.classList.add('fade');
    let placement =
      typeof this.options.placement === 'function'
        ? this.options.placement.call(this, tip, this.element)
        : this.options.placement;
    const autoToken = /\s?auto?\s?/i;
    const autoPlace = autoToken.test(placement);
    if (autoPlace) placement = placement.replace(autoToken, '') || 'top';
    tip.remove();
    tip.style.top = '0px';
    tip.style.left = '0px';
    tip.style.display = 'block';
    tip.classList.add(placement);
    document.body.appendChild(tip);
    const pos = this.element.getBoundingClientRect();
    const actualWidth = tip.offsetWidth;
    const actualHeight = tip.offsetHeight;
    if (autoPlace) {
      const orgPlacement = placement;
      const viewportDim = this.viewport.getBoundingClientRect();
      placement =
        placement === 'bottom' && pos.bottom + actualHeight > viewportDim.bottom
          ? 'top'
          : placement === 'top' && pos.top - actualHeight < viewportDim.top
          ? 'bottom'
          : placement === 'right' && pos.right + actualWidth > viewportDim.width
          ? 'left'
          : placement === 'left' && pos.left - actualWidth < viewportDim.left
          ? 'right'
          : placement;
      tip.classList.remove(orgPlacement);
      tip.classList.add(placement);
    }
    const calculatedOffset = this.getCalculatedOffset(
      placement,
      pos,
      actualWidth,
      actualHeight
    );
    this.applyPlacement(calculatedOffset, placement);
    const prevHoverState = this.hoverState;
    this.hoverState = null;
    if (prevHoverState === 'out') this.leave();
  }
};
Tooltip.prototype.applyPlacement = function(offset, placement) {
  const tip = this.getTooltipElement();
  const width = tip.offsetWidth;
  const height = tip.offsetHeight;
  const computedStyle = window.getComputedStyle(tip);
  const marginTop = parseInt(computedStyle.marginTop, 10);
  const marginLeft = parseInt(computedStyle.marginLeft, 10);
  offset.top += marginTop;
  offset.left += marginLeft;
  tip.style.top = offset.top + 'px';
  tip.style.left = offset.left + 'px';
  tip.classList.add('in');
  const actualWidth = tip.offsetWidth;
  const actualHeight = tip.offsetHeight;
  if (placement === 'top' && actualHeight !== height) {
    offset.top = offset.top + height - actualHeight;
  }
  const delta = this.getViewportAdjustedDelta(
    placement,
    offset,
    actualWidth,
    actualHeight
  );
  if (delta.left) offset.left += delta.left;
  else offset.top += delta.top;
  const isVertical = /top|bottom/.test(placement);
  const arrowDelta = isVertical
    ? delta.left * 2 - width + actualWidth
    : delta.top * 2 - height + actualHeight;
  const arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight';
  tip.style.top = offset.top + 'px';
  tip.style.left = offset.left + 'px';
  this.replaceArrow(arrowDelta, tip[arrowOffsetPosition], isVertical);
};
Tooltip.prototype.replaceArrow = function(delta, dimension, isVertical) {
  const arrow = this.getArrowElement();
  const amount = 50 * (1 - delta / dimension) + '%';
  if (isVertical) {
    arrow.style.left = amount;
    arrow.style.top = '';
  } else {
    arrow.style.top = amount;
    arrow.style.left = '';
  }
};
Tooltip.prototype.setContent = function() {
  const tip = this.getTooltipElement();
  if (this.options.class) {
    tip.classList.add(this.options.class);
  }
  const inner = tip.querySelector('.tooltip-inner');
  if (this.options.item) {
    inner.appendChild(this.viewRegistry.getView(this.options.item));
  } else {
    const title = this.getTitle();
    if (this.options.html) {
      inner.innerHTML = title;
    } else {
      inner.textContent = title;
    }
  }
  tip.classList.remove('fade', 'in', 'top', 'bottom', 'left', 'right');
};
Tooltip.prototype.hide = function(callback) {
  this.inState = {};
  if (this.hideOnClickOutsideOfTooltip) {
    window.removeEventListener('click', this.hideOnClickOutsideOfTooltip, true);
  }
  if (this.hideOnKeydownOutsideOfTooltip) {
    window.removeEventListener(
      'keydown',
      this.hideOnKeydownOutsideOfTooltip,
      true
    );
  }
  this.tip && this.tip.classList.remove('in');
  this.stopObservingMutations();
  if (this.hoverState !== 'in') this.tip && this.tip.remove();
  this.element.removeAttribute('aria-describedby');
  callback && callback();
  this.hoverState = null;
  clearTimeout(followThroughTimer);
  followThroughTimer = setTimeout(function() {
    followThroughTimer = null;
  }, Tooltip.FOLLOW_THROUGH_DURATION);
  return this;
};
Tooltip.prototype.fixTitle = function() {
  if (
    this.element.getAttribute('title') ||
    typeof this.element.getAttribute('data-original-title') !== 'string'
  ) {
    this.element.setAttribute(
      'data-original-title',
      this.element.getAttribute('title') || ''
    );
    this.element.setAttribute('title', '');
  }
};
Tooltip.prototype.hasContent = function() {
  return this.getTitle() || this.options.item;
};
Tooltip.prototype.getCalculatedOffset = function(
  placement,
  pos,
  actualWidth,
  actualHeight
) {
  return placement === 'bottom'
    ? {
        top: pos.top + pos.height,
        left: pos.left + pos.width / 2 - actualWidth / 2
      }
    : placement === 'top'
    ? {
        top: pos.top - actualHeight,
        left: pos.left + pos.width / 2 - actualWidth / 2
      }
    : placement === 'left'
    ? {
        top: pos.top + pos.height / 2 - actualHeight / 2,
        left: pos.left - actualWidth
      }
    :  {
        top: pos.top + pos.height / 2 - actualHeight / 2,
        left: pos.left + pos.width
      };
};
Tooltip.prototype.getViewportAdjustedDelta = function(
  placement,
  pos,
  actualWidth,
  actualHeight
) {
  const delta = { top: 0, left: 0 };
  if (!this.viewport) return delta;
  const viewportPadding =
    (this.options.viewport && this.options.viewport.padding) || 0;
  const viewportDimensions = this.viewport.getBoundingClientRect();
  if (/right|left/.test(placement)) {
    const topEdgeOffset = pos.top - viewportPadding - viewportDimensions.scroll;
    const bottomEdgeOffset =
      pos.top + viewportPadding - viewportDimensions.scroll + actualHeight;
    if (topEdgeOffset < viewportDimensions.top) {
      delta.top = viewportDimensions.top - topEdgeOffset;
    } else if (
      bottomEdgeOffset >
      viewportDimensions.top + viewportDimensions.height
    ) {
      delta.top =
        viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset;
    }
  } else {
    const leftEdgeOffset = pos.left - viewportPadding;
    const rightEdgeOffset = pos.left + viewportPadding + actualWidth;
    if (leftEdgeOffset < viewportDimensions.left) {
      delta.left = viewportDimensions.left - leftEdgeOffset;
    } else if (rightEdgeOffset > viewportDimensions.right) {
      delta.left =
        viewportDimensions.left + viewportDimensions.width - rightEdgeOffset;
    }
  }
  return delta;
};
Tooltip.prototype.getTitle = function() {
  const title = this.element.getAttribute('data-original-title');
  if (title) {
    return title;
  } else {
    return typeof this.options.title === 'function'
      ? this.options.title.call(this.element)
      : this.options.title;
  }
};
Tooltip.prototype.getUID = function(prefix) {
  do prefix += ~~(Math.random() * 1000000);
  while (document.getElementById(prefix));
  return prefix;
};
Tooltip.prototype.getTooltipElement = function() {
  if (!this.tip) {
    let div = document.createElement('div');
    div.innerHTML = this.options.template;
    if (div.children.length !== 1) {
      throw new Error(
        'Tooltip `template` option must consist of exactly 1 top-level element!'
      );
    }
    this.tip = div.firstChild;
  }
  return this.tip;
};
Tooltip.prototype.getArrowElement = function() {
  this.arrow =
    this.arrow || this.getTooltipElement().querySelector('.tooltip-arrow');
  return this.arrow;
};
Tooltip.prototype.enable = function() {
  this.enabled = true;
};
Tooltip.prototype.disable = function() {
  this.enabled = false;
};
Tooltip.prototype.toggleEnabled = function() {
  this.enabled = !this.enabled;
};
Tooltip.prototype.toggle = function(event) {
  if (event) {
    if (event.currentTarget !== this.element) {
      this.getDelegateComponent(event.currentTarget).toggle(event);
      return;
    }
    this.inState.click = !this.inState.click;
    if (this.isInStateTrue()) this.enter();
    else this.leave();
  } else {
    this.getTooltipElement().classList.contains('in')
      ? this.leave()
      : this.enter();
  }
};
Tooltip.prototype.destroy = function() {
  clearTimeout(this.timeout);
  this.tip && this.tip.remove();
  this.disposables.dispose();
};
Tooltip.prototype.getDelegateComponent = function(element) {
  let component = tooltipComponentsByElement.get(element);
  if (!component) {
    component = new Tooltip(
      element,
      this.getDelegateOptions(),
      this.viewRegistry
    );
    tooltipComponentsByElement.set(element, component);
  }
  return component;
};
Tooltip.prototype.recalculatePosition = function() {
  const tip = this.getTooltipElement();
  let placement =
    typeof this.options.placement === 'function'
      ? this.options.placement.call(this, tip, this.element)
      : this.options.placement;
  const autoToken = /\s?auto?\s?/i;
  const autoPlace = autoToken.test(placement);
  if (autoPlace) placement = placement.replace(autoToken, '') || 'top';
  tip.classList.add(placement);
  const pos = this.element.getBoundingClientRect();
  const actualWidth = tip.offsetWidth;
  const actualHeight = tip.offsetHeight;
  if (autoPlace) {
    const orgPlacement = placement;
    const viewportDim = this.viewport.getBoundingClientRect();
    placement =
      placement === 'bottom' && pos.bottom + actualHeight > viewportDim.bottom
        ? 'top'
        : placement === 'top' && pos.top - actualHeight < viewportDim.top
        ? 'bottom'
        : placement === 'right' && pos.right + actualWidth > viewportDim.width
        ? 'left'
        : placement === 'left' && pos.left - actualWidth < viewportDim.left
        ? 'right'
        : placement;
    tip.classList.remove(orgPlacement);
    tip.classList.add(placement);
  }
  const calculatedOffset = this.getCalculatedOffset(
    placement,
    pos,
    actualWidth,
    actualHeight
  );
  this.applyPlacement(calculatedOffset, placement);
};
function extend() {
  const args = Array.prototype.slice.apply(arguments);
  const target = args.shift();
  let source = args.shift();
  while (source) {
    for (const key of Object.getOwnPropertyNames(source)) {
      target[key] = source[key];
    }
    source = args.shift();
  }
  return target;
}
module.exports = Tooltip;

================
File: src/tree-indenter.js
================
const log = () => {};
module.exports = class TreeIndenter {
  constructor(languageMode, scopes = undefined) {
    this.languageMode = languageMode;
    this.scopes =
      scopes ||
      languageMode.config.get('editor.scopes', {
        scope: this.languageMode.rootScopeDescriptor
      });
    log('[TreeIndenter] constructor', this.scopes);
  }
  get isConfigured() {
    return !!this.scopes;
  }
  _getHighestSyntaxNodeAtPosition(row, column = null) {
    if (column == null) {
      column = this.languageMode.buffer.lineForRow(row).search(/\S/);
    }
    let syntaxNode;
    if (column >= 0) {
      syntaxNode = this.languageMode.getSyntaxNodeAtPosition({ row, column });
      while (
        syntaxNode &&
        syntaxNode.parent &&
        syntaxNode.parent.startPosition.row === syntaxNode.startPosition.row &&
        syntaxNode.parent.endPosition.row === syntaxNode.startPosition.row &&
        syntaxNode.parent.startPosition.column ===
          syntaxNode.startPosition.column
      ) {
        syntaxNode = syntaxNode.parent;
      }
      return syntaxNode;
    }
  }
  _treeWalk(node, lastScope = null) {
    if (node == null || node.parent == null) {
      return 0;
    } else {
      let increment = 0;
      const notFirstOrLastSibling =
        node.previousSibling != null && node.nextSibling != null;
      const isScope = this.scopes.indent[node.parent.type];
      notFirstOrLastSibling && isScope && increment++;
      const isScope2 = this.scopes.indentExceptFirst[node.parent.type];
      !increment && isScope2 && node.previousSibling != null && increment++;
      const isScope3 = this.scopes.indentExceptFirstOrBlock[node.parent.type];
      !increment && isScope3 && node.previousSibling != null && increment++;
      let typeDent = 0;
      this.scopes.types.indent[node.type] && typeDent++;
      this.scopes.types.outdent[node.type] && increment && typeDent--;
      increment += typeDent;
      if (
        lastScope &&
        increment > 0 &&
        ((node.parent.startPosition.row === lastScope.node.startPosition.row &&
          node.parent.endIndex <= lastScope.node.endIndex + 1) ||
          (isScope3 &&
            (lastScope.node.endIndex === node.endIndex ||
              node.parent.endIndex === node.endIndex)))
      ) {
        log('ignoring repeat', node.parent.type, lastScope);
        increment = 0;
      } else {
        lastScope &&
          log(
            node.parent.startPosition.row,
            lastScope.node.startPosition.row,
            node.parent.endIndex,
            lastScope.node.endIndex,
            isScope3,
            node.endIndex
          );
      }
      log('treewalk', {
        node,
        notFirstOrLastSibling,
        type: node.parent.type,
        increment
      });
      const newLastScope =
        isScope || isScope2 ? { node: node.parent } : lastScope;
      return this._treeWalk(node.parent, newLastScope) + increment;
    }
  }
  suggestedIndentForBufferRow(row, tabLength, options) {
    const line = this.languageMode.buffer.lineForRow(row);
    const currentIndentation = this.languageMode.indentLevelForLine(
      line,
      tabLength
    );
    const syntaxNode = this._getHighestSyntaxNodeAtPosition(row);
    if (!syntaxNode) {
      const previousRow = Math.max(row - 1, 0);
      const previousIndentation = this.languageMode.indentLevelForLine(
        this.languageMode.indentLevelForLine(previousRow),
        tabLength
      );
      return previousIndentation;
    }
    let indentation = this._treeWalk(syntaxNode);
    if (
      (syntaxNode.type === 'comment' || syntaxNode.type === 'description') &&
      syntaxNode.startPosition.row < row &&
      syntaxNode.endPosition.row > row
    ) {
      indentation += 1;
    }
    if (options && options.preserveLeadingWhitespace) {
      indentation -= currentIndentation;
    }
    return indentation;
  }
};

================
File: src/tree-sitter-grammar.js
================
const path = require('path');
const SyntaxScopeMap = require('./syntax-scope-map');
const Module = require('module');
module.exports = class TreeSitterGrammar {
  constructor(registry, filePath, params) {
    this.registry = registry;
    this.name = params.name;
    this.scopeName = params.scopeName;
    this.contentRegex = buildRegex(params.contentRegex || params.contentRegExp);
    this.injectionRegex = buildRegex(
      params.injectionRegex || params.injectionRegExp
    );
    this.firstLineRegex = buildRegex(params.firstLineRegex);
    this.folds = params.folds || [];
    this.folds.forEach(normalizeFoldSpecification);
    this.commentStrings = {
      commentStartString: params.comments && params.comments.start,
      commentEndString: params.comments && params.comments.end
    };
    const scopeSelectors = {};
    for (const key in params.scopes || {}) {
      const classes = preprocessScopes(params.scopes[key]);
      const selectors = key.split(/,\s+/);
      for (let selector of selectors) {
        selector = selector.trim();
        if (!selector) continue;
        if (scopeSelectors[selector]) {
          scopeSelectors[selector] = [].concat(
            scopeSelectors[selector],
            classes
          );
        } else {
          scopeSelectors[selector] = classes;
        }
      }
    }
    this.scopeMap = new SyntaxScopeMap(scopeSelectors);
    this.fileTypes = params.fileTypes || [];
    this.injectionPointsByType = {};
    for (const injectionPoint of params.injectionPoints || []) {
      this.addInjectionPoint(injectionPoint);
    }
    const languageModulePath = Module._resolveFilename(params.parser, {
      id: filePath,
      filename: filePath,
      paths: Module._nodeModulePaths(path.dirname(filePath))
    });
    this.languageModule = require(languageModulePath);
    this.classNamesById = new Map();
    this.scopeNamesById = new Map();
    this.idsByScope = Object.create(null);
    this.nextScopeId = 256 + 1;
    this.registration = null;
  }
  inspect() {
    return `TreeSitterGrammar {scopeName: ${this.scopeName}}`;
  }
  idForScope(scopeName, _text) {
    if (!scopeName) {
      return undefined;
    }
    let id = this.idsByScope[scopeName];
    if (!id) {
      id = this.nextScopeId += 2;
      const className = scopeName
        .split('.')
        .map(s => `syntax--${s}`)
        .join(' ');
      this.idsByScope[scopeName] = id;
      this.classNamesById.set(id, className);
      this.scopeNamesById.set(id, scopeName);
    }
    return id;
  }
  classNameForScopeId(id) {
    return this.classNamesById.get(id);
  }
  scopeNameForScopeId(id) {
    return this.scopeNamesById.get(id);
  }
  activate() {
    this.registration = this.registry.addGrammar(this);
  }
  deactivate() {
    if (this.registration) this.registration.dispose();
  }
  addInjectionPoint(injectionPoint) {
    let injectionPoints = this.injectionPointsByType[injectionPoint.type];
    if (!injectionPoints) {
      injectionPoints = this.injectionPointsByType[injectionPoint.type] = [];
    }
    injectionPoints.push(injectionPoint);
  }
  removeInjectionPoint(injectionPoint) {
    const injectionPoints = this.injectionPointsByType[injectionPoint.type];
    if (injectionPoints) {
      const index = injectionPoints.indexOf(injectionPoint);
      if (index !== -1) injectionPoints.splice(index, 1);
      if (injectionPoints.length === 0) {
        delete this.injectionPointsByType[injectionPoint.type];
      }
    }
  }
  onDidUpdate(callback) {
  }
  tokenizeLines(text, compatibilityMode = true) {
    return text.split('\n').map(line => this.tokenizeLine(line, null, false));
  }
  tokenizeLine(line, ruleStack, firstLine) {
    return {
      value: line,
      scopes: [this.scopeName]
    };
  }
};
const preprocessScopes = value =>
  typeof value === 'string'
    ? value
    : Array.isArray(value)
    ? value.map(preprocessScopes)
    : value.match
    ? { match: new RegExp(value.match), scopes: preprocessScopes(value.scopes) }
    : Object.assign({}, value, { scopes: preprocessScopes(value.scopes) });
const NODE_NAME_REGEX = /[\w_]+/;
function matcherForSpec(spec) {
  if (typeof spec === 'string') {
    if (spec[0] === '"' && spec[spec.length - 1] === '"') {
      return {
        type: spec.substr(1, spec.length - 2),
        named: false
      };
    }
    if (!NODE_NAME_REGEX.test(spec)) {
      return { type: spec, named: false };
    }
    return { type: spec, named: true };
  }
  return spec;
}
function normalizeFoldSpecification(spec) {
  if (spec.type) {
    if (Array.isArray(spec.type)) {
      spec.matchers = spec.type.map(matcherForSpec);
    } else {
      spec.matchers = [matcherForSpec(spec.type)];
    }
  }
  if (spec.start) normalizeFoldSpecification(spec.start);
  if (spec.end) normalizeFoldSpecification(spec.end);
}
function buildRegex(value) {
  if (Array.isArray(value)) value = value.map(_ => `(${_})`).join('|');
  if (typeof value === 'string') return new RegExp(value);
  return null;
}

================
File: src/tree-sitter-language-mode.js
================
const Parser = require('tree-sitter');
const { Point, Range, spliceArray } = require('text-buffer');
const { Patch } = require('superstring');
const { Emitter } = require('event-kit');
const ScopeDescriptor = require('./scope-descriptor');
const Token = require('./token');
const TokenizedLine = require('./tokenized-line');
const TextMateLanguageMode = require('./text-mate-language-mode');
const { matcherForSelector } = require('./selectors');
const TreeIndenter = require('./tree-indenter');
const { normalizeDelimiters, commentStringsFromDelimiters } = require('./comment-utils.js');
let nextId = 0;
const MAX_RANGE = new Range(Point.ZERO, Point.INFINITY).freeze();
const PARSER_POOL = [];
const WORD_REGEX = /\w/;
class TreeSitterLanguageMode {
  static _patchSyntaxNode() {
    if (!Parser.SyntaxNode.prototype.hasOwnProperty('range')) {
      Object.defineProperty(Parser.SyntaxNode.prototype, 'range', {
        get() {
          return rangeForNode(this);
        }
      });
    }
  }
  constructor({ buffer, grammar, config, grammars, syncTimeoutMicros }) {
    TreeSitterLanguageMode._patchSyntaxNode();
    this.id = nextId++;
    this.buffer = buffer;
    this.grammar = grammar;
    this.config = config;
    this.grammarRegistry = grammars;
    this.rootLanguageLayer = new LanguageLayer(null, this, grammar, 0);
    this.injectionsMarkerLayer = buffer.addMarkerLayer();
    if (syncTimeoutMicros != null) {
      this.syncTimeoutMicros = syncTimeoutMicros;
    }
    this.rootScopeDescriptor = new ScopeDescriptor({
      scopes: [this.grammar.scopeName]
    });
    this.emitter = new Emitter();
    this.isFoldableCache = [];
    this.hasQueuedParse = false;
    this.grammarForLanguageString = this.grammarForLanguageString.bind(this);
    this.rootLanguageLayer
      .update(null)
      .then(() => this.emitter.emit('did-tokenize'));
    this.regexesByPattern = {};
  }
  async parseCompletePromise() {
    let done = false;
    while (!done) {
      if (this.rootLanguageLayer.currentParsePromise) {
        await this.rootLanguageLayer.currentParsePromises;
      } else {
        done = true;
        for (const marker of this.injectionsMarkerLayer.getMarkers()) {
          if (marker.languageLayer.currentParsePromise) {
            done = false;
            await marker.languageLayer.currentParsePromise;
            break;
          }
        }
      }
      await new Promise(resolve => setTimeout(resolve, 0));
    }
  }
  destroy() {
    this.injectionsMarkerLayer.destroy();
    this.rootLanguageLayer = null;
  }
  getLanguageId() {
    return this.grammar.scopeName;
  }
  bufferDidChange({ oldRange, newRange, oldText, newText }) {
    const edit = this.rootLanguageLayer._treeEditForBufferChange(
      oldRange.start,
      oldRange.end,
      newRange.end,
      oldText,
      newText
    );
    this.rootLanguageLayer.handleTextChange(edit, oldText, newText);
    for (const marker of this.injectionsMarkerLayer.getMarkers()) {
      marker.languageLayer.handleTextChange(edit, oldText, newText);
    }
  }
  bufferDidFinishTransaction({ changes }) {
    for (let i = 0, { length } = changes; i < length; i++) {
      const { oldRange, newRange } = changes[i];
      spliceArray(
        this.isFoldableCache,
        newRange.start.row,
        oldRange.end.row - oldRange.start.row,
        { length: newRange.end.row - newRange.start.row }
      );
    }
    this.rootLanguageLayer.update(null);
  }
  parse(language, oldTree, ranges) {
    const parser = PARSER_POOL.pop() || new Parser();
    parser.setLanguage(language);
    const result = parser.parseTextBuffer(this.buffer.buffer, oldTree, {
      syncTimeoutMicros: this.syncTimeoutMicros,
      includedRanges: ranges
    });
    if (result.then) {
      return result.then(tree => {
        PARSER_POOL.push(parser);
        return tree;
      });
    } else {
      PARSER_POOL.push(parser);
      return result;
    }
  }
  get tree() {
    return this.rootLanguageLayer.tree;
  }
  updateForInjection(grammar) {
    this.rootLanguageLayer.updateInjections(grammar);
  }
  buildHighlightIterator() {
    if (!this.rootLanguageLayer) return new NullLanguageModeHighlightIterator();
    return new HighlightIterator(this);
  }
  onDidTokenize(callback) {
    return this.emitter.on('did-tokenize', callback);
  }
  onDidChangeHighlighting(callback) {
    return this.emitter.on('did-change-highlighting', callback);
  }
  classNameForScopeId(scopeId) {
    return this.grammar.classNameForScopeId(scopeId);
  }
  commentStringsForPosition(position) {
    const range =
      this.firstNonWhitespaceRange(position.row) ||
      new Range(position, position);
    const { grammar } = this.getSyntaxNodeAndGrammarContainingRange(range);
    const { grammar: originalPositionGrammar } = this.getSyntaxNodeAndGrammarContainingRange(new Range(position, position));
    let result = commentStringsFromDelimiters(grammar.commentStrings);
    console.log('result???', result, grammar.commentStrings);
    if (originalPositionGrammar !== grammar) {
      result.commentDelimiters = commentStringsFromDelimiters(
        originalPositionGrammar.commentStrings
      ).commentDelimiters;
    }
    return result;
  }
  isRowCommented(row) {
    const range = this.firstNonWhitespaceRange(row);
    if (range) {
      const firstNode = this.getSyntaxNodeContainingRange(range);
      if (firstNode) return firstNode.type.includes('comment');
    }
    return false;
  }
  suggestedIndentForLineAtBufferRow(row, line, tabLength) {
    return this._suggestedIndentForLineWithScopeAtBufferRow(
      row,
      line,
      this.rootScopeDescriptor,
      tabLength
    );
  }
  suggestedIndentForBufferRow(row, tabLength, options) {
    if (!this.treeIndenter) {
      this.treeIndenter = new TreeIndenter(this);
    }
    if (this.treeIndenter.isConfigured) {
      const indent = this.treeIndenter.suggestedIndentForBufferRow(
        row,
        tabLength,
        options
      );
      return indent;
    } else {
      return this._suggestedIndentForLineWithScopeAtBufferRow(
        row,
        this.buffer.lineForRow(row),
        this.rootScopeDescriptor,
        tabLength,
        options
      );
    }
  }
  indentLevelForLine(line, tabLength) {
    let indentLength = 0;
    for (let i = 0, { length } = line; i < length; i++) {
      const char = line[i];
      if (char === '\t') {
        indentLength += tabLength - (indentLength % tabLength);
      } else if (char === ' ') {
        indentLength++;
      } else {
        break;
      }
    }
    return indentLength / tabLength;
  }
  isFoldableAtRow(row) {
    if (this.isFoldableCache[row] != null) return this.isFoldableCache[row];
    const result =
      this.getFoldableRangeContainingPoint(Point(row, Infinity), 0, true) !=
      null;
    this.isFoldableCache[row] = result;
    return result;
  }
  getFoldableRanges() {
    return this.getFoldableRangesAtIndentLevel(null);
  }
  getFoldableRangesAtIndentLevel(goalLevel) {
    let result = [];
    let stack = [{ node: this.tree.rootNode, level: 0 }];
    while (stack.length > 0) {
      const { node, level } = stack.pop();
      const range = this.getFoldableRangeForNode(node, this.grammar);
      if (range) {
        if (goalLevel == null || level === goalLevel) {
          let updatedExistingRange = false;
          for (let i = 0, { length } = result; i < length; i++) {
            if (
              result[i].start.row === range.start.row &&
              result[i].end.row === range.end.row
            ) {
              result[i] = range;
              updatedExistingRange = true;
              break;
            }
          }
          if (!updatedExistingRange) result.push(range);
        }
      }
      const parentStartRow = node.startPosition.row;
      const parentEndRow = node.endPosition.row;
      for (
        let children = node.namedChildren, i = 0, { length } = children;
        i < length;
        i++
      ) {
        const child = children[i];
        const { startPosition: childStart, endPosition: childEnd } = child;
        if (childEnd.row > childStart.row) {
          if (
            childStart.row === parentStartRow &&
            childEnd.row === parentEndRow
          ) {
            stack.push({ node: child, level: level });
          } else {
            const childLevel =
              range &&
              range.containsPoint(childStart) &&
              range.containsPoint(childEnd)
                ? level + 1
                : level;
            if (childLevel <= goalLevel || goalLevel == null) {
              stack.push({ node: child, level: childLevel });
            }
          }
        }
      }
    }
    return result.sort((a, b) => a.start.row - b.start.row);
  }
  getFoldableRangeContainingPoint(point, tabLength, existenceOnly = false) {
    if (!this.tree) return null;
    let smallestRange;
    this._forEachTreeWithRange(new Range(point, point), (tree, grammar) => {
      let node = tree.rootNode.descendantForPosition(
        this.buffer.clipPosition(point)
      );
      while (node) {
        if (existenceOnly && node.startPosition.row < point.row) return;
        if (node.endPosition.row > point.row) {
          const range = this.getFoldableRangeForNode(node, grammar);
          if (range && rangeIsSmaller(range, smallestRange)) {
            smallestRange = range;
            return;
          }
        }
        node = node.parent;
      }
    });
    return existenceOnly
      ? smallestRange && smallestRange.start.row === point.row
      : smallestRange;
  }
  _forEachTreeWithRange(range, callback) {
    if (this.rootLanguageLayer.tree) {
      callback(this.rootLanguageLayer.tree, this.rootLanguageLayer.grammar);
    }
    const injectionMarkers = this.injectionsMarkerLayer.findMarkers({
      intersectsRange: range
    });
    for (const injectionMarker of injectionMarkers) {
      const { tree, grammar } = injectionMarker.languageLayer;
      if (tree) callback(tree, grammar);
    }
  }
  getFoldableRangeForNode(node, grammar, existenceOnly) {
    const { children } = node;
    const childCount = children.length;
    for (var i = 0, { length } = grammar.folds; i < length; i++) {
      const foldSpec = grammar.folds[i];
      if (foldSpec.matchers && !hasMatchingFoldSpec(foldSpec.matchers, node))
        continue;
      let foldStart;
      const startEntry = foldSpec.start;
      if (startEntry) {
        let foldStartNode;
        if (startEntry.index != null) {
          foldStartNode = children[startEntry.index];
          if (
            !foldStartNode ||
            (startEntry.matchers &&
              !hasMatchingFoldSpec(startEntry.matchers, foldStartNode))
          )
            continue;
        } else {
          foldStartNode = children.find(child =>
            hasMatchingFoldSpec(startEntry.matchers, child)
          );
          if (!foldStartNode) continue;
        }
        foldStart = new Point(foldStartNode.endPosition.row, Infinity);
      } else {
        foldStart = new Point(node.startPosition.row, Infinity);
      }
      let foldEnd;
      const endEntry = foldSpec.end;
      if (endEntry) {
        let foldEndNode;
        if (endEntry.index != null) {
          const index =
            endEntry.index < 0 ? childCount + endEntry.index : endEntry.index;
          foldEndNode = children[index];
          if (
            !foldEndNode ||
            (endEntry.type && endEntry.type !== foldEndNode.type)
          )
            continue;
        } else {
          foldEndNode = children.find(child =>
            hasMatchingFoldSpec(endEntry.matchers, child)
          );
          if (!foldEndNode) continue;
        }
        if (foldEndNode.startPosition.row <= foldStart.row) continue;
        foldEnd = foldEndNode.startPosition;
        if (
          this.buffer.findInRangeSync(
            WORD_REGEX,
            new Range(foldEnd, new Point(foldEnd.row, Infinity))
          )
        ) {
          foldEnd = new Point(foldEnd.row - 1, Infinity);
        }
      } else {
        const { endPosition } = node;
        if (endPosition.column === 0) {
          foldEnd = Point(endPosition.row - 1, Infinity);
        } else if (childCount > 0) {
          foldEnd = endPosition;
        } else {
          foldEnd = Point(endPosition.row, 0);
        }
      }
      return existenceOnly ? true : new Range(foldStart, foldEnd);
    }
  }
  getSyntaxNodeContainingRange(range, where = _ => true) {
    return this.getSyntaxNodeAndGrammarContainingRange(range, where).node;
  }
  getSyntaxNodeAndGrammarContainingRange(range, where = _ => true) {
    const startIndex = this.buffer.characterIndexForPosition(range.start);
    const endIndex = this.buffer.characterIndexForPosition(range.end);
    const searchEndIndex = Math.max(0, endIndex - 1);
    let smallestNode = null;
    let smallestNodeGrammar = this.grammar;
    this._forEachTreeWithRange(range, (tree, grammar) => {
      let node = tree.rootNode.descendantForIndex(startIndex, searchEndIndex);
      while (node) {
        if (
          nodeContainsIndices(node, startIndex, endIndex) &&
          where(node, grammar)
        ) {
          if (nodeIsSmaller(node, smallestNode)) {
            smallestNode = node;
            smallestNodeGrammar = grammar;
          }
          break;
        }
        node = node.parent;
      }
    });
    return { node: smallestNode, grammar: smallestNodeGrammar };
  }
  getRangeForSyntaxNodeContainingRange(range, where) {
    const node = this.getSyntaxNodeContainingRange(range, where);
    return node && node.range;
  }
  getSyntaxNodeAtPosition(position, where) {
    return this.getSyntaxNodeContainingRange(
      new Range(position, position),
      where
    );
  }
  bufferRangeForScopeAtPosition(selector, position) {
    const nodeCursorAdapter = new NodeCursorAdaptor();
    if (typeof selector === 'string') {
      const match = matcherForSelector(selector);
      selector = (node, grammar) => {
        const rules = grammar.scopeMap.get([node.type], [0], node.named);
        nodeCursorAdapter.node = node;
        const scopeName = applyLeafRules(rules, nodeCursorAdapter);
        if (scopeName != null) {
          return match(scopeName);
        }
      };
    }
    if (selector === null) selector = undefined;
    const node = this.getSyntaxNodeAtPosition(position, selector);
    return node && node.range;
  }
  tokenizedLineForRow(row) {
    const lineText = this.buffer.lineForRow(row);
    const tokens = [];
    const iterator = this.buildHighlightIterator();
    let start = { row, column: 0 };
    const scopes = iterator.seek(start, row);
    while (true) {
      const end = iterator.getPosition();
      if (end.row > row) {
        end.row = row;
        end.column = lineText.length;
      }
      if (end.column > start.column) {
        tokens.push(
          new Token({
            value: lineText.substring(start.column, end.column),
            scopes: scopes.map(s => this.grammar.scopeNameForScopeId(s))
          })
        );
      }
      if (end.column < lineText.length) {
        const closeScopeCount = iterator.getCloseScopeIds().length;
        for (let i = 0; i < closeScopeCount; i++) {
          scopes.pop();
        }
        scopes.push(...iterator.getOpenScopeIds());
        start = end;
        iterator.moveToSuccessor();
      } else {
        break;
      }
    }
    return new TokenizedLine({
      openScopes: [],
      text: lineText,
      tokens,
      tags: [],
      ruleStack: [],
      lineEnding: this.buffer.lineEndingForRow(row),
      tokenIterator: null,
      grammar: this.grammar
    });
  }
  syntaxTreeScopeDescriptorForPosition(point) {
    const nodes = [];
    point = this.buffer.clipPosition(Point.fromObject(point));
    if (
      point.column > 0 &&
      point.column === this.buffer.lineLengthForRow(point.row)
    ) {
      point = point.copy();
      point.column--;
    }
    this._forEachTreeWithRange(new Range(point, point), tree => {
      let node = tree.rootNode.descendantForPosition(point);
      while (node) {
        nodes.push(node);
        node = node.parent;
      }
    });
    nodes.reverse();
    nodes.sort(
      (a, b) => a.startIndex - b.startIndex || b.endIndex - a.endIndex
    );
    const nodeTypes = nodes.map(node => node.type);
    nodeTypes.unshift(this.grammar.scopeName);
    return new ScopeDescriptor({ scopes: nodeTypes });
  }
  scopeDescriptorForPosition(point) {
    point = this.buffer.clipPosition(Point.fromObject(point));
    if (
      point.column > 0 &&
      point.column === this.buffer.lineLengthForRow(point.row)
    ) {
      point = point.copy();
      point.column--;
    }
    const iterator = this.buildHighlightIterator();
    const scopes = [];
    for (const scope of iterator.seek(point, point.row + 1)) {
      scopes.push(this.grammar.scopeNameForScopeId(scope));
    }
    if (point.isEqual(iterator.getPosition())) {
      for (const scope of iterator.getOpenScopeIds()) {
        scopes.push(this.grammar.scopeNameForScopeId(scope));
      }
    }
    if (scopes.length === 0 || scopes[0] !== this.grammar.scopeName) {
      scopes.unshift(this.grammar.scopeName);
    }
    return new ScopeDescriptor({ scopes });
  }
  tokenForPosition(point) {
    const node = this.getSyntaxNodeAtPosition(point);
    const scopes = this.scopeDescriptorForPosition(point).getScopesArray();
    return new Token({ value: node.text, scopes });
  }
  getGrammar() {
    return this.grammar;
  }
  firstNonWhitespaceRange(row) {
    return this.buffer.findInRangeSync(
      /\S/,
      new Range(new Point(row, 0), new Point(row, Infinity))
    );
  }
  grammarForLanguageString(languageString) {
    return this.grammarRegistry.treeSitterGrammarForLanguageString(
      languageString,
      'original'
    );
  }
  emitRangeUpdate(range) {
    const startRow = range.start.row;
    const endRow = range.end.row;
    for (let row = startRow; row < endRow; row++) {
      this.isFoldableCache[row] = undefined;
    }
    this.emitter.emit('did-change-highlighting', range);
  }
}
class LanguageLayer {
  constructor(marker, languageMode, grammar, depth) {
    this.marker = marker;
    this.languageMode = languageMode;
    this.grammar = grammar;
    this.tree = null;
    this.currentParsePromise = null;
    this.patchSinceCurrentParseStarted = null;
    this.depth = depth;
  }
  buildHighlightIterator() {
    if (this.tree) {
      return new LayerHighlightIterator(this, this.tree.walk());
    } else {
      return new NullLayerHighlightIterator();
    }
  }
  handleTextChange(edit, oldText, newText) {
    const { startPosition, oldEndPosition, newEndPosition } = edit;
    if (this.tree) {
      this.tree.edit(edit);
      if (this.editedRange) {
        if (startPosition.isLessThan(this.editedRange.start)) {
          this.editedRange.start = startPosition;
        }
        if (oldEndPosition.isLessThan(this.editedRange.end)) {
          this.editedRange.end = newEndPosition.traverse(
            this.editedRange.end.traversalFrom(oldEndPosition)
          );
        } else {
          this.editedRange.end = newEndPosition;
        }
      } else {
        this.editedRange = new Range(startPosition, newEndPosition);
      }
    }
    if (this.patchSinceCurrentParseStarted) {
      this.patchSinceCurrentParseStarted.splice(
        startPosition,
        oldEndPosition.traversalFrom(startPosition),
        newEndPosition.traversalFrom(startPosition),
        oldText,
        newText
      );
    }
  }
  destroy() {
    this.tree = null;
    this.destroyed = true;
    this.marker.destroy();
    for (const marker of this.languageMode.injectionsMarkerLayer.getMarkers()) {
      if (marker.parentLanguageLayer === this) {
        marker.languageLayer.destroy();
      }
    }
  }
  async update(nodeRangeSet) {
    if (!this.currentParsePromise) {
      while (
        !this.destroyed &&
        (!this.tree || this.tree.rootNode.hasChanges())
      ) {
        const params = { async: false };
        this.currentParsePromise = this._performUpdate(nodeRangeSet, params);
        if (!params.async) break;
        await this.currentParsePromise;
      }
      this.currentParsePromise = null;
    }
  }
  updateInjections(grammar) {
    if (grammar.injectionRegex) {
      if (!this.currentParsePromise)
        this.currentParsePromise = Promise.resolve();
      this.currentParsePromise = this.currentParsePromise.then(async () => {
        await this._populateInjections(MAX_RANGE, null);
        this.currentParsePromise = null;
      });
    }
  }
  async _performUpdate(nodeRangeSet, params) {
    let includedRanges = null;
    if (nodeRangeSet) {
      includedRanges = nodeRangeSet.getRanges(this.languageMode.buffer);
      if (includedRanges.length === 0) {
        const range = this.marker.getRange();
        this.destroy();
        this.languageMode.emitRangeUpdate(range);
        return;
      }
    }
    let affectedRange = this.editedRange;
    this.editedRange = null;
    this.patchSinceCurrentParseStarted = new Patch();
    let tree = this.languageMode.parse(
      this.grammar.languageModule,
      this.tree,
      includedRanges
    );
    if (tree.then) {
      params.async = true;
      tree = await tree;
    }
    const changes = this.patchSinceCurrentParseStarted.getChanges();
    this.patchSinceCurrentParseStarted = null;
    for (const {
      oldStart,
      newStart,
      oldEnd,
      newEnd,
      oldText,
      newText
    } of changes) {
      const newExtent = Point.fromObject(newEnd).traversalFrom(newStart);
      tree.edit(
        this._treeEditForBufferChange(
          newStart,
          oldEnd,
          Point.fromObject(oldStart).traverse(newExtent),
          oldText,
          newText
        )
      );
    }
    if (this.tree) {
      const rangesWithSyntaxChanges = this.tree.getChangedRanges(tree);
      this.tree = tree;
      if (rangesWithSyntaxChanges.length > 0) {
        for (const range of rangesWithSyntaxChanges) {
          this.languageMode.emitRangeUpdate(rangeForNode(range));
        }
        const combinedRangeWithSyntaxChange = new Range(
          rangesWithSyntaxChanges[0].startPosition,
          last(rangesWithSyntaxChanges).endPosition
        );
        if (affectedRange) {
          this.languageMode.emitRangeUpdate(affectedRange);
          affectedRange = affectedRange.union(combinedRangeWithSyntaxChange);
        } else {
          affectedRange = combinedRangeWithSyntaxChange;
        }
      }
    } else {
      this.tree = tree;
      this.languageMode.emitRangeUpdate(rangeForNode(tree.rootNode));
      if (includedRanges) {
        affectedRange = new Range(
          includedRanges[0].startPosition,
          last(includedRanges).endPosition
        );
      } else {
        affectedRange = MAX_RANGE;
      }
    }
    if (affectedRange) {
      const injectionPromise = this._populateInjections(
        affectedRange,
        nodeRangeSet
      );
      if (injectionPromise) {
        params.async = true;
        return injectionPromise;
      }
    }
  }
  _populateInjections(range, nodeRangeSet) {
    const existingInjectionMarkers = this.languageMode.injectionsMarkerLayer
      .findMarkers({ intersectsRange: range })
      .filter(marker => marker.parentLanguageLayer === this);
    if (existingInjectionMarkers.length > 0) {
      range = range.union(
        new Range(
          existingInjectionMarkers[0].getRange().start,
          last(existingInjectionMarkers).getRange().end
        )
      );
    }
    const markersToUpdate = new Map();
    const nodes = this.tree.rootNode.descendantsOfType(
      Object.keys(this.grammar.injectionPointsByType),
      range.start,
      range.end
    );
    let existingInjectionMarkerIndex = 0;
    for (const node of nodes) {
      for (const injectionPoint of this.grammar.injectionPointsByType[
        node.type
      ]) {
        const languageName = injectionPoint.language(node);
        if (!languageName) continue;
        const grammar = this.languageMode.grammarForLanguageString(
          languageName
        );
        if (!grammar) continue;
        const contentNodes = injectionPoint.content(node, this.buffer);
        if (!contentNodes) continue;
        const injectionNodes = [].concat(contentNodes);
        if (!injectionNodes.length) continue;
        const injectionRange = rangeForNode(node);
        let marker;
        for (
          let i = existingInjectionMarkerIndex,
            n = existingInjectionMarkers.length;
          i < n;
          i++
        ) {
          const existingMarker = existingInjectionMarkers[i];
          const comparison = existingMarker.getRange().compare(injectionRange);
          if (comparison > 0) {
            break;
          } else if (comparison === 0) {
            existingInjectionMarkerIndex = i;
            if (existingMarker.languageLayer.grammar === grammar) {
              marker = existingMarker;
              break;
            }
          } else {
            existingInjectionMarkerIndex = i;
          }
        }
        if (!marker) {
          marker = this.languageMode.injectionsMarkerLayer.markRange(
            injectionRange
          );
          marker.languageLayer = new LanguageLayer(
            marker,
            this.languageMode,
            grammar,
            this.depth + 1
          );
          marker.parentLanguageLayer = this;
        }
        markersToUpdate.set(
          marker,
          new NodeRangeSet(
            nodeRangeSet,
            injectionNodes,
            injectionPoint.newlinesBetween,
            injectionPoint.includeChildren
          )
        );
      }
    }
    for (const marker of existingInjectionMarkers) {
      if (!markersToUpdate.has(marker)) {
        this.languageMode.emitRangeUpdate(marker.getRange());
        marker.languageLayer.destroy();
      }
    }
    if (markersToUpdate.size > 0) {
      const promises = [];
      for (const [marker, nodeRangeSet] of markersToUpdate) {
        promises.push(marker.languageLayer.update(nodeRangeSet));
      }
      return Promise.all(promises);
    }
  }
  _treeEditForBufferChange(start, oldEnd, newEnd, oldText, newText) {
    const startIndex = this.languageMode.buffer.characterIndexForPosition(
      start
    );
    return {
      startIndex,
      oldEndIndex: startIndex + oldText.length,
      newEndIndex: startIndex + newText.length,
      startPosition: start,
      oldEndPosition: oldEnd,
      newEndPosition: newEnd
    };
  }
}
class HighlightIterator {
  constructor(languageMode) {
    this.languageMode = languageMode;
    this.iterators = null;
  }
  seek(targetPosition, endRow) {
    const injectionMarkers = this.languageMode.injectionsMarkerLayer.findMarkers(
      {
        intersectsRange: new Range(targetPosition, new Point(endRow + 1, 0))
      }
    );
    const containingTags = [];
    const containingTagStartIndices = [];
    const targetIndex = this.languageMode.buffer.characterIndexForPosition(
      targetPosition
    );
    this.iterators = [];
    const iterator = this.languageMode.rootLanguageLayer.buildHighlightIterator();
    if (iterator.seek(targetIndex, containingTags, containingTagStartIndices)) {
      this.iterators.push(iterator);
    }
    for (const marker of injectionMarkers) {
      const iterator = marker.languageLayer.buildHighlightIterator();
      if (
        iterator.seek(targetIndex, containingTags, containingTagStartIndices)
      ) {
        this.iterators.push(iterator);
      }
    }
    this.iterators.sort((a, b) => b.compare(a));
    this.detectCoveredScope();
    return containingTags;
  }
  moveToSuccessor() {
    let leader = last(this.iterators);
    if (leader.moveToSuccessor()) {
      const leaderIndex = this.iterators.length - 1;
      let i = leaderIndex;
      while (i > 0 && this.iterators[i - 1].compare(leader) < 0) i--;
      if (i < leaderIndex) {
        this.iterators.splice(i, 0, this.iterators.pop());
      }
    } else {
      this.iterators.pop();
    }
    this.detectCoveredScope();
  }
  detectCoveredScope() {
    const layerCount = this.iterators.length;
    if (layerCount > 1) {
      const first = this.iterators[layerCount - 1];
      const next = this.iterators[layerCount - 2];
      if (
        next.offset === first.offset &&
        next.atEnd === first.atEnd &&
        next.depth > first.depth &&
        !next.isAtInjectionBoundary()
      ) {
        this.currentScopeIsCovered = true;
        return;
      }
    }
    this.currentScopeIsCovered = false;
  }
  getPosition() {
    const iterator = last(this.iterators);
    if (iterator) {
      return iterator.getPosition();
    } else {
      return Point.INFINITY;
    }
  }
  getCloseScopeIds() {
    const iterator = last(this.iterators);
    if (iterator && !this.currentScopeIsCovered) {
      return iterator.getCloseScopeIds();
    }
    return [];
  }
  getOpenScopeIds() {
    const iterator = last(this.iterators);
    if (iterator && !this.currentScopeIsCovered) {
      return iterator.getOpenScopeIds();
    }
    return [];
  }
  logState() {
    const iterator = last(this.iterators);
    if (iterator && iterator.treeCursor) {
      console.log(
        iterator.getPosition(),
        iterator.treeCursor.nodeType,
        `depth=${iterator.languageLayer.depth}`,
        new Range(
          iterator.languageLayer.tree.rootNode.startPosition,
          iterator.languageLayer.tree.rootNode.endPosition
        ).toString()
      );
      if (this.currentScopeIsCovered) {
        console.log('covered');
      } else {
        console.log(
          'close',
          iterator.closeTags.map(id =>
            this.languageMode.grammar.scopeNameForScopeId(id)
          )
        );
        console.log(
          'open',
          iterator.openTags.map(id =>
            this.languageMode.grammar.scopeNameForScopeId(id)
          )
        );
      }
    }
  }
}
class LayerHighlightIterator {
  constructor(languageLayer, treeCursor) {
    this.languageLayer = languageLayer;
    this.depth = this.languageLayer.depth;
    this.atEnd = false;
    this.treeCursor = treeCursor;
    this.offset = 0;
    this.containingNodeTypes = [];
    this.containingNodeChildIndices = [];
    this.containingNodeEndIndices = [];
    this.closeTags = [];
    this.openTags = [];
  }
  seek(targetIndex, containingTags, containingTagStartIndices) {
    while (this.treeCursor.gotoParent()) {}
    this.atEnd = true;
    this.closeTags.length = 0;
    this.openTags.length = 0;
    this.containingNodeTypes.length = 0;
    this.containingNodeChildIndices.length = 0;
    this.containingNodeEndIndices.length = 0;
    const containingTagEndIndices = [];
    if (targetIndex >= this.treeCursor.endIndex) {
      return false;
    }
    let childIndex = -1;
    for (;;) {
      this.containingNodeTypes.push(this.treeCursor.nodeType);
      this.containingNodeChildIndices.push(childIndex);
      this.containingNodeEndIndices.push(this.treeCursor.endIndex);
      const scopeId = this._currentScopeId();
      if (scopeId) {
        if (this.treeCursor.startIndex < targetIndex) {
          insertContainingTag(
            scopeId,
            this.treeCursor.startIndex,
            containingTags,
            containingTagStartIndices
          );
          containingTagEndIndices.push(this.treeCursor.endIndex);
        } else {
          this.atEnd = false;
          this.openTags.push(scopeId);
          this._moveDown();
          break;
        }
      }
      childIndex = this.treeCursor.gotoFirstChildForIndex(targetIndex);
      if (childIndex === null) break;
      if (this.treeCursor.startIndex >= targetIndex) this.atEnd = false;
    }
    if (this.atEnd) {
      this.offset = this.treeCursor.endIndex;
      for (let i = 0, { length } = containingTags; i < length; i++) {
        if (containingTagEndIndices[i] === this.offset) {
          this.closeTags.push(containingTags[i]);
        }
      }
    } else {
      this.offset = this.treeCursor.startIndex;
    }
    return true;
  }
  moveToSuccessor() {
    this.closeTags.length = 0;
    this.openTags.length = 0;
    while (!this.closeTags.length && !this.openTags.length) {
      if (this.atEnd) {
        if (this._moveRight()) {
          const scopeId = this._currentScopeId();
          if (scopeId) this.openTags.push(scopeId);
          this.atEnd = false;
          this._moveDown();
        } else if (this._moveUp(true)) {
          this.atEnd = true;
        } else {
          return false;
        }
      } else if (!this._moveDown()) {
        const scopeId = this._currentScopeId();
        if (scopeId) this.closeTags.push(scopeId);
        this.atEnd = true;
        this._moveUp(false);
      }
    }
    if (this.atEnd) {
      this.offset = this.treeCursor.endIndex;
    } else {
      this.offset = this.treeCursor.startIndex;
    }
    return true;
  }
  getPosition() {
    if (this.atEnd) {
      return this.treeCursor.endPosition;
    } else {
      return this.treeCursor.startPosition;
    }
  }
  compare(other) {
    const result = this.offset - other.offset;
    if (result !== 0) return result;
    if (this.atEnd && !other.atEnd) return -1;
    if (other.atEnd && !this.atEnd) return 1;
    return this.languageLayer.depth - other.languageLayer.depth;
  }
  getCloseScopeIds() {
    return this.closeTags.slice();
  }
  getOpenScopeIds() {
    return this.openTags.slice();
  }
  isAtInjectionBoundary() {
    return this.containingNodeTypes.length === 1;
  }
  _moveUp(atLastChild) {
    let result = false;
    const { endIndex } = this.treeCursor;
    let depth = this.containingNodeEndIndices.length;
    while (
      depth > 1 &&
      (atLastChild || this.containingNodeEndIndices[depth - 2] === endIndex)
    ) {
      atLastChild = false;
      result = true;
      this.treeCursor.gotoParent();
      this.containingNodeTypes.pop();
      this.containingNodeChildIndices.pop();
      this.containingNodeEndIndices.pop();
      --depth;
      const scopeId = this._currentScopeId();
      if (scopeId) this.closeTags.push(scopeId);
    }
    return result;
  }
  _moveDown() {
    let result = false;
    const { startIndex } = this.treeCursor;
    while (this.treeCursor.gotoFirstChild()) {
      if (
        (this.closeTags.length || this.openTags.length) &&
        this.treeCursor.startIndex > startIndex
      ) {
        this.treeCursor.gotoParent();
        break;
      }
      result = true;
      this.containingNodeTypes.push(this.treeCursor.nodeType);
      this.containingNodeChildIndices.push(0);
      this.containingNodeEndIndices.push(this.treeCursor.endIndex);
      const scopeId = this._currentScopeId();
      if (scopeId) this.openTags.push(scopeId);
    }
    return result;
  }
  _moveRight() {
    if (this.treeCursor.gotoNextSibling()) {
      const depth = this.containingNodeTypes.length;
      this.containingNodeTypes[depth - 1] = this.treeCursor.nodeType;
      this.containingNodeChildIndices[depth - 1]++;
      this.containingNodeEndIndices[depth - 1] = this.treeCursor.endIndex;
      return true;
    }
  }
  _currentScopeId() {
    const value = this.languageLayer.grammar.scopeMap.get(
      this.containingNodeTypes,
      this.containingNodeChildIndices,
      this.treeCursor.nodeIsNamed
    );
    const scopeName = applyLeafRules(value, this.treeCursor);
    const node = this.treeCursor.currentNode;
    if (!node.childCount) {
      return this.languageLayer.languageMode.grammar.idForScope(
        scopeName,
        node.text
      );
    } else if (scopeName) {
      return this.languageLayer.languageMode.grammar.idForScope(scopeName);
    }
  }
}
const applyLeafRules = (rules, cursor) => {
  if (!rules || typeof rules === 'string') return rules;
  if (Array.isArray(rules)) {
    for (let i = 0, { length } = rules; i !== length; ++i) {
      const result = applyLeafRules(rules[i], cursor);
      if (result) return result;
    }
    return undefined;
  }
  if (typeof rules === 'object') {
    if (rules.exact) {
      return cursor.nodeText === rules.exact
        ? applyLeafRules(rules.scopes, cursor)
        : undefined;
    }
    if (rules.match) {
      return rules.match.test(cursor.nodeText)
        ? applyLeafRules(rules.scopes, cursor)
        : undefined;
    }
  }
};
class NodeCursorAdaptor {
  get nodeText() {
    return this.node.text;
  }
}
class NullLanguageModeHighlightIterator {
  seek() {
    return [];
  }
  compare() {
    return 1;
  }
  moveToSuccessor() {}
  getPosition() {
    return Point.INFINITY;
  }
  getOpenScopeIds() {
    return [];
  }
  getCloseScopeIds() {
    return [];
  }
}
class NullLayerHighlightIterator {
  seek() {
    return null;
  }
  compare() {
    return 1;
  }
  moveToSuccessor() {}
  getPosition() {
    return Point.INFINITY;
  }
  getOpenScopeIds() {
    return [];
  }
  getCloseScopeIds() {
    return [];
  }
}
class NodeRangeSet {
  constructor(previous, nodes, newlinesBetween, includeChildren) {
    this.previous = previous;
    this.nodes = nodes;
    this.newlinesBetween = newlinesBetween;
    this.includeChildren = includeChildren;
  }
  getRanges(buffer) {
    const previousRanges = this.previous && this.previous.getRanges(buffer);
    const result = [];
    for (const node of this.nodes) {
      let position = node.startPosition;
      let index = node.startIndex;
      if (!this.includeChildren) {
        for (const child of node.children) {
          const nextIndex = child.startIndex;
          if (nextIndex > index) {
            this._pushRange(buffer, previousRanges, result, {
              startIndex: index,
              endIndex: nextIndex,
              startPosition: position,
              endPosition: child.startPosition
            });
          }
          position = child.endPosition;
          index = child.endIndex;
        }
      }
      if (node.endIndex > index) {
        this._pushRange(buffer, previousRanges, result, {
          startIndex: index,
          endIndex: node.endIndex,
          startPosition: position,
          endPosition: node.endPosition
        });
      }
    }
    return result;
  }
  _pushRange(buffer, previousRanges, newRanges, newRange) {
    if (!previousRanges) {
      if (this.newlinesBetween) {
        const { startIndex, startPosition } = newRange;
        this._ensureNewline(buffer, newRanges, startIndex, startPosition);
      }
      newRanges.push(newRange);
      return;
    }
    for (const previousRange of previousRanges) {
      if (previousRange.endIndex <= newRange.startIndex) continue;
      if (previousRange.startIndex >= newRange.endIndex) break;
      const startIndex = Math.max(
        previousRange.startIndex,
        newRange.startIndex
      );
      const endIndex = Math.min(previousRange.endIndex, newRange.endIndex);
      const startPosition = Point.max(
        previousRange.startPosition,
        newRange.startPosition
      );
      const endPosition = Point.min(
        previousRange.endPosition,
        newRange.endPosition
      );
      if (this.newlinesBetween) {
        this._ensureNewline(buffer, newRanges, startIndex, startPosition);
      }
      newRanges.push({ startIndex, endIndex, startPosition, endPosition });
    }
  }
  _ensureNewline(buffer, newRanges, startIndex, startPosition) {
    const lastRange = newRanges[newRanges.length - 1];
    if (lastRange && lastRange.endPosition.row < startPosition.row) {
      newRanges.push({
        startPosition: new Point(
          startPosition.row - 1,
          buffer.lineLengthForRow(startPosition.row - 1)
        ),
        endPosition: new Point(startPosition.row, 0),
        startIndex: startIndex - startPosition.column - 1,
        endIndex: startIndex - startPosition.column
      });
    }
  }
}
function insertContainingTag(tag, index, tags, indices) {
  const i = indices.findIndex(existingIndex => existingIndex > index);
  if (i === -1) {
    tags.push(tag);
    indices.push(index);
  } else {
    tags.splice(i, 0, tag);
    indices.splice(i, 0, index);
  }
}
function rangeIsSmaller(mouse, house) {
  if (!house) return true;
  const mvec = vecFromRange(mouse);
  const hvec = vecFromRange(house);
  return Point.min(mvec, hvec) === mvec;
}
function vecFromRange({ start, end }) {
  return end.translate(start.negate());
}
function rangeForNode(node) {
  return new Range(node.startPosition, node.endPosition);
}
function nodeContainsIndices(node, start, end) {
  if (node.startIndex < start) return node.endIndex >= end;
  if (node.startIndex === start) return node.endIndex > end;
  return false;
}
function nodeIsSmaller(left, right) {
  if (!left) return false;
  if (!right) return true;
  return left.endIndex - left.startIndex < right.endIndex - right.startIndex;
}
function last(array) {
  return array[array.length - 1];
}
function hasMatchingFoldSpec(specs, node) {
  return specs.some(
    ({ type, named }) => type === node.type && named === node.isNamed
  );
}
[
  '_suggestedIndentForLineWithScopeAtBufferRow',
  'suggestedIndentForEditedBufferRow',
  'increaseIndentRegexForScopeDescriptor',
  'decreaseIndentRegexForScopeDescriptor',
  'decreaseNextIndentRegexForScopeDescriptor',
  'regexForPattern',
  'getNonWordCharacters'
].forEach(methodName => {
  TreeSitterLanguageMode.prototype[methodName] =
    TextMateLanguageMode.prototype[methodName];
});
TreeSitterLanguageMode.LanguageLayer = LanguageLayer;
TreeSitterLanguageMode.prototype.syncTimeoutMicros = 1000;
module.exports = TreeSitterLanguageMode;

================
File: src/typescript.js
================
'use strict';
const _ = require('underscore-plus');
const crypto = require('crypto');
const path = require('path');
const defaultOptions = {
  target: 1,
  module: 'commonjs',
  sourceMap: true
};
let TypeScriptSimple = null;
let typescriptVersionDir = null;
exports.shouldCompile = function() {
  return true;
};
exports.getCachePath = function(sourceCode) {
  if (typescriptVersionDir == null) {
    const version = require('typescript-simple/package.json').version;
    typescriptVersionDir = path.join(
      'ts',
      createVersionAndOptionsDigest(version, defaultOptions)
    );
  }
  return path.join(
    typescriptVersionDir,
    crypto
      .createHash('sha1')
      .update(sourceCode, 'utf8')
      .digest('hex') + '.js'
  );
};
exports.compile = function(sourceCode, filePath) {
  if (!TypeScriptSimple) {
    TypeScriptSimple = require('typescript-simple').TypeScriptSimple;
  }
  if (process.platform === 'win32') {
    filePath = 'file:///' + path.resolve(filePath).replace(/\\/g, '/');
  }
  const options = _.defaults({ filename: filePath }, defaultOptions);
  return new TypeScriptSimple(options, false).compile(sourceCode, filePath);
};
function createVersionAndOptionsDigest(version, options) {
  return crypto
    .createHash('sha1')
    .update('typescript', 'utf8')
    .update('\0', 'utf8')
    .update(version, 'utf8')
    .update('\0', 'utf8')
    .update(JSON.stringify(options), 'utf8')
    .digest('hex');
}

================
File: src/ui.js
================
const path = require("path");
const fs = require("fs");
const MarkdownIt = require("markdown-it");
const { TextEditor } = require("atom");
const fuzzyNative = require("@pulsar-edit/fuzzy-native");
const mdComponents = {
  deps: {
    domPurify: null,
    yamlFrontMatter: null,
    markdownItEmoji: null,
    markdownItGitHubHeadings: null,
    markdownItTaskCheckbox: null
  },
  reg: {
    localLinks: {
      currentDir: new RegExp(/^\.\//),
      rootDir: new RegExp(/^\//)
    },
    globalLinks: {
      base64: new RegExp(/^data:image\/.*;base64/, "i")
    },
    atomLinks: {
      package: new RegExp(/^https:\/\/atom\.io\/packages\/(.*)$/),
      flightManual: new RegExp(/^https:\/\/flight-manual\.atom\.io\//)
    }
  },
};
function renderMarkdown(content, givenOpts = {}) {
  const defaultOpts = {
    renderMode: "full",
    html: true,
    sanitize: true,
    sanitizeAllowUnknownProtocols: true,
    sanitizeAllowSelfClose: true,
    breaks: false,
    handleFrontMatter: true,
    useDefaultEmoji: false,
    useGitHubHeadings: false,
    useTaskCheckbox: true,
    taskCheckboxDisabled: true,
    taskCheckboxDivWrap: false,
    transformImageLinks: true,
    transformAtomLinks: true,
    transformNonFqdnLinks: true,
    rootDomain: "", // The root URL that should be used for the above 'transform' options
    filePath: "", // The path to the file where this markdown is generated from,
    disableMode: "none",
  };
  let opts = { ...defaultOpts, ...givenOpts };
  const validateRootDomain = () => {
    return typeof opts.rootDomain === "string" && opts.rootDomain.length > 1;
  };
  const cleanRootDomain = () => {
    return opts.rootDomain.replace(".git", "").replace(/\/$/, "");
  };
  const markdownItOpts = {
    html: opts.html,
    breaks: opts.breaks
  };
  let md = new MarkdownIt(markdownItOpts);
  if (opts.useDefaultEmoji) {
    mdComponents.deps.markdownItEmoji ??= require("markdown-it-emoji");
    md.use(mdComponents.deps.markdownItEmoji, {});
  }
  if (opts.useGitHubHeadings) {
    mdComponents.deps.markdownItGitHubHeadings ??= require("markdown-it-github-headings");
    md.use(mdComponents.deps.markdownItGitHubHeadings, {});
  }
  if (opts.useTaskCheckbox) {
    mdComponents.deps.markdownItTaskCheckbox ??= require("markdown-it-task-checkbox");
    md.use(mdComponents.deps.markdownItTaskCheckbox, {
      disabled: opts.taskCheckboxDisabled,
      divWrap: opts.taskCheckboxDivWrap
    });
  }
  if (opts.transformImageLinks && validateRootDomain()) {
    const defaultImageRenderer = md.renderer.rules.image;
    let couldBeLocalItem;
    if (typeof opts.filePath != "string" || opts.filePath.length < 1) {
      couldBeLocalItem = false;
    } else {
      couldBeLocalItem = true;
    }
    md.renderer.rules.image = (tokens, idx, options, env, self) => {
      let token = tokens[idx];
      let aIndex = token.attrIndex("src");
      if (mdComponents.reg.localLinks.currentDir.test(token.attrGet("src"))) {
        let rawLink = token.attrGet("src");
        rawLink = rawLink.replace(mdComponents.reg.localLinks.currentDir, "");
        // Now we need to handle links for both the web and locally
        // We can do this by first checking if the link resolves locally
        if (couldBeLocalItem) {
          let newSrc = path.resolve(path.dirname(opts.filePath, rawLink));
          if (!fs.lstatSync(newSrc).isFile()) {
            token.attrSet("src", newSrc);
          } else {
            token.attrSet("src", `${cleanRootDomain()}/raw/HEAD/${rawLink}`);
          }
        } else {
          token.attrSet("src", `${cleanRootDomain()}/raw/HEAD/${rawLink}`);
        }
      } else if (mdComponents.reg.localLinks.rootDir.test(token.attrGet("src"))) {
        let rawLink = token.attrGet("src");
        rawLink = rawLink.replace(mdComponents.reg.localLinks.rootDir, "");
        // Now to handle the possible web or local link
        if (couldBeLocalItem) {
          const [rootDirectory] = atom.project.relativePath(opts.filePath);
          if (!fs.lstatSync(src).isFile() && rootDirectory) {
            let newSrc = path.join(rootDirectory, rawLink);
            token.attrSet("src", newSrc);
          } else {
            token.attrSet("src", `${cleanRootDomain()}/raw/HEAD/${rawLink}`);
          }
        } else {
          token.attrSet("src", `${cleanRootDomain()}/raw/HEAD/${rawLink}`);
        }
      } else if (!token.attrGet("src").startsWith("http") && !mdComponents.reg.globalLinks.base64.test(token.attrGet("src"))) {
        let rawLink = token.attrGet("src");
        token.attrSet("src", `${cleanRootDomain()}/raw/HEAD/${rawLink}`);
      } else if ([".gif", ".png", ".jpg", ".jpeg", ".webp"].find(ext => token.attrGet("src").endsWith(ext)) && token.attrGet("src").startsWith("https://github.com") && token.attrGet("src").includes("blob")) {
        let rawLink = token.attrGet("src");
        token.attrSet("src", rawLink.replace("blob", "raw"));
      }
      return defaultImageRenderer(tokens, idx, options, env, self);
    };
  }
  if (validateRootDomain() && opts.transformNonFqdnLinks) {
    md.core.ruler.after("inline", "fix-links", (state) => {
      state.tokens.forEach((blockToken) => {
        if (blockToken.type === "inline" && blockToken.children) {
          blockToken.children.forEach((token) => {
            if (token.type === "link_open") {
              token.attrs.forEach((attr) => {
                if (attr[0] === "href") {
                  let link = attr[1];
                  if (opts.transformNonFqdnLinks && mdComponents.reg.localLinks.currentDir.test(link)) {
                    attr[1] = `${cleanRootDomain()}/blob/HEAD/${link.replace(mdComponents.reg.localLinks.currentDir, "")}`;
                  } else if (opts.transformNonFqdnLinks && mdComponents.reg.localLinks.rootDir.test(link)) {
                    attr[1] = `${cleanRootDomain()}/blob/HEAD/${link.replace(mdComponents.reg.localLinks.rootDir, "")}`;
                  } else if (opts.transformNonFqdnLinks && !link.startsWith("http")) {
                    attr[1] = `${cleanRootDomain()}/blob/HEAD/${link.replace(".git", "")}`;
                  }
                }
              });
            }
          });
        }
      });
    });
  } else if (opts.transformAtomLinks) {
    md.core.ruler.after("inline", "fix-atom-links", (state) => {
      state.tokens.forEach((blockToken) => {
        if (blockToken.type === "inline" && blockToken.children) {
          blockToken.children.forEach((token) => {
            if (token.type === "link_open") {
              token.attrs.forEach((attr) => {
                if (attr[0] === "href") {
                  let link = attr[1];
                  if (mdComponents.reg.atomLinks.package.test(link)) {
                    attr[1] = `https://web.pulsar-edit.dev/packages/${link.match(mdComponents.reg.atomLinks.package)[1]}`;
                  } else if (mdComponents.reg.atomLinks.flightManual.test(link)) {
                    attr[1] = link.replace(mdComponents.reg.atomLinks.flightManual, "https://web.archive.org/web/20221215003438/https://flight-manual.atom.io/");
                  }
                }
              });
            }
          });
        }
      });
    });
  }
  md.options.highlight = function (str, lang) {
    return `<pre><code class="language-${lang}">${md.utils.escapeHtml(str)}</code></pre>`;
  };
  if (opts.disableMode === "strict") {
    md.disable("lheading");
    md.renderer.rules.code_block = (tokens, idx, _options, _env, _self) => {
      if (tokens[idx].type === "code_block") {
        return "";
      }
    };
    // Disable Code Fences
    md.renderer.rules.fence = (tokens, idx, _options, _env, _self) => {
      if (tokens[idx].type === "fence") {
        return "";
      }
    };
    // Disable Images
    md.renderer.rules.image = (tokens, idx, _options, _env, _self) => {
      // Double check this is an image
      if (tokens[idx].type === "image") {
        return "";
      }
    };
    // Only support line breaks in HTML that's inline
    md.inline.ruler.before("html_inline", "only_allow_line_breaks", (state) => {
      if (state.src.charAt(state.pos) === "<") {
        const textAfterPending = state.src.replace(state.pending, "");
        const match = textAfterPending.match(/^<br\s*\/?>/);
        if (match) {
          // We define breakline as a custom Token Type
          let token = state.push("html_inline", "breakline", 0);
          token.content = "<br>";
          state.pos += match[0].length;
          return true;
        }
      }
    });
    md.block.ruler.before("heading", "strip_heading", (state, startLine, endLine) => {
      let pos = state.bMarks[startLine] + state.tShift[startLine];
      if (state.src.charAt(pos) === "#") {
        let max = state.eMarks[startLine];
        const isSpace = () => {
          let code = state.src.charCodeAt(pos);
          switch(code) {
            case 0x09:
            case 0x20:
              return true;
          }
          return false;
        };
        let level = 1;
        let ch = state.src.charAt(++pos);
        while (ch === "#" && pos < max && level <= 6) {
          level++;
          ch = state.src.charAt(++pos);
        }
        if (level > 6 || (pos < max && !isSpace())) { return false; }
        state.pos += level;
        state.line = startLine + 1;
        return true;
      }
    });
    const stripAllTokensTill = (tokens, initIdx, endType) => {
      let idx = initIdx;
      while(idx < tokens.length) {
        tokens[idx].type = "text";
        tokens[idx].content = "";
        if (tokens[idx].type == endType) {
          break;
        }
        idx++;
      }
      return;
    };
    // Disable blockquotes
    md.renderer.rules.blockquote_open = (tokens, idx, _options, _env, _self) => {
      stripAllTokensTill(tokens, idx, "blockquote_close");
      return "";
    };
    // Disable Bullet lists
    md.renderer.rules.bullet_list_open = (tokens, idx, _options, _env, _self) => {
      stripAllTokensTill(tokens, idx, "bullet_list_close");
      return "";
    };
    // Disable Ordered lists
    md.renderer.rules.ordered_list_open = (tokens, idx, _options, _env, _self) => {
      stripAllTokensTill(tokens, idx, "ordered_list_close");
      return "";
    };
    // Ensure that only breaklines are supported as inline raw HTML
    md.renderer.rules.html_inline = (tokens, idx, _options, _env, _self) => {
      if (tokens[idx].type === "html_inline") {
        if (
          tokens[idx].tag !== "breakline"
          ) {
            return "";
          } else {
            return tokens[idx].content;
          }
      }
    };
    // Ensure nothing is supported as block HTML
    md.renderer.rules.html_block = (tokens, idx, _options, _env, _self) => {
      if (tokens[idx].type === "html_block") {
        return "";
      }
    };
  }
  let textContent;
  if (opts.handleFrontMatter) {
    mdComponents.deps.yamlFrontMatter ??= require("yaml-front-matter");
    const { __content, vars } = mdComponents.deps.yamlFrontMatter.loadFront(content);
    const renderYamlTable = (variables) => {
      if (typeof variables === "undefined") {
        return "";
      }
      const entries = Object.entries(variables);
      if (!entries.length) {
        return "";
      }
      const markdownRows = [
        entries.map(entry => entry[0]),
        entries.map(entry => '--'),
        entries.map((entry) => {
          if (typeof entry[1] === "object" && !Array.isArray(entry[1])) {
            return md.render(renderYamlTable(entry[1])).replace(/\n/g, "");
          } else {
            return entry[1];
          }
        })
      ];
      return (
        markdownRows.map(row => "| " + row.join(" | ") + " |").join("\n") + "\n"
      );
    };
    textContent = renderYamlTable(vars) + __content;
  } else {
    textContent = content;
  }
  let rendered = md.render(textContent);
  if (opts.sanitize) {
    mdComponents.deps.domPurify ??= require("dompurify");
    let domPurifyOpts = {
      ALLOW_UNKNOWN_PROTOCOLS: opts.sanitizeAllowUnknownProtocols,
      ALLOW_SELF_CLOSE_IN_ATTR: opts.sanitizeAllowSelfClose
    };
    rendered = mdComponents.deps.domPurify.sanitize(rendered, opts);
  }
  return rendered;
}
function applySyntaxHighlighting(content, givenOpts = {}) {
  const defaultOpts = {
    syntaxScopeNameFunc: null,
    grammar: null,
    renderMode: "full",
  };
  const opts = { ...defaultOpts, ...givenOpts };
  const scopeForFenceName = (fence) => {
    if (typeof opts.syntaxScopeNameFunc == "function") {
      return opts.syntaxScopeNameFunc(fence);
    } else {
      return "text.plain";
    }
  };
  let defaultLanguage;
  const fontFamily = atom.config.get("editor.fontFamily");
  if ((opts.grammar != null ? opts.grammar.scopeName : undefined) === "source.litcoffee") {
    defaultLanguage = "coffee";
  } else {
    defaultLanguage = "text";
  }
  if (fontFamily) {
    for (const codeElement of content.querySelectorAll("code")) {
      codeElement.style.fontFamily = fontFamily;
    }
  }
  let editorCallback;
  if (opts.renderMode === "fragment") {
    editorCallback = makeAtomEditorNonInteractive;
  } else {
    editorCallback = convertAtomEditorToStandardElement;
  }
  const promises = [];
  for (const preElement of content.querySelectorAll("pre")) {
    const codeBlock = preElement.firstElementChild ?? preElement;
    const className = codeBlock.getAttribute("class");
    const fenceName =
      className != null ? className.replace(/^language-/, "") : defaultLanguage;
    const editor = new TextEditor({
      readonly: true,
      keyboardInputEnabled: false
    });
    const editorElement = editor.getElement();
    preElement.classList.add("editor-colors", `lang-${fenceName}`);
    editorElement.setUpdatedSynchronously(true);
    preElement.innerHTML = "";
    preElement.parentNode.insertBefore(editorElement, preElement);
    editor.setText(codeBlock.textContent.replace(/\r?\n$/, ""));
    atom.grammars.assignLanguageMode(editor, scopeForFenceName(fenceName));
    editor.setVisible(true);
    promises.push(editorCallback(editorElement, preElement));
  }
  return Promise.all(promises);
}
/**
 * @function convertToDOM
 * @memberof markdown
 * @desc Takes a raw HTML string of data and returns a proper HTMLFragment.
 * This should be done if you need access to APIs available on the DOM itself.
 * @param {string} content - The HTML String.
 * @returns {HTMLFragment}
 */
function convertToDOM(content) {
  const template = document.createElement("template");
  template.innerHTML = content;
  const fragment = template.content.cloneNode(true);
  return fragment;
}
function setCandidates(matcherOrCandidates, candidates) {
  if(candidates) {
    matcherOrCandidates.fuzzyMatcher.setCandidates(
      [...Array(candidates.length).keys()],
      candidates
    );
    return matcherOrCandidates;
  } else {
    return new Matcher(
      new fuzzyNative.Matcher(
        [...Array(matcherOrCandidates.length).keys()],
        matcherOrCandidates
      )
    );
  }
}
class Matcher {
  constructor(fuzzyMatcher) {
    this.numCpus = Math.max(1, Math.round(4 * 0.8))
    this.fuzzyMatcher = fuzzyMatcher
  }
  match(query, options = {}) {
    let {numThreads, algorithm} = options;
    numThreads ||= this.numCpus;
    algorithm ||= 'fuzzaldrin';
    return this.fuzzyMatcher.match(query, {...options, numThreads, algorithm});
  }
  setCandidates(candidates) {
    return setCandidates(this, candidates);
  }
}
const fuzzyMatcher = {
  setCandidates: setCandidates,
  score(candidate, query, opts = {}) {
    return this.match(candidate, query)?.score || 0;
  },
  match(candidate, query, opts = {}) {
    const matcher = setCandidates([candidate]);
    return matcher.match(query, opts)[0];
  }
}
function makeAtomEditorNonInteractive(editorElement, preElement) {
  preElement.remove();
  editorElement.setAttributeNode(document.createAttribute("gutter-hidden"));
  editorElement.removeAttribute("tabindex");
  for (const cursorLineDecoration of editorElement.getModel().cursorLineDecorations) {
    cursorLineDecoration.destroy();
  }
}
function convertAtomEditorToStandardElement(editorElement, preElement) {
  return new Promise(function (resolve) {
    const editor = editorElement.getModel();
    const done = () =>
      editor.component.getNextUpdatePromise().then(function () {
        for (const line of editorElement.querySelectorAll(
          ".line:not(.dummy)"
        )) {
          const line2 = document.createElement("div");
          line2.className = "line";
          line2.innerHTML = line.firstChild.innerHTML;
          preElement.appendChild(line2);
        }
        editorElement.remove();
        resolve();
      })
    const languageMode = editor.getBuffer().getLanguageMode();
    if (languageMode.fullyTokenized || languageMode.tree) {
      done();
    } else {
      editor.onDidTokenize(done);
    }
  });
}
const markdown = {
  render: renderMarkdown,
  applySyntaxHighlighting: applySyntaxHighlighting,
  convertToDOM: convertToDOM
};
module.exports = {
  markdown,
  fuzzyMatcher
};

================
File: src/update-process-env.js
================
const fs = require('fs');
const childProcess = require('child_process');
const ENVIRONMENT_VARIABLES_TO_PRESERVE = new Set([
  'NODE_ENV',
  'NODE_PATH',
  'ATOM_HOME',
  'ATOM_DISABLE_SHELLING_OUT_FOR_ENVIRONMENT'
]);
const PLATFORMS_KNOWN_TO_WORK = new Set(['darwin', 'linux']);
const ENV_COMMAND =
  'command awk \'BEGIN{for(v in ENVIRON) printf("%s=%s%c", v, ENVIRON[v], 0)}\'';
async function updateProcessEnv(launchEnv) {
  let envToAssign;
  if (launchEnv) {
    if (shouldGetEnvFromShell(launchEnv)) {
      envToAssign = await getEnvFromShell(launchEnv);
    } else if (launchEnv.PWD || launchEnv.PROMPT || launchEnv.PSModulePath) {
      envToAssign = launchEnv;
    }
  }
  if (envToAssign) {
    for (let key in process.env) {
      if (!ENVIRONMENT_VARIABLES_TO_PRESERVE.has(key)) {
        delete process.env[key];
      }
    }
    for (let key in envToAssign) {
      if (
        !ENVIRONMENT_VARIABLES_TO_PRESERVE.has(key) ||
        (!process.env[key] && envToAssign[key])
      ) {
        process.env[key] = envToAssign[key];
      }
    }
    if (envToAssign.ATOM_HOME && fs.existsSync(envToAssign.ATOM_HOME)) {
      process.env.ATOM_HOME = envToAssign.ATOM_HOME;
    }
  }
}
function shouldGetEnvFromShell(env) {
  if (!PLATFORMS_KNOWN_TO_WORK.has(process.platform)) {
    return false;
  }
  if (!env || !env.SHELL || env.SHELL.trim() === '') {
    return false;
  }
  const disableSellingOut =
    env.ATOM_DISABLE_SHELLING_OUT_FOR_ENVIRONMENT ||
    process.env.ATOM_DISABLE_SHELLING_OUT_FOR_ENVIRONMENT;
  if (disableSellingOut === 'true') {
    return false;
  }
  return true;
}
async function getEnvFromShell(env) {
  let { stdout, error } = await new Promise(resolve => {
    let child;
    let error;
    let stdout = '';
    let done = false;
    const cleanup = () => {
      if (!done && child) {
        child.kill();
        done = true;
      }
    };
    process.once('exit', cleanup);
    setTimeout(() => {
      cleanup();
    }, 5000);
    child = childProcess.spawn(env.SHELL, ['-ilc', ENV_COMMAND], {
      encoding: 'utf8',
      detached: true,
      stdio: ['ignore', 'pipe', process.stderr]
    });
    const buffers = [];
    child.on('error', e => {
      done = true;
      error = e;
    });
    child.stdout.on('data', data => {
      buffers.push(data);
    });
    child.on('close', (code, signal) => {
      done = true;
      process.removeListener('exit', cleanup);
      if (buffers.length) {
        stdout = Buffer.concat(buffers).toString('utf8');
      }
      resolve({ stdout, error });
    });
  });
  if (error) {
    if (error.handle) {
      error.handle();
    }
    console.log(
      'warning: ' +
        env.SHELL +
        ' -ilc "' +
        ENV_COMMAND +
        '" failed with signal (' +
        error.signal +
        ')'
    );
    console.log(error);
  }
  if (!stdout || stdout.trim() === '') {
    return null;
  }
  let result = {};
  for (let line of stdout.split('\0')) {
    if (line.includes('=')) {
      let components = line.split('=');
      let key = components.shift();
      let value = components.join('=');
      result[key] = value;
    }
  }
  return result;
}
module.exports = { updateProcessEnv, shouldGetEnvFromShell };

================
File: src/uri-handler-registry.js
================
const url = require('url');
const { Emitter, Disposable } = require('event-kit');
module.exports = class URIHandlerRegistry {
  constructor(maxHistoryLength = 50) {
    this.registrations = new Map();
    this.history = [];
    this.maxHistoryLength = maxHistoryLength;
    this._id = 0;
    this.emitter = new Emitter();
  }
  registerHostHandler(host, callback) {
    if (typeof callback !== 'function') {
      throw new Error(
        'Cannot register a URI host handler with a non-function callback'
      );
    }
    if (this.registrations.has(host)) {
      throw new Error(
        `There is already a URI host handler for the host ${host}`
      );
    } else {
      this.registrations.set(host, callback);
    }
    return new Disposable(() => {
      this.registrations.delete(host);
    });
  }
  async handleURI(uri) {
    const parsed = url.parse(uri, true);
    const { protocol, slashes, auth, port, host } = parsed;
    if (protocol !== 'atom:' || slashes !== true || auth || port) {
      throw new Error(
        `URIHandlerRegistry#handleURI asked to handle an invalid URI: ${uri}`
      );
    }
    const registration = this.registrations.get(host);
    const historyEntry = { id: ++this._id, uri: uri, handled: false, host };
    try {
      if (registration) {
        historyEntry.handled = true;
        await registration(parsed, uri);
      }
    } finally {
      this.history.unshift(historyEntry);
      if (this.history.length > this.maxHistoryLength) {
        this.history.length = this.maxHistoryLength;
      }
      this.emitter.emit('history-change');
    }
  }
  getRecentlyHandledURIs() {
    return this.history;
  }
  onHistoryChange(cb) {
    return this.emitter.on('history-change', cb);
  }
  destroy() {
    this.emitter.dispose();
    this.registrations = new Map();
    this.history = [];
    this._id = 0;
  }
};

================
File: src/view-registry.js
================
const Grim = require('grim');
const { Disposable } = require('event-kit');
const AnyConstructor = Symbol('any-constructor');
module.exports = class ViewRegistry {
  constructor(atomEnvironment) {
    this.animationFrameRequest = null;
    this.documentReadInProgress = false;
    this.performDocumentUpdate = this.performDocumentUpdate.bind(this);
    this.atomEnvironment = atomEnvironment;
    this.clear();
  }
  clear() {
    this.views = new WeakMap();
    this.providers = [];
    this.clearDocumentRequests();
  }
  addViewProvider(modelConstructor, createView) {
    let provider;
    if (arguments.length === 1) {
      switch (typeof modelConstructor) {
        case 'function':
          provider = {
            createView: modelConstructor,
            modelConstructor: AnyConstructor
          };
          break;
        case 'object':
          Grim.deprecate(
            'atom.views.addViewProvider now takes 2 arguments: a model constructor and a createView function. See docs for details.'
          );
          provider = modelConstructor;
          break;
        default:
          throw new TypeError('Arguments to addViewProvider must be functions');
      }
    } else {
      provider = { modelConstructor, createView };
    }
    this.providers.push(provider);
    return new Disposable(() => {
      this.providers = this.providers.filter(p => p !== provider);
    });
  }
  getViewProviderCount() {
    return this.providers.length;
  }
  getView(object) {
    if (object == null) {
      return;
    }
    let view = this.views.get(object);
    if (!view) {
      view = this.createView(object);
      this.views.set(object, view);
    }
    return view;
  }
  createView(object) {
    if (object instanceof HTMLElement) {
      return object;
    }
    let element;
    if (object && typeof object.getElement === 'function') {
      element = object.getElement();
      if (element instanceof HTMLElement) {
        return element;
      }
    }
    if (object && object.element instanceof HTMLElement) {
      return object.element;
    }
    if (object && object.jquery) {
      return object[0];
    }
    for (let provider of this.providers) {
      if (provider.modelConstructor === AnyConstructor) {
        element = provider.createView(object, this.atomEnvironment);
        if (element) {
          return element;
        }
        continue;
      }
      if (object instanceof provider.modelConstructor) {
        element =
          provider.createView &&
          provider.createView(object, this.atomEnvironment);
        if (element) {
          return element;
        }
        let ViewConstructor = provider.viewConstructor;
        if (ViewConstructor) {
          element = new ViewConstructor();
          if (element.initialize) {
            element.initialize(object);
          } else if (element.setModel) {
            element.setModel(object);
          }
          return element;
        }
      }
    }
    if (object && object.getViewClass) {
      let ViewConstructor = object.getViewClass();
      if (ViewConstructor) {
        const view = new ViewConstructor(object);
        return view[0];
      }
    }
    throw new Error(
      `Can't create a view for ${
        object.constructor.name
      } instance. Please register a view provider.`
    );
  }
  updateDocument(fn) {
    this.documentWriters.push(fn);
    if (!this.documentReadInProgress) {
      this.requestDocumentUpdate();
    }
    return new Disposable(() => {
      this.documentWriters = this.documentWriters.filter(
        writer => writer !== fn
      );
    });
  }
  readDocument(fn) {
    this.documentReaders.push(fn);
    this.requestDocumentUpdate();
    return new Disposable(() => {
      this.documentReaders = this.documentReaders.filter(
        reader => reader !== fn
      );
    });
  }
  getNextUpdatePromise() {
    if (this.nextUpdatePromise == null) {
      this.nextUpdatePromise = new Promise(resolve => {
        this.resolveNextUpdatePromise = resolve;
      });
    }
    return this.nextUpdatePromise;
  }
  clearDocumentRequests() {
    this.documentReaders = [];
    this.documentWriters = [];
    this.nextUpdatePromise = null;
    this.resolveNextUpdatePromise = null;
    if (this.animationFrameRequest != null) {
      cancelAnimationFrame(this.animationFrameRequest);
      this.animationFrameRequest = null;
    }
  }
  requestDocumentUpdate() {
    if (this.animationFrameRequest == null) {
      this.animationFrameRequest = requestAnimationFrame(
        this.performDocumentUpdate
      );
    }
  }
  performDocumentUpdate() {
    const { resolveNextUpdatePromise } = this;
    this.animationFrameRequest = null;
    this.nextUpdatePromise = null;
    this.resolveNextUpdatePromise = null;
    let writer = this.documentWriters.shift();
    while (writer) {
      writer();
      writer = this.documentWriters.shift();
    }
    let reader = this.documentReaders.shift();
    this.documentReadInProgress = true;
    while (reader) {
      reader();
      reader = this.documentReaders.shift();
    }
    this.documentReadInProgress = false;
    writer = this.documentWriters.shift();
    while (writer) {
      writer();
      writer = this.documentWriters.shift();
    }
    if (resolveNextUpdatePromise) {
      resolveNextUpdatePromise();
    }
  }
};

================
File: src/wasm-tree-sitter-grammar.js
================
const fs = require('fs');
const path = require('path');
const Grim = require('grim');
const dedent = require('dedent');
const Parser = require('./web-tree-sitter');
const { CompositeDisposable, Emitter } = require('event-kit');
const { File } = require('pathwatcher');
const { normalizeDelimiters } = require('./comment-utils.js');
const parserInitPromise = Parser.init();
function isPosition(obj) {
  return ('row' in obj && 'column' in obj);
}
const ZERO_POINT = Object.freeze({ row: 0, column: 0 });
const QUERY_CAPTURES_DEPRECATION_EXPLANATION = dedent`\
  The \`captures\` method available on Tree-sitter query objects uses a new
  function signature; the old signature is deprecated. The new signature is
  \`(node, options)\`. If you want to limit a query to a specific range,
  specify \`startPosition\` and \`endPosition\` properties within \`options\`.
`;
let didWrapQueryCaptures = false;
// When `web-tree-sitter` harmonized its API with that of `node-tree-sitter`,
function wrapQueryCaptures(query) {
  didWrapQueryCaptures = true;
  let QueryPrototype = Object.getPrototypeOf(query);
  let originalCaptures = QueryPrototype.captures;
  QueryPrototype.captures = function captures(node, ...args) {
    if (
      args.length >= 2 && (isPosition(args[0]) || isPosition(args[1])) ||
      isPosition(args[0])
    ) {
      Grim.deprecate(QUERY_CAPTURES_DEPRECATION_EXPLANATION);
      let startPosition = isPosition(args[0]) ? args[0] : ZERO_POINT;
      let endPosition = isPosition(args[1]) ? args[1] : args[0];
      let originalOptions = args[2] ?? {};
      let newOptions = {
        ...originalOptions,
        startPosition,
        endPosition
      };
      return originalCaptures.call(this, node, newOptions);
    } else {
      return originalCaptures.call(this, node, ...args);
    }
  };
}
module.exports = class WASMTreeSitterGrammar {
  constructor(registry, grammarPath, params) {
    this.registry = registry;
    this.name = params.name;
    this.type = 'modern-tree-sitter';
    this.scopeName = params.scopeName;
    this.contentRegex = buildRegex(params.contentRegex);
    this.firstLineRegex = buildRegex(params.firstLineRegex);
    this.injectionRegex = buildRegex(
      params.injectionRegex || params.injectionRegExp
    );
    this.injectionPointsByType = {};
    this.grammarFilePath = grammarPath;
    this.queryPaths = params.treeSitter;
    this.languageSegment = params.treeSitter?.languageSegment ?? null;
    const dirName = path.dirname(grammarPath);
    this.emitter = new Emitter;
    this.subscriptions = new CompositeDisposable;
    this.queryCache = new Map();
    this.promisesForQueryFiles = new Map();
    this.promisesForQueries = new Map();
    this.treeSitterGrammarPath = path.join(dirName, params.treeSitter.grammar);
    this.fileTypes = params.fileTypes || [];
    this.nextScopeId = 256 + 1;
    this.classNamesById = new Map();
    this.scopeNamesById = new Map();
    this.idsByScope = Object.create(null);
    this.commentStrings = {
      commentStartString: params.comments && params.comments.start,
      commentEndString: params.comments && params.comments.end
    };
    this.commentMetadata = params.comments;
    this.shouldObserveQueryFiles = atom.inDevMode() && !atom.inSpecMode();
    this.getLanguage();
    for (const injectionPoint of params.injectionPoints ?? []) {
      this.addInjectionPoint(injectionPoint);
    }
  }
  idForScope(scopeName, _text) {
    if (!scopeName) { return undefined; }
    let id = this.idsByScope[scopeName];
    if (!id) {
      id = this.nextScopeId += 2;
      const className = scopeName
        .split('.')
        .map(s => `syntax--${s}`)
        .join(' ');
      this.idsByScope[scopeName] = id;
      this.classNamesById.set(id, className);
      this.scopeNamesById.set(id, scopeName);
    }
    return id;
  }
  getCommentDelimiters() {
    let commentDelimiters = atom.config.get(
      'editor.commentDelimiters',
      { scope: [this.scopeName] }
    );
    if (commentDelimiters) return commentDelimiters;
    if (this.commentMetadata) {
      return normalizeDelimiters(this.commentMetadata);
    }
    let start = atom.config.get('editor.commentStart', { scope: [this.scope] });
    let end = atom.config.get('editor.commentEnd', { scope: [this.scope] });
    return normalizeDelimiters({ start, end });
  }
  classNameForScopeId(id) {
    return this.classNamesById.get(id);
  }
  scopeNameForScopeId(id) {
    return this.scopeNamesById.get(id);
  }
  getLanguageSync() {
    return this._language;
  }
  async getLanguage() {
    await parserInitPromise;
    if (!this._language) {
      try {
        this._language = await Parser.Language.load(this.treeSitterGrammarPath);
      } catch (err) {
        console.error(`Error loading grammar for ${this.scopeName}; original error follows`);
        throw err;
      }
    }
    if (!this._queryFilesLoaded) {
      await this.loadQueryFiles(this.grammarFilePath, this.queryPaths);
    }
    return this._language;
  }
  async loadQueryFiles(grammarPath, queryPaths) {
    if (this._loadQueryFilesPromise) {
      return this._loadQueryFilesPromise;
    }
    this._loadQueryFilesPromise = new Promise((resolve) => {
      let promises = [];
      let dirName = path.dirname(grammarPath);
      for (let [key, name] of Object.entries(queryPaths)) {
        if (!key.endsWith('Query')) { continue; }
        let paths = Array.isArray(name) ? name : [name];
        let filePaths = paths.map(p => path.join(dirName, p));
        promises.push(this.loadQueryFile(filePaths, key));
        if (this.shouldObserveQueryFiles && !this._queryFilesLoaded) {
          this.observeQueryFile(filePaths, key);
        }
      }
      return Promise.all(promises).then(() => resolve());
    }).then(() => {
      this._queryFilesLoaded = true;
      this._loadQueryFilesPromise = null;
      this.emitter.emit('did-load-query-files', this);
    });
    return this._loadQueryFilesPromise;
  }
  loadQueryFile(paths, queryType) {
    let key = `${paths.join(',')}/${queryType}`;
    let existingPromise = this.promisesForQueryFiles.get(key);
    if (existingPromise) { return existingPromise; }
    let readFilePromises = paths.map(path => {
      return fs.promises.readFile(path, 'utf-8').then((contents) => {
        return { contents, path };
      });
    });
    let promise = Promise.all(readFilePromises).then((allResults) => {
      let output = "";
      for (let result of allResults) {
        let { contents, path } = result;
        if (contents === "") {
          // An empty file should still count as “present” when assessing whether
          // a grammar has a particular query. So we'll set the contents to a
          // comment instead.
          contents = '; (empty)';
        }
        if (contents.includes('._LANG_')) {
          // The `_LANG_` token indicates places where the last segment of a
          // scope name will vary based on which grammar includes it. It
          // assumes that the grammar author will define a segment (like
          // `ts.tsx`) under the `treeSitter.languageSegment` setting in the
          // grammar file.
          if (this.languageSegment) {
            contents = contents.replace(/\._LANG_/g, `.${this.languageSegment}`);
          } else {
            console.warn(`Warning: query file at ${path} includes _LANG_ tokens, but grammar does not specify a "treeSitter.languageSegment" setting.`);
          }
        }
        output += `\n${contents}`;
      }
      if (this[queryType] !== output) {
        this[queryType] = output;
        this.queryCache.delete(queryType);
      }
    }).finally(() => {
      this.promisesForQueryFiles.delete(key);
    });
    this.promisesForQueryFiles.set(key, promise);
    return promise;
  }
  getQuerySync(queryType) {
    let language = this.getLanguageSync();
    if (!language) { return null; }
    let query = this.queryCache.get(queryType);
    if (!query) {
      query = language.query(this[queryType]);
      this.queryCache.set(queryType, query);
    }
    return query;
  }
  // Extended: Given a kind of query, retrieves a Tree-sitter `Query` object
  getQuery(queryType) {
    let query = this.queryCache.get(queryType);
    if (query) { return Promise.resolve(query); }
    let promise = this.promisesForQueries.get(queryType);
    if (promise) { return promise; }
    promise = new Promise((resolve, reject) => {
      this.getLanguage().then((language) => {
        try {
          query = language.query(this[queryType]);
          if (!didWrapQueryCaptures) {
            wrapQueryCaptures(query);
          }
          this.queryCache.set(queryType, query);
          resolve(query);
        } catch (error) {
          reject(error);
        }
      });
    }).finally(() => {
      this.promisesForQueries.delete(queryType);
    });
    this.promisesForQueries.set(queryType, promise);
    return promise;
  }
  async createQuery(queryContents) {
    let language = await this.getLanguage();
    return language.query(queryContents);
  }
  createQuerySync(queryContents) {
    if (!this._language) {
      throw new Error(`Language not loaded!`);
    }
    return this._language.query(queryContents);
  }
  async setQueryForTest(queryType, contents) {
    await this.getLanguage();
    this.queryCache.delete(queryType);
    this[queryType] = contents;
    let query = await this.getQuery(queryType);
    this.emitter.emit('did-change-query', { filePath: '', queryType });
    return query;
  }
  // Observe a particular query file on disk so that it can immediately be
  // re-applied when it changes. Occurs only in dev mode.
  observeQueryFile(filePaths, queryType) {
    for (let filePath of filePaths) {
      let watcher = new File(filePath);
      this.subscriptions.add(watcher.onDidChange(() => {
        let existingQuery = this[queryType];
        // When any one of the file paths changes, we have to re-concatenate
        // the whole set.
        this.loadQueryFile(filePaths, queryType).then(async () => {
          // Sanity-check the language for errors before we let the buffers know
          // about this change.
          try {
            await this.getQuery(queryType);
          } catch (error) {
            atom.beep();
            console.error(`Error parsing query file: ${queryType}`);
            console.error(error);
            this[queryType] = existingQuery;
            this.queryCache.delete(queryType);
            return;
          }
          this.emitter.emit('did-change-query', { filePath, queryType });
        });
      }));
    }
  }
  onDidChangeQuery(callback) {
    return this.emitter.on('did-change-query', callback);
  }
  onDidChangeQueryFile(callback) {
    return this.onDidChangeQuery(callback);
  }
  onDidLoadQueryFiles(callback) {
    return this.emitter.on('did-load-query-files', callback);
  }
  activate() {
    this.registration = this.registry.addGrammar(this);
  }
  deactivate() {
    this.registration?.dispose();
    this.subscriptions?.dispose();
    this.queryCache.clear();
  }
  addInjectionPoint(injectionPoint) {
    let { type } = injectionPoint;
    let injectionPoints = this.injectionPointsByType[type];
    if (!injectionPoints) {
      injectionPoints = this.injectionPointsByType[type] = [];
    }
    injectionPoints.push(injectionPoint);
  }
  removeInjectionPoint(injectionPoint) {
    const injectionPoints = this.injectionPointsByType[injectionPoint.type];
    if (injectionPoints) {
      const index = injectionPoints.indexOf(injectionPoint);
      if (index !== -1) injectionPoints.splice(index, 1);
      if (injectionPoints.length === 0) {
        delete this.injectionPointsByType[injectionPoint.type];
      }
    }
  }
  inspect() {
    return `WASMTreeSitterGrammar {scopeName: ${this.scopeName}}`;
  }
  onDidUpdate(_callback) {
  }
  tokenizeLines(text, _compatibilityMode = true) {
    return text.split('\n').map(line => this.tokenizeLine(line, null, false));
  }
  tokenizeLine(line, _ruleStack, _firstLine) {
    return {
      value: line,
      scopes: [this.scopeName]
    };
  }
}
function buildRegex(value) {
  if (Array.isArray(value)) value = value.map(_ => `(${_})`).join('|');
  if (typeof value === 'string') return new RegExp(value);
  return null;
}

================
File: src/wasm-tree-sitter-language-mode.js
================
const Parser = require('./web-tree-sitter');
const TokenIterator = require('./token-iterator');
const { Point, Range, spliceArray } = require('text-buffer');
const { Patch } = require('superstring');
const { CompositeDisposable, Emitter } = require('event-kit');
const ScopeDescriptor = require('./scope-descriptor');
const ScopeResolver = require('./scope-resolver');
const Token = require('./token');
const TokenizedLine = require('./tokenized-line');
const { matcherForSelector } = require('./selectors');
const { commentStringsFromDelimiters, getDelimitersForScope } = require('./comment-utils.js');
const createTree = require('./rb-tree');
const ONE_CHAR_FORWARD_TRAVERSAL = Object.freeze(Point(0, 1));
const FEATURE_ASYNC_INDENT = true;
const FEATURE_ASYNC_PARSE = true;
const LINE_LENGTH_LIMIT_FOR_HIGHLIGHTING = 10000;
const REPARSE_BUDGET_PER_TRANSACTION_MILLIS = 10
const PARSE_JOB_LIMIT_MICROS = 3000;
const PARSERS_IN_USE = new Set();
const FUNCTION_TRUE = () => true;
function isParseTimeout(err) {
  return err.message.includes('Parsing failed');
}
function last(array) {
  return array[array.length - 1];
}
function removeLastOccurrenceOf(array, item) {
  return array.splice(array.lastIndexOf(item), 1);
}
function clamp(value, min, max) {
  if (value < min) { return min; }
  if (value > max) { return max; }
  return value;
}
function rangeForNode(node) {
  return new Range(node.startPosition, node.endPosition);
}
function nodeBreadth(node) {
  return node.endIndex - node.startIndex;
}
function rangeToTreeSitterRangeSpec(range, buffer) {
  let startIndex = buffer.characterIndexForPosition(range.start);
  let endIndex = buffer.characterIndexForPosition(range.end);
  let startPosition = { row: range.start.row, column: range.start.column };
  let endPosition = { row: range.end.row, column: range.end.column };
  return { startIndex, startPosition, endIndex, endPosition };
}
function resolveNodeDescriptor(node, descriptor) {
  let parts = descriptor.split('.');
  let result = node;
  while (result !== null && parts.length > 0) {
    let part = parts.shift();
    if (!result[part]) { return null; }
    result = result[part];
  }
  return result;
}
function resolveNodePosition(node, descriptor) {
  let parts = descriptor.split('.');
  let lastPart = parts.pop();
  let result = parts.length === 0 ?
    node :
    resolveNodeDescriptor(node, parts.join('.'));
  if (!result) { return null; }
  return result[lastPart];
}
function ensureNodeIsPatched(node) {
  let done = node.range && node.range instanceof Range;
  if (done) { return; }
  let proto = Object.getPrototypeOf(node);
  Object.defineProperty(proto, 'range', {
    get() { return rangeForNode(this); }
  });
  Object.defineProperty(proto, 'closest', {
    value: function closest(types) {
      if (!Array.isArray(types)) { types = [types]; }
      let node = this;
      while (node) {
        if (types.includes(node.type)) { return node; }
        node = node.parent;
      }
      return null;
    }
  });
}
function comparePoints(a, b) {
  const rows = a.row - b.row;
  if (rows === 0) {
    return a.column - b.column;
  } else {
    return rows;
  }
}
function compareBoundaries(a, b) {
  if (!a.position) {
    a = { position: a, boundary: 'end' };
  }
  if (!b.position) {
    b = { position: b, boundary: 'end' };
  }
  let result = comparePoints(a.position, b.position);
  if (result !== 0) { return result; }
  if (a.boundary === b.boundary) { return 0; }
  return a.boundary === 'end' ? -1 : 1;
}
function isBetweenPoints(point, a, b) {
  let comp = comparePoints(a, b);
  let lesser = comp > 0 ? b : a;
  let greater = comp > 0 ? a : b;
  return comparePoints(point, lesser) >= 0 &&
    comparePoints(point, greater) <= 0;
}
let totalBufferChanges = 0;
let nextTransactionId = 1;
let nextLanguageModeId = 0;
const COMMENT_MATCHER = matcherForSelector('comment');
const MAX_RANGE = new Range(Point.ZERO, Point.INFINITY).freeze();
class WASMTreeSitterLanguageMode {
  constructor({ buffer, grammar, config, grammars, syncTimeoutMicros }) {
    this.id = nextLanguageModeId++;
    this.buffer = buffer;
    this.grammar = grammar;
    this.config = config ?? atom.config;
    this.grammarRegistry = grammars;
    this.syncTimeoutMicros = syncTimeoutMicros ?? PARSE_JOB_LIMIT_MICROS;
    this.useAsyncParsing = FEATURE_ASYNC_PARSE;
    this.useAsyncIndent = FEATURE_ASYNC_INDENT;
    this.transactionReparseBudgetMs = REPARSE_BUDGET_PER_TRANSACTION_MILLIS;
    this.currentTransactionReparseBudgetMs = undefined;
    this.injectionsMarkerLayer = buffer.addMarkerLayer();
    this.rootScopeDescriptor = new ScopeDescriptor({
      scopes: [grammar.scopeName]
    });
    this.rootScopeId = this.grammar.idForScope(this.grammar.scopeName);
    this.emitter = new Emitter();
    this.isFoldableCache = [];
    this.tokenized = false;
    this.subscriptions = new CompositeDisposable;
    this.subscriptions.add(
      this.onDidTokenize(() => this.tokenized = true)
    );
    this.rootLanguage = null;
    this.rootLanguageLayer = null;
    this.grammarForLanguageString = this.grammarForLanguageString.bind(this);
    this.parsersByLanguage = new Index();
    this.tokenIterator = new TokenIterator(this);
    this.autoIndentRequests = 0;
    this.resolveNextTransactionPromise();
    this.indentResolver = new IndentResolver(this.buffer, this);
    this.ready = this.grammar.getLanguage()
      .then(language => {
        this.rootLanguage = language;
        this.rootLanguageLayer = new LanguageLayer(null, this, grammar, 0);
        return this.getOrCreateParserForLanguage(language);
      })
      .then(() => this.rootLanguageLayer.update(null, { id: 0 }))
      .then(() => this.emitter.emit('did-tokenize'));
  }
  destroy() {
    let layers = this.getAllLanguageLayers();
    for (let layer of layers) {
      layer?.destroy();
    }
    this.injectionsMarkerLayer?.destroy();
    this.rootLanguageLayer = null;
    this.subscriptions?.dispose();
  }
  getGrammar() {
    return this.grammar;
  }
  getLanguageId() {
    return this.grammar.scopeName;
  }
  getNonWordCharacters(position) {
    const scope = this.scopeDescriptorForPosition(position);
    return this.config.get('editor.nonWordCharacters', { scope });
  }
  getRootParser() {
    return this.getOrCreateParserForLanguage(this.rootLanguage);
  }
  getOrCreateParserForLanguage(language) {
    let pool = this.parsersByLanguage.get(language);
    let parser;
    if (pool) {
      parser = pool.find(p => !PARSERS_IN_USE.has(p));
    }
    if (!parser) {
      parser = new Parser();
      parser.setLanguage(language);
      this.parsersByLanguage.add(language, parser);
    }
    return parser;
  }
  bufferDidChange(change) {
    if (!this.rootLanguageLayer) { return; }
    let { oldRange, newRange, oldText, newText } = change;
    const startIndex = this.buffer.characterIndexForPosition(
      change.newRange.start
    );
    let edit = {
      startIndex,
      oldEndIndex: startIndex + oldText.length,
      newEndIndex: startIndex + newText.length,
      startPosition: oldRange.start,
      oldEndPosition: oldRange.end,
      newEndPosition: newRange.end
    };
    if (!this.resolveNextTransaction) {
      totalBufferChanges++;
      this.transactionChangeCount = 1;
      this.refreshNextTransactionPromise();
      this.didAutoIndentAfterTransaction = false;
    } else {
      this.transactionChangeCount++;
      totalBufferChanges++;
    }
    this.rootLanguageLayer.handleTextChange(edit, oldText, newText);
    for (const marker of this.injectionsMarkerLayer.getMarkers()) {
      marker.languageLayer.handleTextChange(edit, oldText, newText);
    }
    this.cachedCurrentBufferText = this.buffer.getText();
  }
  bufferDidFinishTransaction({ changes }) {
    let id = nextTransactionId++;
    if (!this.rootLanguageLayer) { return; }
    for (let i = 0, { length } = changes; i < length; i++) {
      const { oldRange, newRange } = changes[i];
      spliceArray(
        this.isFoldableCache,
        newRange.start.row,
        oldRange.end.row - oldRange.start.row,
        { length: newRange.end.row - newRange.start.row }
      );
    }
    this.rootLanguageLayer.update(null, { id }).then(shouldEndTransaction => {
      if (shouldEndTransaction) {
        this.lastTransactionEditedRange = this.rootLanguageLayer?.lastTransactionEditedRange;
        this.lastTransactionChangeCount = this.transactionChangeCount;
        this.lastTransactionAutoIndentRequests = this.autoIndentRequests;
      }
      for (let { newRange } of changes) {
        this.prefillFoldCache(newRange);
      }
      let allLayers = this.getAllInjectionLayers();
      for (let layer of allLayers) {
        layer.treeIsDirty = false;
        layer.editedRange = null;
      }
      if (shouldEndTransaction) {
        this.resolveNextTransactionPromise();
        this.transactionChangeCount = 0;
        this.autoIndentRequests = 0;
        this.currentTransactionReparseBudgetMs = this.transactionReparseBudgetMs;
      }
    });
  }
  emitFoldUpdate(range) {
    const startRow = range.start.row;
    const endRow = range.end.row;
    for (let row = startRow; row < endRow; row++) {
      this.isFoldableCache[row] = undefined;
    }
    this.prefillFoldCache(range);
  }
  emitRangeUpdate(range) {
    this.emitFoldUpdate(range);
    this.emitter.emit('did-change-highlighting', range);
  }
  resolveNextTransactionPromise() {
    if (this.resolveNextTransaction) {
      this.resolveNextTransaction();
      this.resolveNextTransaction = null;
    }
    if (nextTransactionId > 100) {
      nextTransactionId = 1;
    }
    if (!this.nextTransaction) {
      this.nextTransaction = Promise.resolve();
    }
  }
  refreshNextTransactionPromise() {
    if (this.resolveNextTransaction) { return false; }
    this.nextTransaction = new Promise((resolve) => {
      this.resolveNextTransaction = (changes) => {
        resolve(changes);
      };
    });
    return true;
  }
  async atTransactionEnd() {
    if (!this.tokenized) { return this.ready; }
    if (this.atTransactionEndPromise) {
      return this.atTransactionEndPromise;
    }
    let prerequisite = this.nextTransaction || Promise.resolve();
    this.atTransactionEndPromise = prerequisite.then(() => {
      let result = {
        changeCount: this.lastTransactionChangeCount ?? 0,
        range: this.lastTransactionEditedRange ?? null,
        autoIndentRequests: this.lastTransactionAutoIndentRequests ?? 0
      };
      return result;
    }).finally(() => {
      this.atTransactionEndPromise = null;
    });
    return this.atTransactionEndPromise;
  }
  parseCompletePromise() {
    return this.atTransactionEnd();
  }
  prefillFoldCache(range) {
    this.rootLanguageLayer?.foldResolver?.prefillFoldCache(range);
    let markers = this.injectionsMarkerLayer.findMarkers({
      intersectsRange: range
    });
    for (let marker of markers) {
      let { foldResolver } = marker.languageLayer;
      if (!foldResolver) { continue; }
      foldResolver.reset();
      foldResolver.prefillFoldCache(range);
    }
  }
  grammarForLanguageString(languageString) {
    let result =  this.grammarRegistry.treeSitterGrammarForLanguageString(
      languageString,
      'wasm'
    );
    return result;
  }
  updateForInjection(grammar) {
    if (!this.rootLanguageLayer) { return; }
    if (!grammar.injectionRegex && !grammar.injectionRegExp) { return; }
    if (grammar.type !== 'modern-tree-sitter') { return; }
    let layers = this.getAllLanguageLayers();
    for (let layer of layers) {
      if (!layer.tree) continue;
      layer._populateInjections(MAX_RANGE, null);
    }
  }
  onDidTokenize(callback) {
    return this.emitter.on('did-tokenize', callback);
  }
  onDidChangeHighlighting(callback) {
    return this.emitter.on('did-change-highlighting', callback);
  }
  buildHighlightIterator() {
    if (!this.rootLanguageLayer) {
      return new NullLanguageModeHighlightIterator();
    }
    return new HighlightIterator(this);
  }
  classNameForScopeId(scopeId) {
    return this.grammar.classNameForScopeId(scopeId);
  }
  scopeNameForScopeId(scopeId) {
    return this.grammar.scopeNameForScopeId(scopeId);
  }
  idForScope(name, text) {
    return this.grammar.idForScope(name, text);
  }
  syntaxTreeScopeDescriptorForPosition(point) {
    point = this.normalizePointForPositionQuery(point);
    let index = this.buffer.characterIndexForPosition(point);
    let layers = this.languageLayersAtPoint(point);
    let matches = [];
    for (let layer of layers) {
      if (!layer.tree) { continue; }
      let layerMatches = [];
      let root = layer.tree.rootNode;
      let current = root.descendantForIndex(index);
      while (current) {
        layerMatches.unshift({ node: current, depth: layer.depth });
        current = current.parent;
      }
      matches.push(...layerMatches);
    }
    matches.sort(
      (a, b) => (
        a.node.startIndex - b.node.startIndex ||
        b.node.endIndex - a.node.endIndex ||
        a.depth - b.depth
      )
    );
    let scopes = matches.map(({ node }) => (
      node.isNamed ? node.type : `"${node.type}"`
    ));
    scopes.unshift(this.grammar.scopeName);
    return new ScopeDescriptor({ scopes });
  }
  bufferRangeForScopeAtPosition(selector, point) {
    point = this.normalizePointForPositionQuery(point);
    if (typeof selector === 'function') {
      let node = this.getSyntaxNodeAtPosition(point, selector);
      return node?.range;
    }
    let scopeDescriptor = this.scopeDescriptorForPosition(point)
      .getScopesArray();
    let match = selector ? matcherForSelector(selector) : FUNCTION_TRUE;
    if (!this.rootLanguageLayer) {
      return match('text') ? this.buffer.getRange() : null;
    }
    let layers = this.languageLayersAtPoint(point);
    let results = [];
    for (let layer of layers) {
      if (layer.grammar.scopeName === selector) {
        return layer.getExtent();
      }
      let items = layer.scopeMapAtPosition(point);
      for (let { capture, adjustedRange } of items) {
        let range = rangeForNode(adjustedRange);
        if (!range.containsPoint(point)) { continue; }
        if (!scopeDescriptor.includes(capture.name)) { continue; }
        results.push({ capture, adjustedRange, range });
      }
    }
    results = results.sort((a, b) => {
      return nodeBreadth(a.adjustedRange) - nodeBreadth(b.adjustedRange);
    });
    for (let { capture, range } of results) {
      if (match(capture.name)) { return range; }
    }
  }
  scopeDescriptorForPosition(point) {
    if (!this.rootLanguageLayer) {
      return new ScopeDescriptor({ scopes: [this.grammar.scopeName, 'text'] });
    }
    point = this.normalizePointForPositionQuery(point);
    const iterator = this.buildHighlightIterator();
    const scopes = [];
    for (const scope of iterator.seek(point, point.row + 1)) {
      scopes.push(this.grammar.scopeNameForScopeId(scope));
    }
    while (point.isEqual(iterator.getPosition())) {
      for (const scope of iterator.getOpenScopeIds()) {
        scopes.push(this.grammar.scopeNameForScopeId(scope));
      }
      for (const scope of iterator.getCloseScopeIds()) {
        removeLastOccurrenceOf(scopes, this.grammar.scopeNameForScopeId(scope));
      }
      iterator.moveToSuccessor();
    }
    if (scopes.length === 0 || scopes[0] !== this.grammar.scopeName) {
      scopes.unshift(this.grammar.scopeName);
    }
    return new ScopeDescriptor({ scopes });
  }
  normalizePointForPositionQuery(point) {
    if (Array.isArray(point)) { point = new Point(...point); }
    if (!('copy' in point)) {
      point = Point.fromObject(point, true);
    } else {
      point = point.copy();
    }
    point = this.buffer.clipPosition(point);
    if (
      point.column > 0 &&
      point.column === this.buffer.lineLengthForRow(point.row)
    ) {
      point.column--;
    }
    return point;
  }
  parseAsync(language, oldTree, includedRanges, { tag = null } = {}) {
    let devMode = atom.inDevMode();
    let parser = this.getOrCreateParserForLanguage(language);
    parser.reset();
    parser.setTimeoutMicros(this.syncTimeoutMicros);
    PARSERS_IN_USE.add(parser);
    let parseDone = false;
    let text = this.buffer.getText();
    this.cachedCurrentBufferText = text;
    let callback = (index, _, endIndex) => {
      let currentText = parseDone ? this.cachedCurrentBufferText : text;
      return currentText.slice(index, endIndex);
    };
    let tree;
    let batchCount = 0;
    const cleanup = () => {
      parseDone = true;
      if (devMode && tag) {
        console.timeEnd(tag);
        if (batchCount > 0) {
          console.log(`(async: ${batchCount} batches)`);
        }
      }
      parser.setTimeoutMicros(null);
      PARSERS_IN_USE.delete(parser);
    };
    if (devMode && tag) { console.time(tag); }
    try {
      tree = parser.parse(callback, oldTree, { includedRanges });
    } catch (err) {
      if (!isParseTimeout(err)) { throw err; }
      return new Promise((resolve, reject) => {
        const parseJob = () => {
          try {
            batchCount++;
            tree = parser.parse(callback, oldTree, { includedRanges });
          } catch (err) {
            if (!isParseTimeout(err)) { return reject(err); }
            setImmediate(parseJob);
            return;
          }
          cleanup();
          resolve(tree);
        };
        setImmediate(parseJob);
      });
    }
    cleanup();
    return tree;
  }
  parse(language, oldTree, includedRanges, { tag = null } = {}) {
    let devMode = atom.inDevMode();
    let parser = this.getOrCreateParserForLanguage(language);
    parser.reset();
    parser.setTimeoutMicros(null);
    let text = this.buffer.getText();
    this.cachedCurrentBufferText = text;
    let callback = (index, _, endIndex) => {
      let currentText = this.cachedCurrentBufferText;
      return currentText.slice(index, endIndex);
    };
    if (devMode && tag) { console.time(tag); }
    const result = parser.parse(callback, oldTree, { includedRanges });
    if (devMode && tag) { console.timeEnd(tag); }
    return result;
  }
  get tree() {
    return this.rootLanguageLayer?.tree
  }
  getSyntaxNodeContainingRange(range, where = FUNCTION_TRUE) {
    if (!this.rootLanguageLayer) { return null; }
    return this.getSyntaxNodeAndGrammarContainingRange(range, where)?.node;
  }
  getSyntaxNodeAndGrammarContainingRange(range, where = FUNCTION_TRUE) {
    if (!this.rootLanguageLayer) { return { node: null, grammar: null }; }
    let layersAtStart = this.languageLayersAtPoint(range.start, { exact: true });
    let layersAtEnd = this.languageLayersAtPoint(range.end, { exact: true });
    let sharedLayers = layersAtStart.filter(
      layer => layersAtEnd.includes(layer)
    );
    let indexStart = this.buffer.characterIndexForPosition(range.start);
    let indexEnd = this.buffer.characterIndexForPosition(range.end);
    let rangeBreadth = indexEnd - indexStart;
    sharedLayers.reverse();
    let results = [];
    for (let layer of sharedLayers) {
      if (!layer.tree) { continue; }
      let { grammar, depth } = layer;
      let rootNode = layer.tree.rootNode;
      if (!rootNode.range.containsRange(range)) {
        results.push({ node: rootNode, grammar, depth });
        continue;
      }
      let node = this.getSyntaxNodeAtPosition(
        range.start,
        (node, nodeGrammar) => {
          let breadth = node.endIndex - node.startIndex;
          return node.startIndex <= indexEnd &&
            node.endIndex >= indexEnd &&
            breadth > rangeBreadth &&
            nodeGrammar === grammar;
        }
      );
      if (node) {
        results.push({ node, grammar, depth });
      }
    }
    results.sort((a, b) => {
      return (
        nodeBreadth(a.node) - nodeBreadth(b.node) ||
        b.depth - a.depth
      );
    });
    for (let { node, grammar } of results) {
      if (where(node, grammar)) {
        return { node, grammar };
      }
    }
    return { node: null, grammar: null };
  }
  getRangeForSyntaxNodeContainingRange(range, where = FUNCTION_TRUE) {
    if (!this.rootLanguageLayer) { return null; }
    let node = this.getSyntaxNodeContainingRange(range, where);
    return node && rangeForNode(node);
  }
  getSyntaxNodeAtPosition(position, where = FUNCTION_TRUE) {
    if (!this.rootLanguageLayer) { return null; }
    let allLayers = this.languageLayersAtPoint(position);
    allLayers.reverse();
    let results = [];
    for (let layer of allLayers) {
      if (!layer.tree) { continue; }
      let { depth, grammar } = layer;
      let rootNode = layer.tree.rootNode;
      if (!rootNode.range.containsPoint(position)) {
        if (where(rootNode, grammar)) {
          results.push({ rootNode: node, depth });
        }
        continue;
      }
      let index = this.buffer.characterIndexForPosition(position);
      let node = rootNode.descendantForIndex(index);
      while (node) {
        results.push({ node, depth, grammar });
        node = node.parent;
      }
    }
    results.sort((a, b) => {
      return (
        nodeBreadth(a.node) - nodeBreadth(b.node) ||
        b.depth - a.depth
      );
    });
    for (let { node, grammar } of results) {
      if (where(node, grammar)) { return node; }
    }
    return null;
  }
  getFoldableRangeContainingPoint(point) {
    point = this.buffer.clipPosition(point);
    if (point.column >= this.buffer.lineLengthForRow(point.row)) {
      let fold = this.getFoldRangeForRow(point.row);
      if (fold) { return fold; }
    }
    for (let row = point.row - 1; row >= 0; row--) {
      let range = this.getFoldRangeForRow(row);
      if (range && range.containsPoint(point)) { return range; }
    }
    return null;
  }
  getFoldableRanges() {
    if (!this.tokenized) { return []; }
    let layers = this.getAllLanguageLayers();
    let allFolds = [];
    for (let layer of layers) {
      let folds = layer.foldResolver.getAllFoldRanges();
      allFolds.push(...folds);
    }
    return allFolds;
  }
  getFoldableRangesAtIndentLevel(goalLevel) {
    if (!this.tokenized) { return []; }
    let rangeTree = createTree(comparePoints);
    let layers = this.getAllLanguageLayers();
    for (let layer of layers) {
      let folds = layer.foldResolver.getAllFoldRanges();
      for (let fold of folds) {
        rangeTree = rangeTree.insert(fold.start, { start: fold });
        rangeTree = rangeTree.insert(fold.end, { end: fold });
      }
    }
    let foldsByLevel = new Index();
    let currentLevel = 0;
    let iterator = rangeTree.begin;
    while (iterator.key) {
      let { start, end } = iterator.value;
      if (start) {
        foldsByLevel.add(currentLevel, start);
        currentLevel++;
      } else if (end) {
        currentLevel--;
      }
      iterator.next();
    }
    return foldsByLevel.get(goalLevel) || [];
  }
  adjustPositionByOffset(position, offset) {
    let { buffer } = this;
    let index = buffer.characterIndexForPosition(position);
    index += offset;
    return buffer.positionForCharacterIndex(index);
  }
  isFoldableAtRow(row) {
    if (this.isFoldableCache[row] != null) {
      return !!this.isFoldableCache[row];
    }
    let range = this.getFoldRangeForRow(row);
    if (this.tokenized) {
      this.isFoldableCache[row] = !!range;
    }
    return !!range;
  }
  getFoldRangeForRow(row) {
    if (!this.tokenized) { return null; }
    let rowEnd = this.buffer.lineLengthForRow(row);
    let point = new Point(row, rowEnd);
    let layers = this.languageLayersAtPoint(point);
    let leadingCandidate = null;
    for (let layer of layers) {
      let { depth } = layer;
      let candidateFold = layer.foldResolver?.getFoldRangeForRow(row);
      if (!candidateFold) { continue; }
      if (!leadingCandidate || depth > leadingCandidate.depth) {
        leadingCandidate = { fold: candidateFold, depth };
      }
    }
    return leadingCandidate?.fold ?? null;
  }
  commentStringsForPosition(position) {
    const range = this.firstNonWhitespaceRange(position.row) ||
      new Range(position, position);
    const scope = this.scopeDescriptorForPosition(range.start);
    const commentStartEntries = this.config.getAll(
      'editor.commentStart', { scope });
    const commentEndEntries = this.config.getAll(
      'editor.commentEnd', { scope });
    const originalScope = this.scopeDescriptorForPosition(position);
    const commentDelimiters = getDelimitersForScope(originalScope);
    const commentStartEntry = commentStartEntries.find(entry => !!entry);
    const commentEndEntry = commentEndEntries.find(entry => {
      return entry.scopeSelector === commentStartEntry?.scopeSelector
    });
    if (commentStartEntry) {
      return {
        commentStartString: commentStartEntry && commentStartEntry.value,
        commentEndString: commentEndEntry && commentEndEntry.value,
        commentDelimiters: commentDelimiters
      };
    } else {
      let adjustedDelimiters = getDelimitersForScope(scope);
      if (adjustedDelimiters) {
        let result = commentStringsFromDelimiters(adjustedDelimiters);
        if (commentDelimiters) {
          result.commentDelimiters = commentDelimiters;
        }
        return result;
      }
    }
    const { grammar } = this.getSyntaxNodeAndGrammarContainingRange(range);
    const { grammar: originalPositionGrammar } = this.getSyntaxNodeAndGrammarContainingRange(
      new Range(position, position));
    if (grammar && grammar.getCommentDelimiters) {
      let delimiters = grammar.getCommentDelimiters();
      let result = commentStringsFromDelimiters(delimiters);
      if (originalPositionGrammar !== grammar) {
        let originalPositionDelimiters = originalPositionGrammar.getCommentDelimiters();
        result = {
          ...result,
          commentDelimiters: originalPositionDelimiters
        }
      }
      return result;
    } else if (commentDelimiters) {
      return commentStringsFromDelimiters(commentDelimiters);
    }
    return {
      commentStartString: undefined,
      commentEndString: undefined,
      commentDelimiters: { line: undefined, block: undefined }
    }
  }
  isRowCommented(row) {
    const range = this.firstNonWhitespaceRange(row);
    if (range) {
      let descriptor = this.scopeDescriptorForPosition(range.start);
      return descriptor.getScopesArray().some(
        scope => COMMENT_MATCHER(scope)
      );
    }
    return false;
  }
  indentLevelForLine(line, tabLength) {
    let indentLength = 0;
    for (let i = 0, { length } = line; i < length; i++) {
      const char = line[i];
      if (char === '\t') {
        indentLength += tabLength - (indentLength % tabLength);
      } else if (char === ' ') {
        indentLength++;
      } else {
        break;
      }
    }
    return indentLength / tabLength
  }
  shouldUseAsyncIndent() {
    let result = true;
    if (!this.useAsyncParsing || !this.useAsyncIndent) result = false;
    this.currentTransactionReparseBudgetMs ??= this.transactionReparseBudgetMs;
    if (this.currentTransactionReparseBudgetMs > 0) {
      result = false;
    }
    return result;
  }
  suggestedIndentForBufferRow(...args) {
    return this.indentResolver.suggestedIndentForBufferRow(...args);
  }
  suggestedIndentForBufferRows(...args) {
    return this.indentResolver.suggestedIndentForBufferRows(...args);
  }
  suggestedIndentForEditedBufferRow(...args) {
    return this.indentResolver.suggestedIndentForEditedBufferRow(...args);
  }
  suggestedIndentForLineAtBufferRow(row, _line, tabLength) {
    this.autoIndentRequests++;
    return this.suggestedIndentForBufferRow(row, tabLength);
  }
  getAllInjectionLayers() {
    let markers =  this.injectionsMarkerLayer.getMarkers();
    return markers.map(m => m.languageLayer);
  }
  getAllLanguageLayers(where = null) {
    let layers = [
      this.rootLanguageLayer,
      ...this.getAllInjectionLayers()
    ];
    if (!where) return layers;
    let results = [];
    for (let layer of layers) {
      if (!where(layer)) continue;
      results.push(layer);
    }
    return results;
  }
  injectionLayersAtPoint(point, { exact = false } = {}) {
    let injectionMarkers = this.injectionsMarkerLayer.findMarkers({
      containsPosition: point
    });
    injectionMarkers.sort((a, b) => {
      return a.getRange().compare(b.getRange()) ||
        b.depth - a.depth;
    });
    let results = injectionMarkers.map(m => m.languageLayer);
    if (exact) {
      results = results.filter(l => l.containsPoint(point));
    }
    return results;
  }
  languageLayersAtPoint(point, { exact = false } = {}) {
    let injectionLayers = this.injectionLayersAtPoint(point, { exact });
    return [
      this.rootLanguageLayer,
      ...injectionLayers
    ];
  }
  controllingLayerAtPoint(point, where = FUNCTION_TRUE) {
    let layers = this.languageLayersAtPoint(point, { exact: true });
    layers.sort((a, b) => b.depth - a.depth);
    return layers.find(layer => where(layer)) ?? null;
  }
  firstNonWhitespaceRange(row) {
    return this.buffer.findInRangeSync(
      /\S/,
      new Range(new Point(row, 0), new Point(row, Infinity))
    );
  }
  tokenizedLineForRow(row) {
    const lineText = this.buffer.lineForRow(row);
    const tokens = [];
    const iterator = this.buildHighlightIterator();
    let start = { row, column: 0 };
    const scopes = iterator.seek(start, row) || [];
    while (true) {
      const end = { ...iterator.getPosition() };
      if (end.row > row) {
        end.row = row;
        end.column = lineText.length;
      }
      if (end.column > start.column) {
        tokens.push(
          new Token({
            value: lineText.substring(start.column, end.column),
            scopes: scopes.map(s => this.scopeNameForScopeId(s))
          })
        );
      }
      if (end.column < lineText.length) {
        const closeScopeCount = iterator.getCloseScopeIds().length;
        for (let i = 0; i < closeScopeCount; i++) {
          scopes.pop();
        }
        scopes.push(...iterator.getOpenScopeIds());
        start = end;
        iterator.moveToSuccessor();
      } else {
        break;
      }
    }
    return new TokenizedLine({
      openScopes: [],
      text: lineText,
      tokens,
      tags: [],
      ruleStack: [],
      lineEnding: this.buffer.lineEndingForRow(row),
      tokenIterator: this.tokenIterator,
      grammar: this.grammar
    });
  }
  tokenForPosition(point) {
    if (Array.isArray(point)) {
      point = new Point(...point);
    }
    const scopes = this.scopeDescriptorForPosition(point).getScopesArray();
    let range = this.bufferRangeForScopeAtPosition(
      last(scopes),
      point
    );
    return new Token({
      scopes,
      value: this.buffer.getTextInRange(range)
    });
  }
}
class FoldResolver {
  constructor(buffer, layer) {
    this.buffer = buffer;
    this.layer = layer;
    this.boundaries = null;
    this.boundariesStartingPosition = null;
  }
  getFoldRangeForRow(row) {
    if (!this.layer.tree || !this.layer.queries.foldsQuery) { return null; }
    let start = Point.fromObject({ row, column: 0 });
    let end = Point.fromObject({ row: row + 1, column: 0 });
    let tree = this.layer.getOrParseTree({ force: false });
    let iterator = this.getOrCreateBoundariesIterator(tree.rootNode, start, end);
    while (iterator.key) {
      if (comparePoints(iterator.key.position, end) >= 0) { break; }
      let capture = iterator.value;
      let { name } = capture;
      if (name === 'fold') {
        let range = this.resolveRangeForSimpleFold(capture);
        if (this.isValidFold(range)) { return range; }
      } else if (name === 'fold.start') {
        let range = this.resolveRangeForDividedFold(capture);
        if (this.isValidFold(range)) { return range; }
      }
      iterator.next();
    }
    return null;
  }
  isValidFold(range) {
    return range && range.end.row > range.start.row;
  }
  getAllFoldRanges() {
    if (!this.layer.tree || !this.layer.queries.foldsQuery) { return []; }
    let range = this.layer.getExtent();
    let iterator = this.getOrCreateBoundariesIterator(
      this.layer.tree.rootNode, range.start, range.end);
    let results = [];
    let lastValidFoldRange = null;
    while (iterator.key) {
      let capture = iterator.value;
      let { name } = capture;
      let range;
      if (name === 'fold') {
        range = this.resolveRangeForSimpleFold(capture);
      } else if (name === 'fold.start') {
        range = this.resolveRangeForDividedFold(capture);
      }
      if (this.isValidFold(range)) {
        if (lastValidFoldRange?.start?.row !== range.start.row) {
          results.push(range);
          lastValidFoldRange = range;
        }
      }
      iterator.next();
    }
    return results;
  }
  reset() {
    this.boundaries = null;
    this.boundariesRange = null;
  }
  canReuseBoundaries(start, end) {
    if (!this.boundariesRange) { return false; }
    return this.boundariesRange.containsRange(
      new Range(start, end)
    );
  }
  prefillFoldCache(range) {
    if (!this.layer.tree || !this.layer.queries.foldsQuery) { return; }
    this.getOrCreateBoundariesIterator(
      this.layer.tree.rootNode,
      range.start,
      range.end
    );
  }
  getOrCreateBoundariesIterator(rootNode, start, end) {
    if (!this.layer.tree || !this.layer.queries.foldsQuery) { return null; }
    if (this.canReuseBoundaries(start, end)) {
      let result = this.boundaries.ge(start);
      return result;
    }
    let scopeResolver = this.layer.scopeResolver;
    scopeResolver.reset();
    let boundaries = createTree(compareBoundaries);
    let captures = this.layer.queries.foldsQuery.captures(
      rootNode,
      { startPosition: start, endPosition: end }
    );
    for (let capture of captures) {
      let result = scopeResolver.store(capture);
      if (!result) { continue; }
      if (scopeResolver.shouldInvalidateFoldOnChange(capture)) {
        this.layer.foldNodesToInvalidateOnChange.add(capture.node.id);
      }
      if (capture.node.startPosition.row < start.row) {
        continue;
      }
      if (capture.name === 'fold') {
        boundaries = boundaries.insert({
          position: capture.node.startPosition,
          boundary: 'start'
        }, capture);
      } else if (capture.name.startsWith('fold.')) {
        let key = this.keyForDividedFold(capture);
        boundaries = boundaries.insert(key, capture);
      }
    }
    scopeResolver.reset();
    this.boundaries = boundaries;
    this.boundariesRange = new Range(start, end);
    return boundaries.ge(start);
  }
  resolveRangeForDividedFold(capture) {
    let { name } = capture;
    let key = this.keyForDividedFold(capture);
    if (name !== 'fold.start') { return null; }
    let extent = this.layer.getExtent();
    let iterator = this.getOrCreateBoundariesIterator(
      this.layer.tree.rootNode,
      key.position,
      extent.end
    );
    let depth = 0;
    let matchedEndCapture = null;
    while (iterator.key && comparePoints(iterator.key.position, extent.end) <= 0) {
      let { name, node } = iterator.value;
      let isSelf = node.id === capture.node.id;
      if (name === 'fold.end' && !isSelf) {
        if (depth === 0) {
          matchedEndCapture = iterator.value;
          break;
        } else {
          depth--;
        }
      } else if (name === 'fold.start' && !isSelf) {
        depth++;
      }
      iterator.next();
    }
    if (!matchedEndCapture) { return null; }
    return new Range(
      this.resolvePositionForDividedFold(capture),
      this.resolvePositionForDividedFold(matchedEndCapture)
    );
  }
  keyForDividedFold(capture) {
    let { name, node } = capture;
    if (name === 'fold.start') {
      return { position: node.startPosition, boundary: 'start' };
    } else if (name === 'fold.end') {
      return { position: node.startPosition, boundary: 'end' };
    } else {
      return null;
    }
  }
  positionIsNotPrecededByTextOnLine(position) {
    let textForRow = this.buffer.lineForRow(position.row)
    let precedingText = textForRow.substring(0, position.column)
    return !(/\S/.test(precedingText))
  }
  resolvePositionForDividedFold(capture) {
    let { name, node } = capture;
    if (name === 'fold.start') {
      return new Point(node.startPosition.row, Infinity);
    } else if (name === 'fold.end') {
      let end = node.startPosition;
      if (end.column === 0 || this.positionIsNotPrecededByTextOnLine(end)) {
        return new Point(end.row - 1, Infinity);
      } else {
        return new Point.fromObject(end, true);
      }
    } else {
      return null;
    }
  }
  normalizeFoldProperty(prop) {
    if (prop.startsWith('fold.')) {
      prop = prop.replace(/^fold./, '');
    }
    return prop;
  }
  capturePropertyIsFoldAdjustment(prop) {
    prop = this.normalizeFoldProperty(prop);
    return prop in FoldResolver.ADJUSTMENTS;
  }
  applyFoldAdjustment(prop, ...args) {
    prop = this.normalizeFoldProperty(prop);
    return FoldResolver.ADJUSTMENTS[prop](...args);
  }
  resolveRangeForSimpleFold(capture) {
    let { node, setProperties: props } = capture;
    if (node.type === 'ERROR') { return null; }
    let start = new Point(node.startPosition.row, Infinity);
    let end = node.endPosition;
    let defaultOptions = { 'fold.endAt': 'lastChild.startPosition' };
    let options = { ...defaultOptions, ...props };
    try {
      for (let key in options) {
        if (!this.capturePropertyIsFoldAdjustment(key)) { continue; }
        let value = options[key];
        end = this.applyFoldAdjustment(key, end, node, value, props, this.layer);
      }
      if (!end) { return null; }
      end = Point.fromObject(end, true);
      end = this.buffer.clipPosition(end);
      if (end.row <= start.row) { return null; }
      return new Range(start, end);
    } catch (error) {
      console.warn("Error resolving fold range:");
      console.warn(error.message);
      return new Range(start, node.range.end);
    }
  }
}
FoldResolver.ADJUSTMENTS = {
  endAt(end, node, value) {
    end = resolveNodePosition(node, value);
    return end;
  },
  offsetEnd(end, _node, value, _props, layer) {
    let { languageMode } = layer;
    value = Number(value);
    if (isNaN(value)) { return end; }
    return languageMode.adjustPositionByOffset(end, value);
  },
  adjustEndColumn(end, _node, value, _props, layer) {
    let column = Number(value);
    if (isNaN(column)) { return end; }
    let newEnd = Point.fromObject({ column, row: end.row });
    return layer.buffer.clipPosition(newEnd);
  },
  adjustToEndOfPreviousRow(end) {
    return new Point(end.row - 1, Infinity);
  }
};
class NullLanguageModeHighlightIterator {
  seek() {
    return [];
  }
  compare() {
    return 1;
  }
  moveToSuccessor() {}
  getPosition() {
    return Point.INFINITY;
  }
  getOpenScopeIds() {
    return [];
  }
  getCloseScopeIds() {
    return [];
  }
}
class NullLayerHighlightIterator {
  seek() {
    return [false, new OpenScopeMap];
  }
  compare() {
    return 1;
  }
  moveToSuccessor() {}
  getPosition() {
    return Point.INFINITY;
  }
  getOpenScopeIds() {
    return [];
  }
  getCloseScopeIds() {
    return [];
  }
}
let lastIteratorId = 0;
class HighlightIterator {
  constructor(languageMode) {
    this.id = lastIteratorId++;
    this.languageMode = languageMode;
    this.iterators = null;
  }
  inspect() {
    return `[HighlightIterator id=${this.id} iterators=${this.iterators?.length ?? 0}]`;
  }
  seek(start, endRow) {
    if (!(start instanceof Point)) {
      start = Point.fromObject(start, true);
    }
    let { buffer, rootLanguageLayer } = this.languageMode;
    if (!rootLanguageLayer) { return []; }
    let end = {
      row: endRow,
      column: buffer.lineLengthForRow(endRow)
    };
    this.end = end;
    this.iterators = [];
    if (Math.max(start.column, end.column) > LINE_LENGTH_LIMIT_FOR_HIGHLIGHTING) {
      return [];
    }
    let injectionMarkers = this.languageMode.injectionsMarkerLayer.findMarkers(
      {
        intersectsRange: new Range(
          start,
          new Point(endRow + 1, 0)
        )
      }
    );
    injectionMarkers.sort((a, b) => {
      return a.languageLayer.depth - b.languageLayer.depth;
    });
    const iterator = rootLanguageLayer.buildHighlightIterator();
    let openScopesByLayer = new Map();
    let [result, openScopes] = iterator.seek(start, endRow);
    if (rootLanguageLayer?.tree?.rootNode.hasChanges) {
      let range = new Range(start, iterator._getEndPosition(endRow));
      this.languageMode.atTransactionEnd().then(() => {
        this.languageMode.emitRangeUpdate(range);
      });
    }
    openScopesByLayer.set(iterator, openScopes);
    if (result) {
      this.iterators.push(iterator);
    }
    for (const marker of injectionMarkers) {
      const iterator = marker.languageLayer.buildHighlightIterator();
      let [result, openScopes] = iterator.seek(start, endRow);
      if (result) { this.iterators.push(iterator); }
      if (iterator?.languageLayer?.injectionPoint?.coverShallowerScopes) {
        let ranges = iterator.languageLayer.getCurrentRanges();
        for (let [earlierIterator, earlierOpenScopes] of openScopesByLayer) {
          if (earlierIterator.depth >= iterator.depth) { continue; }
          let languageScopeId = earlierIterator.languageLayer.languageScopeId;
          for (let [point, scopes] of earlierOpenScopes) {
            let pointIsCoveredByNewIterator = ranges.some(r => r.containsPoint(point));
            if (!pointIsCoveredByNewIterator) { continue; }
            earlierOpenScopes.set(point, scopes.filter(id => id === languageScopeId));
          }
        }
      }
      openScopesByLayer.set(iterator, openScopes);
    }
    this.iterators.sort((a, b) => b.compare(a));
    this.detectCoveredScope();
    let sortedOpenScopes = [];
    let unsortedScopeBundles = [];
    for (let [iterator, layerOpenScopeMap] of openScopesByLayer) {
      for (let [point, scopes] of layerOpenScopeMap) {
        unsortedScopeBundles.push({ point, scopes, iterator });
      }
    }
    unsortedScopeBundles.sort((a, b) => (
      a.point.compare(b.point) || a.iterator.depth - b.iterator.depth
    ));
    for (let { scopes } of unsortedScopeBundles) {
      sortedOpenScopes.push(...scopes);
    }
    return sortedOpenScopes;
  }
  moveToSuccessor() {
    let leader = last(this.iterators);
    if (!leader) { return; }
    if (leader.moveToSuccessor()) {
      const leaderIndex = this.iterators.length - 1;
      let i = leaderIndex;
      while (i > 0 && this.iterators[i - 1].compare(leader) < 0) {
        i--;
      }
      if (i < leaderIndex) {
        this.iterators.splice(i, 0, this.iterators.pop());
      }
    } else {
      this.iterators.pop();
    }
    this.detectCoveredScope();
  }
  getPosition() {
    let iterator = last(this.iterators || []);
    if (iterator) {
      return iterator.getPosition();
    } else {
      return Point.INFINITY;
    }
  }
  getCloseScopeIds() {
    let iterator = last(this.iterators);
    if (iterator) {
      if (this.currentIteratorIsCovered === true || this.currentIteratorIsCovered === 'close') {
        return iterator.getCloseScopeIds().filter(id => {
          return iterator.languageLayer.languageScopeId === id;
        });
      } else {
        return iterator.getCloseScopeIds();
      }
    }
    return [];
  }
  getOpenScopeIds() {
    let iterator = last(this.iterators);
    if (iterator) {
      if (this.currentIteratorIsCovered === true || this.currentIteratorIsCovered === 'open') {
        return iterator.getOpenScopeIds().filter(id => {
          return iterator.languageLayer.languageScopeId === id;
        });
      } else {
        return iterator.getOpenScopeIds();
      }
    }
    return [];
  }
  detectCoveredScope() {
    const layerCount = this.iterators.length;
    if (layerCount > 1) {
      const rest = [...this.iterators];
      const leader = rest.pop();
      let covers = false;
      for (let it of rest) {
        let iteratorCovers = it.coversIteratorAtPosition(leader, leader.getPosition());
        if (iteratorCovers !== false) {
          covers = iteratorCovers;
          break;
        }
      }
      if (covers) {
        this.currentIteratorIsCovered = covers;
        return;
      }
    }
    this.currentIteratorIsCovered = false;
  }
  logPosition() {
    let iterator = last(this.iterators);
    iterator?.logPosition();
  }
}
const EMPTY_SCOPES = Object.freeze([]);
class LayerHighlightIterator {
  constructor(languageLayer) {
    this.languageLayer = languageLayer;
    this.name = languageLayer.grammar.scopeName;
    this.depth = languageLayer.depth;
    let { injectionPoint } = this.languageLayer;
    this.coverShallowerScopes = injectionPoint?.coverShallowerScopes ?? false
  }
  _getEndPosition(endRow) {
    let { marker } = this.languageLayer;
    let { buffer } = this.languageLayer.languageMode;
    let naiveEndPoint = new Point(
      endRow,
      buffer.lineLengthForRow(endRow)
    );
    if (marker) {
      return Point.min(marker.getRange().end, naiveEndPoint)
    } else {
      return buffer.clipPosition(naiveEndPoint);
    }
  }
  coversIteratorAtPosition(iterator, position) {
    if (!this.coverShallowerScopes) { return false; }
    if (iterator.depth >= this.depth) { return false; }
    let ranges = this.languageLayer.getCurrentRanges();
    if (ranges) {
      let overlappingRange = ranges.find(range => range.containsPoint(position))
      if (!overlappingRange) return false;
      if (overlappingRange.end.compare(position) === 0) {
        return 'close';
      } else if (overlappingRange.start.compare(position) === 0) {
        return 'open';
      } else {
        return true;
      }
    }
  }
  seek(start, endRow) {
    let end = this._getEndPosition(endRow);
    let [boundaries, openScopes] = this.languageLayer.getSyntaxBoundaries(
      start, end);
    this.iterator = boundaries?.begin;
    if (!this.iterator?.key) {
      return [false, openScopes];
    }
    this.start = Point.fromObject(start, true);
    this.end = end;
    return [true, openScopes];
  }
  isAtInjectionBoundary() {
    let position = Point.fromObject(this.iterator.key.position);
    return position.isEqual(this.start) || position.isEqual(this.end);
  }
  _inspectScopes(ids) {
    if (Array.isArray(ids)) {
      return ids.map(id => this._inspectScopes(id)).join(', ')
    }
    return this.languageLayer.languageMode.scopeNameForScopeId(ids);
  }
  getOpenScopeIds() {
    let { key, value } = this.iterator;
    return key.boundary === 'end' ? EMPTY_SCOPES : [...value.scopeIds];
  }
  getCloseScopeIds() {
    let { key, value } = this.iterator;
    return key.boundary === 'start' ? EMPTY_SCOPES : [...value.scopeIds];
  }
  opensScopes() {
    return this.iterator?.key?.boundary === 'start';
  }
  closesScopes() {
    return this.iterator?.key?.boundary === 'end';
  }
  getPosition() {
    return this.iterator?.key?.position ?? Point.INFINITY;
  }
  logPosition() {
    let pos = this.getPosition();
    let { key, value } = this.iterator;
    let { languageMode } = this.languageLayer;
    let verb = key.boundary === 'end' ? 'close' : 'open';
    console.log(
      `[highlight] (${pos.row}, ${pos.column})`,
      verb,
      value.scopeIds.map(id => languageMode.scopeNameForScopeId(id)),
      'next?',
      this.iterator.hasNext
    );
  }
  compare(other) {
    const result = comparePoints(
      this.iterator.key.position,
      other.iterator.key.position
    );
    if (result !== 0) { return result; }
    let ourBoundary = this.iterator.key.boundary;
    let theirBoundary = other.iterator.key.boundary;
    let bothClosing = ourBoundary === 'end' && theirBoundary === 'end';
    if (ourBoundary === 'end' && !bothClosing) {
      return -1;
    } else if (theirBoundary === 'end' && !bothClosing) {
      return 1;
    }
    if (bothClosing) {
      return other.languageLayer.depth - this.languageLayer.depth;
    } else {
      return this.languageLayer.depth - other.languageLayer.depth;
    }
  }
  moveToSuccessor() {
    if (!this.iterator.hasNext || this.done) {
      return false;
    }
    this.iterator.next();
    this.done = this.isDone();
    return true;
  }
  peekAtSuccessor() {
    if (!this.iterator.hasNext) { return null; }
    this.iterator.next();
    let key = this.iterator.key;
    this.iterator.prev();
    return key;
  }
  isDone() {
    if (!this.iterator.hasNext) { return true; }
    if (!this.end) { return false; }
    let next = this.peekAtSuccessor();
    return comparePoints(next.position, this.end) > 0;
  }
}
class GrammarLoadError extends Error {
  constructor(grammar, queryType) {
    super(`Grammar ${grammar.scopeName} failed to load its ${queryType}. Please fix this error or contact the maintainer.`);
    this.name = 'GrammarLoadError';
    this.queryType = queryType;
  }
}
class LanguageLayer {
  constructor(marker, languageMode, grammar, depth, injectionPoint) {
    this.marker = marker;
    this.languageMode = languageMode;
    this.buffer = this.languageMode.buffer;
    this.grammar = grammar;
    this.depth = depth;
    this.injectionPoint = injectionPoint;
    this.rangeList = new RangeList();
    this.nodesToInvalidateOnChange = new Set();
    this.foldNodesToInvalidateOnChange = new Set();
    this.tree = null;
    this.lastSyntaxTree = null;
    this.temporaryTrees = [];
    this.patchSinceCurrentParseStarted = null;
    this.subscriptions = new CompositeDisposable;
    this.currentRangesLayer = this.buffer.addMarkerLayer();
    this.ready = false;
    this.queries = {};
    this.languageLoaded = this.grammar.getLanguage().then(language => {
      this.language = language;
      let queries = ['highlightsQuery', 'foldsQuery', 'indentsQuery', 'localsQuery', 'tagsQuery'];
      let promises = [];
      for (let queryType of queries) {
        if (grammar[queryType]) {
          let promise = this.grammar.getQuery(queryType).then(query => {
            this.queries[queryType] = query;
          }).catch(() => {
            throw new GrammarLoadError(grammar, queryType);
          });
          promises.push(promise);
        }
      }
      return Promise.all(promises);
    }).catch((err) => {
      if (err.name === 'GrammarLoadError') {
        console.warn(err.message);
        if (err.queryType === 'highlightsQuery') {
          grammar.setQueryForTest(
            'highlightsQuery',
            `; (placeholder)`
          );
        }
      } else {
        throw err;
      }
    }).then(() => {
      this.observeQueryChanges();
      this.tree = null;
      this.scopeResolver = new ScopeResolver(
        this,
        (name, text) => this.languageMode.idForScope(name, text)
      );
      this.foldResolver = new FoldResolver(this.buffer, this);
      let languageScope;
      if (depth === 0) {
        languageScope = this.grammar.scopeName;
      } else {
        languageScope = injectionPoint.languageScope;
        if (languageScope === undefined) {
          languageScope = this.grammar.scopeName;
        }
      }
      this.languageScope = languageScope;
      if (languageScope === null || typeof languageScope === 'function') {
        this.languageScopeId = null;
      } else {
        this.languageScopeId = this.languageMode.idForScope(languageScope);
      }
      this.ready = true;
    });
  }
  get highlightsQuery() { return this.queries.highlightsQuery; }
  set highlightsQuery(value) { this.queries.highlightsQuery = value; }
  get indentsQuery() { return this.queries.indentsQuery; }
  set indentsQuery(value) { this.queries.indentsQuery = value; }
  get foldsQuery() { return this.queries.foldsQuery; }
  set foldsQuery(value) { this.queries.foldsQuery = value; }
  get tagsQuery() { return this.queries.tagsQuery; }
  set tagsQuery(value) { this.queries.tagsQuery = value; }
  get localsQuery() { return this.queries.localsQuery; }
  set localsQuery(value) { this.queries.localsQuery = value; }
  isDirty() {
    if (!this.tree) { return false; }
    return this.tree.rootNode.hasChanges;
  }
  inspect() {
    let { scopeName } = this.grammar;
    return `[LanguageLayer ${scopeName || '(anonymous)'} depth=${this.depth} file=${this.buffer.getPath()}]`;
  }
  destroy() {
    if (this.destroyed) { return; }
    this.destroyed = true;
    let temporaryTrees = this.temporaryTrees ?? [];
    let trees = new Set([this.tree, this.lastSyntaxTree, ...temporaryTrees]);
    trees = [...trees];
    this.tree = null;
    this.lastSyntaxTree = null;
    this.temporaryTrees = [];
    while (trees.length > 0) {
      let tree = trees.pop();
      if (!tree) { continue; }
      tree.delete();
    }
    this.marker?.destroy();
    this.currentRangesLayer?.destroy();
    this.foldResolver?.reset();
    this.scopeResolver?.destroy();
    this.subscriptions.dispose();
    for (const marker of this.languageMode.injectionsMarkerLayer.getMarkers()) {
      if (marker.parentLanguageLayer === this) {
        marker.languageLayer.destroy();
      }
    }
  }
  async reloadGrammarQuery(queryType) {
    if (!this.queries[queryType]) { return; }
    let originalQuery = this.queries[queryType];
    try {
      let query = await this.grammar.getQuery(queryType);
      this.queries[queryType] = query;
      let range = this.getExtent();
      this.languageMode.emitRangeUpdate(range);
      this.nodesToInvalidateOnChange.clear();
      this.foldNodesToInvalidateOnChange.clear();
    } catch (error) {
      this.queries[queryType] = originalQuery;
      console.error(`Error parsing query file: ${queryType}`);
      console.error(error);
    }
  }
  observeQueryChanges() {
    this.grammar.onDidChangeQuery(async ({ queryType }) => {
      if (this._pendingQueryFileChange) { return; }
      this._pendingQueryFileChange = true;
      await this.reloadGrammarQuery(queryType);
      this._pendingQueryFileChange = false;
    })
  }
  getExtent() {
    return this.marker?.getRange() ?? this.languageMode.buffer.getRange();
  }
  getSyntaxBoundaries(from, to) {
    let { buffer } = this.languageMode;
    if (!(this.language && this.tree)) {
      return [[], new OpenScopeMap()];
    }
    from = buffer.clipPosition(Point.fromObject(from, true));
    to = buffer.clipPosition(Point.fromObject(to, true));
    let boundaries = createTree(compareBoundaries);
    let extent = this.getExtent();
    let captures = this.queries.highlightsQuery?.captures(
      this.tree.rootNode,
      { startPosition: from, endPosition: to }
    ) ?? [];
    this.scopeResolver.reset();
    for (let capture of captures) {
      let { node } = capture;
      if (this.scopeResolver.shouldInvalidateOnChange(capture)) {
        this.nodesToInvalidateOnChange.add(node.id);
      }
      if (node.childCount === 0 && node.text === '') { continue; }
      // Ask the `ScopeResolver` to process each capture in turn. Some captures
      // will be ignored if they fail certain tests, and some will have their
      // original range altered.
      this.scopeResolver.store(capture);
    }
    // A `HighlightIterator` will want to know which scopes were already open
    // when this range began. Sadly, we also have to keep track of the point in
    // the buffer at which each of those scopes would've been added, because
    let alreadyOpenScopes = new OpenScopeMap();
    let includedRanges = this.depth === 0 ? [extent] : this.getCurrentRanges();
    let languageScopeIdForRange = () => this.languageScopeId;
    if (typeof this.languageScope === 'function') {
      languageScopeIdForRange = (range) => {
        let scopeName = this.languageScope(this.grammar, this.languageMode.buffer, range);
        if (Array.isArray(scopeName)) {
          return scopeName.map(s => this.languageMode.idForScope(s));
        } else {
          return this.languageMode.idForScope(scopeName);
        }
      };
    }
    if (this.languageScopeId || typeof this.languageScope === 'function') {
      for (let range of includedRanges) {
        if (range.end.isLessThanOrEqual(from)) { continue; }
        if (range.start.isGreaterThanOrEqual(to)) { continue; }
        let languageScopeIds = languageScopeIdForRange(range);
        if (!languageScopeIds) continue;
        if (!Array.isArray(languageScopeIds)) {
          languageScopeIds = [languageScopeIds];
        }
        if (range.start.isLessThan(from)) {
          alreadyOpenScopes.set(
            range.start,
            languageScopeIds
          );
        } else {
          for (let id of languageScopeIds) {
            this.scopeResolver.setBoundary(
              range.start,
              id,
              'open',
              { root: true, length: Infinity }
            );
          }
        }
        if (range.end.isGreaterThan(to)) {
        } else {
          for (let i = languageScopeIds.length - 1; i >= 0; i--) {
            this.scopeResolver.setBoundary(
              range.end,
              languageScopeIds[i],
              'close',
              { root: true, length: Infinity }
            );
          }
        }
      }
    }
    for (let [point, data] of this.scopeResolver) {
      if (point.isLessThan(from)) {
        alreadyOpenScopes.set(point, data.open);
        for (let c of data.close) {
          alreadyOpenScopes.removeLastOccurrenceOf(c);
        }
        continue;
      } else if (point.isGreaterThan(to)) {
        continue;
      }
      let OPEN_KEY = { position: point, boundary: 'start' };
      let CLOSE_KEY = { position: point, boundary: 'end' };
      if (data.close.length > 0) {
        boundaries = boundaries.insert(CLOSE_KEY, {
          scopeIds: Object.freeze(data.close)
        });
      }
      if (data.open.length > 0) {
        boundaries = boundaries.insert(OPEN_KEY, {
          scopeIds: Object.freeze(data.open)
        });
      }
    }
    return [boundaries, alreadyOpenScopes];
  }
  buildHighlightIterator() {
    if (this.tree) {
      return new LayerHighlightIterator(this, this.tree);
    } else {
      return new NullLayerHighlightIterator();
    }
  }
  handleTextChange(edit, oldText, newText) {
    if (this.foldResolver) { this.foldResolver.reset(); }
    const {
      startPosition,
      oldEndPosition,
      newEndPosition
    } = edit;
    if (this.tree) {
      this.tree.edit(edit);
      if (this.lastSyntaxTree && this.tree !== this.lastSyntaxTree) {
        this.lastSyntaxTree.edit(edit);
      }
      this.treeIsDirty = true;
      if (this.editedRange) {
        if (startPosition.isLessThan(this.editedRange.start)) {
          this.editedRange.start = startPosition;
        } if (oldEndPosition.isLessThan(this.editedRange.end)) {
          this.editedRange.end = newEndPosition.traverse(
            this.editedRange.end.traversalFrom(oldEndPosition)
          );
        } else {
          this.editedRange.end = newEndPosition;
        }
      } else {
        this.editedRange = new Range(startPosition, newEndPosition);
      }
    }
    if (this.patchSinceCurrentParseStarted) {
      this.patchSinceCurrentParseStarted.splice(
        startPosition,
        oldEndPosition.traversalFrom(startPosition),
        newEndPosition.traversalFrom(startPosition),
        oldText,
        newText
      )
    }
  }
  async update(nodeRangeSet, params = {}) {
    if (!this.languageMode.useAsyncParsing) {
      if (!this.ready) { await this.languageLoaded; }
      await this._performUpdate(nodeRangeSet);
      return true;
    }
    if (!this.currentParsePromise) {
      do {
        params = { ...params, async: false };
        if (!this.ready) {
          params.async = true;
          await this.languageLoaded;
          if (this.currentParsePromise) return false;
        }
        this.currentParsePromise = this._performUpdate(nodeRangeSet, params);
        if (!params.async) { break; }
        await this.currentParsePromise;
      } while (
        !this.destroyed &&
        (!this.tree || this.tree.rootNode.hasChanges)
      );
      this.currentParsePromise = null;
      return true;
    } else {
      return false;
    }
  }
  getLocalReferencesAtPoint(point) {
    if (!this.queries.localsQuery) { return []; }
    let captures = this.queries.localsQuery.captures(
      this.tree.rootNode,
      {
        startPosition: point,
        endPosition: point.translate(ONE_CHAR_FORWARD_TRAVERSAL)
      }
    );
    captures = captures.filter(cap => {
      if (cap.name !== 'local.reference') { return false; }
      if (!rangeForNode(cap.node).containsPoint(point)) {
        return false;
      }
      return true;
    });
    let nodes = captures.map(cap => cap.node);
    nodes = nodes.sort((a, b) => b.range.compare(a.range));
    return nodes;
  }
  findDefinitionForLocalReference(node, captures = null) {
    if (!this.queries.localsQuery) { return []; }
    let name = node.text;
    if (!name) { return []; }
    let localRange = rangeForNode(node);
    let globalScope = this.tree.rootNode;
    if (!captures) {
      let { startPosition, endPosition } = globalScope;
      captures = this.groupLocalsCaptures(
        this.queries.localsQuery.captures(
          globalScope,
          { startPosition, endPosition }
        )
      );
    }
    let { scopes, definitions } = captures;
    let relevantScopes = scopes.filter((scope) => {
      let range = rangeForNode(scope);
      return range.containsRange(localRange);
    }).sort((a, b) => {
      a.range.compare(b.range)
    });
    relevantScopes.push(globalScope);
    let relevantDefinitions = definitions.filter(
      (def) => def.text === name
    );
    if (relevantDefinitions.length === 0) { return []; }
    let definitionsByBaseScope = new Index();
    for (let rDef of relevantDefinitions) {
      let rDefScopes = scopes.filter(s => {
        return isBetweenPoints(
          rDef.startPosition,
          s.startPosition,
          s.endPosition
        );
      }).sort((a, b) => {
        return rangeForNode(b).compare(rangeForNode(a));
      });
      let baseScope = rDefScopes[0] ?? globalScope;
      definitionsByBaseScope.add(baseScope, rDef);
    }
    for (let scope of relevantScopes) {
      let definitionsInScope = definitionsByBaseScope.get(scope) ?? [];
      let { length } = definitionsInScope;
      if (length === 0) { continue; }
      if (length === 1) { return definitionsInScope[0]; }
      let definitionsBeforeLocal = [];
      let definitionsAfterLocal = [];
      for (let def of definitionsInScope) {
        let result = comparePoints(def.startPosition, localRange.start);
        let bucket = result < 0 ?
          definitionsBeforeLocal :
          definitionsAfterLocal;
        bucket.push(def);
      }
      if (definitionsBeforeLocal.length > 0) {
        let maxBeforeLocal;
        for (let def of definitionsBeforeLocal) {
          if (!maxBeforeLocal) {
            maxBeforeLocal = def;
            continue;
          }
          let result = comparePoints(def, maxBeforeLocal);
          if (result > 0) {
            maxBeforeLocal = def;
          }
        }
        return maxBeforeLocal;
      }
      let minAfterLocal;
      for (let def of definitionsAfterLocal) {
        if (!minAfterLocal) {
          minAfterLocal = def;
          continue;
        }
        let result = comparePoints(def, minAfterLocal);
        if (result < 0) {
          minAfterLocal = def;
        }
      }
      return minAfterLocal;
    }
  }
  groupLocalsCaptures(captures) {
    let scopes = [];
    let definitions = [];
    let references = [];
    for (let capture of captures) {
      let { name, node } = capture;
      switch (name) {
        case 'local.scope':
          scopes.push(node);
          break;
        case 'local.definition':
          definitions.push(node);
          break;
        case 'local.reference':
          references.push(node);
          break;
      }
    }
    return { scopes, definitions, references };
  }
  searchForNodesInRange(range, nodeIdSet) {
    let node = this.getSyntaxNodeContainingRange(
      range,
      n => nodeIdSet.has(n.id)
    );
    if (node) {
      let ancestor = node.parent;
      while (ancestor) {
        if (nodeIdSet.has(ancestor.id)) {
          node = ancestor;
        }
        ancestor = ancestor.parent;
      }
      return node;
    }
    return null;
  }
  async _performUpdate(nodeRangeSet, params = {}) {
    if (this.destroyed) return;
    let includedRanges = null;
    this.rangeList.clear();
    if (nodeRangeSet) {
      includedRanges = nodeRangeSet.getRanges(this.languageMode.buffer);
      if (includedRanges.length === 0) {
        const range = this.marker.getRange();
        this.destroy();
        this.languageMode.emitRangeUpdate(range);
        return;
      }
    }
    this.patchSinceCurrentParseStarted = new Patch();
    let language = this.grammar.getLanguageSync();
    let tree;
    if (this.languageMode.useAsyncParsing) {
      tree = this.languageMode.parseAsync(
        language,
        this.tree,
        includedRanges,
      );
      if (tree.then) {
        params.async = true;
        tree = await tree;
      }
    } else {
      tree = this.languageMode.parse(
        language,
        this.tree,
        includedRanges,
      );
    }
    let changes = this.patchSinceCurrentParseStarted.getChanges();
    this.patchSinceCurrentParseStarted = null;
    for (let change of changes) {
      let newExtent = Point.fromObject(change.newEnd).traversalFrom(change.newStart);
      tree.edit(
        this._treeEditForBufferChange(
          change.newStart,
          change.oldEnd,
          Point.fromObject(change.oldStart).traverse(newExtent),
          change.oldText,
          change.newText
        )
      );
    }
    if (includedRanges) {
      this.setCurrentRanges(includedRanges);
    }
    let affectedRange = this.editedRange;
    this.lastTransactionEditedRange = this.editedRange;
    this.editedRange = null;
    let foldRangeList = new RangeList();
    if (affectedRange) {
      let node = this.searchForNodesInRange(
        affectedRange,
        this.nodesToInvalidateOnChange
      );
      if (node) {
        this.rangeList.add(node.range);
      }
      let foldNode = this.searchForNodesInRange(
        affectedRange,
        this.foldNodesToInvalidateOnChange
      );
      if (foldNode) {
        foldRangeList.add(foldNode.range);
      }
    }
    this.nodesToInvalidateOnChange.clear();
    this.foldNodesToInvalidateOnChange.clear();
    if (this.lastSyntaxTree) {
      const rangesWithSyntaxChanges = this.lastSyntaxTree.getChangedRanges(tree);
      let oldSyntaxTree = this.lastSyntaxTree;
      this.lastSyntaxTree = tree;
      let oldTree = this.tree;
      this.tree = tree;
      this.treeIsDirty = false;
      oldTree?.delete();
      oldSyntaxTree?.delete();
      while (this.temporaryTrees.length > 0) {
        let tree = this.temporaryTrees.pop();
        tree.delete();
      }
      if (rangesWithSyntaxChanges.length > 0) {
        for (const range of rangesWithSyntaxChanges) {
          this.rangeList.add(rangeForNode(range));
        }
        const combinedRangeWithSyntaxChange = new Range(
          rangesWithSyntaxChanges[0].startPosition,
          last(rangesWithSyntaxChanges).endPosition
        );
        if (affectedRange) {
          this.rangeList.add(affectedRange);
          affectedRange = affectedRange.union(combinedRangeWithSyntaxChange);
        } else {
          affectedRange = combinedRangeWithSyntaxChange;
        }
      }
    } else {
      this.tree = tree;
      this.treeIsDirty = false;
      this.lastSyntaxTree = tree;
      ensureNodeIsPatched(tree.rootNode);
      this.rangeList.add(rangeForNode(tree.rootNode));
      if (includedRanges) {
        affectedRange = new Range(
          includedRanges[0].startPosition,
          last(includedRanges).endPosition
        );
      } else {
        affectedRange = MAX_RANGE;
      }
    }
    for (let range of this.rangeList) {
      this.languageMode.emitRangeUpdate(range);
    }
    for (let range of foldRangeList) {
      this.languageMode.emitFoldUpdate(range);
    }
    if (affectedRange) {
      let injectionPromise = this._populateInjections(affectedRange, nodeRangeSet);
      if (injectionPromise) {
        params.async = true;
        return injectionPromise;
      }
    }
  }
  setCurrentRanges(includedRanges) {
    if (this.depth === 0) { return; }
    let oldRangeMarkers = this.currentRangesLayer.getMarkers();
    for (let marker of oldRangeMarkers) {
      marker.destroy();
    }
    for (let range of includedRanges) {
      range = rangeForNode(range);
      this.currentRangesLayer.markRange(range);
    }
  }
  getCurrentRanges() {
    let markers = this.currentRangesLayer?.getMarkers();
    if (!markers || markers.length === 0) { return null; }
    return markers.map(m => m.getRange());
  }
  containsPoint(point, exclusive = false) {
    let ranges = this.getCurrentRanges() ?? [this.getExtent()];
    return ranges.some(r => r.containsPoint(point, exclusive));
  }
  getOrParseTree({ force = true, anonymous = false } = {}) {
    if (this.tree && (!this.treeIsDirty || !force)) { return this.tree; }
    if (atom.inDevMode()) {
      console.warn('Re-parsing tree!', this.inspect(), this.treeIsDirty);
    }
    let ranges = null;
    if (this.depth > 0) {
      ranges = this.getCurrentRanges().map(r => {
        return rangeToTreeSitterRangeSpec(r, this.buffer);
      });
    }
    let then = performance.now()
    let tree = this.languageMode.parse(
      this.language,
      this.tree,
      ranges,
    );
    let now = performance.now()
    let parseTime = now - then;
    this.languageMode.currentTransactionReparseBudgetMs -= parseTime;
    if (this.depth === 0 && !anonymous) {
      this.tree = tree;
      this.treeIsDirty = false;
    } else {
      this.temporaryTrees.push(tree);
    }
    return tree;
  }
  getText() {
    let { buffer } = this.languageMode;
    if (!this.marker) {
      return buffer.getText();
    } else {
      return buffer.getTextInRange(this.marker.getRange());
    }
  }
  scopeMapAtPosition(point) {
    if (!this.language || !this.tree) { return []; }
    let { scopeResolver } = this;
    scopeResolver.reset();
    let captures = this.queries.highlightsQuery?.captures(
      this.tree.rootNode,
      {
        startPosition: point,
        endPosition: point.translate(ONE_CHAR_FORWARD_TRAVERSAL)
      }
    ) ?? [];
    let results = [];
    for (let capture of captures) {
      let range = scopeResolver.store(capture);
      if (!range) { continue; }
      if (comparePoints(range.endPosition, point) === 0) { continue; }
      if (isBetweenPoints(point, range.startPosition, range.endPosition)) {
        results.push({ capture, adjustedRange: range });
      }
    }
    scopeResolver.reset();
    results = results.sort((a, b) => {
      return nodeBreadth(b.adjustedRange) - nodeBreadth(a.adjustedRange);
    });
    return results;
  }
  getSyntaxNodeAtPosition(position, where = FUNCTION_TRUE) {
    if (!this.language || !this.tree) { return null; }
    let { buffer } = this.languageMode;
    let index = buffer.characterIndexForPosition(position);
    let node = this.tree.rootNode.descendantForIndex(index);
    while (node) {
      if (where(node, this.grammar)) {
        return node;
      }
      node = node.parent;
    }
    return null;
  }
  getSyntaxNodeContainingRange(range, where = FUNCTION_TRUE) {
    if (!this.language || !this.tree) { return null; }
    let { buffer } = this.languageMode;
    if (range.start.isEqual(range.end)) {
      return this.getSyntaxNodeAtPosition(range.start, where);
    }
    let indexStart = buffer.characterIndexForPosition(range.start);
    let indexEnd = buffer.characterIndexForPosition(range.end);
    let rangeBreadth = indexEnd - indexStart;
    let node = this.getSyntaxNodeAtPosition(
      range.start,
      (node) => {
        let breadth = node.endIndex - node.startIndex;
        let qualifies = node.startIndex <= indexEnd &&
          node.endIndex >= indexEnd &&
          breadth >= rangeBreadth;
        return qualifies && where(node);
      }
    );
    return node ?? null;
  }
  _populateInjections(range, nodeRangeSet) {
    if (!this.tree) { return; }
    const promises = [];
    let existingInjectionMarkers = this.languageMode.injectionsMarkerLayer
      .findMarkers({ intersectsRange: range })
      .filter(marker => marker.parentLanguageLayer === this);
    if (existingInjectionMarkers.length > 0) {
      let earliest = range.start, latest = range.end;
      for (let marker of existingInjectionMarkers) {
        range = marker.getRange();
        if (range.start.compare(earliest) === -1) {
          earliest = range.start;
        }
        if (range.end.compare(latest) === 1) {
          latest = range.end;
        }
      }
      range = range.union(new Range(earliest, latest));
    }
    if (range.isEmpty()) { return; }
    existingInjectionMarkers = this.languageMode.injectionsMarkerLayer
      .findMarkers({ startsInRange: range, endsInRange: range })
      .filter(marker => marker.parentLanguageLayer === this);
    const markersToUpdate = new Map();
    const nodes = this.tree.rootNode.descendantsOfType(
      Object.keys(this.grammar.injectionPointsByType),
      range.start,
      range.end
    );
    let existingInjectionMarkerIndex = 0;
    let newLanguageLayers = 0;
    for (const node of nodes) {
      for (const injectionPoint of this.grammar.injectionPointsByType[node.type]) {
        const languageName = injectionPoint.language(node);
        if (!languageName) { continue; }
        const grammar = this.languageMode.grammarForLanguageString(
          languageName);
        if (!grammar) { continue; }
        const contentNodes = injectionPoint.content(node, this.buffer);
        if (!contentNodes) { continue; }
        const injectionNodes = [].concat(contentNodes);
        if (!injectionNodes.length) continue;
        const injectionRange = node.range;
        let marker;
        for (
          let i = existingInjectionMarkerIndex,
            n = existingInjectionMarkers.length;
          i < n;
          i++
        ) {
          const existingMarker = existingInjectionMarkers[i];
          const comparison = existingMarker.getRange().compare(injectionRange);
          if (comparison > 0) {
            break;
          } else if (comparison === 0) {
            existingInjectionMarkerIndex = i;
            if (existingMarker.languageLayer.grammar === grammar) {
              marker = existingMarker;
              break;
            }
          } else {
            existingInjectionMarkerIndex = i;
          }
        }
        if (!marker) {
          marker = this.languageMode.injectionsMarkerLayer.markRange(
            injectionRange);
          marker.languageLayer = new LanguageLayer(
            marker,
            this.languageMode,
            grammar,
            this.depth + 1,
            injectionPoint
          );
          marker.parentLanguageLayer = this;
          newLanguageLayers++;
        }
        markersToUpdate.set(
          marker,
          new NodeRangeSet(
            nodeRangeSet,
            injectionNodes,
            injectionPoint
          )
        );
      }
    }
    let staleLanguageLayers = 0;
    for (const marker of existingInjectionMarkers) {
      if (!markersToUpdate.has(marker)) {
        this.languageMode.emitRangeUpdate(marker.getRange());
        marker.languageLayer.destroy();
        staleLanguageLayers++;
      }
    }
    if (markersToUpdate.size > 0) {
      for (const [marker, nodeRangeSet] of markersToUpdate) {
        promises.push(marker.languageLayer.update(nodeRangeSet));
      }
    }
    return Promise.all(promises);
  }
  _treeEditForBufferChange(start, oldEnd, newEnd, oldText, newText) {
    let startIndex = this.buffer.characterIndexForPosition(start);
    return {
      startIndex,
      oldEndIndex: startIndex + oldText.length,
      newEndIndex: startIndex + newText.length,
      startPosition: start,
      oldEndPosition: oldEnd,
      newEndPosition: newEnd
    };
  }
}
class NodeRangeSet {
  constructor(previous, nodes, injectionPoint) {
    this.previous = previous;
    this.newlinesBetween = injectionPoint.newlinesBetween;
    this.includeAdjacentWhitespace = injectionPoint.includeAdjacentWhitespace;
    this.includeChildren = injectionPoint.includeChildren;
    this.nodeSpecs = [];
    for (let node of nodes) {
      this.nodeSpecs.push(this.getNodeSpec(node, true));
    }
  }
  getNodeSpec(node, getChildren) {
    let { startIndex, endIndex, startPosition, endPosition, id } = node;
    let result = { startIndex, endIndex, startPosition, endPosition, id };
    if (getChildren && node.childCount > 0) {
      result.children = [];
      for (let child of node.children) {
        result.children.push(this.getNodeSpec(child, false));
      }
    }
    return result;
  }
  getRanges(buffer) {
    const previousRanges = this.previous?.getRanges(buffer);
    let result = [];
    for (let node of this.nodeSpecs) {
      if (node.endIndex === Infinity) {
        node = this._clipRange(node, buffer);
      }
      let position = node.startPosition, index = node.startIndex;
      if (node.children && !this.includeChildren) {
        for (const child of node.children) {
          const nextIndex = child.startIndex;
          if (nextIndex > index) {
            this._pushRange(buffer, previousRanges, result, {
              startIndex: index,
              endIndex: nextIndex,
              startPosition: position,
              endPosition: child.startPosition
            });
          }
          position = child.endPosition;
          index = child.endIndex;
        }
      }
      if (node.endIndex > index) {
        this._pushRange(buffer, previousRanges, result, {
          startIndex: index,
          endIndex: node.endIndex,
          startPosition: position,
          endPosition: node.endPosition
        });
      }
    }
    let whitespaceRanges = [];
    if (this.includeAdjacentWhitespace && result.length > 1) {
      for (let i = 1; i < result.length; i++) {
        let current = result[i], previous = result[i - 1];
        if (current.startIndex === previous.endIndex) { continue; }
        let pseudoRange = {
          startPosition: previous.endPosition,
          startIndex: previous.endIndex,
          endPosition: current.startPosition,
          endIndex: current.startIndex
        };
        let rangeText = buffer.getTextInRange(rangeForNode(pseudoRange));
        if (!/\S/.test(rangeText)) {
          whitespaceRanges.push(pseudoRange);
        }
      }
      result.push(...whitespaceRanges);
      result = result.sort((a, b) => {
        return a.startIndex - b.startIndex ||
          a.endIndex - b.endIndex;
      });
    }
    return this._consolidateRanges(result);
  }
  _clipRange(range, buffer) {
    let clippedRange = buffer.clipRange(rangeForNode(range));
    return rangeToTreeSitterRangeSpec(clippedRange, buffer);
  }
  _consolidateRanges(ranges) {
    if (ranges.length === 1) { return ranges; }
    let consolidated = [];
    let candidate;
    let lastIndex = ranges.length - 1;
    for (let i = 0; i < ranges.length; i++) {
      let range = ranges[i];
      if (!candidate) {
        candidate = range;
        continue;
      }
      if (candidate.endIndex === range.startIndex) {
        candidate = {
          startIndex: candidate.startIndex,
          startPosition: candidate.startPosition,
          endIndex: range.endIndex,
          endPosition: range.endPosition
        };
        if (i === lastIndex) {
          consolidated.push(candidate);
        }
      } else {
        consolidated.push(candidate);
        if (i === lastIndex) {
          consolidated.push(range);
        } else {
          candidate = range;
        }
      }
    }
    return consolidated;
  }
  coversRange(candidateRange) {
    let ranges = this.getRanges().map(r => rangeForNode(r));
    return ranges.some(range => {
      return range.containsRange(candidateRange);
    });
  }
  _pushRange(buffer, previousRanges, newRanges, newRange) {
    if (!previousRanges) {
      if (this.newlinesBetween) {
        const { startIndex, startPosition } = newRange;
        this._ensureNewline(buffer, newRanges, startIndex, startPosition);
      }
      newRanges.push(newRange);
      return;
    }
    for (const previousRange of previousRanges) {
      if (previousRange.endIndex <= newRange.startIndex) continue;
      if (previousRange.startIndex >= newRange.endIndex) break;
      const startIndex = Math.max(
        previousRange.startIndex,
        newRange.startIndex
      );
      const endIndex = Math.min(previousRange.endIndex, newRange.endIndex);
      const startPosition = Point.max(
        previousRange.startPosition,
        newRange.startPosition
      );
      const endPosition = Point.min(
        previousRange.endPosition,
        newRange.endPosition
      );
      if (this.newlinesBetween) {
        this._ensureNewline(buffer, newRanges, startIndex, startPosition);
      }
      newRanges.push({ startIndex, endIndex, startPosition, endPosition });
    }
  }
  _ensureNewline(buffer, newRanges, startIndex, startPosition) {
    const lastRange = last(newRanges);
    if (lastRange && lastRange.endPosition.row < startPosition.row) {
      newRanges.push({
        startPosition: new Point(
          startPosition.row - 1,
          buffer.lineLengthForRow(startPosition.row - 1)
        ),
        endPosition: new Point(startPosition.row, 0),
        startIndex: startIndex - startPosition.column - 1,
        endIndex: startIndex - startPosition.column
      });
    }
  }
}
class OpenScopeMap extends Map {
  constructor() {
    super();
  }
  getScopesArray() {
    let results = [];
    let keys = [...this.keys()];
    keys.sort(comparePoints);
    for (let key of keys) {
      let value = this.get(key);
      results.push(...value);
    }
    return results;
  }
  removeLastOccurrenceOf(scopeId) {
    let candidateKey;
    for (let key of this.keys()) {
      let value = this.get(key);
      if (!value.includes(scopeId)) continue;
      if (!candidateKey || comparePoints(key, candidateKey) === 1) {
        candidateKey = key;
      }
    }
    if (!candidateKey) return false;
    removeLastOccurrenceOf(this.get(candidateKey), scopeId);
    return true;
  }
}
class Index extends Map {
  constructor() {
    super();
  }
  add(key, ...values) {
    let existing = this.get(key);
    if (!existing) {
      existing = [];
      this.set(key, existing);
    }
    existing.push(...values);
  }
}
class RangeList {
  constructor() {
    this.ranges = [];
  }
  clear() {
    this.ranges.length = 0;
  }
  add(newRange) {
    let intersecting = [];
    for (let range of this.ranges) {
      if (newRange.intersectsWith(range)) {
        intersecting.push(range);
      }
    }
    for (let i = intersecting.length - 1; i >= 0; i--) {
      let index = this.ranges.indexOf(intersecting[i]);
      this.ranges.splice(index, 1);
    }
    while (intersecting.length > 0) {
      newRange = newRange.union(intersecting.shift());
    }
    this.insertOrdered(newRange);
  }
  insertOrdered(newRange) {
    let index = this.ranges.findIndex(r => {
      return r.start.compare(newRange.start) > 0;
    });
    this.ranges.splice(index, 0, newRange);
  }
  inspect() {
    let ranges = this.ranges.map(r => r.toString());
    return `[RangeList: ${ranges.join(', ')}]`;
  }
  *[Symbol.iterator]() {
    for (let range of this.ranges) {
      yield range;
    }
  }
}
class IndentResolver {
  constructor(buffer, languageMode) {
    this.buffer = buffer;
    this.languageMode = languageMode;
    this.emitter = new Emitter();
  }
  suggestedIndentForBufferRow(row, tabLength, rawOptions = {}) {
    if (row === 0) { return 0; }
    let root = this.languageMode.rootLanguageLayer;
    if (!root || !root.tree || !root.ready) { return null; }
    let { languageMode } = this;
    let options = {
      skipEvent: false,
      skipBlankLines: true,
      skipDedentCheck: false,
      preserveLeadingWhitespace: false,
      indentationLevels: null,
      forceTreeParse: false,
      ...rawOptions
    };
    let originalControllingLayer = options.controllingLayer;
    let comparisonRow = options.comparisonRow ?? this.getComparisonRow(row, options);
    let existingIndent = 0;
    if (options.preserveLeadingWhitespace) {
      existingIndent = this.indentLevelForLine(
        this.buffer.lineForRow(row), tabLength);
    }
    let comparisonRowIndent = options.comparisonRowIndent;
    if (comparisonRowIndent === undefined) {
      comparisonRowIndent = languageMode.indentLevelForLine(
        this.buffer.lineForRow(comparisonRow), tabLength);
    }
    let comparisonRowEnd = new Point(
      comparisonRow,
      this.buffer.lineLengthForRow(comparisonRow)
    );
    let controllingLayer = languageMode.controllingLayerAtPoint(
      comparisonRowEnd,
      (layer) => {
        if (!layer.queries.indentsQuery) return false;
        if (layer.containsPoint(comparisonRowEnd, true)) {
          return true;
        }
        return layer.getCurrentRanges()?.some(r => {
          return r.end.compare(comparisonRowEnd) === 0;
        });
      }
    );
    if (!controllingLayer) {
      return comparisonRowIndent - existingIndent;
    }
    let { queries: { indentsQuery }, scopeResolver } = controllingLayer;
    scopeResolver.reset();
    let indentTree = null;
    if (options.tree && originalControllingLayer === controllingLayer) {
      indentTree = options.tree;
    }
    if (!indentTree) {
      if (!controllingLayer.treeIsDirty || options.forceTreeParse || !languageMode.shouldUseAsyncIndent()) {
        indentTree = controllingLayer.getOrParseTree();
      } else {
        let comparisonRowText = this.buffer.lineForRow(comparisonRow)
        let rowText = this.buffer.lineForRow(row)
        return languageMode.atTransactionEnd().then(({ changeCount }) => {
          let shouldFallback = false;
          if (changeCount > 1) {
            if (comparisonRowText !== this.buffer.lineForRow(comparisonRow)) {
              shouldFallback = true;
            }
            if (rowText !== this.buffer.lineForRow(row)) {
              shouldFallback = true;
            }
          }
          if (shouldFallback) {
            return undefined;
          }
          let result = this.suggestedIndentForBufferRow(row, tabLength, {
            ...rawOptions,
            comparisonRow: comparisonRow,
            comparisonRowIndent: comparisonRowIndent,
            tree: controllingLayer.tree,
            controllingLayer
          });
          return result;
        });
      }
    }
    let positionSet = new Set;
    let indentCaptures = indentsQuery.captures(
      indentTree.rootNode,
      {
        startPosition: { row: comparisonRow, column: 0 },
        endPosition: { row: row, column: 0 }
      }
    );
    let indentCapturePosition = null;
    let indentDelta = 0;
    let dedentNextDelta = 0;
    let matchNextResult = null;
    for (let capture of indentCaptures) {
      let { node, name } = capture;
      let allowEmpty = this.getProperty(capture, 'allowEmpty', 'boolean', false);
      if (node.text === '' && !allowEmpty) {
        continue;
      }
      // Ignore anything that isn't actually on the row.
      if (node.endPosition.row < comparisonRow) { continue; }
      if (node.startPosition.row > comparisonRow) { continue; }
      if (!scopeResolver.store(capture)) { continue; }
      let passed = this.applyTests(capture, {
        currentRow: row,
        comparisonRow,
        tabLength
      });
      if (!passed) { continue; }
      let key = `${name}/${node.startIndex}/${node.endIndex}`;
      if (positionSet.has(key)) { continue; }
      positionSet.add(key);
      if (name === 'indent') {
        if (indentCapturePosition === null) {
          indentCapturePosition = node.endPosition;
        }
        indentDelta++;
      } else if (name === 'dedent.next') {
        dedentNextDelta++;
      } else if (name === 'match.next') {
        matchNextResult = this.resolveMatch(capture, {
          currentRow: row,
          comparisonRow,
          tabLength,
          indentationLevels: options.indentationLevels
        }) ?? null;
        if (matchNextResult !== null) {
          break;
        }
      } else if (name === 'dedent') {
        if (!indentCapturePosition || comparePoints(node.startPosition, indentCapturePosition) < 0) {
          continue;
        }
        indentDelta--;
        if (indentDelta < 0) {
          indentDelta = 0;
        }
      }
    }
    indentDelta = clamp(indentDelta, 0, 1);
    indentDelta -= clamp(dedentNextDelta, 0, 1);
    if (matchNextResult !== null) {
      indentDelta = 0;
    }
    let dedentDelta = 0;
    let lineText = this.buffer.lineForRow(row);
    let rowStartingColumn = Math.max(lineText.search(/\S/), 0);
    if (!options.skipDedentCheck) {
      scopeResolver.reset();
      let rowStart = new Point(row, rowStartingColumn);
      let dedentControllingLayer = languageMode.controllingLayerAtPoint(
        rowStart,
        (layer) => {
          if (!layer.queries.indentsQuery) return false;
          if (layer.containsPoint(rowStart, true)) {
            return true;
          }
          return layer.getCurrentRanges()?.some(r => {
            return r.start.compare(rowStart) === 0;
          });
        }
      );
      if (dedentControllingLayer && dedentControllingLayer !== controllingLayer) {
        indentsQuery = dedentControllingLayer.queries.indentsQuery;
        indentTree = dedentControllingLayer.getOrParseTree();
      }
      let dedentCaptures = indentsQuery.captures(
        indentTree.rootNode,
        {
          startPosition: { row: row - 1, column: Infinity },
          endPosition: { row: row + 1, column: 0 }
        }
      );
      let currentRowText = lineText.trim();
      positionSet.clear();
      for (let capture of dedentCaptures) {
        let { name, node } = capture;
        let { text } = node;
        let allowEmpty = this.getProperty(capture, 'allowEmpty', 'boolean', false);
        if (text === '' && !allowEmpty) { continue; }
        // `(#set! indent.force)` acts more aggressively, signaling dedent even
        // when the capture isn't the first content on the row. This should be
        let force = this.getProperty(capture, 'force', 'boolean', false);
        if (node.endPosition.row < row) { continue; }
        if (node.startPosition.row > row) { continue; }
        if (!scopeResolver.store(capture)) { continue; }
        let passed = this.applyTests(capture, {
          currentRow: row,
          comparisonRow,
          tabLength
        });
        if (!passed) { continue; }
        if (!force && !currentRowText.startsWith(text)) { continue; }
        if (name === 'match') {
          let matchIndentLevel = this.resolveMatch(
            capture, { row, comparisonRow, tabLength, indentationLevels: options.indentationLevels });
          if (typeof matchIndentLevel === 'number') {
            scopeResolver.reset();
            let finalIndent = Math.max(matchIndentLevel - Math.floor(existingIndent), 0);
            if (!options.skipEvent) {
              this.emitter.emit('did-suggest-indent', {
                currentRow: row,
                comparisonRow,
                matchIndentLevel,
                finalIndent,
                captureMode: 'match'
              });
            }
            return finalIndent;
          }
        } else if (name === 'none') {
          scopeResolver.reset();
          if (!options.skipEvent) {
            this.emitter.emit('did-suggest-indent', {
              currentRow: row,
              comparisonRow,
              finalIndent: 0,
              captureMode: 'none'
            });
          }
          return 0;
        }
        if (name !== 'dedent') { continue; }
        let key = `${node.startIndex}/${node.endIndex}`;
        if (positionSet.has(key)) { continue; }
        positionSet.add(key);
        dedentDelta--;
      }
      dedentDelta = clamp(dedentDelta, -1, 0);
    }
    scopeResolver.reset();
    let baseline = matchNextResult !== null ? matchNextResult : comparisonRowIndent;
    let finalIndent = baseline + indentDelta + dedentDelta;
    let adjustedIndent = Math.max(finalIndent - Math.floor(existingIndent), 0);
    if (!options.skipEvent) {
      this.emitter.emit('did-suggest-indent', {
        currentRow: row,
        comparisonRow,
        comparisonRowIndent,
        indentDelta,
        dedentDelta,
        finalIndent,
        adjustedIndent,
        captureMode: 'normal'
      });
    }
    return adjustedIndent;
  }
  onDidSuggestIndent(callback) {
    return this.emitter.on('did-suggest-indent', callback);
  }
  suggestedIndentForBufferRows(startRow, endRow, tabLength, options = {}) {
    let { languageMode } = this;
    let root = languageMode.rootLanguageLayer;
    if (!root || !root.tree) {
      let results = new Map();
      for (let row = startRow; row <= endRow; row++) {
        results.set(row, null);
      }
      return results;
    }
    let results = new Map();
    let comparisonRow = null;
    let comparisonRowIndent = null;
    let { isPastedText = false } = options;
    let indentDelta;
    for (let row = startRow; row <= endRow; row++) {
      let controllingLayer = languageMode.controllingLayerAtPoint(
        this.buffer.clipPosition(new Point(row - 1, Infinity)),
        (layer) => !!layer.queries.indentsQuery && !!layer.tree
      );
      if (isPastedText) {
        if (row === startRow) {
          if (!controllingLayer) { return null; }
          let tree = controllingLayer.getOrParseTree();
          let firstLineCurrentIndent = this.indentLevelForLine(
            this.buffer.lineForRow(row), tabLength);
          let firstLineIdealIndent = this.suggestedIndentForBufferRow(
            row,
            tabLength,
            {
              ...options,
              controllingLayer,
              tree
            }
          );
          if (firstLineIdealIndent == null) {
            return null;
          } else {
            indentDelta = firstLineIdealIndent - firstLineCurrentIndent;
            if (indentDelta === 0) {
              return null;
            }
            results.set(row, firstLineIdealIndent);
          }
          continue;
        }
        let actualIndent = this.indentLevelForLine(
          this.buffer.lineForRow(row), tabLength);
        results.set(row, actualIndent + indentDelta);
        continue;
      }
      let indent;
      if (controllingLayer) {
        let tree = controllingLayer.getOrParseTree();
        let rowOptions = {
          ...options,
          tree,
          comparisonRow: comparisonRow ?? undefined,
          comparisonRowIndent: comparisonRowIndent ?? undefined,
          indentationLevels: results
        };
        indent = this.suggestedIndentForBufferRow(row, tabLength, rowOptions);
        if (indent === null) {
          return results;
        }
      } else {
        return results;
      }
      results.set(row, indent);
      comparisonRow = row;
      comparisonRowIndent = indent;
    }
    return results;
  }
  suggestedIndentForEditedBufferRow(row, tabLength, options = {}) {
    let { languageMode } = this;
    const line = this.buffer.lineForRow(row);
    const currentRowIndent = this.indentLevelForLine(line, tabLength);
    let comparisonRow = options.comparisonRow ?? this.getComparisonRow(row, options);
    if (currentRowIndent === 0) { return; }
    if (row === 0) { return; }
    let rowStartingColumn = Math.max(line.search(/\S/), 0);
    let controllingLayer = languageMode.controllingLayerAtPoint(
      new Point(row, rowStartingColumn),
      (layer) => !!layer.queries.indentsQuery
    );
    if (!controllingLayer) { return undefined; }
    let { queries: { indentsQuery }, scopeResolver } = controllingLayer;
    if (!indentsQuery) { return undefined; }
    scopeResolver.reset();
    let indentTree = options.tree;
    if (!indentTree) {
      if (!controllingLayer.treeIsDirty || options.forceTreeParse || !this.useAsyncIndent || !this.useAsyncParsing) {
        indentTree = controllingLayer.getOrParseTree();
      } else {
        return this.atTransactionEnd().then(({ changeCount }) => {
          if (changeCount > 1) {
            return null;
          }
          let result = this.suggestedIndentForEditedBufferRow(row, tabLength, {
            ...options,
            tree: controllingLayer.tree
          });
          if (currentRowIndent === result) {
            return null;
          }
          return result;
        });
      }
    }
    if (!indentTree) {
      console.error(`No indent tree!`, controllingLayer.inspect());
      return undefined;
    }
    const indents = indentsQuery.captures(
      indentTree.rootNode,
      {
        startPosition: { row: row - 1, column: Infinity },
        endPosition: { row: row + 1, column: 0 }
      }
    );
    let lineText = this.buffer.lineForRow(row).trim();
    const originalRowIndent = this.suggestedIndentForBufferRow(row, tabLength, {
      skipBlankLines: true,
      skipDedentCheck: true,
      skipEvent: true,
      tree: indentTree
    });
    let seenDedent = false;
    for (let indent of indents) {
      let { node } = indent;
      if (node.startPosition.row !== row) { continue; }
      if (!scopeResolver.store(indent)) { continue; }
      let passed = this.applyTests(indent, {
        currentRow: row,
        comparisonRow,
        tabLength
      });
      if (!passed) return;
      let force = this.getProperty(indent, 'force', 'boolean', false);
      if (!force && node.text !== lineText) { continue; }
      if (indent.name === 'match') {
        let matchIndentLevel = this.resolveMatch(indent, {
          currentRow: row,
          comparisonRow,
          tabLength
        });
        if (typeof matchIndentLevel === 'number') {
          scopeResolver.reset();
          this.emitter.emit('did-suggest-indent', {
            currentRow: row,
            comparisonRow,
            matchIndentLevel,
            finalIndent: matchIndentLevel,
            captureMode: 'match'
          });
          return matchIndentLevel;
        }
      } else if (indent.name === 'none') {
        scopeResolver.reset();
        this.emitter.emit('did-suggest-indent', {
          currentRow: row,
          comparisonRow,
          finalIndent: 0,
          captureMode: 'none'
        });
        return 0;
      }
      if (indent.name !== 'dedent') { continue; }
      seenDedent = true;
    }
    scopeResolver.reset();
    let finalIndent = seenDedent ? Math.max(0, originalRowIndent - 1) : currentRowIndent;
    this.emitter.emit('did-suggest-indent', {
      currentRow: row,
      comparisonRow,
      finalIndent,
      captureMode: 'normal'
    });
    return finalIndent;
  }
  getComparisonRow(row, { skipBlankLines = true } = {}) {
    let comparisonRow = row - 1;
    if (skipBlankLines) {
      while (this.buffer.isRowBlank(comparisonRow) && comparisonRow > 0) {
        comparisonRow--;
      }
    }
    return comparisonRow;
  }
  indentLevelForLine(line, tabLength) {
    let indentLength = 0;
    for (let i = 0, { length } = line; i < length; i++) {
      const char = line[i];
      if (char === '\t') {
        indentLength += tabLength - (indentLength % tabLength);
      } else if (char === ' ') {
        indentLength++;
      } else {
        break;
      }
    }
    return indentLength / tabLength
  }
  resolveMatch(capture, { currentRow, tabLength, indentationLevels }) {
    let { node } = capture;
    let matchIndentOf = this.getProperty(capture, ['match', 'matchIndentOf'], 'string', null);
    let offsetIndent = this.getProperty(capture, ['offset', 'offsetIndent'], 'number', 0);
    if (!matchIndentOf) return undefined;
    let targetPosition = resolveNodePosition(node, matchIndentOf);
    let targetRow = targetPosition?.row;
    if (typeof targetRow !== 'number' || targetRow >= currentRow) {
      return undefined;
    }
    let baseIndent;
    if (indentationLevels) {
      baseIndent = indentationLevels.get(targetRow);
    }
    baseIndent ??= this.languageMode.indentLevelForLine(
      this.buffer.lineForRow(targetRow), tabLength);
    let result = baseIndent + offsetIndent;
    return Math.max(result, 0);
  }
  getProperty(capture, names, coercion = null, fallback = null) {
    let { setProperties: props = {} } = capture;
    if (typeof names === 'string') { names = [names]; }
    for (let name of names) {
      let fullName = `indent.${name}`;
      if (!(fullName in props)) { continue; }
      return this.coerce(props[fullName], coercion) ?? fallback;
    }
    return fallback;
  }
  coerce(value, coercion) {
    switch (coercion) {
      case String:
      case 'string':
        if (value == null) return "";
        return value;
      case Number:
      case 'number': {
        let number = Number(value);
        if (isNaN(number)) return null;
        return number;
      }
      case Boolean:
      case 'boolean':
        if (value == null) return null;
        return true;
      default:
        return value;
    }
  }
  applyTests(capture, meta) {
    let {
      node,
      assertedProperties: asserted = {},
      refutedProperties: refuted = {}
    } = capture;
    for (let [name, test] of Object.entries(IndentResolver.TESTS)) {
      let fullName = `indent.${name}`
      let passed = true;
      if (asserted[fullName]) {
        passed = test(node, asserted[fullName], meta);
      } else if (refuted[fullName]) {
        passed = !test(node, asserted[fullName], meta);
      }
      if (!passed) return false;
    }
    return true;
  }
}
IndentResolver.TESTS = {
  matchesCurrentRow(node, value, { currentRow }) {
    let position = resolveNodePosition(node, value);
    if (!position) return null;
    return position.row === currentRow;
  },
  matchesComparisonRow(node, value, { comparisonRow }) {
    let position = resolveNodePosition(node, value);
    if (!position) return null;
    return position.row === comparisonRow;
  }
}
module.exports = WASMTreeSitterLanguageMode;

================
File: src/web-tree-sitter.js
================
const USE_CUSTOM_WEB_TREE_SITTER = true;
let Parser;
if (USE_CUSTOM_WEB_TREE_SITTER) {
  Parser = require('../vendor/web-tree-sitter/tree-sitter');
} else {
  Parser = require('web-tree-sitter');
}
module.exports = Parser;

================
File: src/window-event-handler.js
================
const { Disposable, CompositeDisposable } = require('event-kit');
const listen = require('./delegated-listener');
const { debounce } = require('underscore-plus');
module.exports = class WindowEventHandler {
  constructor({ atomEnvironment, applicationDelegate }) {
    this.handleDocumentKeyEvent = this.handleDocumentKeyEvent.bind(this);
    this.handleFocusNext = this.handleFocusNext.bind(this);
    this.handleFocusPrevious = this.handleFocusPrevious.bind(this);
    this.handleWindowBlur = this.handleWindowBlur.bind(this);
    this.handleWindowResize = this.handleWindowResize.bind(this);
    this.handleEnterFullScreen = this.handleEnterFullScreen.bind(this);
    this.handleLeaveFullScreen = this.handleLeaveFullScreen.bind(this);
    this.handleWindowBeforeunload = this.handleWindowBeforeunload.bind(this);
    this.handleWindowToggleFullScreen = this.handleWindowToggleFullScreen.bind(
      this
    );
    this.handleWindowClose = this.handleWindowClose.bind(this);
    this.handleWindowReload = this.handleWindowReload.bind(this);
    this.handleWindowToggleDevTools = this.handleWindowToggleDevTools.bind(
      this
    );
    this.handleWindowToggleMenuBar = this.handleWindowToggleMenuBar.bind(this);
    this.handleLinkClick = this.handleLinkClick.bind(this);
    this.handleDocumentContextmenu = this.handleDocumentContextmenu.bind(this);
    this.atomEnvironment = atomEnvironment;
    this.applicationDelegate = applicationDelegate;
    this.reloadRequested = false;
    this.subscriptions = new CompositeDisposable();
    this.handleNativeKeybindings();
  }
  initialize(window, document) {
    this.window = window;
    this.document = document;
    this.subscriptions.add(
      this.atomEnvironment.commands.add(this.window, {
        'window:toggle-full-screen': this.handleWindowToggleFullScreen,
        'window:close': this.handleWindowClose,
        'window:reload': this.handleWindowReload,
        'window:toggle-dev-tools': this.handleWindowToggleDevTools
      })
    );
    if (['win32', 'linux'].includes(process.platform)) {
      this.subscriptions.add(
        this.atomEnvironment.commands.add(this.window, {
          'window:toggle-menu-bar': this.handleWindowToggleMenuBar
        })
      );
    }
    this.subscriptions.add(
      this.atomEnvironment.commands.add(this.document, {
        'core:focus-next': this.handleFocusNext,
        'core:focus-previous': this.handleFocusPrevious
      })
    );
    this.addEventListener(
      this.window,
      'beforeunload',
      this.handleWindowBeforeunload
    );
    this.addEventListener(this.window, 'focus', this.handleWindowFocus);
    this.addEventListener(this.window, 'blur', this.handleWindowBlur);
    this.addEventListener(
      this.window,
      'resize',
      debounce(this.handleWindowResize, 500)
    );
    this.addEventListener(this.document, 'keyup', this.handleDocumentKeyEvent);
    this.addEventListener(
      this.document,
      'keydown',
      this.handleDocumentKeyEvent
    );
    this.addEventListener(this.document, 'drop', this.handleDocumentDrop);
    this.addEventListener(
      this.document,
      'dragover',
      this.handleDocumentDragover
    );
    this.addEventListener(
      this.document,
      'contextmenu',
      this.handleDocumentContextmenu
    );
    this.subscriptions.add(
      listen(this.document, 'click', 'a', this.handleLinkClick)
    );
    this.subscriptions.add(
      listen(this.document, 'submit', 'form', this.handleFormSubmit)
    );
    this.subscriptions.add(
      this.applicationDelegate.onDidEnterFullScreen(this.handleEnterFullScreen)
    );
    this.subscriptions.add(
      this.applicationDelegate.onDidLeaveFullScreen(this.handleLeaveFullScreen)
    );
  }
  handleNativeKeybindings() {
    const bindCommandToAction = (command, action) => {
      this.subscriptions.add(
        this.atomEnvironment.commands.add(
          '.native-key-bindings',
          command,
          event =>
            this.applicationDelegate.getCurrentWindow().webContents[action](),
          false
        )
      );
    };
    bindCommandToAction('core:copy', 'copy');
    bindCommandToAction('core:paste', 'paste');
    bindCommandToAction('core:undo', 'undo');
    bindCommandToAction('core:redo', 'redo');
    bindCommandToAction('core:select-all', 'selectAll');
    bindCommandToAction('core:cut', 'cut');
  }
  unsubscribe() {
    this.subscriptions.dispose();
  }
  on(target, eventName, handler) {
    target.on(eventName, handler);
    this.subscriptions.add(
      new Disposable(function() {
        target.removeListener(eventName, handler);
      })
    );
  }
  addEventListener(target, eventName, handler) {
    target.addEventListener(eventName, handler);
    this.subscriptions.add(
      new Disposable(function() {
        target.removeEventListener(eventName, handler);
      })
    );
  }
  handleDocumentKeyEvent(event) {
    this.atomEnvironment.keymaps.handleKeyboardEvent(event);
    event.stopImmediatePropagation();
  }
  handleDrop(event) {
    event.preventDefault();
    event.stopPropagation();
  }
  handleDragover(event) {
    event.preventDefault();
    event.stopPropagation();
    event.dataTransfer.dropEffect = 'none';
  }
  eachTabIndexedElement(callback) {
    for (let element of this.document.querySelectorAll('[tabindex]')) {
      if (element.disabled) {
        continue;
      }
      if (!(element.tabIndex >= 0)) {
        continue;
      }
      callback(element, element.tabIndex);
    }
  }
  handleFocusNext() {
    const focusedTabIndex =
      this.document.activeElement.tabIndex != null
        ? this.document.activeElement.tabIndex
        : -Infinity;
    let nextElement = null;
    let nextTabIndex = Infinity;
    let lowestElement = null;
    let lowestTabIndex = Infinity;
    this.eachTabIndexedElement(function(element, tabIndex) {
      if (tabIndex < lowestTabIndex) {
        lowestTabIndex = tabIndex;
        lowestElement = element;
      }
      if (focusedTabIndex < tabIndex && tabIndex < nextTabIndex) {
        nextTabIndex = tabIndex;
        nextElement = element;
      }
    });
    if (nextElement != null) {
      nextElement.focus();
    } else if (lowestElement != null) {
      lowestElement.focus();
    }
  }
  handleFocusPrevious() {
    const focusedTabIndex =
      this.document.activeElement.tabIndex != null
        ? this.document.activeElement.tabIndex
        : Infinity;
    let previousElement = null;
    let previousTabIndex = -Infinity;
    let highestElement = null;
    let highestTabIndex = -Infinity;
    this.eachTabIndexedElement(function(element, tabIndex) {
      if (tabIndex > highestTabIndex) {
        highestTabIndex = tabIndex;
        highestElement = element;
      }
      if (focusedTabIndex > tabIndex && tabIndex > previousTabIndex) {
        previousTabIndex = tabIndex;
        previousElement = element;
      }
    });
    if (previousElement != null) {
      previousElement.focus();
    } else if (highestElement != null) {
      highestElement.focus();
    }
  }
  handleWindowFocus() {
    this.document.body.classList.remove('is-blurred');
  }
  handleWindowBlur() {
    this.document.body.classList.add('is-blurred');
    this.atomEnvironment.storeWindowDimensions();
  }
  handleWindowResize() {
    this.atomEnvironment.storeWindowDimensions();
  }
  handleEnterFullScreen() {
    this.document.body.classList.add('fullscreen');
  }
  handleLeaveFullScreen() {
    this.document.body.classList.remove('fullscreen');
  }
  handleWindowBeforeunload(event) {
    if (
      !this.reloadRequested &&
      !this.atomEnvironment.inSpecMode() &&
      this.atomEnvironment.getCurrentWindow().isWebViewFocused()
    ) {
      this.atomEnvironment.hide();
    }
    this.reloadRequested = false;
    this.atomEnvironment.storeWindowDimensions();
    this.atomEnvironment.unloadEditorWindow();
    this.atomEnvironment.destroy();
  }
  handleWindowToggleFullScreen() {
    this.atomEnvironment.toggleFullScreen();
  }
  handleWindowClose() {
    this.atomEnvironment.close();
  }
  handleWindowReload() {
    this.reloadRequested = true;
    this.atomEnvironment.reload();
  }
  handleWindowToggleDevTools() {
    this.atomEnvironment.toggleDevTools();
  }
  handleWindowToggleMenuBar() {
    this.atomEnvironment.config.set(
      'core.autoHideMenuBar',
      !this.atomEnvironment.config.get('core.autoHideMenuBar')
    );
    if (this.atomEnvironment.config.get('core.autoHideMenuBar')) {
      const detail =
        'To toggle, press the Alt key or execute the window:toggle-menu-bar command';
      this.atomEnvironment.notifications.addInfo('Menu bar hidden', { detail });
    }
  }
  handleLinkClick(event) {
    event.preventDefault();
    const uri = event.currentTarget && event.currentTarget.getAttribute('href');
    if (uri && uri[0] !== '#') {
      if (/^https?:\/\//.test(uri)) {
        this.applicationDelegate.openExternal(uri);
      } else if (uri.startsWith('atom://')) {
        this.atomEnvironment.uriHandlerRegistry.handleURI(uri);
      }
    }
  }
  handleFormSubmit(event) {
    event.preventDefault();
  }
  handleDocumentContextmenu(event) {
    event.preventDefault();
    this.atomEnvironment.contextMenu.showForEvent(event);
  }
};

================
File: src/window.js
================
window.measure = function(description, fn) {
  let start = Date.now();
  let value = fn();
  let result = Date.now() - start;
  console.log(description, result);
  return value;
};
window.profile = function(description, fn) {
  window.measure(description, function() {
    console.profile(description);
    let value = fn();
    console.profileEnd(description);
    return value;
  });
};

================
File: src/workspace-center.js
================
'use strict';
const TextEditor = require('./text-editor');
const PaneContainer = require('./pane-container');
module.exports = class WorkspaceCenter {
  constructor(params) {
    params.location = 'center';
    this.paneContainer = new PaneContainer(params);
    this.didActivate = params.didActivate;
    this.paneContainer.onDidActivatePane(() => this.didActivate(this));
    this.paneContainer.onDidChangeActivePane(pane => {
      params.didChangeActivePane(this, pane);
    });
    this.paneContainer.onDidChangeActivePaneItem(item => {
      params.didChangeActivePaneItem(this, item);
    });
    this.paneContainer.onDidDestroyPaneItem(item =>
      params.didDestroyPaneItem(item)
    );
  }
  destroy() {
    this.paneContainer.destroy();
  }
  serialize() {
    return this.paneContainer.serialize();
  }
  deserialize(state, deserializerManager) {
    this.paneContainer.deserialize(state, deserializerManager);
  }
  activate() {
    this.getActivePane().activate();
  }
  getLocation() {
    return 'center';
  }
  setDraggingItem() {
  }
  observeTextEditors(callback) {
    for (let textEditor of this.getTextEditors()) {
      callback(textEditor);
    }
    return this.onDidAddTextEditor(({ textEditor }) => callback(textEditor));
  }
  observePaneItems(callback) {
    return this.paneContainer.observePaneItems(callback);
  }
  onDidChangeActivePaneItem(callback) {
    return this.paneContainer.onDidChangeActivePaneItem(callback);
  }
  onDidStopChangingActivePaneItem(callback) {
    return this.paneContainer.onDidStopChangingActivePaneItem(callback);
  }
  observeActivePaneItem(callback) {
    return this.paneContainer.observeActivePaneItem(callback);
  }
  onDidAddPane(callback) {
    return this.paneContainer.onDidAddPane(callback);
  }
  onWillDestroyPane(callback) {
    return this.paneContainer.onWillDestroyPane(callback);
  }
  onDidDestroyPane(callback) {
    return this.paneContainer.onDidDestroyPane(callback);
  }
  observePanes(callback) {
    return this.paneContainer.observePanes(callback);
  }
  onDidChangeActivePane(callback) {
    return this.paneContainer.onDidChangeActivePane(callback);
  }
  observeActivePane(callback) {
    return this.paneContainer.observeActivePane(callback);
  }
  onDidAddPaneItem(callback) {
    return this.paneContainer.onDidAddPaneItem(callback);
  }
  onWillDestroyPaneItem(callback) {
    return this.paneContainer.onWillDestroyPaneItem(callback);
  }
  onDidDestroyPaneItem(callback) {
    return this.paneContainer.onDidDestroyPaneItem(callback);
  }
  onDidAddTextEditor(callback) {
    return this.onDidAddPaneItem(({ item, pane, index }) => {
      if (item instanceof TextEditor) {
        callback({ textEditor: item, pane, index });
      }
    });
  }
  getPaneItems() {
    return this.paneContainer.getPaneItems();
  }
  getActivePaneItem() {
    return this.paneContainer.getActivePaneItem();
  }
  getTextEditors() {
    return this.getPaneItems().filter(item => item instanceof TextEditor);
  }
  getActiveTextEditor() {
    const activeItem = this.getActivePaneItem();
    if (activeItem instanceof TextEditor) {
      return activeItem;
    }
  }
  saveAll() {
    this.paneContainer.saveAll();
  }
  confirmClose(options) {
    return this.paneContainer.confirmClose(options);
  }
  getPanes() {
    return this.paneContainer.getPanes();
  }
  getActivePane() {
    return this.paneContainer.getActivePane();
  }
  activateNextPane() {
    return this.paneContainer.activateNextPane();
  }
  activatePreviousPane() {
    return this.paneContainer.activatePreviousPane();
  }
  paneForURI(uri) {
    return this.paneContainer.paneForURI(uri);
  }
  paneForItem(item) {
    return this.paneContainer.paneForItem(item);
  }
  destroyActivePane() {
    const activePane = this.getActivePane();
    if (activePane != null) {
      activePane.destroy();
    }
  }
};

================
File: src/workspace-element.js
================
'use strict';
const { ipcRenderer } = require('electron');
const path = require('path');
const fs = require('fs-plus');
const { CompositeDisposable, Disposable } = require('event-kit');
const scrollbarStyle = require('scrollbar-style');
const _ = require('underscore-plus');
class WorkspaceElement extends HTMLElement {
  connectedCallback() {
    this.focus();
    this.htmlElement = document.querySelector('html');
    this.htmlElement.addEventListener('mouseleave', this.handleCenterLeave);
  }
  disconnectedCallback() {
    this.subscriptions.dispose();
    this.htmlElement.removeEventListener('mouseleave', this.handleCenterLeave);
  }
  initializeContent() {
    this.classList.add('workspace');
    this.setAttribute('tabindex', -1);
    this.verticalAxis = document.createElement('atom-workspace-axis');
    this.verticalAxis.classList.add('vertical');
    this.horizontalAxis = document.createElement('atom-workspace-axis');
    this.horizontalAxis.classList.add('horizontal');
    this.horizontalAxis.appendChild(this.verticalAxis);
    this.appendChild(this.horizontalAxis);
  }
  observeScrollbarStyle() {
    this.subscriptions.add(
      scrollbarStyle.observePreferredScrollbarStyle(style => {
        switch (style) {
          case 'legacy':
            this.classList.remove('scrollbars-visible-when-scrolling');
            this.classList.add('scrollbars-visible-always');
            break;
          case 'overlay':
            this.classList.remove('scrollbars-visible-always');
            this.classList.add('scrollbars-visible-when-scrolling');
            break;
        }
      })
    );
  }
  observeTextEditorFontConfig() {
    this.updateGlobalTextEditorStyleSheet();
    this.subscriptions.add(
      this.config.onDidChange(
        'editor.fontSize',
        this.updateGlobalTextEditorStyleSheet.bind(this)
      )
    );
    this.subscriptions.add(
      this.config.onDidChange(
        'editor.fontFamily',
        this.updateGlobalTextEditorStyleSheet.bind(this)
      )
    );
    this.subscriptions.add(
      this.config.onDidChange(
        'editor.lineHeight',
        this.updateGlobalTextEditorStyleSheet.bind(this)
      )
    );
  }
  updateGlobalTextEditorStyleSheet() {
    const styleSheetSource = `atom-workspace {
  --editor-font-size: ${this.config.get('editor.fontSize')}px;
  --editor-font-family: ${this.config.get('editor.fontFamily')};
  --editor-line-height: ${this.config.get('editor.lineHeight')};
}`;
    this.styleManager.addStyleSheet(styleSheetSource, {
      sourcePath: 'global-text-editor-styles',
      priority: -1
    });
  }
  initialize(model, { config, project, styleManager, viewRegistry }) {
    this.handleCenterEnter = this.handleCenterEnter.bind(this);
    this.handleCenterLeave = this.handleCenterLeave.bind(this);
    this.handleEdgesMouseMove = _.throttle(
      this.handleEdgesMouseMove.bind(this),
      100
    );
    this.handleDockDragEnd = this.handleDockDragEnd.bind(this);
    this.handleDragStart = this.handleDragStart.bind(this);
    this.handleDragEnd = this.handleDragEnd.bind(this);
    this.handleDrop = this.handleDrop.bind(this);
    this.model = model;
    this.viewRegistry = viewRegistry;
    this.project = project;
    this.config = config;
    this.styleManager = styleManager;
    if (this.viewRegistry == null) {
      throw new Error(
        'Must pass a viewRegistry parameter when initializing WorkspaceElements'
      );
    }
    if (this.project == null) {
      throw new Error(
        'Must pass a project parameter when initializing WorkspaceElements'
      );
    }
    if (this.config == null) {
      throw new Error(
        'Must pass a config parameter when initializing WorkspaceElements'
      );
    }
    if (this.styleManager == null) {
      throw new Error(
        'Must pass a styleManager parameter when initializing WorkspaceElements'
      );
    }
    this.subscriptions = new CompositeDisposable(
      new Disposable(() => {
        this.paneContainer.removeEventListener(
          'mouseenter',
          this.handleCenterEnter
        );
        this.paneContainer.removeEventListener(
          'mouseleave',
          this.handleCenterLeave
        );
        window.removeEventListener('mousemove', this.handleEdgesMouseMove);
        window.removeEventListener('dragend', this.handleDockDragEnd);
        window.removeEventListener('dragstart', this.handleDragStart);
        window.removeEventListener('dragend', this.handleDragEnd, true);
        window.removeEventListener('drop', this.handleDrop, true);
      }),
      ...[
        this.model.getLeftDock(),
        this.model.getRightDock(),
        this.model.getBottomDock()
      ].map(dock =>
        dock.onDidChangeHovered(hovered => {
          if (hovered) this.hoveredDock = dock;
          else if (dock === this.hoveredDock) this.hoveredDock = null;
          this.checkCleanupDockHoverEvents();
        })
      )
    );
    this.initializeContent();
    this.observeScrollbarStyle();
    this.observeTextEditorFontConfig();
    this.paneContainer = this.model.getCenter().paneContainer.getElement();
    this.verticalAxis.appendChild(this.paneContainer);
    this.addEventListener('focus', this.handleFocus.bind(this));
    this.addEventListener('mousewheel', this.handleMousewheel.bind(this), {
      capture: true
    });
    window.addEventListener('dragstart', this.handleDragStart);
    window.addEventListener('mousemove', this.handleEdgesMouseMove);
    this.panelContainers = {
      top: this.model.panelContainers.top.getElement(),
      left: this.model.panelContainers.left.getElement(),
      right: this.model.panelContainers.right.getElement(),
      bottom: this.model.panelContainers.bottom.getElement(),
      header: this.model.panelContainers.header.getElement(),
      footer: this.model.panelContainers.footer.getElement(),
      modal: this.model.panelContainers.modal.getElement()
    };
    this.horizontalAxis.insertBefore(
      this.panelContainers.left,
      this.verticalAxis
    );
    this.horizontalAxis.appendChild(this.panelContainers.right);
    this.verticalAxis.insertBefore(
      this.panelContainers.top,
      this.paneContainer
    );
    this.verticalAxis.appendChild(this.panelContainers.bottom);
    this.insertBefore(this.panelContainers.header, this.horizontalAxis);
    this.appendChild(this.panelContainers.footer);
    this.appendChild(this.panelContainers.modal);
    this.paneContainer.addEventListener('mouseenter', this.handleCenterEnter);
    this.paneContainer.addEventListener('mouseleave', this.handleCenterLeave);
    return this;
  }
  destroy() {
    this.subscriptions.dispose();
  }
  getModel() {
    return this.model;
  }
  handleDragStart(event) {
    if (!isTab(event.target)) return;
    const { item } = event.target;
    if (!item) return;
    this.model.setDraggingItem(item);
    window.addEventListener('dragend', this.handleDragEnd, { capture: true });
    window.addEventListener('drop', this.handleDrop, { capture: true });
  }
  handleDragEnd(event) {
    this.dragEnded();
  }
  handleDrop(event) {
    this.dragEnded();
  }
  dragEnded() {
    this.model.setDraggingItem(null);
    window.removeEventListener('dragend', this.handleDragEnd, true);
    window.removeEventListener('drop', this.handleDrop, true);
  }
  handleCenterEnter(event) {
    this.cursorInCenter = true;
    this.checkCleanupDockHoverEvents();
  }
  handleCenterLeave(event) {
    this.cursorInCenter = false;
    this.updateHoveredDock({ x: event.pageX, y: event.pageY });
    window.addEventListener('dragend', this.handleDockDragEnd);
  }
  handleEdgesMouseMove(event) {
    this.updateHoveredDock({ x: event.pageX, y: event.pageY });
  }
  handleDockDragEnd(event) {
    this.updateHoveredDock({ x: event.pageX, y: event.pageY });
  }
  updateHoveredDock(mousePosition) {
    if (
      this.hoveredDock &&
      this.hoveredDock.pointWithinHoverArea(mousePosition, true)
    )
      return;
    const docks = [
      this.model.getLeftDock(),
      this.model.getRightDock(),
      this.model.getBottomDock()
    ];
    const nextHoveredDock = docks.find(
      dock =>
        dock !== this.hoveredDock && dock.pointWithinHoverArea(mousePosition)
    );
    docks.forEach(dock => {
      dock.setHovered(dock === nextHoveredDock);
    });
  }
  checkCleanupDockHoverEvents() {
    if (this.cursorInCenter && !this.hoveredDock) {
      window.removeEventListener('dragend', this.handleDockDragEnd);
    }
  }
  handleMousewheel(event) {
    if (
      event.ctrlKey &&
      this.config.get('editor.zoomFontWhenCtrlScrolling') &&
      event.target.closest('atom-text-editor') != null
    ) {
      if (event.wheelDeltaY > 0) {
        this.model.increaseFontSize();
      } else if (event.wheelDeltaY < 0) {
        this.model.decreaseFontSize();
      }
      event.preventDefault();
      event.stopPropagation();
    }
  }
  handleFocus(event) {
    this.model.getActivePane().activate();
  }
  focusPaneViewAbove() {
    this.focusPaneViewInDirection('above');
  }
  focusPaneViewBelow() {
    this.focusPaneViewInDirection('below');
  }
  focusPaneViewOnLeft() {
    this.focusPaneViewInDirection('left');
  }
  focusPaneViewOnRight() {
    this.focusPaneViewInDirection('right');
  }
  focusPaneViewInDirection(direction, pane) {
    const activePane = this.model.getActivePane();
    const paneToFocus = this.nearestVisiblePaneInDirection(
      direction,
      activePane
    );
    paneToFocus && paneToFocus.focus();
  }
  moveActiveItemToPaneAbove(params) {
    this.moveActiveItemToNearestPaneInDirection('above', params);
  }
  moveActiveItemToPaneBelow(params) {
    this.moveActiveItemToNearestPaneInDirection('below', params);
  }
  moveActiveItemToPaneOnLeft(params) {
    this.moveActiveItemToNearestPaneInDirection('left', params);
  }
  moveActiveItemToPaneOnRight(params) {
    this.moveActiveItemToNearestPaneInDirection('right', params);
  }
  moveActiveItemToNearestPaneInDirection(direction, params) {
    const activePane = this.model.getActivePane();
    const nearestPaneView = this.nearestVisiblePaneInDirection(
      direction,
      activePane
    );
    if (nearestPaneView == null) {
      return;
    }
    if (params && params.keepOriginal) {
      activePane
        .getContainer()
        .copyActiveItemToPane(nearestPaneView.getModel());
    } else {
      activePane
        .getContainer()
        .moveActiveItemToPane(nearestPaneView.getModel());
    }
    nearestPaneView.focus();
  }
  nearestVisiblePaneInDirection(direction, pane) {
    const distance = function(pointA, pointB) {
      const x = pointB.x - pointA.x;
      const y = pointB.y - pointA.y;
      return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
    };
    const paneView = pane.getElement();
    const box = this.boundingBoxForPaneView(paneView);
    const paneViews = atom.workspace
      .getVisiblePanes()
      .map(otherPane => otherPane.getElement())
      .filter(otherPaneView => {
        const otherBox = this.boundingBoxForPaneView(otherPaneView);
        switch (direction) {
          case 'left':
            return otherBox.right.x <= box.left.x;
          case 'right':
            return otherBox.left.x >= box.right.x;
          case 'above':
            return otherBox.bottom.y <= box.top.y;
          case 'below':
            return otherBox.top.y >= box.bottom.y;
        }
      })
      .sort((paneViewA, paneViewB) => {
        const boxA = this.boundingBoxForPaneView(paneViewA);
        const boxB = this.boundingBoxForPaneView(paneViewB);
        switch (direction) {
          case 'left':
            return (
              distance(box.left, boxA.right) - distance(box.left, boxB.right)
            );
          case 'right':
            return (
              distance(box.right, boxA.left) - distance(box.right, boxB.left)
            );
          case 'above':
            return (
              distance(box.top, boxA.bottom) - distance(box.top, boxB.bottom)
            );
          case 'below':
            return (
              distance(box.bottom, boxA.top) - distance(box.bottom, boxB.top)
            );
        }
      });
    return paneViews[0];
  }
  boundingBoxForPaneView(paneView) {
    const boundingBox = paneView.getBoundingClientRect();
    return {
      left: { x: boundingBox.left, y: boundingBox.top },
      right: { x: boundingBox.right, y: boundingBox.top },
      top: { x: boundingBox.left, y: boundingBox.top },
      bottom: { x: boundingBox.left, y: boundingBox.bottom }
    };
  }
  runPackageSpecs(options = {}) {
    const activePaneItem = this.model.getActivePaneItem();
    const activePath =
      activePaneItem && typeof activePaneItem.getPath === 'function'
        ? activePaneItem.getPath()
        : null;
    let projectPath;
    if (activePath != null) {
      [projectPath] = this.project.relativizePath(activePath);
    } else {
      [projectPath] = this.project.getPaths();
    }
    if (projectPath) {
      let specPath = path.join(projectPath, 'spec');
      const testPath = path.join(projectPath, 'test');
      if (!fs.existsSync(specPath) && fs.existsSync(testPath)) {
        specPath = testPath;
      }
      ipcRenderer.send('run-package-specs', specPath, options);
    }
  }
}
function isTab(element) {
  let el = element;
  while (el != null) {
    if (el.getAttribute && el.getAttribute('is') === 'tabs-tab') return true;
    el = el.parentElement;
  }
  return false;
}
window.customElements.define('atom-workspace', WorkspaceElement);
function createWorkspaceElement() {
  return document.createElement('atom-workspace');
}
module.exports = {
  createWorkspaceElement
};

================
File: src/workspace.js
================
const _ = require('underscore-plus');
const url = require('url');
const path = require('path');
const { Emitter, Disposable, CompositeDisposable } = require('event-kit');
const fs = require('fs-plus');
const { Directory } = require('pathwatcher');
const Grim = require('grim');
const DefaultDirectorySearcher = require('./default-directory-searcher');
const RipgrepDirectorySearcher = require('./ripgrep-directory-searcher');
const Dock = require('./dock');
const Model = require('./model');
const StateStore = require('./state-store');
const TextEditor = require('./text-editor');
const Panel = require('./panel');
const PanelContainer = require('./panel-container');
const Task = require('./task');
const WorkspaceCenter = require('./workspace-center');
const { createWorkspaceElement } = require('./workspace-element');
const STOPPED_CHANGING_ACTIVE_PANE_ITEM_DELAY = 100;
const ALL_LOCATIONS = ['center', 'left', 'right', 'bottom'];
module.exports = class Workspace extends Model {
  constructor(params) {
    super(...arguments);
    this.disposables = new CompositeDisposable();
    this.updateWindowTitle = this.updateWindowTitle.bind(this);
    this.updateDocumentEdited = this.updateDocumentEdited.bind(this);
    this.didDestroyPaneItem = this.didDestroyPaneItem.bind(this);
    this.didChangeActivePaneOnPaneContainer = this.didChangeActivePaneOnPaneContainer.bind(
      this
    );
    this.didChangeActivePaneItemOnPaneContainer = this.didChangeActivePaneItemOnPaneContainer.bind(
      this
    );
    this.didActivatePaneContainer = this.didActivatePaneContainer.bind(this);
    this.enablePersistence = params.enablePersistence;
    this.packageManager = params.packageManager;
    this.config = params.config;
    this.project = params.project;
    this.notificationManager = params.notificationManager;
    this.viewRegistry = params.viewRegistry;
    this.grammarRegistry = params.grammarRegistry;
    this.applicationDelegate = params.applicationDelegate;
    this.assert = params.assert;
    this.deserializerManager = params.deserializerManager;
    this.textEditorRegistry = params.textEditorRegistry;
    this.styleManager = params.styleManager;
    this.draggingItem = false;
    this.itemLocationStore = new StateStore('AtomPreviousItemLocations', 1);
    this.emitter = new Emitter();
    this.openers = [];
    this.destroyedItemURIs = [];
    this.stoppedChangingActivePaneItemTimeout = null;
    this.scandalDirectorySearcher = new DefaultDirectorySearcher();
    this.ripgrepDirectorySearcher = new RipgrepDirectorySearcher();
    this.consumeServices(this.packageManager);
    this.paneContainers = {
      center: this.createCenter(),
      left: this.createDock('left'),
      right: this.createDock('right'),
      bottom: this.createDock('bottom')
    };
    this.activePaneContainer = this.paneContainers.center;
    this.hasActiveTextEditor = false;
    this.panelContainers = {
      top: new PanelContainer({
        viewRegistry: this.viewRegistry,
        location: 'top'
      }),
      left: new PanelContainer({
        viewRegistry: this.viewRegistry,
        location: 'left',
        dock: this.paneContainers.left
      }),
      right: new PanelContainer({
        viewRegistry: this.viewRegistry,
        location: 'right',
        dock: this.paneContainers.right
      }),
      bottom: new PanelContainer({
        viewRegistry: this.viewRegistry,
        location: 'bottom',
        dock: this.paneContainers.bottom
      }),
      header: new PanelContainer({
        viewRegistry: this.viewRegistry,
        location: 'header'
      }),
      footer: new PanelContainer({
        viewRegistry: this.viewRegistry,
        location: 'footer'
      }),
      modal: new PanelContainer({
        viewRegistry: this.viewRegistry,
        location: 'modal'
      })
    };
    this.incoming = new Map();
  }
  get paneContainer() {
    Grim.deprecate(
      '`atom.workspace.paneContainer` has always been private, but it is now gone. Please use `atom.workspace.getCenter()` instead and consult the workspace API docs for public methods.'
    );
    return this.paneContainers.center.paneContainer;
  }
  getElement() {
    if (!this.element) {
      this.element = createWorkspaceElement().initialize(this, {
        config: this.config,
        project: this.project,
        viewRegistry: this.viewRegistry,
        styleManager: this.styleManager
      });
    }
    return this.element;
  }
  createCenter() {
    return new WorkspaceCenter({
      config: this.config,
      applicationDelegate: this.applicationDelegate,
      notificationManager: this.notificationManager,
      deserializerManager: this.deserializerManager,
      viewRegistry: this.viewRegistry,
      didActivate: this.didActivatePaneContainer,
      didChangeActivePane: this.didChangeActivePaneOnPaneContainer,
      didChangeActivePaneItem: this.didChangeActivePaneItemOnPaneContainer,
      didDestroyPaneItem: this.didDestroyPaneItem
    });
  }
  createDock(location) {
    return new Dock({
      location,
      config: this.config,
      applicationDelegate: this.applicationDelegate,
      deserializerManager: this.deserializerManager,
      notificationManager: this.notificationManager,
      viewRegistry: this.viewRegistry,
      didActivate: this.didActivatePaneContainer,
      didChangeActivePane: this.didChangeActivePaneOnPaneContainer,
      didChangeActivePaneItem: this.didChangeActivePaneItemOnPaneContainer,
      didDestroyPaneItem: this.didDestroyPaneItem
    });
  }
  reset(packageManager) {
    this.packageManager = packageManager;
    this.emitter.dispose();
    this.emitter = new Emitter();
    this.paneContainers.center.destroy();
    this.paneContainers.left.destroy();
    this.paneContainers.right.destroy();
    this.paneContainers.bottom.destroy();
    _.values(this.panelContainers).forEach(panelContainer => {
      panelContainer.destroy();
    });
    this.paneContainers = {
      center: this.createCenter(),
      left: this.createDock('left'),
      right: this.createDock('right'),
      bottom: this.createDock('bottom')
    };
    this.activePaneContainer = this.paneContainers.center;
    this.hasActiveTextEditor = false;
    this.panelContainers = {
      top: new PanelContainer({
        viewRegistry: this.viewRegistry,
        location: 'top'
      }),
      left: new PanelContainer({
        viewRegistry: this.viewRegistry,
        location: 'left',
        dock: this.paneContainers.left
      }),
      right: new PanelContainer({
        viewRegistry: this.viewRegistry,
        location: 'right',
        dock: this.paneContainers.right
      }),
      bottom: new PanelContainer({
        viewRegistry: this.viewRegistry,
        location: 'bottom',
        dock: this.paneContainers.bottom
      }),
      header: new PanelContainer({
        viewRegistry: this.viewRegistry,
        location: 'header'
      }),
      footer: new PanelContainer({
        viewRegistry: this.viewRegistry,
        location: 'footer'
      }),
      modal: new PanelContainer({
        viewRegistry: this.viewRegistry,
        location: 'modal'
      })
    };
    this.openers = [];
    this.destroyedItemURIs = [];
    if (this.element) {
      this.element.destroy();
      this.element = null;
    }
    this.consumeServices(this.packageManager);
  }
  initialize() {
    this.originalFontSize = this.config.get('defaultFontSize');
    this.project.onDidChangePaths(this.updateWindowTitle);
    this.subscribeToAddedItems();
    this.subscribeToMovedItems();
    this.subscribeToDockToggling();
    this.disposables.add(
      this.config.onDidChange('core.addCurrentTabToWindowTitle', () => {
        this.updateWindowTitle();
      })
    );
  }
  consumeServices({ serviceHub }) {
    this.directorySearchers = [];
    serviceHub.consume('atom.directory-searcher', '^0.1.0', provider =>
      this.directorySearchers.unshift(provider)
    );
  }
  serialize() {
    return {
      deserializer: 'Workspace',
      packagesWithActiveGrammars: this.getPackageNamesWithActiveGrammars(),
      destroyedItemURIs: this.destroyedItemURIs.slice(),
      paneContainer: { version: 2 },
      paneContainers: {
        center: this.paneContainers.center.serialize(),
        left: this.paneContainers.left.serialize(),
        right: this.paneContainers.right.serialize(),
        bottom: this.paneContainers.bottom.serialize()
      }
    };
  }
  deserialize(state, deserializerManager) {
    const packagesWithActiveGrammars =
      state.packagesWithActiveGrammars != null
        ? state.packagesWithActiveGrammars
        : [];
    for (let packageName of packagesWithActiveGrammars) {
      const pkg = this.packageManager.getLoadedPackage(packageName);
      if (pkg != null) {
        pkg.loadGrammarsSync();
      }
    }
    if (state.destroyedItemURIs != null) {
      this.destroyedItemURIs = state.destroyedItemURIs;
    }
    if (state.paneContainers) {
      this.paneContainers.center.deserialize(
        state.paneContainers.center,
        deserializerManager
      );
      this.paneContainers.left.deserialize(
        state.paneContainers.left,
        deserializerManager
      );
      this.paneContainers.right.deserialize(
        state.paneContainers.right,
        deserializerManager
      );
      this.paneContainers.bottom.deserialize(
        state.paneContainers.bottom,
        deserializerManager
      );
    } else if (state.paneContainer) {
      this.paneContainers.center.deserialize(
        state.paneContainer,
        deserializerManager
      );
    }
    this.hasActiveTextEditor = this.getActiveTextEditor() != null;
    this.updateWindowTitle();
  }
  getPackageNamesWithActiveGrammars() {
    const packageNames = [];
    const addGrammar = ({ includedGrammarScopes, packageName } = {}) => {
      if (!packageName) {
        return;
      }
      if (packageNames.indexOf(packageName) !== -1) {
        return;
      }
      packageNames.push(packageName);
      for (let scopeName of includedGrammarScopes != null
        ? includedGrammarScopes
        : []) {
        addGrammar(this.grammarRegistry.grammarForScopeName(scopeName));
      }
    };
    const editors = this.getTextEditors();
    for (let editor of editors) {
      addGrammar(editor.getGrammar());
    }
    if (editors.length > 0) {
      for (let grammar of this.grammarRegistry.getGrammars()) {
        if (grammar.injectionSelector) {
          addGrammar(grammar);
        }
      }
    }
    return _.uniq(packageNames);
  }
  didActivatePaneContainer(paneContainer) {
    if (paneContainer !== this.getActivePaneContainer()) {
      this.activePaneContainer = paneContainer;
      this.didChangeActivePaneItem(
        this.activePaneContainer.getActivePaneItem()
      );
      this.emitter.emit(
        'did-change-active-pane-container',
        this.activePaneContainer
      );
      this.emitter.emit(
        'did-change-active-pane',
        this.activePaneContainer.getActivePane()
      );
      this.emitter.emit(
        'did-change-active-pane-item',
        this.activePaneContainer.getActivePaneItem()
      );
    }
  }
  didChangeActivePaneOnPaneContainer(paneContainer, pane) {
    if (paneContainer === this.getActivePaneContainer()) {
      this.emitter.emit('did-change-active-pane', pane);
    }
  }
  didChangeActivePaneItemOnPaneContainer(paneContainer, item) {
    if (paneContainer === this.getActivePaneContainer()) {
      this.didChangeActivePaneItem(item);
      this.emitter.emit('did-change-active-pane-item', item);
    }
    if (paneContainer === this.getCenter()) {
      const hadActiveTextEditor = this.hasActiveTextEditor;
      this.hasActiveTextEditor = item instanceof TextEditor;
      if (this.hasActiveTextEditor || hadActiveTextEditor) {
        const itemValue = this.hasActiveTextEditor ? item : undefined;
        this.emitter.emit('did-change-active-text-editor', itemValue);
      }
    }
  }
  didChangeActivePaneItem(item) {
    this.updateWindowTitle();
    this.updateDocumentEdited();
    if (this.activeItemSubscriptions) this.activeItemSubscriptions.dispose();
    this.activeItemSubscriptions = new CompositeDisposable();
    let modifiedSubscription, titleSubscription;
    if (item != null && typeof item.onDidChangeTitle === 'function') {
      titleSubscription = item.onDidChangeTitle(this.updateWindowTitle);
    } else if (item != null && typeof item.on === 'function') {
      titleSubscription = item.on('title-changed', this.updateWindowTitle);
      if (
        titleSubscription == null ||
        typeof titleSubscription.dispose !== 'function'
      ) {
        titleSubscription = new Disposable(() => {
          item.off('title-changed', this.updateWindowTitle);
        });
      }
    }
    if (item != null && typeof item.onDidChangeModified === 'function') {
      modifiedSubscription = item.onDidChangeModified(
        this.updateDocumentEdited
      );
    } else if (item != null && typeof item.on === 'function') {
      modifiedSubscription = item.on(
        'modified-status-changed',
        this.updateDocumentEdited
      );
      if (
        modifiedSubscription == null ||
        typeof modifiedSubscription.dispose !== 'function'
      ) {
        modifiedSubscription = new Disposable(() => {
          item.off('modified-status-changed', this.updateDocumentEdited);
        });
      }
    }
    if (titleSubscription != null) {
      this.activeItemSubscriptions.add(titleSubscription);
    }
    if (modifiedSubscription != null) {
      this.activeItemSubscriptions.add(modifiedSubscription);
    }
    this.cancelStoppedChangingActivePaneItemTimeout();
    this.stoppedChangingActivePaneItemTimeout = setTimeout(() => {
      this.stoppedChangingActivePaneItemTimeout = null;
      this.emitter.emit('did-stop-changing-active-pane-item', item);
    }, STOPPED_CHANGING_ACTIVE_PANE_ITEM_DELAY);
  }
  cancelStoppedChangingActivePaneItemTimeout() {
    if (this.stoppedChangingActivePaneItemTimeout != null) {
      clearTimeout(this.stoppedChangingActivePaneItemTimeout);
    }
  }
  setDraggingItem(draggingItem) {
    _.values(this.paneContainers).forEach(dock => {
      dock.setDraggingItem(draggingItem);
    });
  }
  subscribeToAddedItems() {
    this.onDidAddPaneItem(({ item, pane, index }) => {
      if (item instanceof TextEditor) {
        const subscriptions = new CompositeDisposable(
          this.textEditorRegistry.add(item),
          this.textEditorRegistry.maintainConfig(item)
        );
        if (!this.project.findBufferForId(item.buffer.id)) {
          this.project.addBuffer(item.buffer);
        }
        item.onDidDestroy(() => {
          subscriptions.dispose();
        });
        this.emitter.emit('did-add-text-editor', {
          textEditor: item,
          pane,
          index
        });
        if (!item.isDestroyed()) {
          subscriptions.add(
            item.observeGrammar(this.handleGrammarUsed.bind(this))
          );
        }
      }
    });
  }
  subscribeToDockToggling() {
    const docks = [
      this.getLeftDock(),
      this.getRightDock(),
      this.getBottomDock()
    ];
    docks.forEach(dock => {
      dock.onDidChangeVisible(visible => {
        if (visible) return;
        const { activeElement } = document;
        const dockElement = dock.getElement();
        if (
          dockElement === activeElement ||
          dockElement.contains(activeElement)
        ) {
          this.getCenter().activate();
        }
      });
    });
  }
  subscribeToMovedItems() {
    for (const paneContainer of this.getPaneContainers()) {
      paneContainer.observePanes(pane => {
        pane.onDidAddItem(({ item }) => {
          if (typeof item.getURI === 'function' && this.enablePersistence) {
            const uri = item.getURI();
            if (uri) {
              const location = paneContainer.getLocation();
              let defaultLocation;
              if (typeof item.getDefaultLocation === 'function') {
                defaultLocation = item.getDefaultLocation();
              }
              defaultLocation = defaultLocation || 'center';
              if (location === defaultLocation) {
                this.itemLocationStore.delete(item.getURI());
              } else {
                this.itemLocationStore.save(item.getURI(), location);
              }
            }
          }
        });
      });
    }
  }
  updateWindowTitle() {
    let itemPath, itemTitle, projectPath, representedPath;
    const appName = atom.getAppName();
    const left = this.project.getPaths();
    const projectPaths = left != null ? left : [];
    const item = this.getActivePaneItem();
    if (item) {
      itemPath =
        typeof item.getPath === 'function' ? item.getPath() : undefined;
      const longTitle =
        typeof item.getLongTitle === 'function'
          ? item.getLongTitle()
          : undefined;
      itemTitle =
        longTitle == null
          ? typeof item.getTitle === 'function'
            ? item.getTitle()
            : undefined
          : longTitle;
      projectPath = _.find(
        projectPaths,
        projectPath =>
          itemPath === projectPath ||
          (itemPath != null
            ? itemPath.startsWith(projectPath + path.sep)
            : undefined)
      );
    }
    if (itemTitle == null) {
      itemTitle = 'untitled';
    }
    if (projectPath == null) {
      projectPath = itemPath ? path.dirname(itemPath) : projectPaths[0];
    }
    if (projectPath != null) {
      projectPath = fs.tildify(projectPath);
    }
    const titleParts = [];
    if (item != null && projectPath != null && this.config.get('core.addCurrentTabToWindowTitle')) {
      titleParts.push(itemTitle, projectPath);
      representedPath = itemPath != null ? itemPath : projectPath;
    } else if (item != null && projectPath != null && !this.config.get('core.addCurrentTabToWindowTitle')) {
      titleParts.push(projectPath);
      representedPath = itemPath != null ? itemPath : projectPath;
    } else if (projectPath != null) {
      titleParts.push(projectPath);
      representedPath = projectPath;
    } else {
      titleParts.push(itemTitle);
      representedPath = '';
    }
    if (process.platform !== 'darwin') {
      titleParts.push(appName);
    }
    document.title = titleParts.join(' \u2014 ');
    this.applicationDelegate.setRepresentedFilename(representedPath);
    this.emitter.emit('did-change-window-title');
  }
  updateDocumentEdited() {
    const activePaneItem = this.getActivePaneItem();
    const modified =
      activePaneItem != null && typeof activePaneItem.isModified === 'function'
        ? activePaneItem.isModified() || false
        : false;
    this.applicationDelegate.setWindowDocumentEdited(modified);
  }
  onDidChangeActivePaneContainer(callback) {
    return this.emitter.on('did-change-active-pane-container', callback);
  }
  observeTextEditors(callback) {
    for (let textEditor of this.getTextEditors()) {
      callback(textEditor);
    }
    return this.onDidAddTextEditor(({ textEditor }) => callback(textEditor));
  }
  observePaneItems(callback) {
    return new CompositeDisposable(
      ...this.getPaneContainers().map(container =>
        container.observePaneItems(callback)
      )
    );
  }
  onDidChangeActivePaneItem(callback) {
    return this.emitter.on('did-change-active-pane-item', callback);
  }
  onDidStopChangingActivePaneItem(callback) {
    return this.emitter.on('did-stop-changing-active-pane-item', callback);
  }
  onDidChangeActiveTextEditor(callback) {
    return this.emitter.on('did-change-active-text-editor', callback);
  }
  observeActivePaneItem(callback) {
    callback(this.getActivePaneItem());
    return this.onDidChangeActivePaneItem(callback);
  }
  observeActiveTextEditor(callback) {
    callback(this.getActiveTextEditor());
    return this.onDidChangeActiveTextEditor(callback);
  }
  onDidOpen(callback) {
    return this.emitter.on('did-open', callback);
  }
  onDidAddPane(callback) {
    return new CompositeDisposable(
      ...this.getPaneContainers().map(container =>
        container.onDidAddPane(callback)
      )
    );
  }
  onWillDestroyPane(callback) {
    return new CompositeDisposable(
      ...this.getPaneContainers().map(container =>
        container.onWillDestroyPane(callback)
      )
    );
  }
  onDidDestroyPane(callback) {
    return new CompositeDisposable(
      ...this.getPaneContainers().map(container =>
        container.onDidDestroyPane(callback)
      )
    );
  }
  observePanes(callback) {
    return new CompositeDisposable(
      ...this.getPaneContainers().map(container =>
        container.observePanes(callback)
      )
    );
  }
  onDidChangeActivePane(callback) {
    return this.emitter.on('did-change-active-pane', callback);
  }
  observeActivePane(callback) {
    callback(this.getActivePane());
    return this.onDidChangeActivePane(callback);
  }
  onDidAddPaneItem(callback) {
    return new CompositeDisposable(
      ...this.getPaneContainers().map(container =>
        container.onDidAddPaneItem(callback)
      )
    );
  }
  onWillDestroyPaneItem(callback) {
    return new CompositeDisposable(
      ...this.getPaneContainers().map(container =>
        container.onWillDestroyPaneItem(callback)
      )
    );
  }
  onDidDestroyPaneItem(callback) {
    return new CompositeDisposable(
      ...this.getPaneContainers().map(container =>
        container.onDidDestroyPaneItem(callback)
      )
    );
  }
  onDidAddTextEditor(callback) {
    return this.emitter.on('did-add-text-editor', callback);
  }
  onDidChangeWindowTitle(callback) {
    return this.emitter.on('did-change-window-title', callback);
  }
  async open(itemOrURI, options = {}) {
    let uri, item;
    if (typeof itemOrURI === 'string') {
      uri = this.project.resolvePath(itemOrURI);
    } else if (itemOrURI) {
      item = itemOrURI;
      if (typeof item.getURI === 'function') uri = item.getURI();
    }
    let resolveItem = () => {};
    if (uri) {
      const incomingItem = this.incoming.get(uri);
      if (!incomingItem) {
        this.incoming.set(
          uri,
          new Promise(resolve => {
            resolveItem = resolve;
          })
        );
      } else {
        await incomingItem;
      }
    }
    try {
      if (!atom.config.get('core.allowPendingPaneItems')) {
        options.pending = false;
      }
      if (uri && (!url.parse(uri).protocol || process.platform === 'win32')) {
        this.applicationDelegate.addRecentDocument(uri);
      }
      let pane, itemExistsInWorkspace;
      if (item || uri) {
        if (options.pane) {
          pane = options.pane;
        } else if (options.searchAllPanes) {
          pane = item ? this.paneForItem(item) : this.paneForURI(uri);
        } else {
          let container;
          if (uri) container = this.paneContainerForURI(uri);
          if (!container) container = this.getActivePaneContainer();
          pane = container.getActivePane();
          switch (options.split) {
            case 'left':
              pane = pane.findLeftmostSibling();
              break;
            case 'right':
              pane = pane.findRightmostSibling();
              break;
            case 'up':
              pane = pane.findTopmostSibling();
              break;
            case 'down':
              pane = pane.findBottommostSibling();
              break;
          }
        }
        if (pane) {
          if (item) {
            itemExistsInWorkspace = pane.getItems().includes(item);
          } else {
            item = pane.itemForURI(uri);
            itemExistsInWorkspace = item != null;
          }
        }
      }
      if (item) await Promise.resolve();
      if (!itemExistsInWorkspace) {
        item = item || (await this.createItemForURI(uri, options));
        if (!item) return;
        if (options.pane) {
          pane = options.pane;
        } else {
          let location = options.location;
          if (!location && !options.split && uri && this.enablePersistence) {
            location = await this.itemLocationStore.load(uri);
          }
          if (!location && typeof item.getDefaultLocation === 'function') {
            location = item.getDefaultLocation();
          }
          const allowedLocations =
            typeof item.getAllowedLocations === 'function'
              ? item.getAllowedLocations()
              : ALL_LOCATIONS;
          location = allowedLocations.includes(location)
            ? location
            : allowedLocations[0];
          const container = this.paneContainers[location] || this.getCenter();
          pane = container.getActivePane();
          switch (options.split) {
            case 'left':
              pane = pane.findLeftmostSibling();
              break;
            case 'right':
              pane = pane.findOrCreateRightmostSibling();
              break;
            case 'up':
              pane = pane.findTopmostSibling();
              break;
            case 'down':
              pane = pane.findOrCreateBottommostSibling();
              break;
          }
        }
      }
      if (!options.pending && pane.getPendingItem() === item) {
        pane.clearPendingItem();
      }
      this.itemOpened(item);
      if (options.activateItem === false) {
        pane.addItem(item, { pending: options.pending });
      } else {
        pane.activateItem(item, { pending: options.pending });
      }
      if (options.activatePane !== false) {
        pane.activate();
      }
      let initialColumn = 0;
      let initialLine = 0;
      if (!Number.isNaN(options.initialLine)) {
        initialLine = options.initialLine;
      }
      if (!Number.isNaN(options.initialColumn)) {
        initialColumn = options.initialColumn;
      }
      if (initialLine >= 0 || initialColumn >= 0) {
        if (typeof item.setCursorBufferPosition === 'function') {
          item.setCursorBufferPosition([initialLine, initialColumn]);
        }
        if (typeof item.unfoldBufferRow === 'function') {
          item.unfoldBufferRow(initialLine);
        }
        if (typeof item.scrollToBufferPosition === 'function') {
          item.scrollToBufferPosition([initialLine, initialColumn], {
            center: true
          });
        }
      }
      const index = pane.getActiveItemIndex();
      this.emitter.emit('did-open', { uri, pane, item, index });
      if (uri) {
        this.incoming.delete(uri);
      }
      let activationHookItem;
      let activationHookText;
      if (item instanceof TextEditor) {
        activationHookItem = item.getTitle();
        activationHookText = "file-name-opened";
      } else {
        activationHookText = "uri-opened";
        if (typeof item.getURI === "function") {
          activationHookItem = item.getURI();
        } else if (typeof item.getUri === "function") {
          activationHookItem = item.getUri();
        } else {
          activationHookItem = "";
          activationHookText = "";
          // We are purposefully redeclaring the text here, to fail gracefully
        }
      }
      if (activationHookText?.length > 1 && activationHookItem?.length > 1) {
        this.packageManager.triggerActivationHook(
          `${activationHookItem}:${activationHookText}`
        );
      }
    } finally {
      resolveItem();
    }
    return item;
  }
  // Essential: Search the workspace for items matching the given URI and hide them.
  //
  // * `itemOrURI` The item to hide or a {String} containing the URI
  //   of the item to hide.
  //
  // Returns a {Boolean} indicating whether any items were found (and hidden).
  hide(itemOrURI) {
    let foundItems = false;
    // If any visible item has the given URI, hide it
    for (const container of this.getPaneContainers()) {
      const isCenter = container === this.getCenter();
      if (isCenter || container.isVisible()) {
        for (const pane of container.getPanes()) {
          const activeItem = pane.getActiveItem();
          const foundItem =
            activeItem != null &&
            (activeItem === itemOrURI ||
              (typeof activeItem.getURI === 'function' &&
                activeItem.getURI() === itemOrURI));
          if (foundItem) {
            foundItems = true;
            // We can't really hide the center so we just destroy the item.
            if (isCenter) {
              pane.destroyItem(activeItem);
            } else {
              container.hide();
            }
          }
        }
      }
    }
    return foundItems;
  }
  // Essential: Search the workspace for items matching the given URI. If any are found, hide them.
  // Otherwise, open the URL.
  //
  // * `itemOrURI` (optional) The item to toggle or a {String} containing the URI
  //   of the item to toggle.
  //
  // Returns a Promise that resolves when the item is shown or hidden.
  toggle(itemOrURI) {
    if (this.hide(itemOrURI)) {
      return Promise.resolve();
    } else {
      return this.open(itemOrURI, { searchAllPanes: true });
    }
  }
  // Open Pulsar's license in the active pane.
  openLicense() {
    const resPath = path.join(process.resourcesPath, 'LICENSE.md')
    if(fs.existsSync(resPath)) {
      return this.open(resPath);
    } else {
      return this.open(path.join(__dirname, '..', 'LICENSE.md'))
    }
  }
  // Synchronously open the given URI in the active pane. **Only use this method
  // in specs. Calling this in production code will block the UI thread and
  // everyone will be mad at you.**
  //
  // * `uri` A {String} containing a URI.
  // * `options` An optional options {Object}
  //   * `initialLine` A {Number} indicating which row to move the cursor to
  //     initially. Defaults to `0`.
  //   * `initialColumn` A {Number} indicating which column to move the cursor to
  //     initially. Defaults to `0`.
  //   * `activatePane` A {Boolean} indicating whether to call {Pane::activate} on
  //     the containing pane. Defaults to `true`.
  //   * `activateItem` A {Boolean} indicating whether to call {Pane::activateItem}
  //     on containing pane. Defaults to `true`.
  openSync(uri_ = '', options = {}) {
    const { initialLine, initialColumn } = options;
    const activatePane =
      options.activatePane != null ? options.activatePane : true;
    const activateItem =
      options.activateItem != null ? options.activateItem : true;
    const uri = this.project.resolvePath(uri_);
    let item = this.getActivePane().itemForURI(uri);
    if (uri && item == null) {
      for (const opener of this.getOpeners()) {
        item = opener(uri, options);
        if (item) break;
      }
    }
    if (item == null) {
      item = this.project.openSync(uri, { initialLine, initialColumn });
    }
    if (activateItem) {
      this.getActivePane().activateItem(item);
    }
    this.itemOpened(item);
    if (activatePane) {
      this.getActivePane().activate();
    }
    return item;
  }
  openURIInPane(uri, pane) {
    return this.open(uri, { pane });
  }
  // Public: Creates a new item that corresponds to the provided URI.
  //
  // If no URI is given, or no registered opener can open the URI, a new empty
  // {TextEditor} will be created.
  //
  // * `uri` A {String} containing a URI.
  //
  // Returns a {Promise} that resolves to the {TextEditor} (or other item) for the given URI.
  async createItemForURI(uri, options) {
    if (uri != null) {
      for (const opener of this.getOpeners()) {
        const item = opener(uri, options);
        if (item != null) return item;
      }
    }
    try {
      const item = await this.openTextFile(uri, options);
      return item;
    } catch (error) {
      switch (error.code) {
        case 'CANCELLED':
          return Promise.resolve();
        case 'EACCES':
          this.notificationManager.addWarning(
            `Permission denied '${error.path}'`
          );
          return Promise.resolve();
        case 'EPERM':
        case 'EBUSY':
        case 'ENXIO':
        case 'EIO':
        case 'ENOTCONN':
        case 'UNKNOWN':
        case 'ECONNRESET':
        case 'EINVAL':
        case 'EMFILE':
        case 'ENOTDIR':
        case 'EAGAIN':
          this.notificationManager.addWarning(
            `Unable to open '${error.path != null ? error.path : uri}'`,
            { detail: error.message }
          );
          return Promise.resolve();
        default:
          throw error;
      }
    }
  }
  async openTextFile(uri, options) {
    const filePath = this.project.resolvePath(uri);
    if (filePath != null) {
      try {
        fs.closeSync(fs.openSync(filePath, 'r'));
      } catch (error) {
        // allow ENOENT errors to create an editor for paths that dont exist
        if (error.code !== 'ENOENT') {
          throw error;
        }
      }
    }
    const fileSize = fs.getSizeSync(filePath);
    if (fileSize >= this.config.get('core.warnOnLargeFileLimit') * 1048576) {
      // 40MB by default
      await new Promise((resolve, reject) => {
        this.applicationDelegate.confirm(
          {
            message:
              'Pulsar will be unresponsive during the loading of very large files.',
            detail: 'Do you still want to load this file?',
            buttons: ['Proceed', 'Cancel']
          },
          response => {
            if (response === 1) {
              const error = new Error();
              error.code = 'CANCELLED';
              reject(error);
            } else {
              resolve();
            }
          }
        );
      });
    }
    const buffer = await this.project.bufferForPath(filePath, options);
    return this.textEditorRegistry.build(
      Object.assign({ buffer, autoHeight: false }, options)
    );
  }
  handleGrammarUsed(grammar) {
    if (grammar == null) {
      return;
    }
    this.packageManager.triggerActivationHook(
      `${grammar.scopeName}:root-scope-used`
    );
    this.packageManager.triggerActivationHook(
      `${grammar.packageName}:grammar-used`
    );
  }
  // Public: Returns a {Boolean} that is `true` if `object` is a `TextEditor`.
  //
  // * `object` An {Object} you want to perform the check against.
  isTextEditor(object) {
    return object instanceof TextEditor;
  }
  // Extended: Create a new text editor.
  //
  // Returns a {TextEditor}.
  buildTextEditor(params) {
    const editor = this.textEditorRegistry.build(params);
    const subscription = this.textEditorRegistry.maintainConfig(editor);
    editor.onDidDestroy(() => subscription.dispose());
    return editor;
  }
  // Public: Asynchronously reopens the last-closed item's URI if it hasn't already been
  // reopened.
  //
  // Returns a {Promise} that is resolved when the item is opened
  reopenItem() {
    const uri = this.destroyedItemURIs.pop();
    if (uri) {
      return this.open(uri);
    } else {
      return Promise.resolve();
    }
  }
  // Public: Register an opener for a uri.
  //
  // When a URI is opened via {Workspace::open}, Pulsar loops through its registered
  // opener functions until one returns a value for the given uri.
  // Openers are expected to return an object that inherits from HTMLElement or
  // a model which has an associated view in the {ViewRegistry}.
  // A {TextEditor} will be used if no opener returns a value.
  //
  // ## Examples
  //
  // ```coffee
  // atom.workspace.addOpener (uri) ->
  //   if path.extname(uri) is '.toml'
  //     return new TomlEditor(uri)
  // ```
  //
  // * `opener` A {Function} to be called when a path is being opened.
  //
  // Returns a {Disposable} on which `.dispose()` can be called to remove the
  // opener.
  //
  // Note that the opener will be called if and only if the URI is not already open
  // in the current pane. The searchAllPanes flag expands the search from the
  // current pane to all panes. If you wish to open a view of a different type for
  // a file that is already open, consider changing the protocol of the URI. For
  // example, perhaps you wish to preview a rendered version of the file `/foo/bar/baz.quux`
  // that is already open in a text editor view. You could signal this by calling
  // {Workspace::open} on the URI `quux-preview://foo/bar/baz.quux`. Then your opener
  // can check the protocol for quux-preview and only handle those URIs that match.
  //
  // To defer your package's activation until a specific URL is opened, add a
  // `workspaceOpeners` field to your `package.json` containing an array of URL
  // strings.
  addOpener(opener) {
    this.openers.push(opener);
    return new Disposable(() => {
      _.remove(this.openers, opener);
    });
  }
  getOpeners() {
    return this.openers;
  }
  /*
  Section: Pane Items
  */
  // Essential: Get all pane items in the workspace.
  //
  // Returns an {Array} of items.
  getPaneItems() {
    return _.flatten(
      this.getPaneContainers().map(container => container.getPaneItems())
    );
  }
  // Essential: Get the active {Pane}'s active item.
  //
  // Returns a pane item {Object}.
  getActivePaneItem() {
    return this.getActivePaneContainer().getActivePaneItem();
  }
  // Essential: Get all text editors in the workspace, if they are pane items.
  //
  // Returns an {Array} of {TextEditor}s.
  getTextEditors() {
    return this.getPaneItems().filter(item => item instanceof TextEditor);
  }
  // Essential: Get the workspace center's active item if it is a {TextEditor}.
  //
  // Returns a {TextEditor} or `undefined` if the workspace center's current
  // active item is not a {TextEditor}.
  getActiveTextEditor() {
    const activeItem = this.getCenter().getActivePaneItem();
    if (activeItem instanceof TextEditor) {
      return activeItem;
    }
  }
  // Save all pane items.
  saveAll() {
    this.getPaneContainers().forEach(container => {
      container.saveAll();
    });
  }
  confirmClose(options) {
    return Promise.all(
      this.getPaneContainers().map(container => container.confirmClose(options))
    ).then(results => !results.includes(false));
  }
  // Save the active pane item.
  //
  // If the active pane item currently has a URI according to the item's
  // `.getURI` method, calls `.save` on the item. Otherwise
  // {::saveActivePaneItemAs} # will be called instead. This method does nothing
  // if the active item does not implement a `.save` method.
  saveActivePaneItem() {
    return this.getCenter()
      .getActivePane()
      .saveActiveItem();
  }
  // Prompt the user for a path and save the active pane item to it.
  //
  // Opens a native dialog where the user selects a path on disk, then calls
  // `.saveAs` on the item with the selected path. This method does nothing if
  // the active item does not implement a `.saveAs` method.
  saveActivePaneItemAs() {
    this.getCenter()
      .getActivePane()
      .saveActiveItemAs();
  }
  // Destroy (close) the active pane item.
  //
  // Removes the active pane item and calls the `.destroy` method on it if one is
  // defined.
  destroyActivePaneItem() {
    return this.getActivePane().destroyActiveItem();
  }
  /*
  Section: Panes
  */
  // Extended: Get the most recently focused pane container.
  //
  // Returns a {Dock} or the {WorkspaceCenter}.
  getActivePaneContainer() {
    return this.activePaneContainer;
  }
  // Extended: Get all panes in the workspace.
  //
  // Returns an {Array} of {Pane}s.
  getPanes() {
    return _.flatten(
      this.getPaneContainers().map(container => container.getPanes())
    );
  }
  getVisiblePanes() {
    return _.flatten(
      this.getVisiblePaneContainers().map(container => container.getPanes())
    );
  }
  // Extended: Get the active {Pane}.
  //
  // Returns a {Pane}.
  getActivePane() {
    return this.getActivePaneContainer().getActivePane();
  }
  // Extended: Make the next pane active.
  activateNextPane() {
    return this.getActivePaneContainer().activateNextPane();
  }
  // Extended: Make the previous pane active.
  activatePreviousPane() {
    return this.getActivePaneContainer().activatePreviousPane();
  }
  // Extended: Get the first pane container that contains an item with the given
  // URI.
  //
  // * `uri` {String} uri
  //
  // Returns a {Dock}, the {WorkspaceCenter}, or `undefined` if no item exists
  // with the given URI.
  paneContainerForURI(uri) {
    return this.getPaneContainers().find(container =>
      container.paneForURI(uri)
    );
  }
  // Extended: Get the first pane container that contains the given item.
  //
  // * `item` the Item that the returned pane container must contain.
  //
  // Returns a {Dock}, the {WorkspaceCenter}, or `undefined` if no item exists
  // with the given URI.
  paneContainerForItem(uri) {
    return this.getPaneContainers().find(container =>
      container.paneForItem(uri)
    );
  }
  // Extended: Get the first {Pane} that contains an item with the given URI.
  //
  // * `uri` {String} uri
  //
  // Returns a {Pane} or `undefined` if no item exists with the given URI.
  paneForURI(uri) {
    for (let location of this.getPaneContainers()) {
      const pane = location.paneForURI(uri);
      if (pane != null) {
        return pane;
      }
    }
  }
  // Extended: Get the {Pane} containing the given item.
  //
  // * `item` the Item that the returned pane must contain.
  //
  // Returns a {Pane} or `undefined` if no pane exists for the given item.
  paneForItem(item) {
    for (let location of this.getPaneContainers()) {
      const pane = location.paneForItem(item);
      if (pane != null) {
        return pane;
      }
    }
  }
  // Destroy (close) the active pane.
  destroyActivePane() {
    const activePane = this.getActivePane();
    if (activePane != null) {
      activePane.destroy();
    }
  }
  // Close the active center pane item, or the active center pane if it is
  // empty, or the current window if there is only the empty root pane.
  closeActivePaneItemOrEmptyPaneOrWindow() {
    if (this.getCenter().getActivePaneItem() != null) {
      this.getCenter()
        .getActivePane()
        .destroyActiveItem();
    } else if (this.getCenter().getPanes().length > 1) {
      this.getCenter().destroyActivePane();
    } else if (this.config.get('core.closeEmptyWindows')) {
      atom.close();
    }
  }
  // Increase the editor font size by 1px.
  increaseFontSize() {
    this.config.set('editor.fontSize', this.config.get('editor.fontSize') + 1);
  }
  // Decrease the editor font size by 1px.
  decreaseFontSize() {
    const fontSize = this.config.get('editor.fontSize');
    if (fontSize > 1) {
      this.config.set('editor.fontSize', fontSize - 1);
    }
  }
  // Restore to the window's default editor font size.
  resetFontSize() {
    this.config.set(
      'editor.fontSize',
      this.config.get('editor.defaultFontSize')
    );
  }
  // Removes the item's uri from the list of potential items to reopen.
  itemOpened(item) {
    let uri;
    if (typeof item.getURI === 'function') {
      uri = item.getURI();
    } else if (typeof item.getUri === 'function') {
      uri = item.getUri();
    }
    if (uri != null) {
      _.remove(this.destroyedItemURIs, uri);
    }
  }
  // Adds the destroyed item's uri to the list of items to reopen.
  didDestroyPaneItem({ item }) {
    let uri;
    if (typeof item.getURI === 'function') {
      uri = item.getURI();
    } else if (typeof item.getUri === 'function') {
      uri = item.getUri();
    }
    if (uri != null) {
      this.destroyedItemURIs.push(uri);
    }
  }
  // Called by Model superclass when destroyed
  destroyed() {
    this.paneContainers.center.destroy();
    this.paneContainers.left.destroy();
    this.paneContainers.right.destroy();
    this.paneContainers.bottom.destroy();
    this.cancelStoppedChangingActivePaneItemTimeout();
    if (this.activeItemSubscriptions != null) {
      this.activeItemSubscriptions.dispose();
    }
    if (this.element) this.element.destroy();
  }
  /*
  Section: Pane Locations
  */
  // Essential: Get the {WorkspaceCenter} at the center of the editor window.
  getCenter() {
    return this.paneContainers.center;
  }
  // Essential: Get the {Dock} to the left of the editor window.
  getLeftDock() {
    return this.paneContainers.left;
  }
  // Essential: Get the {Dock} to the right of the editor window.
  getRightDock() {
    return this.paneContainers.right;
  }
  // Essential: Get the {Dock} below the editor window.
  getBottomDock() {
    return this.paneContainers.bottom;
  }
  getPaneContainers() {
    return [
      this.paneContainers.center,
      this.paneContainers.left,
      this.paneContainers.right,
      this.paneContainers.bottom
    ];
  }
  getVisiblePaneContainers() {
    const center = this.getCenter();
    return atom.workspace
      .getPaneContainers()
      .filter(container => container === center || container.isVisible());
  }
  /*
  Section: Panels
  Panels are used to display UI related to an editor window. They are placed at one of the four
  edges of the window: left, right, top or bottom. If there are multiple panels on the same window
  edge they are stacked in order of priority: higher priority is closer to the center, lower
  priority towards the edge.
  *Note:* If your panel changes its size throughout its lifetime, consider giving it a higher
  priority, allowing fixed size panels to be closer to the edge. This allows control targets to
  remain more static for easier targeting by users that employ mice or trackpads. (See
  [atom/atom#4834](https://github.com/atom/atom/issues/4834) for discussion.)
  */
  // Essential: Get an {Array} of all the panel items at the bottom of the editor window.
  getBottomPanels() {
    return this.getPanels('bottom');
  }
  // Essential: Adds a panel item to the bottom of the editor window.
  //
  // * `options` {Object}
  //   * `item` Your panel content. It can be DOM element, a jQuery element, or
  //     a model with a view registered via {ViewRegistry::addViewProvider}. We recommend the
  //     latter. See {ViewRegistry::addViewProvider} for more information.
  //   * `visible` (optional) {Boolean} false if you want the panel to initially be hidden
  //     (default: true)
  //   * `priority` (optional) {Number} Determines stacking order. Lower priority items are
  //     forced closer to the edges of the window. (default: 100)
  //
  // Returns a {Panel}
  addBottomPanel(options) {
    return this.addPanel('bottom', options);
  }
  // Essential: Get an {Array} of all the panel items to the left of the editor window.
  getLeftPanels() {
    return this.getPanels('left');
  }
  // Essential: Adds a panel item to the left of the editor window.
  //
  // * `options` {Object}
  //   * `item` Your panel content. It can be DOM element, a jQuery element, or
  //     a model with a view registered via {ViewRegistry::addViewProvider}. We recommend the
  //     latter. See {ViewRegistry::addViewProvider} for more information.
  //   * `visible` (optional) {Boolean} false if you want the panel to initially be hidden
  //     (default: true)
  //   * `priority` (optional) {Number} Determines stacking order. Lower priority items are
  //     forced closer to the edges of the window. (default: 100)
  //
  // Returns a {Panel}
  addLeftPanel(options) {
    return this.addPanel('left', options);
  }
  // Essential: Get an {Array} of all the panel items to the right of the editor window.
  getRightPanels() {
    return this.getPanels('right');
  }
  // Essential: Adds a panel item to the right of the editor window.
  //
  // * `options` {Object}
  //   * `item` Your panel content. It can be DOM element, a jQuery element, or
  //     a model with a view registered via {ViewRegistry::addViewProvider}. We recommend the
  //     latter. See {ViewRegistry::addViewProvider} for more information.
  //   * `visible` (optional) {Boolean} false if you want the panel to initially be hidden
  //     (default: true)
  //   * `priority` (optional) {Number} Determines stacking order. Lower priority items are
  //     forced closer to the edges of the window. (default: 100)
  //
  // Returns a {Panel}
  addRightPanel(options) {
    return this.addPanel('right', options);
  }
  // Essential: Get an {Array} of all the panel items at the top of the editor window.
  getTopPanels() {
    return this.getPanels('top');
  }
  // Essential: Adds a panel item to the top of the editor window above the tabs.
  //
  // * `options` {Object}
  //   * `item` Your panel content. It can be DOM element, a jQuery element, or
  //     a model with a view registered via {ViewRegistry::addViewProvider}. We recommend the
  //     latter. See {ViewRegistry::addViewProvider} for more information.
  //   * `visible` (optional) {Boolean} false if you want the panel to initially be hidden
  //     (default: true)
  //   * `priority` (optional) {Number} Determines stacking order. Lower priority items are
  //     forced closer to the edges of the window. (default: 100)
  //
  // Returns a {Panel}
  addTopPanel(options) {
    return this.addPanel('top', options);
  }
  // Essential: Get an {Array} of all the panel items in the header.
  getHeaderPanels() {
    return this.getPanels('header');
  }
  // Essential: Adds a panel item to the header.
  //
  // * `options` {Object}
  //   * `item` Your panel content. It can be DOM element, a jQuery element, or
  //     a model with a view registered via {ViewRegistry::addViewProvider}. We recommend the
  //     latter. See {ViewRegistry::addViewProvider} for more information.
  //   * `visible` (optional) {Boolean} false if you want the panel to initially be hidden
  //     (default: true)
  //   * `priority` (optional) {Number} Determines stacking order. Lower priority items are
  //     forced closer to the edges of the window. (default: 100)
  //
  // Returns a {Panel}
  addHeaderPanel(options) {
    return this.addPanel('header', options);
  }
  // Essential: Get an {Array} of all the panel items in the footer.
  getFooterPanels() {
    return this.getPanels('footer');
  }
  // Essential: Adds a panel item to the footer.
  //
  // * `options` {Object}
  //   * `item` Your panel content. It can be DOM element, a jQuery element, or
  //     a model with a view registered via {ViewRegistry::addViewProvider}. We recommend the
  //     latter. See {ViewRegistry::addViewProvider} for more information.
  //   * `visible` (optional) {Boolean} false if you want the panel to initially be hidden
  //     (default: true)
  //   * `priority` (optional) {Number} Determines stacking order. Lower priority items are
  //     forced closer to the edges of the window. (default: 100)
  //
  // Returns a {Panel}
  addFooterPanel(options) {
    return this.addPanel('footer', options);
  }
  // Essential: Get an {Array} of all the modal panel items
  getModalPanels() {
    return this.getPanels('modal');
  }
  // Essential: Adds a panel item as a modal dialog.
  //
  // * `options` {Object}
  //   * `item` Your panel content. It can be a DOM element, a jQuery element, or
  //     a model with a view registered via {ViewRegistry::addViewProvider}. We recommend the
  //     model option. See {ViewRegistry::addViewProvider} for more information.
  //   * `visible` (optional) {Boolean} false if you want the panel to initially be hidden
  //     (default: true)
  //   * `priority` (optional) {Number} Determines stacking order. Lower priority items are
  //     forced closer to the edges of the window. (default: 100)
  //   * `autoFocus` (optional) {Boolean|Element} true if you want modal focus managed for you by Pulsar.
  //     Pulsar will automatically focus on this element or your modal panel's first tabbable element when the modal
  //     opens and will restore the previously selected element when the modal closes. Pulsar will
  //     also automatically restrict user tab focus within your modal while it is open.
  //     (default: false)
  //
  // Returns a {Panel}
  addModalPanel(options = {}) {
    return this.addPanel('modal', options);
  }
  // Essential: Returns the {Panel} associated with the given item. Returns
  // `null` when the item has no panel.
  //
  // * `item` Item the panel contains
  panelForItem(item) {
    for (let location in this.panelContainers) {
      const container = this.panelContainers[location];
      const panel = container.panelForItem(item);
      if (panel != null) {
        return panel;
      }
    }
    return null;
  }
  getPanels(location) {
    return this.panelContainers[location].getPanels();
  }
  addPanel(location, options) {
    if (options == null) {
      options = {};
    }
    return this.panelContainers[location].addPanel(
      new Panel(options, this.viewRegistry)
    );
  }
  /*
  Section: Searching and Replacing
  */
  // Public: Performs a search across all files in the workspace.
  //
  // * `regex` {RegExp} to search with.
  // * `options` (optional) {Object}
  //   * `paths` An {Array} of glob patterns to search within.
  //   * `onPathsSearched` (optional) {Function} to be periodically called
  //     with number of paths searched.
  //   * `leadingContextLineCount` {Number} default `0`; The number of lines
  //      before the matched line to include in the results object.
  //   * `trailingContextLineCount` {Number} default `0`; The number of lines
  //      after the matched line to include in the results object.
  // * `iterator` {Function} callback on each file found.
  //
  // Returns a {Promise} with a `cancel()` method that will cancel all
  // of the underlying searches that were started as part of this scan.
  scan(regex, options = {}, iterator) {
    if (_.isFunction(options)) {
      iterator = options;
      options = {};
    }
    // Find a searcher for every Directory in the project. Each searcher that is matched
    // will be associated with an Array of Directory objects in the Map.
    const directoriesForSearcher = new Map();
    for (const directory of this.project.getDirectories()) {
      let searcher = options.ripgrep
        ? this.ripgrepDirectorySearcher
        : this.scandalDirectorySearcher;
      for (const directorySearcher of this.directorySearchers) {
        if (directorySearcher.canSearchDirectory(directory)) {
          searcher = directorySearcher;
          break;
        }
      }
      let directories = directoriesForSearcher.get(searcher);
      if (!directories) {
        directories = [];
        directoriesForSearcher.set(searcher, directories);
      }
      directories.push(directory);
    }
    // Define the onPathsSearched callback.
    let onPathsSearched;
    if (_.isFunction(options.onPathsSearched)) {
      // Maintain a map of directories to the number of search results. When notified of a new count,
      // replace the entry in the map and update the total.
      const onPathsSearchedOption = options.onPathsSearched;
      let totalNumberOfPathsSearched = 0;
      const numberOfPathsSearchedForSearcher = new Map();
      onPathsSearched = function(searcher, numberOfPathsSearched) {
        const oldValue = numberOfPathsSearchedForSearcher.get(searcher);
        if (oldValue) {
          totalNumberOfPathsSearched -= oldValue;
        }
        numberOfPathsSearchedForSearcher.set(searcher, numberOfPathsSearched);
        totalNumberOfPathsSearched += numberOfPathsSearched;
        return onPathsSearchedOption(totalNumberOfPathsSearched);
      };
    } else {
      onPathsSearched = function() {};
    }
    // Kick off all of the searches and unify them into one Promise.
    const allSearches = [];
    directoriesForSearcher.forEach((directories, searcher) => {
      const searchOptions = {
        inclusions: options.paths || [],
        includeHidden: true,
        excludeVcsIgnores: this.config.get('core.excludeVcsIgnoredPaths'),
        exclusions: this.config.get('core.ignoredNames'),
        follow: this.config.get('core.followSymlinks'),
        leadingContextLineCount: options.leadingContextLineCount || 0,
        trailingContextLineCount: options.trailingContextLineCount || 0,
        PCRE2: options.PCRE2,
        didMatch: result => {
          if (!this.project.isPathModified(result.filePath)) {
            return iterator(result);
          }
        },
        didError(error) {
          return iterator(null, error);
        },
        didSearchPaths(count) {
          return onPathsSearched(searcher, count);
        }
      };
      const directorySearcher = searcher.search(
        directories,
        regex,
        searchOptions
      );
      allSearches.push(directorySearcher);
    });
    const searchPromise = Promise.all(allSearches);
    for (let buffer of this.project.getBuffers()) {
      if (buffer.isModified()) {
        const filePath = buffer.getPath();
        if (!this.project.contains(filePath)) {
          continue;
        }
        var matches = [];
        buffer.scan(regex, match => matches.push(match));
        if (matches.length > 0) {
          iterator({ filePath, matches });
        }
      }
    }
    // Make sure the Promise that is returned to the client is cancelable. To be consistent
    // with the existing behavior, instead of cancel() rejecting the promise, it should
    // resolve it with the special value 'cancelled'. At least the built-in find-and-replace
    // package relies on this behavior.
    let isCancelled = false;
    const cancellablePromise = new Promise((resolve, reject) => {
      const onSuccess = function() {
        if (isCancelled) {
          resolve('cancelled');
        } else {
          resolve(null);
        }
      };
      const onFailure = function(error) {
        for (let promise of allSearches) {
          promise.cancel();
        }
        reject(error);
      };
      searchPromise.then(onSuccess, onFailure);
    });
    cancellablePromise.cancel = () => {
      isCancelled = true;
      // Note that cancelling all of the members of allSearches will cause all of the searches
      // to resolve, which causes searchPromise to resolve, which is ultimately what causes
      // cancellablePromise to resolve.
      allSearches.map(promise => promise.cancel());
    };
    return cancellablePromise;
  }
  // Public: Performs a replace across all the specified files in the project.
  //
  // * `regex` A {RegExp} to search with.
  // * `replacementText` {String} to replace all matches of regex with.
  // * `filePaths` An {Array} of file path strings to run the replace on.
  // * `iterator` A {Function} callback on each file with replacements:
  //   * `options` {Object} with keys `filePath` and `replacements`.
  //
  // Returns a {Promise}.
  replace(regex, replacementText, filePaths, iterator) {
    return new Promise((resolve, reject) => {
      let buffer;
      const openPaths = this.project
        .getBuffers()
        .map(buffer => buffer.getPath());
      const outOfProcessPaths = _.difference(filePaths, openPaths);
      let inProcessFinished = !openPaths.length;
      let outOfProcessFinished = !outOfProcessPaths.length;
      const checkFinished = () => {
        if (outOfProcessFinished && inProcessFinished) {
          resolve();
        }
      };
      if (!outOfProcessFinished.length) {
        let flags = 'g';
        if (regex.multiline) {
          flags += 'm';
        }
        if (regex.ignoreCase) {
          flags += 'i';
        }
        const task = Task.once(
          require.resolve('./replace-handler'),
          outOfProcessPaths,
          regex.source,
          flags,
          replacementText,
          () => {
            outOfProcessFinished = true;
            checkFinished();
          }
        );
        task.on('replace:path-replaced', iterator);
        task.on('replace:file-error', error => {
          iterator(null, error);
        });
      }
      for (buffer of this.project.getBuffers()) {
        if (!filePaths.includes(buffer.getPath())) {
          continue;
        }
        const replacements = buffer.replace(regex, replacementText, iterator);
        if (replacements) {
          iterator({ filePath: buffer.getPath(), replacements });
        }
      }
      inProcessFinished = true;
      checkFinished();
    });
  }
  checkoutHeadRevision(editor) {
    if (editor.getPath()) {
      const checkoutHead = async () => {
        const repository = await this.project.repositoryForDirectory(
          new Directory(editor.getDirectoryPath())
        );
        if (repository) repository.checkoutHeadForEditor(editor);
      };
      if (this.config.get('editor.confirmCheckoutHeadRevision')) {
        this.applicationDelegate.confirm(
          {
            message: 'Confirm Checkout HEAD Revision',
            detail: `Are you sure you want to discard all changes to "${editor.getFileName()}" since the last Git commit?`,
            buttons: ['OK', 'Cancel']
          },
          response => {
            if (response === 0) checkoutHead();
          }
        );
      } else {
        checkoutHead();
      }
    }
  }
};

================
File: package.json
================
{
  "name": "pulsar",
  "author": "Pulsar-Edit <admin@pulsar-edit.dev>",
  "productName": "Pulsar",
  "version": "1.121.0-dev",
  "description": "A Community-led Hyper-Hackable Text Editor",
  "branding": {
    "id": "pulsar",
    "name": "Pulsar",
    "urlWeb": "https://pulsar-edit.dev/",
    "urlGH": "https://github.com/pulsar-edit",
    "urlForum": "https://github.com/orgs/pulsar-edit/discussions"
  },
  "main": "./src/main-process/main.js",
  "repository": {
    "type": "git",
    "url": "https://github.com/pulsar-edit/pulsar"
  },
  "bugs": {
    "url": "https://github.com/pulsar-edit/pulsar/issues"
  },
  "engines": {
    "node": ">=14"
  },
  "license": "MIT",
  "electronVersion": "12.2.3",
  "resolutions": {
    "es5-ext": "https://github.com/pulsar-edit/es5-ext#169f6ae9b2675675269a0ba265f83c29c7b56244",
    "superstring": "github:pulsar-edit/superstring#de97b496663fce40050bf2d66e1466ccfbd00943",
    "text-buffer/superstring": "github:pulsar-edit/superstring#de97b496663fce40050bf2d66e1466ccfbd00943"
  },
  "dependencies": {
    "@atom/source-map-support": "^0.3.4",
    "@babel/core": "7.18.6",
    "@pulsar-edit/fuzzy-native": "https://github.com/pulsar-edit/fuzzy-native.git#c6ddd2e0ace7b3cfe8082fcbe5985c49f76da5b8",
    "about": "file:packages/about",
    "archive-view": "file:packages/archive-view",
    "async": "3.2.4",
    "atom-dark-syntax": "file:packages/atom-dark-syntax",
    "atom-dark-ui": "file:packages/atom-dark-ui",
    "atom-keymap": "8.2.15",
    "atom-light-syntax": "file:packages/atom-light-syntax",
    "atom-light-ui": "file:packages/atom-light-ui",
    "atom-select-list": "^0.8.1",
    "autocomplete-atom-api": "file:packages/autocomplete-atom-api",
    "autocomplete-css": "file:packages/autocomplete-css",
    "autocomplete-html": "file:packages/autocomplete-html",
    "autocomplete-plus": "file:./packages/autocomplete-plus",
    "autocomplete-snippets": "file:packages/autocomplete-snippets",
    "autoflow": "file:packages/autoflow",
    "autosave": "file:./packages/autosave",
    "babel-preset-atomic": "^5.0.0",
    "background-tips": "file:packages/background-tips",
    "base16-tomorrow-dark-theme": "file:packages/base16-tomorrow-dark-theme",
    "base16-tomorrow-light-theme": "file:packages/base16-tomorrow-light-theme",
    "bookmarks": "file:packages/bookmarks",
    "bracket-matcher": "file:packages/bracket-matcher",
    "chai": "4.3.4",
    "clear-cut": "^2.0.2",
    "coffeescript": "1.12.7",
    "color": "3.1.3",
    "command-palette": "file:packages/command-palette",
    "dalek": "file:packages/dalek",
    "dedent": "^0.7.0",
    "deprecation-cop": "file:packages/deprecation-cop",
    "dev-live-reload": "file:packages/dev-live-reload",
    "document-register-element": "https://github.com/pulsar-edit/document-register-element.git#1f5868f",
    "dompurify": "^3.0.6",
    "encoding-selector": "file:packages/encoding-selector",
    "etch": "0.14.1",
    "event-kit": "^2.5.3",
    "exception-reporting": "file:packages/exception-reporting",
    "find-and-replace": "file:packages/find-and-replace",
    "find-parent-dir": "^0.3.0",
    "focus-trap": "6.3.0",
    "fs-admin": "0.19.0",
    "fs-plus": "^3.1.1",
    "fstream": "1.0.12",
    "fuzzy-finder": "file:packages/fuzzy-finder",
    "git-diff": "file:packages/git-diff",
    "git-utils": "^5.7.3",
    "github": "https://github.com/pulsar-edit/github/archive/refs/tags/v0.36.20-pretranspiled.tar.gz",
    "go-to-line": "file:packages/go-to-line",
    "grammar-selector": "file:packages/grammar-selector",
    "grim": "2.0.3",
    "image-view": "file:packages/image-view",
    "incompatible-packages": "file:packages/incompatible-packages",
    "jasmine-json": "~0.0",
    "jasmine-reporters": "1.1.0",
    "jasmine-tagged": "^1.1.4",
    "key-path-helpers": "^0.4.0",
    "keybinding-resolver": "file:./packages/keybinding-resolver",
    "language-c": "file:packages/language-c",
    "language-clojure": "file:packages/language-clojure",
    "language-coffee-script": "file:packages/language-coffee-script",
    "language-csharp": "file:packages/language-csharp",
    "language-css": "file:packages/language-css",
    "language-gfm": "file:packages/language-gfm",
    "language-git": "file:packages/language-git",
    "language-go": "file:packages/language-go",
    "language-html": "file:packages/language-html",
    "language-hyperlink": "file:packages/language-hyperlink",
    "language-java": "file:packages/language-java",
    "language-javascript": "file:packages/language-javascript",
    "language-json": "file:packages/language-json",
    "language-less": "file:packages/language-less",
    "language-make": "file:packages/language-make",
    "language-mustache": "file:packages/language-mustache",
    "language-objective-c": "file:packages/language-objective-c",
    "language-perl": "file:packages/language-perl",
    "language-php": "file:packages/language-php",
    "language-property-list": "file:packages/language-property-list",
    "language-python": "file:packages/language-python",
    "language-ruby": "file:packages/language-ruby",
    "language-ruby-on-rails": "file:packages/language-ruby-on-rails",
    "language-rust-bundled": "file:packages/language-rust-bundled",
    "language-sass": "file:packages/language-sass",
    "language-shellscript": "file:packages/language-shellscript",
    "language-source": "file:packages/language-source",
    "language-sql": "file:packages/language-sql",
    "language-text": "file:packages/language-text",
    "language-todo": "file:packages/language-todo",
    "language-toml": "file:packages/language-toml",
    "language-typescript": "file:packages/language-typescript",
    "language-xml": "file:packages/language-xml",
    "language-yaml": "file:packages/language-yaml",
    "less-cache": "pulsar-edit/less-cache#v2.0.1",
    "line-ending-selector": "file:packages/line-ending-selector",
    "line-top-index": "0.3.1",
    "link": "file:packages/link",
    "markdown-it": "^13.0.2",
    "markdown-it-emoji": "^2.0.2",
    "markdown-it-github-headings": "^2.0.1",
    "markdown-it-task-checkbox": "^1.0.6",
    "markdown-preview": "file:./packages/markdown-preview",
    "minimatch": "^3.0.3",
    "mocha": "6.2.3",
    "mocha-junit-reporter": "2.0.0",
    "mocha-multi-reporters": "^1.1.4",
    "mock-spawn": "^0.2.6",
    "normalize-package-data": "3.0.2",
    "notifications": "file:./packages/notifications",
    "nsfw": "2.2.2",
    "one-dark-syntax": "file:packages/one-dark-syntax",
    "one-dark-ui": "file:packages/one-dark-ui",
    "one-light-syntax": "file:packages/one-light-syntax",
    "one-light-ui": "file:packages/one-light-ui",
    "open-on-github": "file:packages/open-on-github",
    "package-generator": "file:packages/package-generator",
    "pathwatcher": "^8.1.2",
    "postcss": "8.4.31",
    "postcss-selector-parser": "6.0.4",
    "pulsar-updater": "file:packages/pulsar-updater",
    "resolve": "1.18.1",
    "scandal": "^3.2.0",
    "scoped-property-store": "^0.17.0",
    "scrollbar-style": "^4.0.1",
    "season": "^6.0.2",
    "second-mate": "https://github.com/pulsar-edit/second-mate.git#9686771",
    "semver": "7.5.2",
    "service-hub": "^0.7.4",
    "settings-view": "file:packages/settings-view",
    "sinon": "9.2.1",
    "snippets": "file:./packages/snippets",
    "solarized-dark-syntax": "file:packages/solarized-dark-syntax",
    "solarized-light-syntax": "file:packages/solarized-light-syntax",
    "spell-check": "file:packages/spell-check",
    "status-bar": "file:packages/status-bar",
    "styleguide": "file:./packages/styleguide",
    "superstring": "github:pulsar-edit/superstring#de97b496663fce40050bf2d66e1466ccfbd00943",
    "symbol-provider-ctags": "file:./packages/symbol-provider-ctags",
    "symbol-provider-tree-sitter": "file:./packages/symbol-provider-tree-sitter",
    "symbols-view": "file:./packages/symbols-view",
    "tabs": "file:packages/tabs",
    "temp": "0.9.4",
    "text-buffer": "^13.18.6",
    "timecop": "file:./packages/timecop",
    "tree-sitter": "0.20.0",
    "tree-view": "file:packages/tree-view",
    "typescript-simple": "github:pulsar-edit/typescript-simple#ccb03e558217030e8f261339281f1d69147934f7",
    "underscore-plus": "^1.7.0",
    "update-package-dependencies": "file:./packages/update-package-dependencies",
    "vscode-ripgrep": "1.9.0",
    "web-tree-sitter": "^0.20.7",
    "welcome": "file:packages/welcome",
    "whitespace": "file:./packages/whitespace",
    "winreg": "^1.2.1",
    "wrap-guide": "file:./packages/wrap-guide",
    "yaml-front-matter": "^4.1.1",
    "yargs": "17.6.2"
  },
  "packageDependencies": {
    "atom-dark-syntax": "file:./packages/atom-dark-syntax",
    "atom-dark-ui": "file:./packages/atom-dark-ui",
    "atom-light-syntax": "file:./packages/atom-light-syntax",
    "atom-light-ui": "file:./packages/atom-light-ui",
    "base16-tomorrow-dark-theme": "file:./packages/base16-tomorrow-dark-theme",
    "base16-tomorrow-light-theme": "file:./packages/base16-tomorrow-light-theme",
    "one-dark-ui": "file:./packages/one-dark-ui",
    "one-light-ui": "file:./packages/one-light-ui",
    "one-dark-syntax": "file:./packages/one-dark-syntax",
    "one-light-syntax": "file:./packages/one-light-syntax",
    "solarized-dark-syntax": "file:./packages/solarized-dark-syntax",
    "solarized-light-syntax": "file:./packages/solarized-light-syntax",
    "about": "file:./packages/about",
    "archive-view": "file:./packages/archive-view",
    "autocomplete-atom-api": "file:packages/autocomplete-atom-api",
    "autocomplete-css": "file:./packages/autocomplete-css",
    "autocomplete-html": "file:./packages/autocomplete-html",
    "autocomplete-plus": "file:./packages/autocomplete-plus",
    "autocomplete-snippets": "file:./packages/autocomplete-snippets",
    "autoflow": "file:./packages/autoflow",
    "autosave": "file:./packages/autosave",
    "background-tips": "file:./packages/background-tips",
    "bookmarks": "file:./packages/bookmarks",
    "bracket-matcher": "file:./packages/bracket-matcher",
    "command-palette": "file:./packages/command-palette",
    "dalek": "file:./packages/dalek",
    "deprecation-cop": "file:./packages/deprecation-cop",
    "dev-live-reload": "file:./packages/dev-live-reload",
    "encoding-selector": "file:./packages/encoding-selector",
    "exception-reporting": "file:./packages/exception-reporting",
    "find-and-replace": "file:./packages/find-and-replace",
    "fuzzy-finder": "file:packages/fuzzy-finder",
    "github": "0.36.20",
    "git-diff": "file:./packages/git-diff",
    "go-to-line": "file:./packages/go-to-line",
    "grammar-selector": "file:./packages/grammar-selector",
    "image-view": "file:./packages/image-view",
    "incompatible-packages": "file:./packages/incompatible-packages",
    "keybinding-resolver": "file:./packages/keybinding-resolver",
    "line-ending-selector": "file:./packages/line-ending-selector",
    "link": "file:./packages/link",
    "markdown-preview": "file:./packages/markdown-preview",
    "notifications": "file:./packages/notifications",
    "open-on-github": "file:./packages/open-on-github",
    "package-generator": "file:./packages/package-generator",
    "pulsar-updater": "file:./packages/pulsar-updater",
    "settings-view": "file:./packages/settings-view",
    "snippets": "file:./packages/snippets",
    "spell-check": "file:./packages/spell-check",
    "status-bar": "file:./packages/status-bar",
    "styleguide": "file:./packages/styleguide",
    "symbol-provider-ctags": "file:./packages/symbol-provider-ctags",
    "symbol-provider-tree-sitter": "file:./packages/symbol-provider-tree-sitter",
    "symbols-view": "file:./packages/symbols-view",
    "tabs": "file:./packages/tabs",
    "timecop": "file:./packages/timecop",
    "tree-view": "file:./packages/tree-view",
    "update-package-dependencies": "file:./packages/update-package-dependencies",
    "welcome": "file:./packages/welcome",
    "whitespace": "file:./packages/whitespace",
    "wrap-guide": "file:./packages/wrap-guide",
    "language-c": "file:./packages/language-c",
    "language-clojure": "file:./packages/language-clojure",
    "language-coffee-script": "file:./packages/language-coffee-script",
    "language-csharp": "file:./packages/language-csharp",
    "language-css": "file:./packages/language-css",
    "language-gfm": "file:./packages/language-gfm",
    "language-git": "file:./packages/language-git",
    "language-go": "file:./packages/language-go",
    "language-html": "file:./packages/language-html",
    "language-hyperlink": "file:./packages/language-hyperlink",
    "language-java": "file:./packages/language-java",
    "language-javascript": "file:./packages/language-javascript",
    "language-json": "file:./packages/language-json",
    "language-less": "file:./packages/language-less",
    "language-make": "file:./packages/language-make",
    "language-mustache": "file:./packages/language-mustache",
    "language-objective-c": "file:./packages/language-objective-c",
    "language-perl": "file:./packages/language-perl",
    "language-php": "file:./packages/language-php",
    "language-property-list": "file:./packages/language-property-list",
    "language-python": "file:./packages/language-python",
    "language-ruby": "file:./packages/language-ruby",
    "language-ruby-on-rails": "file:./packages/language-ruby-on-rails",
    "language-rust-bundled": "file:./packages/language-rust-bundled",
    "language-sass": "file:./packages/language-sass",
    "language-shellscript": "file:./packages/language-shellscript",
    "language-source": "file:./packages/language-source",
    "language-sql": "file:./packages/language-sql",
    "language-text": "file:./packages/language-text",
    "language-todo": "file:./packages/language-todo",
    "language-toml": "file:./packages/language-toml",
    "language-typescript": "file:./packages/language-typescript",
    "language-xml": "file:./packages/language-xml",
    "language-yaml": "file:./packages/language-yaml"
  },
  "private": true,
  "scripts": {
    "build": "electron-rebuild",
    "build:apm": "cd ppm && yarn install",
    "start": "electron --no-sandbox --enable-logging . -f",
    "dist": "node script/electron-builder.js",
    "js-docs": "jsdoc2md --files src --configure docs/.jsdoc.json > ./docs/Pulsar-API-Documentation.md",
    "private-js-docs": "jsdoc2md --private --files src --configure docs/.jsdoc.json > ./docs/Source-Code-Documentation.md"
  },
  "devDependencies": {
    "@electron/notarize": "^1.2.3",
    "@playwright/test": "1.22.2",
    "electron": "12.2.3",
    "electron-builder": "23.3.1",
    "electron-rebuild": "3.2.7",
    "eslint": "^8.33.0",
    "eslint-plugin-jsdoc": "^39.7.4",
    "eslint-plugin-node": "^11.1.0",
    "jsdoc-to-markdown": "^8.0.0",
    "playwright": "1.22.2",
    "playwright-core": "1.22.2",
    "random-seed": "0.3.0",
    "webdriverio": "7.20.9"
  }
}
