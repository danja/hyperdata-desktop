This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-10-19T15:19:10.782Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
packages/
  about/
    lib/
      components/
        about-view.js
        atom-logo.js
      about.js
      etch-component.js
      main.js
      update-manager.js
  command-palette/
    lib/
      command-palette-package.js
      command-palette-view.js
  keybinding-resolver/
    lib/
      keybinding-resolver-view.js
      main.js
  markdown-preview/
    lib/
      language-ids/
        chroma.js
        highlightjs.js
        linguist.js
        rouge.js
      extension-helper.js
      main.js
      markdown-preview-view.js
      renderer.js
  notifications/
    lib/
      command-logger.js
      main.js
      notification-element.js
      notification-issue.js
      notifications-log-item.js
      notifications-log.js
      template-helper.js
      user-utilities.js
  package-generator/
    lib/
      main.js
      package-generator-view.js
  settings-view/
    lib/
      atom-io-client.js
      badge-view.js
      collapsible-section-panel.js
      editor-panel.js
      error-view.js
      general-panel.js
      install-panel.js
      installed-packages-panel.js
      keybindings-panel.js
      list-view.js
      list.js
      main.js
      package-card.js
      package-detail-view.js
      package-grammars-view.js
      package-keymap-view.js
      package-manager.js
      package-readme-view.js
      package-snippets-view.js
      package-updates-status-view.js
      rich-description.js
      rich-title.js
      search-setting-view.js
      search-settings-panel.js
      settings-icon-status-view.js
      settings-panel.js
      settings-view.js
      system-windows-panel.js
      themes-panel.js
      updates-panel.js
      uri-handler-panel.js
      utils.js
src/
  main-process/
    atom-window.js
  config-schema.js
  notification-manager.js
  notification.js
  package-manager.js
  package-transpilation-registry.js
  package.js
  pane-container.js
  pane.js
  text-editor-component.js
  text-editor.js
  workspace-element.js
  workspace.js
static/
  index.html
  index.js
package.json

================================================================
Repository Files
================================================================

================
File: packages/about/lib/components/about-view.js
================
const { Disposable } = require('atom');
const etch = require('etch');
const { shell } = require('electron');
const AtomLogo = require('./atom-logo');
const EtchComponent = require('../etch-component');

const $ = etch.dom;

module.exports = class AboutView extends EtchComponent {
  handleAtomVersionClick(e) {
    e.preventDefault();
    atom.clipboard.write(this.props.currentAtomVersion);
  }

  handleElectronVersionClick(e) {
    e.preventDefault();
    atom.clipboard.write(this.props.currentElectronVersion);
  }

  handleChromeVersionClick(e) {
    e.preventDefault();
    atom.clipboard.write(this.props.currentChromeVersion);
  }

  handleNodeVersionClick(e) {
    e.preventDefault();
    atom.clipboard.write(this.props.currentNodeVersion);
  }

  handleReleaseNotesClick(e) {
    e.preventDefault();
    shell.openExternal(
      this.props.updateManager.getReleaseNotesURLForCurrentVersion()
    );
  }

  handleLicenseClick(e) {
    e.preventDefault();
    atom.commands.dispatch(
      atom.views.getView(atom.workspace),
      'application:open-license'
    );
  }

  handleTermsOfUseClick(e) {
    e.preventDefault();
    shell.openExternal('https://atom.io/terms'); //If we use this then this URL will need updating but button disabled (L#182)
    // TODO Update to Privacy Policy once `pulsar-edit.github.io` #161 is resolved
  }

  handleHowToUpdateClick(e) {
    e.preventDefault();
    shell.openExternal(
            'https://github.com/pulsar-edit/pulsar/tree/master/packages/pulsar-updater#readme'
    );
  }

  executeUpdateAction(e) {
    e.preventDefault();
    atom.commands.dispatch(
      atom.views.getView(atom.workspace),
      'pulsar-updater:check-for-update'
    );
  }

  handleShowMoreClick(e) {
    e.preventDefault();
    var showMoreDiv = document.querySelector('.show-more');
    var showMoreText = document.querySelector('.about-more-expand');
    switch (showMoreText.textContent) {
      case 'Show more':
        showMoreDiv.classList.toggle('hidden');
        showMoreText.textContent = 'Hide';
        break;
      case 'Hide':
        showMoreDiv.classList.toggle('hidden');
        showMoreText.textContent = 'Show more';
        break;
    }
  }

  render() {
    return $.div(
      { className: 'pane-item native-key-bindings about' },
      $.div(
        { className: 'about-container min-width-min-content' },
        $.header(
          { className: 'about-header' },
          $.a(
            { className: 'about-atom-io', href: `${atom.branding.urlWeb}`, },
            $(AtomLogo)
          ),
          $.div(
            { className: 'about-header-info' },
            $.span(
              {
                className: 'about-version-container atom',
                onclick: this.handleAtomVersionClick.bind(this)
              },
              $.span(
                { className: 'about-version' },
                `${this.props.currentAtomVersion} ${process.arch}`
              ),
              $.span({ className: 'icon icon-clippy about-copy-version' })
            ),
            $.a(
              {
                className: 'about-header-release-notes',
                onclick: this.handleReleaseNotesClick.bind(this)
              },
              'Release Notes'
            )
          ),
          $.span(
            {
              className:
                'about-version-container show-more-expand',
              onclick: this.handleShowMoreClick.bind(this)
            },
            $.span({ className: 'about-more-expand' }, 'Show more')
          ),
          $.div(
            { className: 'show-more hidden about-more-info' },
            $.div(
              { className: 'about-more-info' },
              $.span(
                {
                  className: 'about-version-container inline-block electron',
                  onclick: this.handleElectronVersionClick.bind(this)
                },
                $.span(
                  { className: 'about-more-version' },
                  `Electron: ${this.props.currentElectronVersion} `
                ),
                $.span({ className: 'icon icon-clippy about-copy-version' })
              )
            ),
            $.div(
              { className: 'about-more-info' },
              $.span(
                {
                  className: 'about-version-container inline-block chrome',
                  onclick: this.handleChromeVersionClick.bind(this)
                },
                $.span(
                  { className: 'about-more-version' },
                  `Chrome: ${this.props.currentChromeVersion} `
                ),
                $.span({ className: 'icon icon-clippy about-copy-version' })
              )
            ),
            $.div(
              { className: 'about-more-info' },
              $.span(
                {
                  className: 'about-version-container inline-block node',
                  onclick: this.handleNodeVersionClick.bind(this)
                },
                $.span(
                  { className: 'about-more-version' },
                  `Node: ${this.props.currentNodeVersion} `
                ),
                $.span({ className: 'icon icon-clippy about-copy-version' })
              )
            )
          )
        )
      ),

      $.div(
        { className: 'about-updates group-start min-width-min-content' },
        $.div(
          { className: 'about-updates-box' },
          $.div(
            { className: 'about-updates-status' },
            $.div(
              { className: 'about-updates-item app-unsupported' },
              $.span(
                { className: 'about-updates-label is-strong' },
                'Updates have been moved to the package ', $.code({style: {'white-space': 'nowrap'}}, 'pulsar-updater'), '.',
                $.br()
              ),
              $.a(
                {
                  className: 'about-updates-instructions',
                  onclick: this.handleHowToUpdateClick.bind(this)
                },
                'How to update'
              )
            )
          ),
          this.renderUpdateChecker()
        )
      ),

      $.div(
        { className: 'about-actions group-item' },
        $.div(
          { className: 'btn-group' },
          $.button(
            {
              className: 'btn view-license',
              onclick: this.handleLicenseClick.bind(this)
            },
            'License'
          ),
          //Disabled the below as we don't have this but can reuse if there is the need
          /*$.button(
            {
              className: 'btn terms-of-use',
              onclick: this.handleTermsOfUseClick.bind(this)
            },
            'Terms of Use'
          )*/
        )
      ),

      $.div(
        { className: 'about-love group-start' },
        $.a({ className: 'icon icon-code', href: `${atom.branding.urlGH}` }),
        $.span({ className: 'inline' }, ' with '),
        $.a({ className: 'icon icon-heart', href: `${atom.branding.urlWeb}` + "community" }),
        $.span({ className: 'inline' }, ' by '),
        //$.a({ className: 'icon icon-logo-github', href: `${atom.branding.urlWeb}` }) Replace icon with Pulsar word logo and delete following line
        $.a({ className: 'inline', href: `${atom.branding.urlWeb}` }, 'Pulsar Team')
      ),
    );
  }

  renderUpdateChecker() {
    if (atom.packages.isPackageDisabled("pulsar-updater")) {
      return $.div(
        { className: 'about-updates-item app-unsupported' },
        $.span(
          { className: 'about-updates-label is-strong' },
          'Enable `pulsar-updater` to check for updates'
        )
      );
    } else {
      return $.button(
        {
          className: 'btn about-update-action-button',
          onclick: this.executeUpdateAction.bind(this),
          style: {
            display: 'block',
            margin: '0 .5em'
          }
        },
        'Check Now'
      );
    }
  }

  serialize() {
    return {
      deserializer: this.constructor.name,
      uri: this.props.uri
    };
  }

  onDidChangeTitle() {
    return new Disposable();
  }

  onDidChangeModified() {
    return new Disposable();
  }

  getTitle() {
    return 'About';
  }

  getIconName() {
    return 'info';
  }
};

================
File: packages/about/lib/components/atom-logo.js
================
/** @babel */
/** @jsx etch.dom */

const etch = require('etch');
const EtchComponent = require('../etch-component');

const $ = etch.dom;

module.exports = class AtomLogo extends EtchComponent {
  render() {
    return (
      <svg className='about-logo' xmlns="http://www.w3.org/2000/svg" version="1.1" x="0px" y="0px" viewBox="0 0 570.40002 191.69999" width="570.40002" height="100">
      <defs id="defs400"></defs>
      <path
         fill="currentColor"
         id="path42"
         d="m 95.9,72.6 c -12.8,0 -23.2,10.4 -23.2,23.2 0,12.8 10.4,23.2 23.2,23.2 12.8,0 23.2,-10.4 23.2,-23.2 0,-12.8 -10.4,-23.2 -23.2,-23.2 z"
         class="st0" />
         <path fill="currentColor" id="path44" d="m 67.4,127.7 c 0.8,0.3 1.6,0.5 2.4,0.5 1.6,0 3.1,-0.6 4.3,-1.8 2.4,-2.4 2.4,-6.3 0,-8.7 -1.2,-1.2 -2.8,-1.8 -4.4,-1.8 -1.6,0 -3.2,0.6 -4.4,1.8 -1.8,1.8 -2.3,4.5 -1.3,6.7 l -12.4,4.8 -51.6,61.4 1.1,1.1 61.4,-51.6 z" class="st0" />
         <path fill="currentColor" id="path46" d="m 58,152.1 c 5.4,4.6 10.9,8.7 16.7,12.4 2.1,-0.8 6.7,-2.6 8.7,-3.8 -7.1,-4.1 -12.8,-8.3 -19.3,-13.8 z" class="st0" />
         <path fill="currentColor" id="path48" d="M 129.2,51.6 124.4,64 c -0.8,-0.3 -1.6,-0.5 -2.3,-0.5 -1.6,0 -3.1,0.6 -4.3,1.8 -2.4,2.4 -2.4,6.3 0,8.7 1.2,1.2 2.8,1.8 4.4,1.8 1.6,0 3.2,-0.6 4.4,-1.8 1.8,-1.8 2.3,-4.5 1.3,-6.7 L 140.3,62.5 191.9,1.1 190.8,0 Z" class="st0" />
         <path fill="currentColor" id="path50" d="m 121.3,54.8 c -7.4,-4.6 -16.1,-7.3 -25.4,-7.3 -26.6,0 -48.3,21.7 -48.3,48.3 0,9.3 2.7,18 7.3,25.4 l 2.6,-1 c 0.4,-2.6 1.6,-5 3.5,-7 0.4,-0.4 0.8,-0.7 1.3,-1.1 -2.4,-4.9 -3.8,-10.5 -3.8,-16.3 0,-20.6 16.8,-37.4 37.4,-37.4 5.9,0 11.4,1.4 16.3,3.8 0.3,-0.4 0.6,-0.9 1,-1.3 1.9,-1.9 4.3,-3.1 7,-3.5 z" class="st0" />
         <path fill="currentColor" id="path52" d="m 95.9,133.2 c -5.9,0 -11.4,-1.4 -16.3,-3.8 -0.3,0.4 -0.6,0.9 -1,1.3 -1.9,1.9 -4.3,3.1 -7,3.5 l -1,2.6 c 7.4,4.6 16.1,7.3 25.4,7.3 26.6,0 48.3,-21.7 48.3,-48.3 0,-9.3 -2.7,-18 -7.3,-25.4 l -2.6,1 c -0.4,2.6 -1.6,5 -3.5,7 -0.4,0.4 -0.8,0.7 -1.3,1.1 2.4,4.9 3.8,10.5 3.8,16.3 -0.1,20.7 -16.9,37.4 -37.5,37.4 z" class="st0" />
         <path fill="currentColor" id="path54" d="m 16.2,95.9 c -10,24.6 -10.5,48.8 0.1,65.7 l 5.3,-6.3 c -7.2,-13.1 -7.2,-30.8 -0.9,-49.5 5,9.7 11.4,19.2 19,28 l 5.1,-6 C 36.3,117.7 29.5,106.9 24.6,95.9 31,81.5 40.9,67 54,53.9 66.8,41.1 81.2,31.1 95.9,24.5 c 10.8,4.8 21.7,11.5 32,20.2 l 6,-5.1 c -9,-7.7 -18.6,-14 -28.1,-18.9 3.2,-1.1 6.3,-2 9.4,-2.7 15.8,-3.6 29.6,-2.3 40.2,3.5 l 6.3,-5.3 C 149.2,8.2 132.4,6.1 113.5,10.4 107.6,11.7 101.7,13.6 95.8,16.1 67.2,4.4 39.2,5.7 22.5,22.4 9.6,35.3 5.3,55.2 10.5,78.3 c 1.3,5.9 3.3,11.8 5.7,17.6 z m 11.7,-68 C 41.1,14.7 62.8,12.8 86,20.6 72.8,27.4 59.9,36.8 48.4,48.4 36.7,60.1 27.4,73 20.7,86 19.7,82.9 18.7,79.8 18,76.6 13.5,56.1 17,38.8 27.9,27.9 Z" class="st0" />
         <path fill="currentColor" id="path56" d="m 147.1,63.9 c 8.6,10.3 15.4,21.2 20.2,31.9 l -0.1,0.3 c -6.6,14.7 -16.7,29.1 -29.2,41.6 -18.4,18.4 -40.1,31.1 -61.2,35.9 -15.8,3.6 -29.6,2.3 -40.2,-3.5 l -6.3,5.3 c 8.3,5.3 18.4,8 29.7,8 5.9,0 12.1,-0.7 18.5,-2.2 22.5,-5.1 45.6,-18.5 65,-37.9 11.4,-11.4 20.9,-24.3 27.8,-37.6 7.8,23.2 5.9,44.9 -7.3,58.1 -10,10 -25.7,13.7 -43.8,10.8 -3.4,2.1 -6.8,4 -10.3,5.7 7.7,2 15.1,3.1 22,3.1 15.2,0 28.3,-4.8 37.6,-14.1 C 193.7,145.1 185.6,97 152.3,57.9 Z" class="st0" />
         <path fill="currentColor" id="path58" d="m 170.2,36.4 c 4.4,8.1 6.1,18.2 5.1,29.5 2.3,3.6 4.4,7.3 6.2,10.9 3.8,-18.3 1.7,-34.5 -6.1,-46.8 z" class="st0" />
         <path fill="currentColor" id="path60" d="m 263.9,70.6 h -41.6 v 56.7 h 9.7 v -19.7 h 0.7 l 31.1,-0.1 c 3,0 5.5,-1.1 7.6,-3.2 2.1,-2.1 3.2,-4.6 3.2,-7.5 V 81.3 c 0,-2.9 -1.1,-5.5 -3.2,-7.5 -2,-2.1 -4.6,-3.2 -7.5,-3.2 z m 1,26.3 c 0,0.6 -0.4,1 -1,1 h -30.8 c -0.6,0 -1,-0.4 -1,-1 V 81.4 c 0,-0.6 0.4,-1 1,-1 h 30.8 c 0.6,0 1,0.4 1,1 z" class="st0" />
         <path fill="currentColor" id="path62" d="m 324.5,116.7 c 0,0.7 -0.5,1 -0.9,1 h -30.9 c -0.6,0 -1,-0.4 -1,-1 V 70.6 H 282 v 46.1 c 0,3 1,5.5 3.1,7.6 2.1,2.1 4.6,3.1 7.6,3.1 h 30.9 c 2.9,0 5.5,-1.1 7.5,-3.1 2.1,-2.1 3.2,-4.6 3.2,-7.6 V 70.6 h -9.8 z" class="st0" />
         <polygon transform="translate(697.6,5098.3)" fill="currentColor" id="polygon64" points="-353.6,-4970.9 -307.4,-4970.9 -307.4,-4980.7 -343.8,-4980.7 -343.8,-5027.8 -353.6,-5027.8 " class="st0" />
         <path fill="currentColor" id="path66" d="m 436.4,70.5 h -30.9 c -3,0 -5.5,1.1 -7.6,3.1 -2.1,2.1 -3.1,4.6 -3.1,7.6 v 11.9 c 0,3 1,5.5 3.1,7.6 2.1,2.1 4.6,3.1 7.6,3.1 h 30.9 c 0.4,0 0.9,0.3 0.9,1 v 11.9 c 0,0.7 -0.5,1 -0.9,1 h -30.9 c -0.6,0 -1,-0.4 -1,-1 v -4 h -9.7 v 4 c 0,3 1,5.5 3.1,7.6 2.1,2.1 4.6,3.1 7.6,3.1 h 30.9 c 2.9,0 5.5,-1.1 7.5,-3.1 2.1,-2.1 3.2,-4.6 3.2,-7.6 v -11.9 c 0,-3 -1.1,-5.5 -3.2,-7.6 -2.1,-2.1 -4.6,-3.1 -7.5,-3.1 h -30.9 c -0.6,0 -1,-0.4 -1,-1 V 81.2 c 0,-0.6 0.4,-1 1,-1 h 30.9 c 0.4,0 0.9,0.3 0.9,1 v 4 h 9.8 v -4 c 0,-3 -1.1,-5.5 -3.2,-7.6 -2,-2 -4.6,-3.1 -7.5,-3.1 z" class="st0" />
         <path fill="currentColor" id="path68" d="m 498.3,70.5 h -30.8 c -3,0 -5.5,1.1 -7.6,3.1 -2.1,2.1 -3.1,4.6 -3.1,7.6 v 46.1 h 9.7 v -19.4 h 32.8 v 19.4 h 9.8 V 81.2 c 0,-3 -1.1,-5.5 -3.2,-7.6 -2.1,-2 -4.7,-3.1 -7.6,-3.1 z m 1,27.8 h -32.8 v -17 c 0,-0.6 0.4,-1 1,-1 h 30.8 c 0.6,0 1,0.4 1,1 z" class="st0" />
         <path fill="currentColor" id="path70" d="m 567.2,104.4 c 2.1,-2.1 3.2,-4.6 3.2,-7.5 V 81.4 c 0,-2.9 -1.1,-5.5 -3.2,-7.5 -2.1,-2.1 -4.7,-3.2 -7.6,-3.2 h -41.5 v 56.7 h 9.7 v -19.8 h 15 l 0.1,0.2 16.5,19.6 h 10.9 v -2.1 l -14.8,-17.6 h 4 c 3.1,-0.1 5.6,-1.2 7.7,-3.3 z m -38.4,-6.5 c -0.6,0 -1,-0.4 -1,-1 V 81.4 c 0,-0.6 0.4,-1 1,-1 h 30.8 c 0.6,0 1,0.4 1,1 v 15.5 c 0,0.6 -0.4,1 -1,1 z" class="st0" />
      </svg>
    )
  }
};

================
File: packages/about/lib/about.js
================
const { CompositeDisposable, Emitter } = require('atom');
const AboutView = require('./components/about-view');

// Deferred requires
let shell;

module.exports = class About {
  constructor(initialState) {
    this.subscriptions = new CompositeDisposable();
    this.emitter = new Emitter();

    this.state = initialState;
    this.views = {
      aboutView: null
    };

    this.subscriptions.add(
      atom.workspace.addOpener(uriToOpen => {
        if (uriToOpen === this.state.uri) {
          return this.deserialize();
        }
      })
    );

    this.subscriptions.add(
      atom.commands.add('atom-workspace', 'about:view-release-notes', () => {
        shell = shell || require('electron').shell;
        shell.openExternal(
          this.state.updateManager.getReleaseNotesURLForCurrentVersion()
        );
      })
    );
  }

  destroy() {
    if (this.views.aboutView) this.views.aboutView.destroy();
    this.views.aboutView = null;

    this.setState({ updateManager: null });

    this.subscriptions.dispose();
  }

  setState(newState) {
    if (newState && typeof newState === 'object') {
      let { state } = this;
      this.state = Object.assign({}, state, newState);

      this.didChange();
    }
  }

  didChange() {
    this.emitter.emit('did-change');
  }

  onDidChange(callback) {
    this.emitter.on('did-change', callback);
  }

  deserialize(state) {
    if (!this.views.aboutView) {
      this.setState(state);

      this.views.aboutView = new AboutView({
        uri: this.state.uri,
        updateManager: this.state.updateManager,
        currentAtomVersion: this.state.currentAtomVersion,
        currentElectronVersion: this.state.currentElectronVersion,
        currentChromeVersion: this.state.currentChromeVersion,
        currentNodeVersion: this.state.currentNodeVersion
      });
      this.handleStateChanges();
    }

    return this.views.aboutView;
  }

  handleStateChanges() {
    this.onDidChange(() => {
      if (this.views.aboutView) {
        this.views.aboutView.update({
          updateManager: this.state.updateManager,
          currentAtomVersion: this.state.currentAtomVersion,
          currentElectronVersion: this.state.currentElectronVersion,
          currentChromeVersion: this.state.currentChromeVersion,
          currentNodeVersion: this.state.currentNodeVersion
        });
      }
    });
  }
};

================
File: packages/about/lib/etch-component.js
================
const etch = require('etch');

/*
  Public: Abstract class for handling the initialization
  boilerplate of an Etch component.
*/
module.exports = class EtchComponent {
  constructor(props) {
    this.props = props;

    etch.initialize(this);
    EtchComponent.setScheduler(atom.views);
  }

  /*
    Public: Gets the scheduler Etch uses for coordinating DOM updates.

    Returns a {Scheduler}
  */
  static getScheduler() {
    return etch.getScheduler();
  }

  /*
    Public: Sets the scheduler Etch uses for coordinating DOM updates.

    * `scheduler` {Scheduler}
  */
  static setScheduler(scheduler) {
    etch.setScheduler(scheduler);
  }

  /*
    Public: Updates the component's properties and re-renders it. Only the
    properties you specify in this object will update – any other properties
    the component stores will be unaffected.

    * `props` an {Object} representing the properties you want to update
  */
  update(props) {
    let oldProps = this.props;
    this.props = Object.assign({}, oldProps, props);
    return etch.update(this);
  }

  /*
    Public: Destroys the component, removing it from the DOM.
  */
  destroy() {
    etch.destroy(this);
  }

  render() {
    throw new Error('Etch components must implement a `render` method');
  }
};

================
File: packages/about/lib/main.js
================
const UpdateManager = require('./update-manager');
const About = require('./about');
let updateManager;

// The local storage key for the available update version.
const AboutURI = 'atom://about';

module.exports = {
  activate() {
    this.createModel();
  },

  deactivate() {
    this.model.destroy();

    if (updateManager) {
      updateManager = undefined;
    }
  },

  deserializeAboutView(state) {
    if (!this.model) {
      this.createModel();
    }

    return this.model.deserialize(state);
  },

  createModel() {
    updateManager = updateManager || new UpdateManager();

    this.model = new About({
      uri: AboutURI,
      currentAtomVersion: atom.getVersion(),
      currentElectronVersion: process.versions.electron,
      currentChromeVersion: process.versions.chrome,
      currentNodeVersion: process.version,
      updateManager: updateManager
    });
  }

};

================
File: packages/about/lib/update-manager.js
================
let UpdateManager = class UpdateManager {
  constructor() {
    this.currentVersion = atom.getVersion();
  }

  getReleaseNotesURLForCurrentVersion() {
    return this.getReleaseNotesURLForVersion(this.currentVersion);
  }

  getReleaseNotesURLForVersion(appVersion) {
    if (appVersion.startsWith('v')) {
      appVersion = appVersion.replace("v", "");
    }

    return `https://github.com/pulsar-edit/pulsar/blob/master/CHANGELOG.md#${appVersion.replace(/\./g, "")}`;
  }
};

module.exports = UpdateManager;

================
File: packages/command-palette/lib/command-palette-package.js
================
/** @babel */

import {CompositeDisposable} from 'atom'
import CommandPaletteView from './command-palette-view'

class CommandPalettePackage {
  activate () {
    this.commandPaletteView = new CommandPaletteView()
    this.disposables = new CompositeDisposable()
    this.disposables.add(atom.commands.add('atom-workspace', {
      'command-palette:toggle': () => {
        this.commandPaletteView.toggle()
      },
      'command-palette:show-hidden-commands': () => {
        this.commandPaletteView.show(true)
      }
    }))
    this.disposables.add(atom.config.observe('command-palette.preserveLastSearch', (newValue) => {
      this.commandPaletteView.update({preserveLastSearch: newValue})
    }))
    return this.commandPaletteView.show()
  }

  async deactivate () {
    this.disposables.dispose()
    await this.commandPaletteView.destroy()
  }
}

const pack = new CommandPalettePackage()
export default pack

================
File: packages/command-palette/lib/command-palette-view.js
================
/** @babel */

import SelectListView from 'atom-select-list'
import {humanizeKeystroke} from 'underscore-plus'

export default class CommandPaletteView {
  constructor (initiallyVisibleItemCount = 10) {
    this.keyBindingsForActiveElement = []
    this.selectListView = new SelectListView({
      initiallyVisibleItemCount: initiallyVisibleItemCount, // just for being able to disable visible-on-render in spec
      items: [],
      filter: this.filter,
      emptyMessage: 'No matches found',
      elementForItem: (item, {index, selected, visible}) => {
        if (!visible) {
          return document.createElement("li")
        }

        const li = document.createElement('li')
        li.classList.add('event', 'two-lines')
        li.dataset.eventName = item.name

        const rightBlock = document.createElement('div')
        rightBlock.classList.add('pull-right')

        this.keyBindingsForActiveElement
        .filter(({command}) => command === item.name)
        .forEach(keyBinding => {
          const kbd = document.createElement('kbd')
          kbd.classList.add('key-binding')
          kbd.textContent = humanizeKeystroke(keyBinding.keystrokes)
          rightBlock.appendChild(kbd)
        })
        li.appendChild(rightBlock)

        const leftBlock = document.createElement('div')
        const titleEl = document.createElement('div')
        titleEl.classList.add('primary-line')
        titleEl.title = item.name
        leftBlock.appendChild(titleEl)

        const query = this.selectListView.getQuery()
        this.highlightMatchesInElement(item.displayName, query, titleEl)

        if (selected) {
          let secondaryEl = document.createElement('div')
          secondaryEl.classList.add('secondary-line')
          secondaryEl.style.display = 'flex'

          if (typeof item.description === 'string') {
            secondaryEl.appendChild(this.createDescription(item.description, query))
          }

          if (Array.isArray(item.tags)) {
            const matchingTags = item.tags
              .map(t => [t, atom.ui.fuzzyMatcher.score(t, query)])
              .filter(([t, s]) => s > 0)
              .sort((a, b) => a.s - b.s)
              .map(([t, s]) => t)

            if (matchingTags.length > 0) {
              secondaryEl.appendChild(this.createTags(matchingTags, query))
            }
          }

          leftBlock.appendChild(secondaryEl)
        }

        li.appendChild(leftBlock)
        return li
      },
      didConfirmSelection: (keyBinding) => {
        this.hide()
        const event = new CustomEvent(keyBinding.name, {bubbles: true, cancelable: true})
        this.activeElement.dispatchEvent(event)
      },
      didCancelSelection: () => {
        this.hide()
      }
    })
    this.selectListView.element.classList.add('command-palette')
  }

  async destroy () {
    await this.selectListView.destroy()
  }

  toggle () {
    if (this.panel && this.panel.isVisible()) {
      this.hide()
      return Promise.resolve()
    } else {
      return this.show()
    }
  }

  async show (showHiddenCommands = false) {
    if (!this.panel) {
      this.panel = atom.workspace.addModalPanel({item: this.selectListView})
    }

    if (!this.preserveLastSearch) {
      this.selectListView.reset()
    } else {
      this.selectListView.refs.queryEditor.selectAll()
    }

    this.activeElement = (document.activeElement === document.body) ? atom.views.getView(atom.workspace) : document.activeElement
    this.keyBindingsForActiveElement = atom.keymaps.findKeyBindings({target: this.activeElement})
    const commandsForActiveElement = atom.commands
        .findCommands({target: this.activeElement})
        .filter(command => showHiddenCommands === !!command.hiddenInCommandPalette)
    commandsForActiveElement.sort((a, b) => a.displayName.localeCompare(b.displayName))
    await this.selectListView.update({items: commandsForActiveElement})

    this.previouslyFocusedElement = document.activeElement
    this.panel.show()
    this.selectListView.focus()
  }

  hide () {
    this.panel.hide()
    if (this.previouslyFocusedElement) {
      this.previouslyFocusedElement.focus()
      this.previouslyFocusedElement = null
    }
  }

  async update (props) {
    if (props.hasOwnProperty('preserveLastSearch')) {
      this.preserveLastSearch = props.preserveLastSearch
    }
  }

  highlightMatchesInElement (text, query, el) {
    const matches = atom.ui.fuzzyMatcher.match(text, query, {recordMatchIndexes: true})
    let matchedChars = []
    let lastIndex = 0;
    const matchIndexes = matches ? (matches.matchIndexes ?? []) : []
    matchIndexes.forEach(matchIndex => {
      const unmatched = text.substring(lastIndex, matchIndex)
      if (unmatched) {
        if (matchedChars.length > 0) {
          const matchSpan = document.createElement('span')
          matchSpan.classList.add('character-match')
          matchSpan.textContent = matchedChars.join('')
          el.appendChild(matchSpan)
          matchedChars = []
        }

        el.appendChild(document.createTextNode(unmatched))
      }

      matchedChars.push(text[matchIndex])
      lastIndex = matchIndex + 1
    })

    if (matchedChars.length > 0) {
      const matchSpan = document.createElement('span')
      matchSpan.classList.add('character-match')
      matchSpan.textContent = matchedChars.join('')
      el.appendChild(matchSpan)
    }

    const unmatched = text.substring(lastIndex)
    if (unmatched) {
      el.appendChild(document.createTextNode(unmatched))
    }
  }

  filter = (items, query) => {
    if (query.length === 0) {
      return items
    }

    const scoredItems = []
    for (const item of items) {
      let score = atom.ui.fuzzyMatcher.score(item.displayName, query)
      if (item.tags) {
        score += item.tags.reduce(
          (currentScore, tag) => currentScore + atom.ui.fuzzyMatcher.score(tag, query),
          0
        )
      }
      if (item.description) {
        score += atom.ui.fuzzyMatcher.score(item.description, query)
      }

      if (score > 0) {
        scoredItems.push({item, score})
      }
    }
    scoredItems.sort((a, b) => b.score - a.score)
    return scoredItems.map((i) => i.item)
  }

  createDescription (description, query) {
    const descriptionEl = document.createElement('div')

    // in case of overflow, give full contents on long hover
    descriptionEl.title = description

    Object.assign(descriptionEl.style, {
      flexGrow: 1,
      flexShrink: 1,
      textOverflow: 'ellipsis',
      whiteSpace: 'nowrap',
      overflow: 'hidden'
    })
    this.highlightMatchesInElement(description, query, descriptionEl)
    return descriptionEl
  }

  createTag (tagText, query) {
    const tagEl = document.createElement('li')
    Object.assign(tagEl.style, {
      borderBottom: 0,
      display: 'inline',
      padding: 0
    })
    this.highlightMatchesInElement(tagText, query, tagEl)
    return tagEl
  }

  createTags (matchingTags, query) {
    const tagsEl = document.createElement('ol')
    Object.assign(tagsEl.style, {
      display: 'inline',
      marginLeft: '4px',
      flexShrink: 0,
      padding: 0
    })

    const introEl = document.createElement('strong')
    introEl.textContent = 'matching tags: '

    tagsEl.appendChild(introEl)
    matchingTags.map(t => this.createTag(t, query)).forEach((tagEl, i) => {
      tagsEl.appendChild(tagEl)
      if (i < matchingTags.length - 1) {
        const commaSpace = document.createElement('span')
        commaSpace.textContent = ', '
        tagsEl.appendChild(commaSpace)
      }
    })
    return tagsEl
  }
}

================
File: packages/keybinding-resolver/lib/keybinding-resolver-view.js
================
/** @babel */
/** @jsx etch.dom */

import fs from 'fs-plus'
import etch from 'etch'
import {CompositeDisposable} from 'atom'
import path from 'path'

export default class KeyBindingResolverView {
  constructor () {
    this.keystrokes = null
    this.usedKeyBinding = null
    this.unusedKeyBindings = []
    this.unmatchedKeyBindings = []
    this.partiallyMatchedBindings = []
    this.attached = false
    this.disposables = new CompositeDisposable()
    this.keybindingDisposables = new CompositeDisposable()

    this.disposables.add(atom.workspace.getBottomDock().observeActivePaneItem(item => {
      if (item === this) {
        this.attach()
      } else {
        this.detach()
      }
    }))

    this.disposables.add(atom.workspace.getBottomDock().observeVisible(visible => {
      if (visible) {
        if (atom.workspace.getBottomDock().getActivePaneItem() === this) this.attach()
      } else {
        this.detach()
      }
    }))

    etch.initialize(this)
  }

  getTitle () {
    return 'Key Binding Resolver'
  }

  getIconName () {
    return 'keyboard'
  }

  getDefaultLocation () {
    return 'bottom'
  }

  getAllowedLocations () {
    // TODO: Support left and right possibly
    return ['bottom']
  }

  getURI () {
    return 'atom://keybinding-resolver'
  }

  serialize () {
    return {
      deserializer: 'keybinding-resolver/KeyBindingResolverView'
    }
  }

  destroy () {
    this.disposables.dispose()
    this.detach()
    return etch.destroy(this)
  }

  attach () {
    if (this.attached) return

    this.attached = true
    this.keybindingDisposables = new CompositeDisposable()
    this.keybindingDisposables.add(atom.keymaps.onDidMatchBinding(({keystrokes, binding, keyboardEventTarget, eventType}) => {
      if (eventType === 'keyup' && binding == null) {
        return
      }

      const unusedKeyBindings = atom.keymaps
        .findKeyBindings({keystrokes, target: keyboardEventTarget})
        .filter((b) => b !== binding)

      const unmatchedKeyBindings = atom.keymaps
        .findKeyBindings({keystrokes})
        .filter((b) => b !== binding && !unusedKeyBindings.includes(b))

      this.update({usedKeyBinding: binding, unusedKeyBindings, unmatchedKeyBindings, keystrokes})
    }))

    this.keybindingDisposables.add(atom.keymaps.onDidPartiallyMatchBindings(({keystrokes, partiallyMatchedBindings}) => {
      this.update({keystrokes, partiallyMatchedBindings})
    }))

    this.keybindingDisposables.add(atom.keymaps.onDidFailToMatchBinding(({keystrokes, keyboardEventTarget, eventType}) => {
      if (eventType === 'keyup') {
        return
      }

      const unusedKeyBindings = atom.keymaps.findKeyBindings({keystrokes, target: keyboardEventTarget})
      const unmatchedKeyBindings = atom.keymaps
        .findKeyBindings({keystrokes})
        .filter((b) => !unusedKeyBindings.includes(b))

      this.update({unusedKeyBindings, unmatchedKeyBindings, keystrokes})
    }))
  }

  detach () {
    if (!this.attached) return

    this.attached = false
    this.keybindingDisposables.dispose()
    this.keybindingDisposables = null
  }

  update (props) {
    this.keystrokes = props.keystrokes
    this.usedKeyBinding = props.usedKeyBinding
    this.unusedKeyBindings = props.unusedKeyBindings || []
    this.unmatchedKeyBindings = props.unmatchedKeyBindings || []
    this.partiallyMatchedBindings = props.partiallyMatchedBindings || []
    return etch.update(this)
  }

  render () {
    return (
      <div className='key-binding-resolver'>
        <div className='panel-heading'>{this.renderKeystrokes()}</div>
        <div className='panel-body'>{this.renderKeyBindings()}</div>
      </div>
    )
  }

  renderKeystrokes () {
    if (this.keystrokes) {
      if (this.partiallyMatchedBindings.length > 0) {
        return <span className='keystroke highlight-info'>{this.keystrokes} (partial)</span>
      } else {
        return <span className='keystroke highlight-info'>{this.keystrokes}</span>
      }
    } else {
      return <span>Press any key</span>
    }
  }

  renderKeyBindings () {
    if (this.partiallyMatchedBindings.length > 0) {
      return (
        <table className='table-condensed'>
          <tbody>
            {this.partiallyMatchedBindings.map((binding) => (
              <tr className='unused'>
                <td className='copy' onclick={() => this.copyKeybinding(binding)}><span className='icon icon-clippy' /></td>
                <td className='command'>{binding.command}</td>
                <td className='keystrokes'>{binding.keystrokes}</td>
                <td className='selector'>{binding.selector}</td>
                <td className='source' onclick={() => this.openKeybindingFile(binding.source)}>{binding.source}</td>
              </tr>
          ))}
          </tbody>
        </table>
      )
    } else {
      let usedKeyBinding = ''
      if (this.usedKeyBinding) {
        usedKeyBinding = (
          <tr className='used'>
            <td className='copy' onclick={() => this.copyKeybinding(this.usedKeyBinding)}><span className='icon icon-clippy' /></td>
            <td className='command'>{this.usedKeyBinding.command}</td>
            <td className='selector'>{this.usedKeyBinding.selector}</td>
            <td className='source' onclick={() => this.openKeybindingFile(this.usedKeyBinding.source)}>{this.usedKeyBinding.source}</td>
          </tr>
        )
      }
      return (
        <table className='table-condensed'>
          <tbody>
            {usedKeyBinding}
            {this.unusedKeyBindings.map((binding) => (
              <tr className='unused'>
                <td className='copy' onclick={() => this.copyKeybinding(binding)}><span className='icon icon-clippy' /></td>
                <td className='command'>{binding.command}</td>
                <td className='selector'>{binding.selector}</td>
                <td className='source' onclick={() => this.openKeybindingFile(binding.source)}>{binding.source}</td>
              </tr>
            ))}
            {this.unmatchedKeyBindings.map((binding) => (
              <tr className='unmatched'>
                <td className='copy' onclick={() => this.copyKeybinding(binding)}><span className='icon icon-clippy' /></td>
                <td className='command'>{binding.command}</td>
                <td className='selector'>{binding.selector}</td>
                <td className='source' onclick={() => this.openKeybindingFile(binding.source)}>{binding.source}</td>
              </tr>
          ))}
          </tbody>
        </table>
      )
    }
  }

  isInAsarArchive (pathToCheck) {
    const {resourcePath} = atom.getLoadSettings()
    return pathToCheck.startsWith(`${resourcePath}${path.sep}`) && path.extname(resourcePath) === '.asar'
  }

  extractBundledKeymap (bundledKeymapPath) {
    const metadata = require(path.join(atom.getLoadSettings().resourcePath, 'package.json'))
    const bundledKeymaps = metadata ? metadata._atomKeymaps : {}
    const keymapName = path.basename(bundledKeymapPath)
    const extractedKeymapPath = path.join(require('temp').mkdirSync('atom-bundled-keymap-'), keymapName)
    fs.writeFileSync(
      extractedKeymapPath,
      JSON.stringify(bundledKeymaps[keymapName] || {}, null, 2)
    )
    return extractedKeymapPath
  }

  extractBundledPackageKeymap (keymapRelativePath) {
    const packageName = keymapRelativePath.split(path.sep)[1]
    const keymapName = path.basename(keymapRelativePath)
    const metadata = atom.packages.packagesCache[packageName] || {}
    const keymaps = metadata.keymaps || {}
    const extractedKeymapPath = path.join(require('temp').mkdirSync('atom-bundled-keymap-'), keymapName)
    fs.writeFileSync(
      extractedKeymapPath,
      JSON.stringify(keymaps[keymapRelativePath] || {}, null, 2)
    )
    return extractedKeymapPath
  }

  openKeybindingFile (keymapPath) {
    if (this.isInAsarArchive(keymapPath)) {
      keymapPath = this.extractBundledKeymap(keymapPath)
    } else if (keymapPath.startsWith('core:node_modules')) {
      keymapPath = this.extractBundledPackageKeymap(keymapPath.replace('core:', ''))
    } else if (keymapPath.startsWith('core:')) {
      keymapPath = this.extractBundledKeymap(keymapPath.replace('core:', ''))
    }

    atom.workspace.open(keymapPath)
  }

  copyKeybinding (binding) {
    let content
    const keymapExtension = path.extname(atom.keymaps.getUserKeymapPath())
    let escapedKeystrokes = binding.keystrokes.replace(/\\/g, '\\\\') // Escape backslashes
    if (keymapExtension === '.cson') {
      content = `\
'${binding.selector}':
  '${escapedKeystrokes}': '${binding.command}'
`
    } else {
      content = `\
"${binding.selector}": {
  "${escapedKeystrokes}": "${binding.command}"
}
`
    }

    atom.notifications.addInfo('Keybinding Copied')
    return atom.clipboard.write(content)
  }
}

================
File: packages/keybinding-resolver/lib/main.js
================
const {CompositeDisposable} = require('atom')

const KeyBindingResolverView = require('./keybinding-resolver-view')

const KEYBINDING_RESOLVER_URI = 'atom://keybinding-resolver'

module.exports = {
  activate () {
    this.subscriptions = new CompositeDisposable()

    this.subscriptions.add(atom.workspace.addOpener(uri => {
      if (uri === KEYBINDING_RESOLVER_URI) {
        return new KeyBindingResolverView()
      }
    }))

    this.subscriptions.add(atom.commands.add('atom-workspace', {
      'key-binding-resolver:toggle': () => this.toggle()
    }))
  },

  deactivate () {
    this.subscriptions.dispose()
  },

  toggle () {
    atom.workspace.toggle(KEYBINDING_RESOLVER_URI)
  },

  deserializeKeyBindingResolverView (serialized) {
    return new KeyBindingResolverView()
  }
}

================
File: packages/markdown-preview/lib/language-ids/chroma.js
================
/*
 * This Document defines the Language Identifiers for 'Chroma'
 * That is the string used after a code block delimiter to define
 * what programming language is within the code block.
 *
 * 'Chroma' is the Syntax Highlighting Engine used by Codeberg/Gitea/Hugo within
 * the Goldmark Markdown rendering engine:
 * https://github.com/alecthomas/chroma
 *
 * This file can be updated here:
 * https://github.com/alecthomas/chroma/tree/master/lexers
 * Where each Lexer is able to define its name, and aliases within its exported
 * Config type. Otherwise the name of the lexer file is used.
 */

module.exports = {
  bash: 'source.shell',
  sh: 'source.shell',
  ksh: 'source.shell',
  zsh: 'source.shell',
  shell: 'source.shell',
  'bash-session': 'text.shell-session',
  console: 'text.shell-session',
  'shell-session': 'text.shell-session',
  cpp: 'source.cpp',
  'c++': 'source.cpp',
  c: 'source.c',
  clojure: 'source.clojure',
  clj: 'source.clojure',
  'coffee-script': 'source.coffee',
  coffeescript: 'source.coffee',
  coffee: 'source.coffee',
  csharp: 'source.cs',
  'c#': 'source.cs',
  css: 'source.css',
  'go-html-template': 'text.html.gohtml',
  handlebars: 'text.html.mustache',
  hbs: 'text.html.mustache',
  java: 'source.java',
  js: 'source.js',
  javascript: 'source.js',
  json: 'source.json',
  'objective-c': 'source.objc',
  objectivec: 'source.objc',
  'obj-c': 'source.objc',
  objc: 'source.objc',
  perl: 'source.perl',
  pl: 'source.perl',
  php: 'source.php',
  php3: 'source.php',
  php4: 'source.php',
  php5: 'source.php',
  'java-properties': 'text.xml.plist',
  python: 'source.python',
  py: 'source.python',
  sage: 'source.python',
  python3: 'source.python',
  py3: 'source.python',
  ruby: 'source.ruby',
  rb: 'source.ruby',
  duby: 'source.ruby',
  rust: 'source.rust',
  rs: 'source.rust',
  sass: 'source.sass',
  scss: 'source.css.scss',
  sql: 'source.sql',
  toml: 'source.toml',
  ts: 'source.ts',
  tsx: 'source.tsx',
  typescript: 'source.ts',
  xml: 'text.xml',
  yaml: 'source.yaml'
};

================
File: packages/markdown-preview/lib/language-ids/highlightjs.js
================
/*
 * This Document defines the Language Identifiers for 'highlightjs'
 * That is the string used after a code block delimiter to define
 * what programming language is within the code block.
 *
 * 'highlightjs' is a Syntax Highlighting Engine used widely across the web,
 * and is the default syntax highlighting engine for `markdown-it`:
 * https://highlightjs.org/
 *
 * This file can be updated here:
 * https://github.com/highlightjs/highlight.js/blob/main/SUPPORTED_LANGUAGES.md
 * Which helpfully lists the available aliases of each supported language.
 */

module.exports = {
  shell: 'source.shell',
  console: 'source.shell',
  bash: 'source.shell',
  sh: 'source.shell',
  zsh: 'source.shell',
  powershell: 'source.powershell',
  ps: 'source.powershell',
  ps1: 'source.powershell',
  c: 'source.c',
  h: 'source.c',
  cpp: 'source.cpp',
  hpp: 'source.cpp',
  cc: 'source.cpp',
  hh: 'source.cpp',
  'c++': 'source.cpp',
  'h++': 'source.cpp',
  cxx: 'source.cpp',
  hxx: 'source.cpp',
  coffeescript: 'source.coffee',
  coffee: 'source.coffee',
  cson: 'source.coffee',
  iced: 'source.coffee',
  csharp: 'source.cs',
  cs: 'source.cs',
  css: 'source.css',
  clojure: 'source.clojure',
  clj: 'source.clojure',
  scss: 'source.scss',
  erlang: 'source.erl',
  erl: 'source.erl',
  go: 'source.go',
  golang: 'source.go',
  html: 'text.html.basic',
  xhtml: 'text.html.basic',
  rss: 'text.xml',
  atom: 'text.xml',
  xml: 'text.xml',
  xsd: 'text.xml',
  xsl: 'text.xml',
  plist: 'text.xml.plist',
  hbs: 'text.html.handlebars',
  'html.hbs': 'text.html.handlebars',
  'html.handlebars': 'text.html.handlebars',
  htmlbars: 'text.html.handlebars',
  handlebars: 'text.html.handlebars',
  java: 'source.java',
  jsp: 'text.html.jsp',
  properties: 'source.java-properties',
  javascript: 'source.js',
  js: 'source.js',
  jsx: 'source.js',
  json: 'source.json',
  less: 'source.css.less',
  objectivec: 'source.objc',
  mm: 'source.objc',
  objc: 'source.objc',
  'obj-c': 'source.objc',
  'obj-c++': 'source.objcpp',
  'objective-c++': 'source.objcpp',
  php: 'text.html.php',
  python: 'source.python',
  py: 'source.python',
  gyp: 'source.python',
  pycon: 'text.python.console',
  ruby: 'source.ruby',
  rb: 'source.ruby',
  gemspec: 'source.ruby',
  podspec: 'source.ruby',
  thor: 'source.ruby',
  irb: 'source.ruby',
  plaintext: 'text.plain',
  txt: 'text.plain',
  text: 'text.plain',
  toml: 'source.toml',
  typescript: 'source.ts',
  ts: 'source.ts',
  tsx: 'source.ts',
  mts: 'source.ts',
  cts: 'source.ts',
  yaml: 'source.yaml',
  yml: 'source.yaml',
  makefile: 'source.makefile',
  mk: 'source.makefile',
  mak: 'source.makefile',
  make: 'source.makefile',
  perl: 'source.perl',
  pl: 'source.perl',
  pm: 'source.perl',
  sql: 'source.sql'
};

================
File: packages/markdown-preview/lib/language-ids/linguist.js
================
/*
 * This Document defines the Language Identifiers for 'Linguist'
 * That is the string used after a code block delimiter to define
 * what programming language is within the code block.
 *
 * 'Linguist' is the Syntax Highlighting Engine used by GitHub for
 * GitHub FLavoured Markdown:
 * https://github.com/github-linguist/linguist
 *
 * This file can be updated here:
 * https://github.com/github-linguist/linguist/blob/master/lib/linguist/languages.yml
 * Where each key name, and `alias` is a valid language identifier.
 */

module.exports = {
  bash: 'source.shell',
  sh: 'source.shell',
  'shell-script': 'source.shell',
  zsh: 'source.shell',
  powershell: 'source.powershell',
  ps1: 'source.powershell',
  posh: 'source.powershell',
  pwsh: 'source.powershell',
  c: 'source.c',
  'c++': 'source.cpp',
  cpp: 'source.cpp',
  coffee: 'source.coffee',
  'coffee-script': 'source.coffee',
  coffeescript: 'source.coffee',
  cson: 'source.coffee',
  cs: 'source.cs',
  csharp: 'source.cs',
  cake: 'source.cake',
  cakescript: 'source.csx',
  css: 'source.css',
  clojure: 'source.clojure',
  edn: 'source.edn',
  sass: 'source.sass',
  scss: 'source.css.scss',
  erlang: 'source.erl',
  go: 'source.go',
  golang: 'source.go',
  'go.mod': 'source.mod',
  'go mod': 'source.mod',
  'go module': 'source.mod',
  'go.sum': 'source.sum',
  'go sum': 'source.sum',
  'go.work.sum': 'source.sum',
  'go work sum': 'source.sum',
  gitconfig: 'source.git-config',
  gitmodules: 'source.git-config',
  html: 'text.html.basic',
  hta: 'text.html.basic',
  htm: 'text.html.basic',
  'hmtl.hl': 'text.html.basic',
  xht: 'text.html.basic',
  xhmtl: 'text.html.basic',
  kit: 'text.html.basic',
  ejs: 'text.html.ejs',
  ect: 'text.html.ejs',
  'ejs.t': 'text.html.ejs',
  jst: 'text.html.ejs',
  erb: 'text.html.erb',
  rhtml: 'text.html.erb',
  'html+ruby': 'text.html.erb',
  java: 'source.java',
  jav: 'source.java',
  jsh: 'source.java',
  jsp: 'text.html.jsp',
  tag: 'text.html.jsp',
  properties: 'source.java-properties',
  javascript: 'source.js',
  js: 'source.js',
  node: 'source.js',
  json5: 'source.js',
  json: 'source.json',
  geojson: 'source.json',
  jsonl: 'source.json',
  topojson: 'source.json',
  less: 'source.css.less',
  'less-css': 'source.css.less',
  litcoffee: 'source.litcoffee',
  mustache: 'text.html.mustache',
  hbs: 'text.html.handlebars',
  htmlbars: 'text.html.handlebars',
  objc: 'source.objc',
  'objective-c': 'source.objc',
  'obj-c': 'source.objc',
  'obj-c++': 'source.objcpp',
  'objc++': 'source.objcpp',
  'objectivec++': 'source.objcpp',
  objectivec: 'source.objc',
  php: 'text.html.php',
  inc: 'text.html.php',
  'html+php': 'text.html.php',
  py: 'source.python',
  python: 'source.python',
  python3: 'source.python',
  pycon: 'text.python.console',
  rb: 'source.ruby',
  ruby: 'source.ruby',
  jruby: 'source.ruby',
  macruby: 'source.ruby',
  rake: 'source.ruby',
  rb: 'source.ruby',
  rbx: 'source.ruby',
  text: 'text.plain',
  toml: 'source.toml',
  ts: 'source.ts',
  typescript: 'source.ts',
  xml: 'text.xml',
  rss: 'text.xml',
  xsd: 'text.xml',
  wsdl: 'text.xml',
  xslt: 'text.xml.xsl',
  xsl: 'text.xml.xsl',
  yaml: 'source.yaml',
  yml: 'source.yaml',
  make: 'source.makefile',
  cperl: 'source.perl',
  perl: 'source.perl',
  sql: 'source.sql'
};

================
File: packages/markdown-preview/lib/language-ids/rouge.js
================
/*
 * This Document defines the Language Identifiers for 'Rouge'
 * That is the string used after a code block delimiter to define
 * what programming language is within the code block.
 *
 * 'Rouge' is the Syntax Highlighting Engine used by GitLab and Jekyll:
 * https://github.com/rouge-ruby/rouge
 *
 * This file can be updated here:
 * https://github.com/rouge-ruby/rouge/tree/master/lib/rouge/lexers
 * And and outdated full list with aliases can be found here:
 * https://github.com/rouge-ruby/rouge/wiki/List-of-supported-languages-and-lexers
 * The Wiki document does list the main identifier for each language, and may list
 * optional aliases. But like mentioned, this document seems a few years out of date.
 * Otherwise each lexer exports a `tag` and optional `aliases` from its file.
 */

module.exports = {
  c: 'source.c',
  cpp: 'source.cpp',
  'c++': 'source.cpp',
  clojure: 'source.clojure',
  clj: 'source.clojure',
  cljs: 'source.clojure',
  coffeescript: 'source.coffee',
  coffee: 'source.coffee',
  'coffee-script': 'source.coffee',
  literate_coffeescript: 'source.litcoffee',
  litcoffee: 'source.litcoffee',
  csharp: 'source.cs',
  'c#': 'source.cs',
  cs: 'source.cs',
  css: 'source.css',
  go: 'source.go',
  golang: 'source.go',
  html: 'text.html.basic',
  erb: 'text.html.erb',
  eruby: 'text.html.erb',
  rhtml: 'text.html.erb',
  jsp: 'text.html.jsp',
  java: 'source.java',
  properties: 'source.java-properties',
  javascript: 'source.js',
  js: 'source.js',
  json: 'source.json',
  make: 'source.makefile',
  makefile: 'source.makefile',
  mf: 'source.makefile',
  gnumake: 'source.makefile',
  bsdmake: 'source.makefile',
  handlebars: 'text.html.mustache',
  hbs: 'text.html.mustache',
  mustache: 'text.html.mustache',
  objective_c: 'source.objc',
  objc: 'source.objc',
  'obj-c': 'source.objc',
  obj_c: 'source.objc',
  objectivec: 'source.objc',
  perl: 'source.perl',
  pl: 'source.perl',
  php: 'source.php',
  php3: 'source.php',
  php4: 'source.php',
  php5: 'source.php',
  plist: 'text.xml.plist',
  python: 'source.python',
  py: 'source.python',
  ruby: 'source.ruby',
  rb: 'source.ruby',
  rust: 'source.rust',
  rs: 'source.rust',
  no_run: 'source.rust',
  sass: 'source.sass',
  scss: 'source.css.scss',
  console: 'source.shell',
  terminal: 'source.shell',
  shell_session: 'source.shell-session',
  'shell-session': 'source.shell-session',
  shell: 'source.shell',
  bash: 'source.shell',
  zsh: 'source.shell',
  ksh: 'source.shell',
  sh: 'source.shell',
  sql: 'source.sql',
  plaintext: 'text.plain',
  text: 'text.plain',
  toml: 'source.toml',
  tsx: 'source.tsx',
  typescript: 'source.ts',
  ts: 'source.ts',
  xml: 'text.xml',
  mxml: 'text.xml',
  yaml: 'source.yaml',
  yml: 'source.yaml'
};

================
File: packages/markdown-preview/lib/extension-helper.js
================
function getUserLanguageIds() {
  try {
    let usersLanguageIDs = atom.config.get("markdown-preview.customSyntaxHighlightingLanguageIdentifiers");

    let obj = {};

    // Bail early if empty
    if (usersLanguageIDs.length === 0) {
      return obj;
    }

    let pairs = usersLanguageIDs.split(",");

    for (let i = 0; i < pairs.length; i++) {
      let split = pairs[i].split(":");
      obj[split[0].trim()] = split[1].trim();
    }

    return obj;
    
  } catch(err) {
    atom.notifications.addError(`Unable to load Markdown Preview Custom Syntax Highlighting Language Identifiers\n${err.toString()}`);
    return {};
  }
}

function getLanguageIds() {

  let preferredLanguageID = atom.config.get("markdown-preview.syntaxHighlightingLanguageIdentifier");
  let usersLanguageIDs = getUserLanguageIds();

  let languageIds;

  switch(preferredLanguageID) {
    // Defer require for all language id files. First call for an given one will
    // be expensive, but due to the module cache, should be fine afterwards
    // plus only requiring the one needed, should result in less wasted memory
    case "chroma":
      languageIds = require("./language-ids/chroma.js");
      break;
    case "highlightjs":
      languageIds = require("./language-ids/highlightjs.js");
      break;
    case "rouge":
      languageIds = require("./language-ids/rouge.js");
      break;
    case "linguist":
    default:
      languageIds = require("./language-ids/linguist.js");
      break;
  }

  if (Object.keys(usersLanguageIDs).length > 0) {
    for (let key in usersLanguageIDs) {
      languageIds[key] = usersLanguageIDs[key];
    }
  }

  return languageIds;
}

module.exports = {
  scopeForFenceName(fenceName) {
    fenceName = fenceName.toLowerCase()

    let scopesByFenceName = getLanguageIds();

    return scopesByFenceName.hasOwnProperty(fenceName)
      ? scopesByFenceName[fenceName]
      : `source.${fenceName}`
  }
}

================
File: packages/markdown-preview/lib/main.js
================
const fs = require('fs-plus')
const { CompositeDisposable } = require('atom')

let MarkdownPreviewView = null
let renderer = null

const isMarkdownPreviewView = function (object) {
  if (MarkdownPreviewView == null) {
    MarkdownPreviewView = require('./markdown-preview-view')
  }
  return object instanceof MarkdownPreviewView
}

module.exports = {
  activate() {
    this.disposables = new CompositeDisposable()
    this.commandSubscriptions = new CompositeDisposable()

    this.style = new CSSStyleSheet()

    // TODO: When we upgrade Electron, we can push onto `adoptedStyleSheets`
    // directly. For now, we have to do this silly thing.
    let styleSheets = Array.from(document.adoptedStyleSheets ?? [])
    styleSheets.push(this.style)
    document.adoptedStyleSheets = styleSheets

    this.disposables.add(
      atom.config.observe('markdown-preview.grammars', grammars => {
        this.commandSubscriptions.dispose()
        this.commandSubscriptions = new CompositeDisposable()

        if (grammars == null) {
          grammars = []
        }

        for (const grammar of grammars.map(grammar =>
          grammar.replace(/\./g, ' ')
        )) {
          this.commandSubscriptions.add(
            atom.commands.add(`atom-text-editor[data-grammar='${grammar}']`, {
              'markdown-preview:toggle': () => this.toggle(),
              'markdown-preview:copy-html': {
                displayName: 'Markdown Preview: Copy HTML',
                didDispatch: () => this.copyHTML()
              },
              'markdown-preview:save-as-html': {
                displayName: 'Markdown Preview: Save as HTML',
                didDispatch: () => this.saveAsHTML()
              },
              'markdown-preview:toggle-break-on-single-newline': () => {
                const keyPath = 'markdown-preview.breakOnSingleNewline'
                atom.config.set(keyPath, !atom.config.get(keyPath))
              },
              'markdown-preview:toggle-github-style': () => {
                const keyPath = 'markdown-preview.useGitHubStyle'
                atom.config.set(keyPath, !atom.config.get(keyPath))
              }
            })
          )
        }
      })
    )

    this.disposables.add(
      atom.config.observe('editor.fontFamily', (fontFamily) => {
        // Keep the user's `fontFamily` setting in sync with preview styles.
        // `pre` blocks will use this font automatically, but `code` elements
        // need a specific style rule.
        //
        // Since this applies to all content, we should declare this only once,
        // instead of once per preview view.
        this.style.replaceSync(`
          .markdown-preview code {
            font-family: ${fontFamily} !important;
          }
        `)
      })
    )

    const previewFile = this.previewFile.bind(this)
    for (const extension of [
      'markdown',
      'md',
      'mdown',
      'mkd',
      'mkdown',
      'ron',
      'txt'
    ]) {
      this.disposables.add(
        atom.commands.add(
          `.tree-view .file .name[data-name$=\\.${extension}]`,
          'markdown-preview:preview-file',
          previewFile
        )
      )
    }

    this.disposables.add(
      atom.workspace.addOpener(uriToOpen => {
        let [protocol, path] = uriToOpen.split('://')
        if (protocol !== 'markdown-preview') {
          return
        }

        try {
          path = decodeURI(path)
        } catch (error) {
          return
        }

        if (path.startsWith('editor/')) {
          return this.createMarkdownPreviewView({ editorId: path.substring(7) })
        } else {
          return this.createMarkdownPreviewView({ filePath: path })
        }
      })
    )
  },

  deactivate() {
    this.disposables.dispose()
    this.commandSubscriptions.dispose()
  },

  createMarkdownPreviewView(state) {
    if (state.editorId || fs.isFileSync(state.filePath)) {
      if (MarkdownPreviewView == null) {
        MarkdownPreviewView = require('./markdown-preview-view')
      }
      return new MarkdownPreviewView(state)
    }
  },

  toggle() {
    if (isMarkdownPreviewView(atom.workspace.getActivePaneItem())) {
      atom.workspace.destroyActivePaneItem()
      return
    }

    const editor = atom.workspace.getActiveTextEditor()
    if (editor == null) {
      return
    }

    const grammars = atom.config.get('markdown-preview.grammars') || []
    if (!grammars.includes(editor.getGrammar().scopeName)) {
      return
    }

    if (!this.removePreviewForEditor(editor)) {
      return this.addPreviewForEditor(editor)
    }
  },

  uriForEditor(editor) {
    return `markdown-preview://editor/${editor.id}`
  },

  removePreviewForEditor(editor) {
    const uri = this.uriForEditor(editor)
    const previewPane = atom.workspace.paneForURI(uri)
    if (previewPane != null) {
      previewPane.destroyItem(previewPane.itemForURI(uri))
      return true
    } else {
      return false
    }
  },

  addPreviewForEditor(editor) {
    const uri = this.uriForEditor(editor)
    const previousActivePane = atom.workspace.getActivePane()
    const options = { searchAllPanes: true }
    if (atom.config.get('markdown-preview.openPreviewInSplitPane')) {
      options.split = 'right'
    }

    return atom.workspace
      .open(uri, options)
      .then(function (markdownPreviewView) {
        if (isMarkdownPreviewView(markdownPreviewView)) {
          previousActivePane.activate()
        }
      })
  },

  previewFile({ target }) {
    const filePath = target.dataset.path
    if (!filePath) {
      return
    }

    for (const editor of atom.workspace.getTextEditors()) {
      if (editor.getPath() === filePath) {
        return this.addPreviewForEditor(editor)
      }
    }

    atom.workspace.open(`markdown-preview://${encodeURI(filePath)}`, {
      searchAllPanes: true
    })
  },

  async copyHTML() {
    const editor = atom.workspace.getActiveTextEditor()
    if (editor == null) {
      return
    }

    if (renderer == null) {
      renderer = require('./renderer')
    }
    const text = editor.getSelectedText() || editor.getText()
    const html = await renderer.toHTML(
      text,
      editor.getPath(),
      editor.getGrammar(),
      editor.id
    )

    atom.clipboard.write(html)
  },

  saveAsHTML() {
    const activePaneItem = atom.workspace.getActivePaneItem()
    if (isMarkdownPreviewView(activePaneItem)) {
      atom.workspace.getActivePane().saveItemAs(activePaneItem)
      return
    }

    const editor = atom.workspace.getActiveTextEditor()
    if (editor == null) {
      return
    }

    const grammars = atom.config.get('markdown-preview.grammars') || []
    if (!grammars.includes(editor.getGrammar().scopeName)) {
      return
    }

    const uri = this.uriForEditor(editor)
    const markdownPreviewPane = atom.workspace.paneForURI(uri)
    const markdownPreviewPaneItem =
      markdownPreviewPane != null
        ? markdownPreviewPane.itemForURI(uri)
        : undefined

    if (isMarkdownPreviewView(markdownPreviewPaneItem)) {
      return markdownPreviewPane.saveItemAs(markdownPreviewPaneItem)
    }
  }
}

================
File: packages/markdown-preview/lib/markdown-preview-view.js
================
const path = require('path')
const morphdom = require('morphdom')

const { Emitter, Disposable, CompositeDisposable, File } = require('atom')
const _ = require('underscore-plus')
const fs = require('fs-plus')

const renderer = require('./renderer')

module.exports = class MarkdownPreviewView {
  static deserialize(params) {
    return new MarkdownPreviewView(params)
  }

  constructor({ editorId, filePath }) {
    this.editorId = editorId
    this.filePath = filePath
    this.element = document.createElement('div')
    this.element.classList.add('markdown-preview')
    this.element.tabIndex = -1

    this.emitter = new Emitter()
    this.loaded = false
    this.disposables = new CompositeDisposable()
    this.registerScrollCommands()
    if (this.editorId != null) {
      this.resolveEditor(this.editorId)
    } else if (atom.packages.hasActivatedInitialPackages()) {
      this.subscribeToFilePath(this.filePath)
    } else {
      this.disposables.add(
        atom.packages.onDidActivateInitialPackages(() => {
          this.subscribeToFilePath(this.filePath)
        })
      )
    }
    this.editorCache = new renderer.EditorCache(editorId)
  }

  serialize() {
    return {
      deserializer: 'MarkdownPreviewView',
      filePath: this.getPath() != null ? this.getPath() : this.filePath,
      editorId: this.editorId
    }
  }

  copy() {
    return new MarkdownPreviewView({
      editorId: this.editorId,
      filePath: this.getPath() != null ? this.getPath() : this.filePath
    })
  }

  destroy() {
    this.disposables.dispose()
    this.element.remove()
    this.editorCache.destroy()
  }

  registerScrollCommands() {
    this.disposables.add(
      atom.commands.add(this.element, {
        'core:move-up': () => {
          this.element.scrollTop -= document.body.offsetHeight / 20
        },
        'core:move-down': () => {
          this.element.scrollTop += document.body.offsetHeight / 20
        },
        'core:page-up': () => {
          this.element.scrollTop -= this.element.offsetHeight
        },
        'core:page-down': () => {
          this.element.scrollTop += this.element.offsetHeight
        },
        'core:move-to-top': () => {
          this.element.scrollTop = 0
        },
        'core:move-to-bottom': () => {
          this.element.scrollTop = this.element.scrollHeight
        }
      })
    )
  }

  onDidChangeTitle(callback) {
    return this.emitter.on('did-change-title', callback)
  }

  onDidChangeModified(_callback) {
    // No op to suppress deprecation warning
    return new Disposable()
  }

  onDidChangeMarkdown(callback) {
    return this.emitter.on('did-change-markdown', callback)
  }

  subscribeToFilePath(filePath) {
    this.file = new File(filePath)
    this.emitter.emit('did-change-title')
    this.disposables.add(
      this.file.onDidRename(() => this.emitter.emit('did-change-title'))
    )
    this.handleEvents()
    return this.renderMarkdown()
  }

  resolveEditor(editorId) {
    const resolve = () => {
      this.editor = this.editorForId(editorId)

      if (this.editor != null) {
        this.emitter.emit('did-change-title')
        this.disposables.add(
          this.editor.onDidDestroy(() =>
            this.subscribeToFilePath(this.getPath())
          )
        )
        this.handleEvents()
        this.renderMarkdown()
      } else {
        this.subscribeToFilePath(this.filePath)
      }
    }

    if (atom.packages.hasActivatedInitialPackages()) {
      resolve()
    } else {
      this.disposables.add(atom.packages.onDidActivateInitialPackages(resolve))
    }
  }

  editorForId(editorId) {
    for (const editor of atom.workspace.getTextEditors()) {
      if (editor.id != null && editor.id.toString() === editorId.toString()) {
        return editor
      }
    }
    return null
  }

  handleEvents() {
    const lazyRenderMarkdown = _.debounce(() => this.renderMarkdown(), 250)
    this.disposables.add(
      atom.grammars.onDidAddGrammar(() => lazyRenderMarkdown())
    )
    if (typeof atom.grammars.onDidRemoveGrammar === 'function') {
      this.disposables.add(
        atom.grammars.onDidRemoveGrammar(() => lazyRenderMarkdown())
      )
    } else {
      // TODO: Remove onDidUpdateGrammar hook once onDidRemoveGrammar is released
      this.disposables.add(
        atom.grammars.onDidUpdateGrammar(() => lazyRenderMarkdown())
      )
    }

    atom.commands.add(this.element, {
      'core:copy': event => {
        event.stopPropagation()
        return this.copyToClipboard()
      },
      'markdown-preview:select-all': () => {
        this.selectAll()
      },
      'markdown-preview:zoom-in': () => {
        const zoomLevel = parseFloat(getComputedStyle(this.element).zoom)
        this.element.style.zoom = zoomLevel + 0.1
      },
      'markdown-preview:zoom-out': () => {
        const zoomLevel = parseFloat(getComputedStyle(this.element).zoom)
        this.element.style.zoom = zoomLevel - 0.1
      },
      'markdown-preview:reset-zoom': () => {
        this.element.style.zoom = 1
      },
      'markdown-preview:toggle-break-on-single-newline'() {
        const keyPath = 'markdown-preview.breakOnSingleNewline'
        atom.config.set(keyPath, !atom.config.get(keyPath))
      },
      'markdown-preview:toggle-github-style'() {
        const keyPath = 'markdown-preview.useGitHubStyle'
        atom.config.set(keyPath, !atom.config.get(keyPath))
      }
    })

    const changeHandler = () => {
      this.renderMarkdown()

      const pane = atom.workspace.paneForItem(this)
      if (pane != null && pane !== atom.workspace.getActivePane()) {
        pane.activateItem(this)
      }
    }

    if (this.file) {
      this.disposables.add(this.file.onDidChange(changeHandler))
    } else if (this.editor) {
      this.disposables.add(
        this.editor.getBuffer().onDidStopChanging(function () {
          if (atom.config.get('markdown-preview.liveUpdate')) {
            changeHandler()
          }
        })
      )
      this.disposables.add(
        this.editor.onDidChangePath(() => this.emitter.emit('did-change-title'))
      )
      this.disposables.add(
        this.editor.getBuffer().onDidSave(function () {
          if (!atom.config.get('markdown-preview.liveUpdate')) {
            changeHandler()
          }
        })
      )
      this.disposables.add(
        this.editor.getBuffer().onDidReload(function () {
          if (!atom.config.get('markdown-preview.liveUpdate')) {
            changeHandler()
          }
        })
      )
    }

    this.disposables.add(
      atom.config.onDidChange(
        'markdown-preview.breakOnSingleNewline',
        changeHandler
      )
    )

    this.disposables.add(
      atom.config.observe('markdown-preview.gitHubStyleMode', gitHubStyleMode => {
        this.gitHubStyleMode = gitHubStyleMode
        if (this.useGitHubStyle) {
          this.element.setAttribute('data-use-github-style', gitHubStyleMode)
        }
      })
    )

    this.disposables.add(
      atom.config.observe('markdown-preview.useGitHubStyle', useGitHubStyle => {
        this.useGitHubStyle = useGitHubStyle
        if (useGitHubStyle) {
          this.element.setAttribute('data-use-github-style', this.gitHubStyleMode)
        } else {
          this.element.removeAttribute('data-use-github-style')
        }
      })
    )

    document.onselectionchange = () => {
      const selection = window.getSelection()
      const selectedNode = selection.baseNode
      if (
        selectedNode === null ||
        this.element === selectedNode ||
        this.element.contains(selectedNode)
      ) {
        if (selection.isCollapsed) {
          this.element.classList.remove('has-selection')
        } else {
          this.element.classList.add('has-selection')
        }
      }
    }
  }

  renderMarkdown() {
    if (!this.loaded) {
      this.showLoading()
    }
    return this.getMarkdownSource()
      .then(source => {
        if (source != null) {
          if (this.loaded) {
            return this.renderMarkdownText(source);
          } else {
            // If we haven't loaded yet, defer before we render the Markdown
            // for the first time. This allows the pane to appear and to
            // display the loading indicator. Otherwise the first render
            // happens before the pane is even visible.
            //
            // This doesn't slow anything down; it just shifts the work around
            // so that the pane appears earlier in the cycle.
            return new Promise((resolve) => {
              setTimeout(() => {
                resolve(this.renderMarkdownText(source))
              }, 0)
            })
          }
        }
      })
      .catch(reason => this.showError({ message: reason }))
  }

  getMarkdownSource() {
    if (this.file && this.file.getPath()) {
      return this.file
        .read()
        .then(source => {
          if (source === null) {
            return Promise.reject(
              new Error(`${this.file.getBaseName()} could not be found`)
            )
          } else {
            return Promise.resolve(source)
          }
        })
        .catch(reason => Promise.reject(reason))
    } else if (this.editor != null) {
      return Promise.resolve(this.editor.getText())
    } else {
      return Promise.reject(new Error('No editor found'))
    }
  }

  async getHTML() {
    const source = await this.getMarkdownSource()

    if (source == null) {
      return
    }

    return renderer.toHTML(source, this.getPath(), this.getGrammar())
  }

  async renderMarkdownText(text) {
    const { scrollTop } = this.element
    try {
      const [domFragment, done] = await renderer.toDOMFragment(
        text,
        this.getPath(),
        this.getGrammar(),
        this.editorId
      )

      this.loading = false
      this.loaded = true

      // Clone the existing container
      let newElement = this.element.cloneNode(false)
      newElement.appendChild(domFragment)

      morphdom(this.element, newElement, {
        onBeforeNodeDiscarded(node) {
          // Don't discard `atom-text-editor` elements despite the fact that
          // they don't exist in the new content.
          if (node.nodeName === 'ATOM-TEXT-EDITOR') {
            return false
          }
        }
      })

      await done(this.element)
      this.element.classList.remove('loading')

      this.emitter.emit('did-change-markdown')
      this.element.scrollTop = scrollTop
    } catch (error) {
      this.showError(error)
    }
  }

  getTitle() {
    if (this.file != null && this.getPath() != null) {
      return `${path.basename(this.getPath())} Preview`
    } else if (this.editor != null) {
      return `${this.editor.getTitle()} Preview`
    } else {
      return 'Markdown Preview'
    }
  }

  getIconName() {
    return 'markdown'
  }

  getURI() {
    if (this.file != null) {
      return `markdown-preview://${this.getPath()}`
    } else {
      return `markdown-preview://editor/${this.editorId}`
    }
  }

  getPath() {
    if (this.file != null) {
      return this.file.getPath()
    } else if (this.editor != null) {
      return this.editor.getPath()
    }
  }

  getGrammar() {
    return this.editor != null ? this.editor.getGrammar() : undefined
  }

  getDocumentStyleSheets() {
    // This function exists so we can stub it
    return document.styleSheets
  }

  getTextEditorStyles() {
    const textEditorStyles = document.createElement('atom-styles')
    textEditorStyles.initialize(atom.styles)
    textEditorStyles.setAttribute('context', 'atom-text-editor')
    document.body.appendChild(textEditorStyles)

    // Extract style elements content
    return Array.prototype.slice
      .apply(textEditorStyles.childNodes)
      .map(styleElement => styleElement.innerText)
  }

  getMarkdownPreviewCSS() {
    const markdownPreviewRules = []
    const ruleRegExp = /\.markdown-preview/
    const cssUrlRegExp = /url\(atom:\/\/markdown-preview\/assets\/(.*)\)/

    for (const stylesheet of this.getDocumentStyleSheets()) {
      if (stylesheet.rules != null) {
        for (const rule of stylesheet.rules) {
          // We only need `.markdown-review` css
          if (rule.selectorText && rule.selectorText.match(ruleRegExp)) {
            markdownPreviewRules.push(rule.cssText)
          }
        }
      }
    }

    return markdownPreviewRules
      .concat(this.getTextEditorStyles())
      .join('\n')
      .replace(/atom-text-editor/g, 'pre.editor-colors')
      .replace(/:host/g, '.host') // Remove shadow-dom :host selector causing problem on FF
      .replace(cssUrlRegExp, function (_match, assetsName, _offset, _string) {
        // base64 encode assets
        const assetPath = path.join(__dirname, '../assets', assetsName)
        const originalData = fs.readFileSync(assetPath, 'binary')
        const base64Data = Buffer.from(originalData, 'binary').toString(
          'base64'
        )
        return `url('data:image/jpeg;base64,${base64Data}')`
      })
  }

  showError(result) {
    this.element.textContent = ''
    this.element.classList.remove('loading')
    const h2 = document.createElement('h2')
    h2.textContent = 'Previewing Markdown Failed'
    this.element.appendChild(h2)
    if (result) {
      const h3 = document.createElement('h3')
      h3.textContent = result.message
      this.element.appendChild(h3)
    }
  }

  showLoading() {
    this.loading = true
    this.element.classList.add('loading')
  }

  selectAll() {
    if (this.loading) {
      return
    }

    const selection = window.getSelection()
    selection.removeAllRanges()
    const range = document.createRange()
    range.selectNodeContents(this.element)
    selection.addRange(range)
  }

  async copyToClipboard() {
    if (this.loading) {
      return
    }

    const selection = window.getSelection()
    const selectedText = selection.toString()
    const selectedNode = selection.baseNode

    // Use default copy event handler if there is selected text inside this view
    if (
      selectedText &&
      selectedNode != null &&
      (this.element === selectedNode || this.element.contains(selectedNode))
    ) {
      atom.clipboard.write(selectedText)
    } else {
      try {
        const html = await this.getHTML()

        atom.clipboard.write(html)
      } catch (error) {
        atom.notifications.addError('Copying Markdown as HTML failed', {
          dismissable: true,
          detail: error.message
        })
      }
    }
  }

  getSaveDialogOptions() {
    let defaultPath = this.getPath()
    if (defaultPath) {
      defaultPath += '.html'
    } else {
      let projectPath
      defaultPath = 'untitled.md.html'
      if ((projectPath = atom.project.getPaths()[0])) {
        defaultPath = path.join(projectPath, defaultPath)
      }
    }

    return { defaultPath }
  }

  async saveAs(htmlFilePath) {
    if (this.loading) {
      atom.notifications.addWarning(
        'Please wait until the Markdown Preview has finished loading before saving'
      )
      return
    }

    const filePath = this.getPath()
    let title = 'Markdown to HTML'
    if (filePath) {
      title = path.parse(filePath).name
    }

    const htmlBody = await this.getHTML()

    const html =
      `\
<!DOCTYPE html>
<html>
  <head>
      <meta charset="utf-8" />
      <title>${title}</title>
      <style>${this.getMarkdownPreviewCSS()}</style>
  </head>
  <body class='markdown-preview' data-use-github-style="${this.gitHubStyleMode}">${htmlBody}</body>
</html>` + '\n' // Ensure trailing newline

    fs.writeFileSync(htmlFilePath, html)
    return atom.workspace.open(htmlFilePath)
  }
}

================
File: packages/markdown-preview/lib/renderer.js
================
const { TextEditor } = require('atom')
const path = require('path')
const createDOMPurify = require('dompurify')
const emoji = require('emoji-images')
const fs = require('fs-plus')
let marked = null // Defer until used
let renderer = null
let cheerio = null
let yamlFrontMatter = null

const { scopeForFenceName } = require('./extension-helper')
const { resourcePath } = atom.getLoadSettings()
const packagePath = path.dirname(__dirname)

const emojiFolder = path.join(
  path.dirname(require.resolve('emoji-images')),
  'pngs'
)

// Creating `TextEditor` instances is costly, so we'll try to re-use instances
// when a preview changes.
class EditorCache {
  static BY_ID = new Map()

  static findOrCreateById(id) {
    let cache = EditorCache.BY_ID.get(id)
    if (!cache) {
      cache = new EditorCache(id)
      EditorCache.BY_ID.set(id, cache)
    }
    return cache
  }

  constructor(id) {
    this.id = id
    this.editorsByPre = new Map()
    this.possiblyUnusedEditors = new Set()
  }

  destroy() {
    let editors = Array.from(this.editorsByPre.values())
    for (let editor of editors) {
      editor.destroy()
    }
    this.editorsByPre.clear()
    this.possiblyUnusedEditors.clear()
    EditorCache.BY_ID.delete(this.id)
  }

  // Called when we start a render. Every `TextEditor` is assumed to be stale,
  // but any editor that is successfully looked up from the cache during this
  // render is saved from culling.
  beginRender() {
    this.possiblyUnusedEditors.clear()
    for (let editor of this.editorsByPre.values()) {
      this.possiblyUnusedEditors.add(editor)
    }
  }

  // Cache an editor by the PRE element that it's standing in for.
  addEditor(pre, editor) {
    this.editorsByPre.set(pre, editor)
  }

  getEditor(pre) {
    let editor = this.editorsByPre.get(pre)
    if (editor) {
      // Cache hit! This editor will be reused, so we should prevent it from
      // getting culled.
      this.possiblyUnusedEditors.delete(editor)
    }
    return editor
  }

  endRender() {
    // Any editor that didn't get claimed during the render is orphaned and
    // should be disposed of.
    let toBeDeleted = new Set()
    for (let [pre, editor] of this.editorsByPre.entries()) {
      if (!this.possiblyUnusedEditors.has(editor)) continue
      toBeDeleted.add(pre)
    }

    this.possiblyUnusedEditors.clear()

    for (let pre of toBeDeleted) {
      let editor = this.editorsByPre.get(pre)
      let element = editor.getElement()
      if (element.parentNode) {
        element.remove()
      }
      this.editorsByPre.delete(pre)
      editor.destroy()
    }
  }
}

exports.EditorCache = EditorCache

function chooseRender(text, filePath) {
  if (atom.config.get("markdown-preview.useOriginalParser")) {
    // Legacy rendering with `marked`.
    return render(text, filePath)
  } else {
    // Built-in rendering with `markdown-it`.
    let html = atom.ui.markdown.render(text, {
      renderMode: "fragment",
      filePath: filePath,
      breaks: atom.config.get('markdown-preview.breakOnSingleNewline'),
      useDefaultEmoji: true,
      sanitizeAllowUnknownProtocols: atom.config.get('markdown-preview.allowUnsafeProtocols')
    })
    return atom.ui.markdown.convertToDOM(html)
  }
}

exports.toDOMFragment = async function (text, filePath, grammar, editorId) {
  text ??= ""
  let defaultLanguage = getDefaultLanguageForGrammar(grammar)

  // We cache editor instances in this code path because it's the one used by
  // the preview pane, so we expect it to be updated quite frequently.
  let cache = EditorCache.findOrCreateById(editorId)
  cache.beginRender()

  const domFragment = chooseRender(text, filePath)
  annotatePreElements(domFragment, defaultLanguage)

  return [
    domFragment,
    async (element) => {
      await highlightCodeBlocks(element, grammar, cache, makeAtomEditorNonInteractive)
      cache.endRender()
    }
  ]
}

exports.toHTML = async function (text, filePath, grammar) {
  text ??= "";

  // We don't cache editor instances in this code path because it's the one
  // used by the “Copy HTML” command, so this is likely to be a one-off for
  // which caches won't help.

  const domFragment = chooseRender(text, filePath)
  const div = document.createElement('div')
  annotatePreElements(domFragment, getDefaultLanguageForGrammar(grammar))
  div.appendChild(domFragment)
  document.body.appendChild(div)

  await highlightCodeBlocks(div, grammar, null, convertAtomEditorToStandardElement)

  const result = div.innerHTML;
  div.remove();

  return result;
}

// Render with the package's own `marked` library.
function render(text, filePath) {
  if (marked == null || yamlFrontMatter == null || cheerio == null) {
    marked = require('marked')
    yamlFrontMatter = require('yaml-front-matter')
    cheerio = require('cheerio')

    renderer = new marked.Renderer()
    renderer.listitem = function (text, isTask) {
      const listAttributes = isTask ? ' class="task-list-item"' : ''

      return `<li ${listAttributes}>${text}</li>\n`
    }
  }

  marked.setOptions({
    breaks: atom.config.get('markdown-preview.breakOnSingleNewline'),
    renderer
  })

  const { __content, ...vars } = yamlFrontMatter.loadFront(text)

  let html = marked.parse(renderYamlTable(vars) + __content)

  // emoji-images is too aggressive, so replace images in monospace tags with
  // the actual emoji text.
  const $ = cheerio.load(emoji(html, emojiFolder, 20))
  $('pre img').each((_index, element) =>
    $(element).replaceWith($(element).attr('title'))
  )
  $('code img').each((_index, element) =>
    $(element).replaceWith($(element).attr('title'))
  )

  html = $.html()

  html = createDOMPurify().sanitize(html, {
    ALLOW_UNKNOWN_PROTOCOLS: atom.config.get(
      'markdown-preview.allowUnsafeProtocols'
    )
  })

  const template = document.createElement('template')
  template.innerHTML = html.trim()
  const fragment = template.content.cloneNode(true)

  resolveImagePaths(fragment, filePath)

  return fragment
}

function renderYamlTable(variables) {
  const entries = Object.entries(variables)

  if (!entries.length) {
    return ''
  }

  const markdownRows = [
    entries.map(entry => entry[0]),
    entries.map(_ => '--'),
    entries.map((entry) => {
      if (typeof entry[1] === "object" && !Array.isArray(entry[1])) {
        // Remove all newlines, or they ruin formatting of parent table
        return marked.parse(renderYamlTable(entry[1])).replace(/\n/g,"");
      } else {
        return entry[1];
      }
    })
  ]

  return (
    markdownRows.map(row => '| ' + row.join(' | ') + ' |').join('\n') + '\n'
  )
}

function resolveImagePaths(element, filePath) {
  const [rootDirectory] = atom.project.relativizePath(filePath)

  const result = []
  for (const img of element.querySelectorAll('img')) {
    // We use the raw attribute instead of the .src property because the value
    // of the property seems to be transformed in some cases.
    let src

    if ((src = img.getAttribute('src'))) {
      if (src.match(/^(https?|atom):\/\//)) {
        continue
      }
      if (src.startsWith(process.resourcesPath)) {
        continue
      }
      if (src.startsWith(resourcePath)) {
        continue
      }
      if (src.startsWith(packagePath)) {
        continue
      }

      if (src[0] === '/') {
        if (!fs.isFileSync(src)) {
          if (rootDirectory) {
            result.push((img.src = path.join(rootDirectory, src.substring(1))))
          } else {
            result.push(undefined)
          }
        } else {
          result.push(undefined)
        }
      } else {
        result.push((img.src = path.resolve(path.dirname(filePath), src)))
      }
    } else {
      result.push(undefined)
    }
  }

  return result
}

function getDefaultLanguageForGrammar(grammar) {
  return grammar?.scopeName === 'source.litcoffee' ? 'coffee' : 'text'
}

function annotatePreElements(fragment, defaultLanguage) {
  for (let preElement of fragment.querySelectorAll('pre')) {
    const codeBlock = preElement.firstElementChild ?? preElement
    const className = codeBlock.getAttribute('class')
    const fenceName = className?.replace(/^language-/, '') ?? defaultLanguage
    preElement.classList.add('editor-colors', `lang-${fenceName}`)
  }
}

function reassignEditorToLanguage(editor, languageScope) {
  // When we successfully reassign the language on an editor, its
  // `data-grammar` attribute updates on its own.
  let result = atom.grammars.assignLanguageMode(editor, languageScope)
  if (result) return true

  // When we fail to assign the language on an editor — maybe its package is
  // deactivated — it won't reset itself to the default grammar, so we have to
  // do it ourselves.
  result = atom.grammars.assignLanguageMode(editor, `text.plain.null-grammar`)
  if (!result) return false
}

// After render, create an `atom-text-editor` for each `pre` element so that we
// enjoy syntax highlighting.
function highlightCodeBlocks(element, grammar, cache, editorCallback) {
  let defaultLanguage = getDefaultLanguageForGrammar(grammar)

  const promises = []

  for (const preElement of element.querySelectorAll('pre')) {
    const codeBlock = preElement.firstElementChild ?? preElement
    const className = codeBlock.getAttribute('class')
    const fenceName = className?.replace(/^language-/, '') ?? defaultLanguage
    let editorText = codeBlock.textContent.replace(/\r?\n$/, '')

    // If this PRE element was present in the last render, then we should
    // already have a cached text editor available for use.
    let editor = cache?.getEditor(preElement) ?? null
    let editorElement
    if (!editor) {
      editor = new TextEditor({ keyboardInputEnabled: false })
      editorElement = editor.getElement()
      editor.setReadOnly(true)
      cache?.addEditor(preElement, editor)
    } else {
      editorElement = editor.getElement()
    }

    // If the PRE changed its content, we need to change the content of its
    // `TextEditor`.
    if (editor.getText() !== editorText) {
      editor.setReadOnly(false)
      editor.setText(editorText)
      editor.setReadOnly(true)
    }

    // If the PRE changed its language, we need to change the language of its
    // `TextEditor`.
    let scopeDescriptor = editor.getRootScopeDescriptor()[0]
    let languageScope = scopeForFenceName(fenceName)
    if (languageScope !== scopeDescriptor && `.${languageScope}` !== scopeDescriptor) {
      reassignEditorToLanguage(editor, languageScope)
    }

    // If the editor is brand new, we'll have to insert it; otherwise it should
    // already be in the right place.
    if (!editorElement.parentNode) {
      preElement.parentNode.insertBefore(editorElement, preElement)
      editor.setVisible(true)
    }

    promises.push(editorCallback(editorElement, preElement))
  }
  return Promise.all(promises)
}

function makeAtomEditorNonInteractive(editorElement) {
  editorElement.setAttributeNode(document.createAttribute('gutter-hidden'))
  editorElement.removeAttribute('tabindex')

  // Remove line decorations from code blocks.
  for (const cursorLineDecoration of editorElement.getModel()
    .cursorLineDecorations) {
    cursorLineDecoration.destroy()
  }
}

function convertAtomEditorToStandardElement(editorElement, preElement) {
  return new Promise(function (resolve) {
    const editor = editorElement.getModel()
    // In this code path, we're transplanting the highlighted editor HTML into
    // the existing `pre` element, so we should empty its contents first.
    preElement.innerHTML = ''
    const done = () =>
      editor.component.getNextUpdatePromise().then(function () {
        for (const line of editorElement.querySelectorAll(
          '.line:not(.dummy)'
        )) {
          const line2 = document.createElement('div')
          line2.className = 'line'
          line2.innerHTML = line.firstChild.innerHTML
          preElement.appendChild(line2)
        }
        editorElement.remove()
        resolve()
      })
    const languageMode = editor.getBuffer().getLanguageMode()
    if (languageMode.fullyTokenized || languageMode.tree) {
      done()
    } else {
      editor.onDidTokenize(done)
    }
  })
}

================
File: packages/notifications/lib/command-logger.js
================
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS202: Simplify dynamic range loops
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/main/docs/suggestions.md
 */
// Originally from lee-dohm/bug-report
// https://github.com/lee-dohm/bug-report/blob/master/lib/command-logger.coffee

// Command names that are ignored and not included in the log. This uses an Object to provide fast
// string matching.
let CommandLogger;
const ignoredCommands = {
  'show.bs.tooltip': true,
  'shown.bs.tooltip': true,
  'hide.bs.tooltip': true,
  'hidden.bs.tooltip': true,
  'editor:display-updated': true,
  'mousewheel': true
};

// Ten minutes in milliseconds.
const tenMinutes = 10 * 60 * 1000;

// Public: Handles logging all of the Pulsar commands for the automatic repro steps feature.
//
// It uses an array as a circular data structure to log only the most recent commands.
module.exports =
(CommandLogger = (function() {
  CommandLogger = class CommandLogger {
    static initClass() {
  
      // Public: Maximum size of the log.
      this.prototype.logSize = 16;
    }
    static instance() {
      return this._instance != null ? this._instance : (this._instance = new CommandLogger);
    }

    static start() {
      return this.instance().start();
    }

    // Public: Creates a new logger.
    constructor() {
      this.initLog();
    }

    start() {
      return atom.commands.onWillDispatch(event => {
        return this.logCommand(event);
      });
    }

    // Public: Formats the command log for the bug report.
    //
    // * `externalData` An {Object} containing other information to include in the log.
    //
    // Returns a {String} of the Markdown for the report.
    getText(externalData) {
      const lines = [];
      const lastTime = Date.now();

      this.eachEvent(event => {
        if (event.time > lastTime) { return; }
        if (!event.name || ((lastTime - event.time) >= tenMinutes)) { return; }
        return lines.push(this.formatEvent(event, lastTime));
      });

      if (externalData) {
        lines.push(`     ${this.formatTime(0)} ${externalData.title}`);
      }

      lines.unshift('```');
      lines.push('```');
      return lines.join("\n");
    }

    // Public: Gets the latest event from the log.
    //
    // Returns the event {Object}.
    latestEvent() {
      return this.eventLog[this.logIndex];
    }

    // Public: Logs the command.
    //
    // * `command` Command {Object} to be logged
    //   * `type` Name {String} of the command
    //   * `target` {String} describing where the command was triggered
    logCommand(command) {
      const {type: name, target, time} = command;
      if (command.detail != null ? command.detail.jQueryTrigger : undefined) { return; }
      if (name in ignoredCommands) { return; }

      let event = this.latestEvent();

      if (event.name === name) {
        return event.count++;
      } else {
        this.logIndex = (this.logIndex + 1) % this.logSize;
        event = this.latestEvent();
        event.name = name;
        event.targetNodeName = target.nodeName;
        event.targetClassName = target.className;
        event.targetId = target.id;
        event.count = 1;
        return event.time = time != null ? time : Date.now();
      }
    }

    // Private: Calculates the time of the last event to be reported.
    //
    // * `data` Data from an external bug passed in from another package.
    //
    // Returns the {Date} of the last event that should be reported.
    calculateLastEventTime(data) {
      if (data) { return data.time; }

      let lastTime = null;
      this.eachEvent(event => lastTime = event.time);
      return lastTime;
    }

    // Private: Executes a function on each event in chronological order.
    //
    // This function is used instead of similar underscore functions because the log is held in a
    // circular buffer.
    //
    // * `fn` {Function} to execute for each event in the log.
    //   * `event` An {Object} describing the event passed to your function.
    //
    // ## Examples
    //
    // This code would output the name of each event to the console.
    //
    // ```coffee
    // logger.eachEvent (event) ->
    //   console.log event.name
    // ```
    eachEvent(fn) {
      for (let offset = 1, end = this.logSize, asc = 1 <= end; asc ? offset <= end : offset >= end; asc ? offset++ : offset--) {
        fn(this.eventLog[(this.logIndex + offset) % this.logSize]);
      }
    }

    // Private: Format the command count for reporting.
    //
    // Returns the {String} format of the command count.
    formatCount(count) {
      switch (false) {
        case !(count < 2): return '    ';
        case !(count < 10): return `  ${count}x`;
        case !(count < 100): return ` ${count}x`;
      }
    }

    // Private: Formats a command event for reporting.
    //
    // * `event` Event {Object} to be formatted.
    // * `lastTime` {Date} of the last event to report.
    //
    // Returns the {String} format of the command event.
    formatEvent(event, lastTime) {
      const {count, time, name, targetNodeName, targetClassName, targetId} = event;
      const nodeText = targetNodeName.toLowerCase();
      const idText = targetId ? `#${targetId}` : '';
      let classText = '';
      if (targetClassName != null) { for (var klass of Array.from(targetClassName.split(" "))) { classText += `.${klass}`; } }
      return `${this.formatCount(count)} ${this.formatTime(lastTime - time)} ${name} (${nodeText}${idText}${classText})`;
    }

    // Private: Format the command time for reporting.
    //
    // * `time` {Date} to format
    //
    // Returns the {String} format of the command time.
    formatTime(time) {
      const minutes = Math.floor(time / 60000);
      let seconds = Math.floor(((time % 60000) / 1000) * 10) / 10;
      if (seconds < 10) { seconds = `0${seconds}`; }
      if (Math.floor(seconds) !== seconds) { seconds = `${seconds}.0`; }
      return `-${minutes}:${seconds}`;
    }

    // Private: Initializes the log structure for speed.
    initLog() {
      this.logIndex = 0;
      return this.eventLog = __range__(0, this.logSize, false).map((i) => ({
        name: null,
        count: 0,
        targetNodeName: null,
        targetClassName: null,
        targetId: null,
        time: null
      }));
    }
  };
  CommandLogger.initClass();
  return CommandLogger;
})());

function __range__(left, right, inclusive) {
  let range = [];
  let ascending = left < right;
  let end = !inclusive ? right : ascending ? right + 1 : right - 1;
  for (let i = left; ascending ? i < end : i > end; ascending ? i++ : i--) {
    range.push(i);
  }
  return range;
}

================
File: packages/notifications/lib/main.js
================
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS205: Consider reworking code to avoid use of IIFEs
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/main/docs/suggestions.md
 */
const {Notification, CompositeDisposable} = require('atom');
const fs = require('fs-plus');
let StackTraceParser = null;
const NotificationElement = require('./notification-element');
const NotificationsLog = require('./notifications-log');

const Notifications = {
  isInitialized: false,
  subscriptions: null,
  duplicateTimeDelay: 500,
  lastNotification: null,

  activate(state) {
    let notification;
    const CommandLogger = require('./command-logger');
    CommandLogger.start();
    this.subscriptions = new CompositeDisposable;

    for (notification of Array.from(atom.notifications.getNotifications())) { this.addNotificationView(notification); }
    this.subscriptions.add(atom.notifications.onDidAddNotification(notification => this.addNotificationView(notification)));

    this.subscriptions.add(atom.onWillThrowError(function({message, url, line, originalError, preventDefault}) {
      let match;
      if (originalError.name === 'BufferedProcessError') {
        message = message.replace('Uncaught BufferedProcessError: ', '');
        return atom.notifications.addError(message, {dismissable: true});

      } else if ((originalError.code === 'ENOENT') && !/\/atom/i.test(message) && (match = /spawn (.+) ENOENT/.exec(message))) {
        message = `\
'${match[1]}' could not be spawned.
Is it installed and on your path?
If so please open an issue on the package spawning the process.\
`;
        return atom.notifications.addError(message, {dismissable: true});

      } else if (!atom.inDevMode() || atom.config.get('notifications.showErrorsInDevMode')) {
        preventDefault();

        // Ignore errors with no paths in them since they are impossible to trace
        if (originalError.stack && !isCoreOrPackageStackTrace(originalError.stack)) {
          return;
        }

        const options = {
          detail: `${url}:${line}`,
          stack: originalError.stack,
          dismissable: true
        };
        return atom.notifications.addFatalError(message, options);
      }
    })
    );

    this.subscriptions.add(atom.commands.add('atom-workspace', 'core:cancel', () => (() => {
      const result = [];
      for (notification of Array.from(atom.notifications.getNotifications())) {           result.push(notification.dismiss());
      }
      return result;
    })())
    );

    this.subscriptions.add(atom.config.observe('notifications.defaultTimeout', value => { return this.visibilityDuration = value; }));

    if (atom.inDevMode()) {
      this.subscriptions.add(atom.commands.add('atom-workspace', 'notifications:trigger-error', function() {
        try {
          return abc + 2; // nope
        } catch (error) {
          const options = {
            detail: error.stack.split('\n')[1],
            stack: error.stack,
            dismissable: true
          };
          return atom.notifications.addFatalError(`Uncaught ${error.stack.split('\n')[0]}`, options);
        }
      })
      );
    }

    if (this.notificationsLog != null) { this.addNotificationsLogSubscriptions(); }
    this.subscriptions.add(atom.workspace.addOpener(uri => { if (uri === NotificationsLog.prototype.getURI()) { return this.createLog(); } }));
    this.subscriptions.add(atom.commands.add('atom-workspace', 'notifications:toggle-log', () => atom.workspace.toggle(NotificationsLog.prototype.getURI())));
    return this.subscriptions.add(atom.commands.add('atom-workspace', 'notifications:clear-log', function() {
      for (notification of Array.from(atom.notifications.getNotifications())) {
        notification.options.dismissable = true;
        notification.dismissed = false;
        notification.dismiss();
      }
      return atom.notifications.clear();
    })
    );
  },

  deactivate() {
    this.subscriptions.dispose();
    if (this.notificationsElement != null) {
      this.notificationsElement.remove();
    }
    if (this.notificationsPanel != null) {
      this.notificationsPanel.destroy();
    }
    if (this.notificationsLog != null) {
      this.notificationsLog.destroy();
    }

    this.subscriptions = null;
    this.notificationsElement = null;
    this.notificationsPanel = null;

    return this.isInitialized = false;
  },

  initializeIfNotInitialized() {
    if (this.isInitialized) { return; }

    this.subscriptions.add(atom.views.addViewProvider(Notification, model => {
      return new NotificationElement(model, this.visibilityDuration);
    })
    );

    this.notificationsElement = document.createElement('atom-notifications');
    atom.views.getView(atom.workspace).appendChild(this.notificationsElement);

    return this.isInitialized = true;
  },

  createLog(state) {
    this.notificationsLog = new NotificationsLog(this.duplicateTimeDelay, state != null ? state.typesHidden : undefined);
    if (this.subscriptions != null) { this.addNotificationsLogSubscriptions(); }
    return this.notificationsLog;
  },

  addNotificationsLogSubscriptions() {
    this.subscriptions.add(this.notificationsLog.onDidDestroy(() => { return this.notificationsLog = null; }));
    return this.subscriptions.add(this.notificationsLog.onItemClick(notification => {
      const view = atom.views.getView(notification);
      view.makeDismissable();

      if (!view.element.classList.contains('remove')) { return; }
      view.element.classList.remove('remove');
      this.notificationsElement.appendChild(view.element);
      notification.dismissed = false;
      return notification.setDisplayed(true);
    })
    );
  },

  addNotificationView(notification) {
    if (notification == null) { return; }
    this.initializeIfNotInitialized();
    if (notification.wasDisplayed()) { return; }

    if (this.lastNotification != null) {
      // do not show duplicates unless some amount of time has passed
      const timeSpan = notification.getTimestamp() - this.lastNotification.getTimestamp();
      if (!(timeSpan < this.duplicateTimeDelay) || !notification.isEqual(this.lastNotification)) {
        this.notificationsElement.appendChild(atom.views.getView(notification).element);
        if (this.notificationsLog != null) {
          this.notificationsLog.addNotification(notification);
        }
      }
    } else {
      this.notificationsElement.appendChild(atom.views.getView(notification).element);
      if (this.notificationsLog != null) {
        this.notificationsLog.addNotification(notification);
      }
    }

    notification.setDisplayed(true);
    return this.lastNotification = notification;
  }
};

var isCoreOrPackageStackTrace = function(stack) {
  if (StackTraceParser == null) { StackTraceParser = require('stacktrace-parser'); }
  for (var {file} of Array.from(StackTraceParser.parse(stack))) {
    if ((file === '<embedded>') || fs.isAbsolute(file)) {
      return true;
    }
  }
  return false;
};

module.exports = Notifications;

================
File: packages/notifications/lib/notification-element.js
================
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS103: Rewrite code to no longer use __guard__, or convert again using --optional-chaining
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/main/docs/suggestions.md
 */
let NotificationElement;
const fs = require('fs-plus');
const path = require('path');
const {shell} = require('electron');

const NotificationIssue = require('./notification-issue');
const TemplateHelper = require('./template-helper');
const UserUtilities = require('./user-utilities');

const NotificationTemplate = `\
<div class="content">
  <div class="message item"></div>
  <div class="detail item">
    <div class="detail-content"></div>
    <a href="#" class="stack-toggle"></a>
    <div class="stack-container"></div>
  </div>
  <div class="meta item"></div>
</div>
<div class="close icon icon-x"></div>
<div class="close-all btn btn-error">Close All</div>\
`;

const FatalMetaNotificationTemplate = `\
<div class="description fatal-notification"></div>
<div class="btn-toolbar">
  <a href="#" class="btn-issue btn btn-error"></a>
  <a href="#" class="btn-copy-report icon icon-clippy" title="Copy error report to clipboard"></a>
</div>\
`;

const MetaNotificationTemplate = `\
<div class="description"></div>\
`;

const ButtonListTemplate = `\
<div class="btn-toolbar"></div>\
`;

const ButtonTemplate = `\
<a href="#" class="btn"></a>\
`;

module.exports =
(NotificationElement = (function() {
  NotificationElement = class NotificationElement {
    static initClass() {
      this.prototype.animationDuration = 360;
      this.prototype.visibilityDuration = 5000;
      this.prototype.autohideTimeout = null;
    }

    constructor(model, visibilityDuration) {
      this.model = model;
      this.visibilityDuration = visibilityDuration;
      this.fatalTemplate = TemplateHelper.create(FatalMetaNotificationTemplate);
      this.metaTemplate = TemplateHelper.create(MetaNotificationTemplate);
      this.buttonListTemplate = TemplateHelper.create(ButtonListTemplate);
      this.buttonTemplate = TemplateHelper.create(ButtonTemplate);

      this.element = document.createElement('atom-notification');
      if (this.model.getType() === 'fatal') { this.issue = new NotificationIssue(this.model); }
      this.renderPromise = this.render().catch(function(e) {
        console.error(e.message);
        return console.error(e.stack);
      });

      this.model.onDidDismiss(() => this.removeNotification());

      if (!this.model.isDismissable()) {
        this.autohide();
        this.element.addEventListener('click', this.makeDismissable.bind(this), {once: true});
      }

      this.element.issue = this.issue;
      this.element.getRenderPromise = this.getRenderPromise.bind(this);
    }

    getModel() { return this.model; }

    getRenderPromise() { return this.renderPromise; }

    render() {
      let detail, metaContainer, metaContent;
      this.element.classList.add(`${this.model.getType()}`);
      this.element.classList.add("icon", `icon-${this.model.getIcon()}`, "native-key-bindings");

      if (detail = this.model.getDetail()) { this.element.classList.add('has-detail'); }
      if (this.model.isDismissable()) { this.element.classList.add('has-close'); }
      if (detail && (this.model.getOptions().stack != null)) { this.element.classList.add('has-stack'); }

      this.element.setAttribute('tabindex', '-1');

      this.element.innerHTML = NotificationTemplate;

      const options = this.model.getOptions();

      const notificationContainer = this.element.querySelector('.message');

      notificationContainer.innerHTML = atom.ui.markdown.render(this.model.getMessage());

      if (detail = this.model.getDetail()) {
        let stack;
        addSplitLinesToContainer(this.element.querySelector('.detail-content'), detail);

        if (stack = options.stack) {
          const stackToggle = this.element.querySelector('.stack-toggle');
          const stackContainer = this.element.querySelector('.stack-container');

          addSplitLinesToContainer(stackContainer, stack);

          stackToggle.addEventListener('click', e => this.handleStackTraceToggleClick(e, stackContainer));
          this.handleStackTraceToggleClick({currentTarget: stackToggle}, stackContainer);
        }
      }

      if (metaContent = options.description) {
        this.element.classList.add('has-description');
        metaContainer = this.element.querySelector('.meta');
        metaContainer.appendChild(TemplateHelper.render(this.metaTemplate));
        const description = this.element.querySelector('.description');
        description.innerHTML = atom.ui.markdown.render(metaContent);
      }

      if (options.buttons && (options.buttons.length > 0)) {
        this.element.classList.add('has-buttons');
        metaContainer = this.element.querySelector('.meta');
        metaContainer.appendChild(TemplateHelper.render(this.buttonListTemplate));
        const toolbar = this.element.querySelector('.btn-toolbar');
        let buttonClass = this.model.getType();
        if (buttonClass === 'fatal') { buttonClass = 'error'; }
        buttonClass = `btn-${buttonClass}`;
        options.buttons.forEach(button => {
          toolbar.appendChild(TemplateHelper.render(this.buttonTemplate));
          const buttonEl = toolbar.childNodes[toolbar.childNodes.length - 1];
          buttonEl.textContent = button.text;
          buttonEl.classList.add(buttonClass);
          if (button.className != null) {
            buttonEl.classList.add.apply(buttonEl.classList, button.className.split(' '));
          }
          if (button.onDidClick != null) {
            return buttonEl.addEventListener('click', e => {
              return button.onDidClick.call(this, e);
            });
          }
        });
      }

      const closeButton = this.element.querySelector('.close');
      closeButton.addEventListener('click', () => this.handleRemoveNotificationClick());

      const closeAllButton = this.element.querySelector('.close-all');
      closeAllButton.classList.add(this.getButtonClass());
      closeAllButton.addEventListener('click', () => this.handleRemoveAllNotificationsClick());

      if (this.model.getType() === 'fatal') {
        return this.renderFatalError();
      } else {
        return Promise.resolve();
      }
    }

    renderFatalError() {
      const repoUrl = this.issue.getRepoUrl();
      const packageName = this.issue.getPackageName();

      const fatalContainer = this.element.querySelector('.meta');
      fatalContainer.appendChild(TemplateHelper.render(this.fatalTemplate));
      const fatalNotification = this.element.querySelector('.fatal-notification');

      const issueButton = fatalContainer.querySelector('.btn-issue');

      const copyReportButton = fatalContainer.querySelector('.btn-copy-report');
      atom.tooltips.add(copyReportButton, {title: copyReportButton.getAttribute('title')});
      copyReportButton.addEventListener('click', e => {
        e.preventDefault();
        return this.issue.getIssueBody().then(issueBody => atom.clipboard.write(issueBody));
      });

      if ((packageName != null) && (repoUrl != null)) {
        fatalNotification.innerHTML = `The error was thrown from the <a href=\"${repoUrl}\">${packageName} package</a>. `;
      } else if (packageName != null) {
        issueButton.remove();
        fatalNotification.textContent = `The error was thrown from the ${packageName} package. `;
      } else {
        fatalNotification.textContent = "This is likely a bug in Pulsar. ";
      }

      // We only show the create issue button if it's clearly in atom core or in a package with a repo url
      if (issueButton.parentNode != null) {
        if ((packageName != null) && (repoUrl != null)) {
          issueButton.textContent = `Create issue on the ${packageName} package`;
        } else {
          issueButton.textContent = "Create issue on pulsar-edit/pulsar";
        }

        const promises = [];
        promises.push(this.issue.findSimilarIssues());
        promises.push(UserUtilities.checkPulsarUpToDate());
        if (packageName != null) {
          promises.push(UserUtilities.checkPackageUpToDate(packageName));
        }

        return Promise.all(promises).then(allData => {
          let issue;
          const [issues, atomCheck, packageCheck] = Array.from(allData);

          if ((issues != null ? issues.open : undefined) || (issues != null ? issues.closed : undefined)) {
            issue = issues.open || issues.closed;
            issueButton.setAttribute('href', issue.html_url);
            issueButton.textContent = "View Issue";
            fatalNotification.innerHTML += " This issue has already been reported.";
          } else if ((packageCheck != null) && !packageCheck.upToDate && !packageCheck.isCore) {
            issueButton.setAttribute('href', '#');
            issueButton.textContent = "Check for package updates";
            issueButton.addEventListener('click', function(e) {
              e.preventDefault();
              const command = 'settings-view:check-for-package-updates';
              return atom.commands.dispatch(atom.views.getView(atom.workspace), command);
            });

            fatalNotification.innerHTML += `\
<code>${packageName}</code> is out of date: ${packageCheck.installedVersion} installed;
${packageCheck.latestVersion} latest.
Upgrading to the latest version may fix this issue.\
`;
          } else if ((packageCheck != null) && !packageCheck.upToDate && packageCheck.isCore) {
            issueButton.remove();

            fatalNotification.innerHTML += `\
<br><br>
Locally installed core Pulsar package <code>${packageName}</code> is out of date: ${packageCheck.installedVersion} installed locally;
${packageCheck.versionShippedWithPulsar} included with the version of Pulsar you're running.
Removing the locally installed version may fix this issue.\
`;

            const packagePath = __guard__(atom.packages.getLoadedPackage(packageName), x => x.path);
            if (fs.isSymbolicLinkSync(packagePath)) {
              fatalNotification.innerHTML += `\
<br><br>
Use: <code>apm unlink ${packagePath}</code>\
`;
            }
          } else if ((atomCheck != null) && !atomCheck.upToDate) {
            issueButton.remove();

            fatalNotification.innerHTML += `\
Pulsar is out of date: ${atomCheck.installedVersion} installed;
${atomCheck.latestVersion} latest.
Upgrading to the <a href='https://github.com/pulsar-edit/pulsar/releases/tag/v${atomCheck.latestVersion}'>latest version</a> may fix this issue.\
`;
          } else {
            fatalNotification.innerHTML += " You can help by creating an issue. Please explain what actions triggered this error.";
            issueButton.addEventListener('click', e => {
              e.preventDefault();
              issueButton.classList.add('opening');
              return this.issue.getIssueUrlForSystem().then(function(issueUrl) {
                shell.openExternal(issueUrl);
                return issueButton.classList.remove('opening');
              });
            });
          }

        });
      } else {
        return Promise.resolve();
      }
    }

    makeDismissable() {
      if (!this.model.isDismissable()) {
        clearTimeout(this.autohideTimeout);
        this.model.options.dismissable = true;
        this.model.dismissed = false;
        return this.element.classList.add('has-close');
      }
    }

    removeNotification() {
      if (!this.element.classList.contains('remove')) {
        this.element.classList.add('remove');
        return this.removeNotificationAfterTimeout();
      }
    }

    handleRemoveNotificationClick() {
      this.removeNotification();
      return this.model.dismiss();
    }

    handleRemoveAllNotificationsClick() {
      const notifications = atom.notifications.getNotifications();
      for (var notification of Array.from(notifications)) {
        atom.views.getView(notification).removeNotification();
        if (notification.isDismissable() && !notification.isDismissed()) {
          notification.dismiss();
        }
      }
    }

    handleStackTraceToggleClick(e, container) {
      if (typeof e.preventDefault === 'function') {
        e.preventDefault();
      }
      if (container.style.display === 'none') {
        e.currentTarget.innerHTML = '<span class="icon icon-dash"></span>Hide Stack Trace';
        return container.style.display = 'block';
      } else {
        e.currentTarget.innerHTML = '<span class="icon icon-plus"></span>Show Stack Trace';
        return container.style.display = 'none';
      }
    }

    autohide() {
      return this.autohideTimeout = setTimeout(() => {
        return this.removeNotification();
      }
      , this.visibilityDuration);
    }

    removeNotificationAfterTimeout() {
      if (this.element === document.activeElement) { atom.workspace.getActivePane().activate(); }

      return setTimeout(() => {
        return this.element.remove();
      }
      , this.animationDuration); // keep in sync with CSS animation
    }

    getButtonClass() {
      const type = `btn-${this.model.getType()}`;
      if (type === 'btn-fatal') { return 'btn-error'; } else { return type; }
    }
  };
  NotificationElement.initClass();
  return NotificationElement;
})());

var addSplitLinesToContainer = function(container, content) {
  if (typeof content !== 'string') { content = content.toString(); }
  for (var line of Array.from(content.split('\n'))) {
    var div = document.createElement('div');
    div.classList.add('line');
    div.textContent = line;
    container.appendChild(div);
  }
};

function __guard__(value, transform) {
  return (typeof value !== 'undefined' && value !== null) ? transform(value) : undefined;
}

================
File: packages/notifications/lib/notification-issue.js
================
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS202: Simplify dynamic range loops
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/main/docs/suggestions.md
 */
let NotificationIssue;
const fs = require('fs-plus');
const path = require('path');
const StackTraceParser = require('stacktrace-parser');

const CommandLogger = require('./command-logger');
const UserUtilities = require('./user-utilities');

const TITLE_CHAR_LIMIT = 100; // Truncate issue title to 100 characters (including ellipsis)

const FileURLRegExp = new RegExp('file://\w*/(.*)');

module.exports = class NotificationIssue {
  constructor(notification) {
    this.normalizedStackPaths = this.normalizedStackPaths.bind(this);
    this.notification = notification;
  }

  findSimilarIssues() {
    let repoUrl = this.getRepoUrl();
    if (repoUrl == null) { repoUrl = 'pulsar-edit/pulsar'; }
    const repo = repoUrl.replace(/http(s)?:\/\/(\d+\.)?github.com\//gi, '');
    const issueTitle = this.getIssueTitle();
    const query = `${issueTitle} repo:${repo}`;
    const githubHeaders = new Headers({
      accept: 'application/vnd.github.v3+json',
      contentType: "application/json"
    });

    return fetch(`https://api.github.com/search/issues?q=${encodeURIComponent(query)}&sort=created`, {headers: githubHeaders})
      .then(r => r != null ? r.json() : undefined)
      .then(function(data) {
        if ((data != null ? data.items : undefined) != null) {
          const issues = {};
          for (var issue of Array.from(data.items)) {
            if ((issue.title.indexOf(issueTitle) > -1) && (issues[issue.state] == null)) {
              issues[issue.state] = issue;
              if ((issues.open != null) && (issues.closed != null)) { return issues; }
            }
          }

          if ((issues.open != null) || (issues.closed != null)) { return issues; }
        }
        return null;
      }).catch(_ => null);
  }

  getIssueUrlForSystem() {
    // Windows will not launch URLs greater than ~2000 bytes so we need to shrink it
    // Also is.gd has a limit of 5000 bytes...
    return this.getIssueUrl().then(issueUrl => fetch("https://is.gd/create.php?format=simple", {
      method: 'POST',
      headers: {'Content-Type': 'application/x-www-form-urlencoded'},
      body: `url=${encodeURIComponent(issueUrl)}`
    })
    .then(r => r.text())
    .catch(e => null));
  }

  getIssueUrl() {
    return this.getIssueBody().then(issueBody => {
      let repoUrl = this.getRepoUrl();
      if (repoUrl == null) {
        repoUrl = 'https://github.com/pulsar-edit/pulsar'; 
      }
      return `${repoUrl}/issues/new?title=${this.encodeURI(this.getIssueTitle())}&body=${this.encodeURI(issueBody)}`;
    });
  }

  encodeURI(str) {
    return encodeURI(str).replace(/#/g, '%23').replace(/;/g, '%3B').replace(/%20/g, '+');
  }

  getIssueTitle() {
    let title = this.notification.getMessage();
    title = title.replace(process.env.ATOM_HOME, '$ATOM_HOME');
    if (process.platform === 'win32') {
      title = title.replace(process.env.USERPROFILE, '~');
      title = title.replace(path.sep, path.posix.sep); // Standardize issue titles
    } else {
      title = title.replace(process.env.HOME, '~');
    }

    if (title.length > TITLE_CHAR_LIMIT) {
      title = title.substring(0, TITLE_CHAR_LIMIT - 3) + '...';
    }
    return title.replace(/\r?\n|\r/g, "");
  }

  getIssueBody() {
    return new Promise((resolve, reject) => {
      if (this.issueBody) { return resolve(this.issueBody); }
      const systemPromise = UserUtilities.getOSVersion();
      const nonCorePackagesPromise = UserUtilities.getNonCorePackages();

      return Promise.all([systemPromise, nonCorePackagesPromise]).then(all => {
        let packageMessage, packageVersion;
        const [systemName, nonCorePackages] = Array.from(all);

        const message = this.notification.getMessage();
        const options = this.notification.getOptions();
        const repoUrl = this.getRepoUrl();
        const packageName = this.getPackageName();
        if (packageName != null) {
          packageVersion = atom.packages.getLoadedPackage(packageName)?.metadata?.version;
        }
        const copyText = '';
        const systemUser = process.env.USER;
        let rootUserStatus = '';

        if (systemUser === 'root') {
          rootUserStatus = '**User**: root';
        }

        if ((packageName != null) && (repoUrl != null)) {
          packageMessage = `[${packageName}](${repoUrl}) package ${packageVersion}`;
        } else if (packageName != null) {
          packageMessage = `'${packageName}' package v${packageVersion}`;
        } else {
          packageMessage = 'Pulsar Core';
        }

        this.issueBody = `\
<!--
Have you read Pulsar's Code of Conduct? By filing an Issue, you are expected to comply with it, including treating everyone with respect: https://github.com/atom/.github/blob/master/CODE_OF_CONDUCT.md

Do you want to ask a question? Are you looking for support? The Pulsar message board is the best place for getting support: https://discuss.atom.io
-->

### Prerequisites

* [ ] Put an X between the brackets on this line if you have done all of the following:
    * Reproduced the problem in Safe Mode: <https://flight-manual.atom.io/hacking-atom/sections/debugging/#using-safe-mode>
    * Followed all applicable steps in the debugging guide: <https://flight-manual.atom.io/hacking-atom/sections/debugging/>
    * Checked the FAQs on the message board for common solutions: <https://discuss.atom.io/c/faq>
    * Checked that your issue isn't already filed: <https://github.com/issues?q=is%3Aissue+user%3Aatom>
    * Checked that there is not already an Pulsar package that provides the described functionality: <https://atom.io/packages>

### Description

<!-- Description of the issue -->

### Steps to Reproduce

1. <!-- First Step -->
2. <!-- Second Step -->
3. <!-- and so on… -->

**Expected behavior:**

<!-- What you expect to happen -->

**Actual behavior:**

<!-- What actually happens -->

### Versions

**Pulsar**: ${atom.getVersion()} ${process.arch}
**Electron**: ${process.versions.electron}
**OS**: ${systemName}
**Thrown From**: ${packageMessage}
${rootUserStatus}

### Stack Trace

${message}

\`\`\`
At ${options.detail}

${this.normalizedStackPaths(options.stack)}
\`\`\`

### Commands

${CommandLogger.instance().getText()}

### Non-Core Packages

\`\`\`
${nonCorePackages.join('\n')}
\`\`\`

### Additional Information

<!-- Any additional information, configuration or data that might be necessary to reproduce the issue. -->
${copyText}\
`;
        return resolve(this.issueBody);
      });
    });
  }

  normalizedStackPaths(stack) {
    return stack != null ? stack.replace(/(^\W+at )([\w.]{2,} [(])?(.*)(:\d+:\d+[)]?)/gm, (m, p1, p2, p3, p4) => p1 + (p2 || '') +
      this.normalizePath(p3) + p4
    ) : undefined;
  }

  normalizePath(path) {
    return path.replace('file:///', '')                         // Randomly inserted file url protocols
        .replace(/[/]/g, '\\')                           // Temp switch for Windows home matching
        .replace(fs.getHomeDirectory(), '~')             // Remove users home dir for apm-dev'ed packages
        .replace(/\\/g, '/')                             // Switch \ back to / for everyone
        .replace(/.*(\/(app\.asar|packages\/).*)/, '$1'); // Remove everything before app.asar or pacakges
  }

  getRepoUrl() {
    const packageName = this.getPackageName();
    if (packageName == null) { return; }
    let repo = atom.packages.getLoadedPackage(packageName)?.metadata?.repository;
    let repoUrl = (repo != null ? repo.url : undefined) != null ? (repo != null ? repo.url : undefined) : repo;
    if (!repoUrl) {
      let packagePath;
      if (packagePath = atom.packages.resolvePackagePath(packageName)) {
        try {
          repo = JSON.parse(fs.readFileSync(path.join(packagePath, 'package.json')))?.repository;
          repoUrl = (repo != null ? repo.url : undefined) != null ? (repo != null ? repo.url : undefined) : repo;
        } catch (error) {}
      }
    }

    return repoUrl != null ? repoUrl.replace(/\.git$/, '').replace(/^git\+/, '') : undefined;
  }

  getPackageNameFromFilePath(filePath) {
    if (!filePath) { return; }

    let packageName = __guard__(/\/\.atom\/dev\/packages\/([^\/]+)\//.exec(filePath), x => x[1]);
    if (packageName) { return packageName; }

    packageName = __guard__(/\\\.atom\\dev\\packages\\([^\\]+)\\/.exec(filePath), x1 => x1[1]);
    if (packageName) { return packageName; }

    packageName = __guard__(/\/\.atom\/packages\/([^\/]+)\//.exec(filePath), x2 => x2[1]);
    if (packageName) { return packageName; }

    packageName = __guard__(/\\\.atom\\packages\\([^\\]+)\\/.exec(filePath), x3 => x3[1]);
    if (packageName) { return packageName; }
  }

  getPackageName() {
    let packageName, packagePath;
    const options = this.notification.getOptions();

    if (options.packageName != null) { return options.packageName; }
    if ((options.stack == null) && (options.detail == null)) { return; }

    const packagePaths = this.getPackagePathsByPackageName();
    for (packageName in packagePaths) {
      packagePath = packagePaths[packageName];
      if ((packagePath.indexOf(path.join('.atom', 'dev', 'packages')) > -1) || (packagePath.indexOf(path.join('.atom', 'packages')) > -1)) {
        packagePaths[packageName] = fs.realpathSync(packagePath);
      }
    }

    const getPackageName = filePath => {
      let match;
      filePath = /\((.+?):\d+|\((.+)\)|(.+)/.exec(filePath)[0];

      // Stack traces may be a file URI
      if (match = FileURLRegExp.exec(filePath)) {
        filePath = match[1];
      }

      filePath = path.normalize(filePath);

      if (path.isAbsolute(filePath)) {
        for (var packName in packagePaths) {
          packagePath = packagePaths[packName];
          if (filePath === 'node.js') { continue; }
          var isSubfolder = filePath.indexOf(path.normalize(packagePath + path.sep)) === 0;
          if (isSubfolder) { return packName; }
        }
      }
      return this.getPackageNameFromFilePath(filePath);
    };

    if ((options.detail != null) && (packageName = getPackageName(options.detail))) {
      return packageName;
    }

    if (options.stack != null) {
      const stack = StackTraceParser.parse(options.stack);
      for (let i = 0, end = stack.length, asc = 0 <= end; asc ? i < end : i > end; asc ? i++ : i--) {
        var {file} = stack[i];

        // Empty when it was run from the dev console
        if (!file) { return; }
        packageName = getPackageName(file);
        if (packageName != null) { return packageName; }
      }
    }

  }

  getPackagePathsByPackageName() {
    const packagePathsByPackageName = {};
    for (var pack of Array.from(atom.packages.getLoadedPackages())) {
      packagePathsByPackageName[pack.name] = pack.path;
    }
    return packagePathsByPackageName;
  }
}

function __guard__(value, transform) {
  return (typeof value !== 'undefined' && value !== null) ? transform(value) : undefined;
}

================
File: packages/notifications/lib/notifications-log-item.js
================
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/main/docs/suggestions.md
 */
let NotificationsLogItem;
const {Emitter, CompositeDisposable, Disposable} = require('atom');
const moment = require('moment');

module.exports = (NotificationsLogItem = (function() {
  NotificationsLogItem = class NotificationsLogItem {
    static initClass() {
      this.prototype.subscriptions = null;
      this.prototype.timestampInterval = null;
    }

    constructor(notification) {
      this.notification = notification;
      this.emitter = new Emitter;
      this.subscriptions = new CompositeDisposable;
      this.render();
    }

    render() {
      const notificationView = atom.views.getView(this.notification);
      const notificationElement = this.renderNotification(notificationView);

      this.timestamp = document.createElement('div');
      this.timestamp.classList.add('timestamp');
      this.notification.moment = moment(this.notification.getTimestamp());
      this.subscriptions.add(atom.tooltips.add(this.timestamp, {title: this.notification.moment.format("ll LTS")}));
      this.updateTimestamp();
      this.timestampInterval = setInterval(this.updateTimestamp.bind(this), 60 * 1000);
      this.subscriptions.add(new Disposable(() => clearInterval(this.timestampInterval)));

      this.element = document.createElement('li');
      this.element.classList.add('notifications-log-item', this.notification.getType());
      this.element.appendChild(notificationElement);
      this.element.appendChild(this.timestamp);
      this.element.addEventListener('click', e => {
        if (e.target.closest('.btn-toolbar a, .btn-toolbar button') == null) {
          return this.emitter.emit('click');
        }
      });

      this.element.getRenderPromise = () => notificationView.getRenderPromise();
      if (this.notification.getType() === 'fatal') {
        notificationView.getRenderPromise().then(() => {
          return this.element.replaceChild(this.renderNotification(notificationView), notificationElement);
        });
      }

      return this.subscriptions.add(new Disposable(() => this.element.remove()));
    }

    renderNotification(view) {
      const message = document.createElement('div');
      message.classList.add('message');
      message.innerHTML = view.element.querySelector(".content > .message").innerHTML;

      const buttons = document.createElement('div');
      buttons.classList.add('btn-toolbar');
      const nButtons = view.element.querySelector(".content > .meta > .btn-toolbar");
      if (nButtons != null) {
        for (var button of Array.from(nButtons.children)) {
          var logButton = button.cloneNode(true);
          logButton.originalButton = button;
          logButton.addEventListener('click', function(e) {
            const newEvent = new MouseEvent('click', e);
            return e.target.originalButton.dispatchEvent(newEvent);
          });
          for (var tooltip of Array.from(atom.tooltips.findTooltips(button))) {
            this.subscriptions.add(atom.tooltips.add(logButton, tooltip.options));
          }
          buttons.appendChild(logButton);
        }
      }

      const nElement = document.createElement('div');
      nElement.classList.add('notifications-log-notification', 'icon', `icon-${this.notification.getIcon()}`, this.notification.getType());
      nElement.appendChild(message);
      nElement.appendChild(buttons);
      return nElement;
    }

    getElement() { return this.element; }

    destroy() {
      this.subscriptions.dispose();
      return this.emitter.emit('did-destroy');
    }

    onClick(callback) {
      return this.emitter.on('click', callback);
    }

    onDidDestroy(callback) {
      return this.emitter.on('did-destroy', callback);
    }

    updateTimestamp() {
      return this.timestamp.textContent = this.notification.moment.fromNow();
    }
  };
  NotificationsLogItem.initClass();
  return NotificationsLogItem;
})());

================
File: packages/notifications/lib/notifications-log.js
================
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/main/docs/suggestions.md
 */
let NotificationsLog;
const {Emitter, CompositeDisposable, Disposable} = require('atom');
const NotificationsLogItem = require('./notifications-log-item');

const typeIcons = {
  fatal: 'bug',
  error: 'flame',
  warning: 'alert',
  info: 'info',
  success: 'check'
};

module.exports = (NotificationsLog = (function() {
  NotificationsLog = class NotificationsLog {
    static initClass() {
      this.prototype.subscriptions = null;
      this.prototype.logItems = [];
      this.prototype.typesHidden = {
        fatal: false,
        error: false,
        warning: false,
        info: false,
        success: false
      };
    }

    constructor(duplicateTimeDelay, typesHidden = null) {
      this.duplicateTimeDelay = duplicateTimeDelay;
      if (typesHidden != null) { this.typesHidden = typesHidden; }
      this.emitter = new Emitter;
      this.subscriptions = new CompositeDisposable;
      this.subscriptions.add(atom.notifications.onDidClearNotifications(() => this.clearLogItems()));
      this.render();
      this.subscriptions.add(new Disposable(() => this.clearLogItems()));
    }

    render() {
      let button;
      this.element = document.createElement('div');
      this.element.classList.add('notifications-log');

      const header = document.createElement('header');
      this.element.appendChild(header);

      this.list = document.createElement('ul');
      this.list.classList.add('notifications-log-items');
      this.element.appendChild(this.list);

      for (var type in typeIcons) {
        var icon = typeIcons[type];
        button = document.createElement('button');
        button.classList.add('notification-type', 'btn', 'icon', `icon-${icon}`, type);
        button.classList.toggle('show-type', !this.typesHidden[type]);
        this.list.classList.toggle(`hide-${type}`, this.typesHidden[type]);
        button.dataset.type = type;
        button.addEventListener('click', e => this.toggleType(e.target.dataset.type));
        this.subscriptions.add(atom.tooltips.add(button, {title: `Toggle ${type} notifications`}));
        header.appendChild(button);
      }

      button = document.createElement('button');
      button.classList.add('notifications-clear-log', 'btn', 'icon', 'icon-trashcan');
      button.addEventListener('click', e => atom.commands.dispatch(atom.views.getView(atom.workspace), "notifications:clear-log"));
      this.subscriptions.add(atom.tooltips.add(button, {title: "Clear notifications"}));
      header.appendChild(button);

      let lastNotification = null;
      for (var notification of Array.from(atom.notifications.getNotifications())) {
        if (lastNotification != null) {
          // do not show duplicates unless some amount of time has passed
          var timeSpan = notification.getTimestamp() - lastNotification.getTimestamp();
          if (!(timeSpan < this.duplicateTimeDelay) || !notification.isEqual(lastNotification)) {
            this.addNotification(notification);
          }
        } else {
          this.addNotification(notification);
        }

        lastNotification = notification;
      }

      return this.subscriptions.add(new Disposable(() => this.element.remove()));
    }

    destroy() {
      this.subscriptions.dispose();
      return this.emitter.emit('did-destroy');
    }

    getElement() { return this.element; }

    getURI() { return 'atom://notifications/log'; }

    getTitle() { return 'Log'; }

    getLongTitle() { return 'Notifications Log'; }

    getIconName() { return 'alert'; }

    getDefaultLocation() { return 'bottom'; }

    getAllowedLocations() { return ['left', 'right', 'bottom']; }

    serialize() {
      return {
        typesHidden: this.typesHidden,
        deserializer: 'notifications/NotificationsLog'
      };
    }

    toggleType(type, force) {
      const button = this.element.querySelector(`.notification-type.${type}`);
      const hide = !button.classList.toggle('show-type', force);
      this.list.classList.toggle(`hide-${type}`, hide);
      return this.typesHidden[type] = hide;
    }

    addNotification(notification) {
      const logItem = new NotificationsLogItem(notification);
      logItem.onClick(() => this.emitter.emit('item-clicked', notification));
      this.logItems.push(logItem);
      return this.list.insertBefore(logItem.getElement(), this.list.firstChild);
    }

    onItemClick(callback) {
      return this.emitter.on('item-clicked', callback);
    }

    onDidDestroy(callback) {
      return this.emitter.on('did-destroy', callback);
    }

    clearLogItems() {
      for (var logItem of Array.from(this.logItems)) { logItem.destroy(); }
      return this.logItems = [];
    }
  };
  NotificationsLog.initClass();
  return NotificationsLog;
})());

================
File: packages/notifications/lib/template-helper.js
================
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/main/docs/suggestions.md
 */
module.exports = {
  create(htmlString) {
    const template = document.createElement('template');
    template.innerHTML = htmlString;
    document.body.appendChild(template);
    return template;
  },

  render(template) {
    return document.importNode(template.content, true);
  }
};

================
File: packages/notifications/lib/user-utilities.js
================
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/main/docs/suggestions.md
 */
const os = require('os');
const fs = require('fs');
const path = require('path');
const semver = require('semver');
const {BufferedProcess} = require('atom');

/*
A collection of methods for retrieving information about the user's system for
bug report purposes.
*/

const DEV_PACKAGE_PATH = path.join('dev', 'packages');

module.exports = {

  /*
  Section: System Information
  */

  getPlatform() {
    return os.platform();
  },

  // OS version strings lifted from https://github.com/lee-dohm/bug-report
  getOSVersion() {
    return new Promise((resolve, reject) => {
      switch (this.getPlatform()) {
        case 'darwin': return resolve(this.macVersionText());
        case 'win32': return resolve(this.winVersionText());
        case 'linux': return resolve(this.linuxVersionText());
        default: return resolve(`${os.platform()} ${os.release()}`);
      }
    });
  },

  macVersionText() {
    return this.macVersionInfo().then(function(info) {
      if (!info.ProductName || !info.ProductVersion) { return 'Unknown macOS version'; }
      return `${info.ProductName} ${info.ProductVersion}`;
    });
  },

  macVersionInfo() {
    return new Promise(function(resolve, reject) {
      let stdout = '';
      const plistBuddy = new BufferedProcess({
        command: '/usr/libexec/PlistBuddy',
        args: [
          '-c',
          'Print ProductVersion',
          '-c',
          'Print ProductName',
          '/System/Library/CoreServices/SystemVersion.plist'
        ],
        stdout(output) { return stdout += output; },
        exit() {
          const [ProductVersion, ProductName] = Array.from(stdout.trim().split('\n'));
          return resolve({ProductVersion, ProductName});
        }
      });

      return plistBuddy.onWillThrowError(function({handle}) {
        handle();
        return resolve({});
      });
    });
  },

  linuxVersionText() {
    return this.linuxVersionInfo().then(function(info) {
      if (info.DistroName && info.DistroVersion) {
        return `${info.DistroName} ${info.DistroVersion}`;
      } else {
        return `${os.platform()} ${os.release()}`;
      }
    });
  },

  linuxVersionInfo() {
    return new Promise(function(resolve, reject) {
      let stdout = '';

      const lsbRelease = new BufferedProcess({
        command: 'lsb_release',
        args: ['-ds'],
        stdout(output) { return stdout += output; },
        exit(exitCode) {
          const [DistroName, DistroVersion] = Array.from(stdout.trim().split(' '));
          return resolve({DistroName, DistroVersion});
        }
      });

      return lsbRelease.onWillThrowError(function({handle}) {
        handle();
        return resolve({});
      });
    });
  },

  winVersionText() {
    return new Promise(function(resolve, reject) {
      const data = [];
      const systemInfo = new BufferedProcess({
        command: 'systeminfo',
        stdout(oneLine) { return data.push(oneLine); },
        exit() {
          let res;
          let info = data.join('\n');
          info = (res = /OS.Name.\s+(.*)$/im.exec(info)) ? res[1] : 'Unknown Windows version';
          return resolve(info);
        }
      });

      return systemInfo.onWillThrowError(function({handle}) {
        handle();
        return resolve('Unknown Windows version');
      });
    });
  },

  /*
  Section: Installed Packages
  */

  getNonCorePackages() {
    return new Promise(function(resolve, reject) {
      const nonCorePackages = atom.packages.getAvailablePackageMetadata().filter(p => !atom.packages.isBundledPackage(p.name));
      const devPackageNames = atom.packages.getAvailablePackagePaths().filter(p => p.includes(DEV_PACKAGE_PATH)).map(p => path.basename(p));
      return resolve(Array.from(nonCorePackages).map((pack) => `${pack.name} ${pack.version} ${Array.from(devPackageNames).includes(pack.name) ? '(dev)' : ''}`));
    });
  },

  checkPulsarUpToDate() {
    const installedVersion = atom.getVersion().replace(/-.*$/, '');
    return {
      upToDate: true,
      latestVersion: installedVersion,
      installedVersion
    }
  },

  getPackageVersion(packageName) {
    const pack = atom.packages.getLoadedPackage(packageName);
    return (pack != null ? pack.metadata.version : undefined);
  },

  getPackageVersionShippedWithPulsar(packageName) {
    return require(path.join(atom.getLoadSettings().resourcePath, 'package.json')).packageDependencies[packageName];
  },

  getLatestPackageData(packageName) {
    const githubHeaders = new Headers({
      accept: 'application/json',
      contentType: "application/json"
    });
    const apiURL = process.env.ATOM_API_URL || 'https://api.pulsar-edit.dev/api';
    return fetch(`${apiURL}/${packageName}`, {headers: githubHeaders})
      .then(r => {
        if (r.ok) {
          return r.json();
        } else {
          return Promise.reject(new Error(`Fetching updates resulted in status ${r.status}`));
        }
      });
  },

  checkPackageUpToDate(packageName) {
    return this.getLatestPackageData(packageName).then(latestPackageData => {
      let isCore;
      const installedVersion = this.getPackageVersion(packageName);
      let upToDate = (installedVersion != null) && semver.gte(installedVersion, latestPackageData?.releases?.latest);
      const latestVersion = latestPackageData?.releases?.latest;
      const versionShippedWithPulsar = this.getPackageVersionShippedWithPulsar(packageName);

      if (isCore = (versionShippedWithPulsar != null)) {
        // A core package is out of date if the version which is being used
        // is lower than the version which normally ships with the version
        // of Pulsar which is running. This will happen when there's a locally
        // installed version of the package with a lower version than Pulsar's.
        upToDate = (installedVersion != null) && semver.gte(installedVersion, versionShippedWithPulsar);
      }

      return {isCore, upToDate, latestVersion, installedVersion, versionShippedWithPulsar};
  });
  }
};

================
File: packages/package-generator/lib/main.js
================
const PackageGeneratorView = require('./package-generator-view')

module.exports = {
  activate () {
    this.view = new PackageGeneratorView()
  },

  deactivate () {
    if (this.view) this.view.destroy()
  }
}

================
File: packages/package-generator/lib/package-generator-view.js
================
const path = require('path')
const _ = require('underscore-plus')
const {TextEditor, BufferedProcess, CompositeDisposable, Disposable} = require('atom')
const fs = require('fs-plus')

module.exports =
class PackageGeneratorView {
  constructor () {
    this.disposables = new CompositeDisposable()

    this.element = document.createElement('div')
    this.element.classList.add('package-generator')

    this.miniEditor = new TextEditor({mini: true})
    this.element.appendChild(this.miniEditor.element)

    this.error = document.createElement('div')
    this.error.classList.add('error')
    this.element.appendChild(this.error)

    this.message = document.createElement('div')
    this.message.classList.add('message')
    this.element.appendChild(this.message)

    this.disposables.add(atom.commands.add('atom-workspace', {
      'package-generator:generate-package': () => this.attach('package'),
      'package-generator:generate-language-package': () => this.attach('language'),
      'package-generator:generate-syntax-theme': () => this.attach('theme')
    }))

    const blurHandler = () => this.close()
    this.miniEditor.element.addEventListener('blur', blurHandler)
    this.disposables.add(new Disposable(() => this.miniEditor.element.removeEventListener('blur', blurHandler)))
    this.disposables.add(atom.commands.add(this.element, {
      'core:confirm': () => this.confirm(),
      'core:cancel': () => this.close()
    }))
  }

  destroy () {
    if (this.panel != null) this.panel.destroy()
    this.disposables.dispose()
  }

  attach (mode) {
    this.mode = mode
    if (this.panel == null) this.panel = atom.workspace.addModalPanel({item: this, visible: false})
    this.previouslyFocusedElement = document.activeElement
    this.panel.show()
    this.message.textContent = `Enter ${this.mode} path`
    if (this.mode === 'package') {
      this.setPathText('my-package')
    } else if (this.mode === 'language') {
      this.setPathText('language-my-language', [9, Infinity])
    } else {
      this.setPathText('my-theme-syntax', [0, 8])
    }
    this.miniEditor.element.focus()
  }

  setPathText (placeholderName, rangeToSelect) {
    if (rangeToSelect == null) rangeToSelect = [0, placeholderName.length]
    const packagesDirectory = this.getPackagesDirectory()
    this.miniEditor.setText(path.join(packagesDirectory, placeholderName))
    const pathLength = this.miniEditor.getText().length
    const endOfDirectoryIndex = pathLength - placeholderName.length
    this.miniEditor.setSelectedBufferRange([[0, endOfDirectoryIndex + rangeToSelect[0]], [0, endOfDirectoryIndex + rangeToSelect[1]]])
  }

  close () {
    if (!this.panel.isVisible()) return
    this.panel.hide()
    if (this.previouslyFocusedElement != null) this.previouslyFocusedElement.focus()
  }

  confirm () {
    if (this.validPackagePath()) {
      this.createPackageFiles(() => {
        const packagePath = this.getPackagePath()
        atom.open({pathsToOpen: [packagePath]})
        this.close()
      })
    }
  }

  getPackagePath () {
    const packagePath = fs.normalize(this.miniEditor.getText().trim())
    const packageName = _.dasherize(path.basename(packagePath))
    return path.join(path.dirname(packagePath), packageName)
  }

  getPackagesDirectory () {
    return process.env.ATOM_REPOS_HOME || atom.config.get('core.projectHome') || path.join(fs.getHomeDirectory(), 'github')
  }

  validPackagePath () {
    if (fs.existsSync(this.getPackagePath())) {
      this.error.textContent = `Path already exists at '${this.getPackagePath()}'`
      this.error.style.display = 'block'
      return false
    } else {
      return true
    }
  }

  getInitOptions (packagePath) {
    const options = [`--${this.mode}`, packagePath]
    if (this.mode !== 'theme') {
      return [...options, '--syntax', atom.config.get('package-generator.packageSyntax')]
    } else {
      return options
    }
  }

  initPackage (packagePath, callback) {
    const command = ['init'].concat(this.getInitOptions(packagePath))
    this.runCommand(atom.packages.getApmPath(), command, callback)
  }

  linkPackage (packagePath, callback) {
    const args = ['link']
    if (atom.config.get('package-generator.createInDevMode')) args.push('--dev')
    args.push(packagePath.toString())

    this.runCommand(atom.packages.getApmPath(), args, callback)
  }

  isStoredInDotAtom (packagePath) {
    const packagesPath = path.join(atom.getConfigDirPath(), 'packages', path.sep)
    if (packagePath.startsWith(packagesPath)) return true

    const devPackagesPath = path.join(atom.getConfigDirPath(), 'dev', 'packages', path.sep)
    return packagePath.startsWith(devPackagesPath)
  }

  createPackageFiles (callback) {
    const packagePath = this.getPackagePath()

    if (this.isStoredInDotAtom(packagePath)) {
      this.initPackage(packagePath, callback)
    } else {
      this.initPackage(packagePath, () => this.linkPackage(packagePath, callback))
    }
  }

  runCommand (command, args, exit) {
    this.process = new BufferedProcess({command, args, exit})
  }
}

================
File: packages/settings-view/lib/atom-io-client.js
================
const fs = require('fs-plus');
const path = require('path');
const {remote} = require('electron');
const glob = require('glob');
const request = require('request');

module.exports = class AtomIoClient {
  constructor(packageManager, baseURL) {
    this.packageManager = packageManager;
    this.baseURL = baseURL;
    if (this.baseURL == null) { this.baseURL = 'https://api.pulsar-edit.dev/api/'; }
    // 5 hour expiry
    this.expiry = 1000 * 60 * 60 * 5;
    this.createAvatarCache();
    this.expireAvatarCache();
  }

  // Public: Get an avatar image from the filesystem, fetching it first if necessary
  avatar(login, callback) {
    this.cachedAvatar(login, (err, cached) => {
      let stale;
      if (cached) { stale = (Date.now() - parseInt(cached.split('-').pop())) > this.expiry; }
      if (cached && (!stale || !this.online())) {
        return callback(null, cached);
      } else {
        return this.fetchAndCacheAvatar(login, callback);
      }
    });
  }

  // Public: get a package from the atom.io API, with the appropriate level of
  // caching.
  package(name, callback) {
    const packagePath = `packages/${name}`;
    const data = this.fetchFromCache(packagePath);
    if (data) {
      return callback(null, data);
    } else {
      return this.request(packagePath, callback);
    }
  }

  featuredPackages(callback) {
    // TODO clean up caching copypasta
    const data = this.fetchFromCache('packages/featured');
    if (data) {
      return callback(null, data);
    } else {
      return this.getFeatured(false, callback);
    }
  }

  featuredThemes(callback) {
    // TODO clean up caching copypasta
    const data = this.fetchFromCache('themes/featured');
    if (data) {
      return callback(null, data);
    } else {
      return this.getFeatured(true, callback);
    }
  }

  getFeatured(loadThemes, callback) {
    // apm already does this, might as well use it instead of request i guess? The
    // downside is that I need to repeat caching logic here.
    this.packageManager.getFeatured(loadThemes)
      .then(packages => {
        // copypasta from below
        const key = loadThemes ? 'themes/featured' : 'packages/featured';
        const cached = this.deepCache(key, packages);
          // data: packages
          // createdOn: Date.now()
        // localStorage.setItem(@cacheKeyForPath(key), JSON.stringify(cached))
        // end copypasta
        return callback(null, packages);
    }).catch(error => callback(error, null));
  }

  request(path, callback) {
    const options = {
      url: `${this.baseURL}${path}`,
      headers: {'User-Agent': navigator.userAgent},
      gzip: true
    };

    request(options, (err, res, body) => {
      if (err) { return callback(err); }

      try {
        // NOTE: request's json option does not populate err if parsing fails,
        // so we do it manually
        body = this.parseJSON(body);
        delete body.versions;

        const cached = this.deepCache(path, body);
        // cached =
        //   data: body
        //   createdOn: Date.now()
        // localStorage.setItem(@cacheKeyForPath(path), JSON.stringify(cached))
        return callback(err, cached.data);
      } catch (error) {
        return callback(error);
      }
    });
  }

  deepCache(path, body) {
    const cached = {
      data: body,
      createdOn: Date.now()
    };
    localStorage.setItem(this.cacheKeyForPath(path), JSON.stringify(cached));
    if(body instanceof Array) {
      body.forEach(child => this.deepCache(`packages/${child.name}`, child));
    }
    return cached;
  }

  cacheKeyForPath(path) {
    return `settings-view:${path}`;
  }

  online() {
    return navigator.onLine;
  }

  // This could use a better name, since it checks whether it's appropriate to return
  // the cached data and pretends it's null if it's stale and we're online
  fetchFromCache(packagePath) {
    let cached = localStorage.getItem(this.cacheKeyForPath(packagePath));
    cached = cached ? this.parseJSON(cached) : undefined;
    if ((cached != null) && (!this.online() || ((Date.now() - cached.createdOn) < this.expiry))) {
      return cached.data;
    } else {
      // falsy data means "try to hit the network"
      return null;
    }
  }

  createAvatarCache() {
    return fs.makeTree(this.getCachePath());
  }

  avatarPath(login) {
    return path.join(this.getCachePath(), `${login}-${Date.now()}`);
  }

  cachedAvatar(login, callback) {
    glob(this.avatarGlob(login), (err, files) => {
      if (err) { return callback(err); }
      files.sort().reverse();
      for (let imagePath of Array.from(files)) {
        const filename = path.basename(imagePath);
        const array = filename.split('-'), createdOn = array[array.length - 1];
        if ((Date.now() - parseInt(createdOn)) < this.expiry) {
          return callback(null, imagePath);
        }
      }
      return callback(null, null);
    });
  }

  avatarGlob(login) {
    return path.join(this.getCachePath(), `${login}-*([0-9])`);
  }

  fetchAndCacheAvatar(login, callback) {
    if (!this.online()) {
      return callback(null, null);
    } else {
      const imagePath = this.avatarPath(login);
      const requestObject = {
        url: `https://avatars.githubusercontent.com/${login}`,
        headers: {'User-Agent': navigator.userAgent}
      };
      return request.head(requestObject, function(error, response, body) {
        if ((error != null) || (response.statusCode !== 200) || !response.headers['content-type'].startsWith('image/')) {
          return callback(error);
        } else {
          const writeStream = fs.createWriteStream(imagePath);
          writeStream.on('finish', () => callback(null, imagePath));
          writeStream.on('error', function(error) {
            writeStream.close();
            try {
              if (fs.existsSync(imagePath)) { fs.unlinkSync(imagePath); }
            } catch (error1) {}
            return callback(error);
          });
          return request(requestObject).pipe(writeStream);
        }
      });
    }
  }

  // The cache expiry doesn't need to be clever, or even compare dates, it just
  // needs to always keep around the newest item, and that item only. The localStorage
  // cache updates in place, so it doesn't need to be purged.

  expireAvatarCache() {
    const deleteAvatar = child => {
      const avatarPath = path.join(this.getCachePath(), child);
      fs.unlink(avatarPath, function(error) {
        if (error && (error.code !== 'ENOENT')) { // Ignore cache paths that don't exist
          return console.warn(`Error deleting avatar (${error.code}): ${avatarPath}`);
        }
      });
    };

    return fs.readdir(this.getCachePath(), function(error, _files) {
      let key;
      if (_files == null) { _files = []; }
      const files = {};
      for (let filename of Array.from(_files)) {
        const parts = filename.split('-');
        const stamp = parts.pop();
        key = parts.join('-');
        if (files[key] == null) { files[key] = []; }
        files[key].push(`${key}-${stamp}`);
      }

      const result = [];
      for (key in files) {
        const children = files[key];
        children.sort();
        children.pop(); // keep
        // Right now a bunch of clients might be instantiated at once, so
        // we can just ignore attempts to unlink files that have already been removed
        // - this should be fixed with a singleton client
        result.push(children.forEach(deleteAvatar));
      }
      return result;
    });
  }

  getCachePath() {
    return this.cachePath != null ? this.cachePath : (this.cachePath = path.join(remote.app.getPath('userData'), 'Cache', 'settings-view'));
  }

  search(query, options) {
    const qs = {q: query};

    if (options.themes) {
      qs.filter = 'theme';
    } else if (options.packages) {
      qs.filter = 'package';
    }

    options = {
      url: `${this.baseURL}packages/search`,
      headers: {'User-Agent': navigator.userAgent},
      qs,
      gzip: true
    };

    return new Promise((resolve, reject) => {
      request(options, (err, res, textBody) => {
        let error;
        if (err) {
          error = new Error(`Searching for \u201C${query}\u201D failed.`);
          error.stderr = err.message;
          return reject(error);
        } else {
          try {
            // NOTE: request's json option does not populate err if parsing fails,
            // so we do it manually
            const body = this.parseJSON(textBody);
            if (body.filter) {
              resolve(
                body.filter(pkg => (pkg.releases != null ? pkg.releases.latest : undefined) != null)
                    .map(({readme, metadata, downloads, stargazers_count, repository, badges}) => Object.assign(metadata, {readme, downloads, stargazers_count, badges, repository: repository.url}))
              );
            }
            else {}
            error = new Error(`Searching for \u201C${query}\u201D failed.\n`);
            error.stderr = "API returned: " + textBody;
            return reject(error);

          } catch (e) {
            error = new Error(`Searching for \u201C${query}\u201D failed.`);
            error.stderr = e.message + '\n' + textBody;
            return reject(error);
          }
        }
      });
    });
  }

  parseJSON(s) {
    return JSON.parse(s);
  }
};

================
File: packages/settings-view/lib/badge-view.js
================
/** @babel */
/** @jsx etch.dom */

import etch from 'etch'

export default class BadgeView {
  constructor(badge) {
    this.badge = badge;

    etch.initialize(this)
  }

  render () {
    const icons = this.getIcons();
    const classes = this.getClasses();
    const badge = this.badge;

    if (this.hasLink()) {
      if (this.hasText()) {
        // Link and Text

        return (
          <a href={badge.link}>
            <span class={classes}>
              <i class={icons}></i>
              {badge.title}: <span class="badge-expandable">...</span><span class="badge-text"> {badge.text}</span>
            </span>
          </a>
        );
      } else {
        // Link no text

        return (
          <a href={badge.link}>
            <span class={classes}>
              <i class={icons}></i>
              {badge.title}
            </span>
          </a>
        );
      }
    } else {
      if (this.hasText()) {
        // No Link, has Text

        return (
          <span class={classes}>
            <i class={icons}></i>
            {badge.title}: <span class="badge-expandable">...</span><span class="badge-text"> {badge.text}</span>
          </span>
        );
      } else {
        // No Link, no text

        return (
          <span class={classes}>
            <i class={icons}></i>
            {badge.title}
          </span>
        );
      }
    }
    
  }

  hasLink () {
    if (typeof this.badge.link === "string") {
      return true;
    }
    return false;
  }

  hasText () {
    if (typeof this.badge.text === "string") {
      return true;
    }
    return false;
  }

  getIcons () {
    switch(this.badge.type) {
      case "warn":
        return "icon icon-alert";
        break;
      case "success":
        return "icon icon-check";
        break;
      case "info":
        return "icon icon-info";
        break;
      default:
        return "";
        break;
    }
  }

  getClasses () {
    switch(this.badge.type) {
      case "warn":
        return "badge badge-error";
        break;
      case "success":
        return "badge badge-success";
        break;
      case "info":
        return "badge badge-info";
        break;
      default:
        return "badge";
        break;
    }
  }

  update () {}

  destroy () {}

}

================
File: packages/settings-view/lib/collapsible-section-panel.js
================
/** @babel */

import {Disposable} from 'atom'

export default class CollapsibleSectionPanel {
  notHiddenCardsLength (sectionElement) {
    return sectionElement.querySelectorAll('.package-card:not(.hidden)').length
  }

  updateSectionCount (headerElement, countElement, packageCount, totalCount) {
    if (totalCount != null) {
      countElement.textContent = `${packageCount}/${totalCount}`
    } else {
      countElement.textContent = packageCount
    }

    if (packageCount > 0) {
      headerElement.classList.add('has-items')
    }
  }

  updateSectionCounts () {
    this.resetSectionHasItems()

    const filterText = this.refs.filterEditor.getText()
    if (filterText === '') {
      this.updateUnfilteredSectionCounts()
    } else {
      this.updateFilteredSectionCounts()
    }
  }

  handleEvents () {
    const handler = (e) => {
      const target = e.target.closest('.sub-section .has-items')
      if (target) {
        target.parentNode.classList.toggle('collapsed')
      }
    }
    this.element.addEventListener('click', handler)
    return new Disposable(() => this.element.removeEventListener('click', handler))
  }

  resetCollapsibleSections (headerSections) {
    for (const headerSection of headerSections) {
      this.resetCollapsibleSection(headerSection)
    }
  }

  resetCollapsibleSection (headerSection) {
    headerSection.classList.remove('has-items')
  }
}

================
File: packages/settings-view/lib/editor-panel.js
================
/** @babel */
/** @jsx etch.dom */

import {CompositeDisposable} from 'atom'
import etch from 'etch'
import SettingsPanel from './settings-panel'

export default class EditorPanel {
  constructor () {
    etch.initialize(this)
    this.subscriptions = new CompositeDisposable()
    this.subscriptions.add(atom.commands.add(this.element, {
      'core:move-up': () => { this.scrollUp() },
      'core:move-down': () => { this.scrollDown() },
      'core:page-up': () => { this.pageUp() },
      'core:page-down': () => { this.pageDown() },
      'core:move-to-top': () => { this.scrollToTop() },
      'core:move-to-bottom': () => { this.scrollToBottom() }
    }))
  }

  destroy () {
    this.subscriptions.dispose()
    return etch.destroy(this)
  }

  update () {}

  render () {
    return (
      <div tabIndex='0' className='panels-item' onclick={this.didClick}>
        <SettingsPanel
          namespace='editor'
          icon='code'
          note={`<div class="text icon icon-question" id="editor-settings-note" tabindex="-1">These settings are related to text editing. Some of these can be overriden on a per-language basis. Check language settings by clicking its package card in the <a class="link packages-open">Packages list</a>.</div>`} />
      </div>
    )
  }

  focus () {
    this.element.focus()
  }

  show () {
    this.element.style.display = ''
  }

  didClick (event) {
    const target = event.target.closest('.packages-open')
    if (target) {
      atom.workspace.open('atom://config/packages')
    }
  }

  scrollUp () {
    this.element.scrollTop -= document.body.offsetHeight / 20
  }

  scrollDown () {
    this.element.scrollTop += document.body.offsetHeight / 20
  }

  pageUp () {
    this.element.scrollTop -= this.element.offsetHeight
  }

  pageDown () {
    this.element.scrollTop += this.element.offsetHeight
  }

  scrollToTop () {
    this.element.scrollTop = 0
  }

  scrollToBottom () {
    this.element.scrollTop = this.element.scrollHeight
  }
}

================
File: packages/settings-view/lib/error-view.js
================
/** @babel */
/** @jsx etch.dom */

import etch from 'etch'

export default class ErrorView {
  constructor (packageManager, {message, stderr, packageInstallError}) {
    etch.initialize(this)

    this.isOutputHidden = true
    this.refs.detailsArea.style.display = 'none'
    this.refs.details.textContent = stderr
    this.refs.message.textContent = message

    // Check for native build tools and show warning if missing.
    if (packageInstallError && process.platform === 'win32') {
      packageManager.checkNativeBuildTools().catch(() => {
        this.refs.alert.appendChild(new CompileToolsErrorView().element)
      })
    }
  }

  update () {}

  destroy () {
    return etch.destroy(this)
  }

  render () {
    return (
      <div className='error-message'>
        <div ref='alert' className='alert alert-danger alert-dismissable native-key-bindings' tabIndex='-1'>
          <button ref='close' className='close icon icon-x' onclick={() => this.destroy()} />
          <span ref='message' className='native-key-bindings' />
          <a ref='detailsLink' className='alert-link error-link' onclick={() => this.toggleOutput()}>{'Show output\u2026'}</a>
          <div ref='detailsArea' className='padded'>
            <pre ref='details' className='error-details text' />
          </div>
        </div>
      </div>
    )
  }

  toggleOutput () {
    if (this.isOutputHidden) {
      this.isOutputHidden = false
      this.refs.detailsArea.style.display = ''
      this.refs.detailsLink.textContent = 'Hide output\u2026'
    } else {
      this.isOutputHidden = true
      this.refs.detailsArea.style.display = 'none'
      this.refs.detailsLink.textContent = 'Show output\u2026'
    }
  }
}

class CompileToolsErrorView {
  constructor () {
    etch.initialize(this)
  }

  update () {}

  render () {
    return (
      <div>
        <div className='icon icon-alert compile-tools-heading compile-tools-message'>Compiler tools not found</div>
        <div className='compile-tools-message'>Packages that depend on modules that contain C/C++ code will fail to install.</div>
        <div className='compile-tools-message'>
          <span>Please install Python and Visual Studio to continue.</span>
        </div>
        <div className='compile-tools-message'>
          <span>Run </span>
          <code className='alert-danger'>pulsar -p install --check</code>
          <span> after installing to test compiling a native module.</span>
        </div>
      </div>
    )
  }
}

================
File: packages/settings-view/lib/general-panel.js
================
/** @babel */
/** @jsx etch.dom */

import {CompositeDisposable} from 'atom'
import etch from 'etch'
import SettingsPanel from './settings-panel'

export default class GeneralPanel {
  constructor () {
    etch.initialize(this)
    this.subscriptions = new CompositeDisposable()
    this.subscriptions.add(atom.commands.add(this.element, {
      'core:move-up': () => { this.scrollUp() },
      'core:move-down': () => { this.scrollDown() },
      'core:page-up': () => { this.pageUp() },
      'core:page-down': () => { this.pageDown() },
      'core:move-to-top': () => { this.scrollToTop() },
      'core:move-to-bottom': () => { this.scrollToBottom() }
    }))
  }

  destroy () {
    this.subscriptions.dispose()
    return etch.destroy(this)
  }

  update () {}

  render () {
    return (
      <div tabIndex='0' className='panels-item' onclick={this.didClick}>
        <SettingsPanel
          ref='panel'
          namespace='core'
          icon='settings'
          note={`<div class="text icon icon-question" id="core-settings-note" tabindex="-1">These are Pulsar's core settings which affect behavior unrelated to text editing. Individual packages may have their own additional settings found within their package card in the <a class="link packages-open">Packages list</a>.</div>`} />
      </div>
    )
  }

  focus () {
    this.element.focus()
  }

  show () {
    this.element.style.display = ''
  }

  didClick (event) {
    const target = event.target.closest('.packages-open')
    if (target) {
      atom.workspace.open('atom://config/packages')
    }
  }

  scrollUp () {
    this.element.scrollTop -= document.body.offsetHeight / 20
  }

  scrollDown () {
    this.element.scrollTop += document.body.offsetHeight / 20
  }

  pageUp () {
    this.element.scrollTop -= this.element.offsetHeight
  }

  pageDown () {
    this.element.scrollTop += this.element.offsetHeight
  }

  scrollToTop () {
    this.element.scrollTop = 0
  }

  scrollToBottom () {
    this.element.scrollTop = this.element.scrollHeight
  }
}

================
File: packages/settings-view/lib/install-panel.js
================
/** @babel */
/** @jsx etch.dom */

import path from 'path'
import electron from 'electron'
import etch from 'etch'
import hostedGitInfo from 'hosted-git-info'

import {CompositeDisposable, TextEditor} from 'atom'

import PackageCard from './package-card'
import ErrorView from './error-view'

const PackageNameRegex = /config\/install\/(package|theme):([a-z0-9-_]+)/i

export default class InstallPanel {
  constructor (settingsView, packageManager) {
    this.settingsView = settingsView
    this.packageManager = packageManager
    this.disposables = new CompositeDisposable()
    this.client = this.packageManager.getClient()
    this.atomIoURL = 'https://web.pulsar-edit.dev/'

    etch.initialize(this)

    this.refs.searchMessage.style.display = 'none'

    this.refs.searchEditor.setPlaceholderText('Search packages')
    this.searchType = 'packages'
    this.disposables.add(
      this.packageManager.on('package-install-failed', ({pack, error}) => {
        this.refs.searchErrors.appendChild(new ErrorView(this.packageManager, error).element)
      })
    )
    this.disposables.add(
      this.packageManager.on('package-installed theme-installed', ({pack}) => {
        const gitUrlInfo =
          (this.currentGitPackageCard && this.currentGitPackageCard.pack && this.currentGitPackageCard.pack.gitUrlInfo)
          ? this.currentGitPackageCard.pack.gitUrlInfo
          : null

        if (gitUrlInfo && gitUrlInfo === pack.gitUrlInfo) {
          this.updateGitPackageCard(pack)
        }
      })
    )
    const searchBuffer = this.refs.searchEditor.getBuffer();
    searchBuffer.debouncedEmitDidStopChangingEvent = (timer => () => {
      clearTimeout(timer);
      timer = setTimeout(searchBuffer.emitDidStopChangingEvent.bind(searchBuffer), 700);
    })();
    // TODO remove hack to extend stop changing delay
    this.disposables.add(
      this.refs.searchEditor.onDidStopChanging(() => {
        this.performSearch()
      })
    )
    this.disposables.add(atom.commands.add(this.element, {
      'core:move-up': () => { this.scrollUp() },
      'core:move-down': () => { this.scrollDown() },
      'core:page-up': () => { this.pageUp() },
      'core:page-down': () => { this.pageDown() },
      'core:move-to-top': () => { this.scrollToTop() },
      'core:move-to-bottom': () => { this.scrollToBottom() }
    }))

    this.loadFeaturedPackages()
  }

  destroy () {
    this.disposables.dispose()
    return etch.destroy(this)
  }

  update () {}

  focus () {
    this.refs.searchEditor.element.focus()
  }

  show () {
    this.element.style.display = ''
  }

  render () {
    return (
      <div className='panels-item' tabIndex='-1'>
        <div className='section packages'>
          <div className='section-container'>
            <h1 ref='installHeading' className='section-heading icon icon-plus'>Install Packages</h1>

            <div className='text native-key-bindings' tabIndex='-1'>
              <span className='icon icon-question' />
              <span ref='publishedToText'>Packages are published to </span>
              <a className='link' onclick={this.didClickOpenAtomIo.bind(this)}>web.pulsar-edit.dev</a>
              <span> and are installed to {path.join(process.env.ATOM_HOME, 'packages')}</span>
            </div>

            <div className='search-container clearfix'>
              <div className='editor-container'>
                <TextEditor mini ref='searchEditor' />
              </div>
              <div className='btn-group'>
                <button ref='searchPackagesButton' className='btn btn-default selected' onclick={this.didClickSearchPackagesButton.bind(this)}>Packages</button>
                <button ref='searchThemesButton' className='btn btn-default' onclick={this.didClickSearchThemesButton.bind(this)}>Themes</button>
              </div>
            </div>

            <div ref='searchErrors' />
            <div ref='searchMessage' className='alert alert-info search-message icon icon-search' />
            <div ref='resultsContainer' className='container package-container' />
          </div>
        </div>

        <div className='section packages'>
          <div className='section-container'>
            <div ref='featuredHeading' className='section-heading icon icon-star' />
            <div ref='featuredErrors' />
            <div ref='loadingMessage' className='alert alert-info icon icon-hourglass' />
            <div ref='featuredContainer' className='container package-container' />
          </div>
        </div>
      </div>
    )
  }

  setSearchType (searchType) {
    if (searchType === 'theme') {
      this.searchType = 'themes'
      this.refs.searchThemesButton.classList.add('selected')
      this.refs.searchPackagesButton.classList.remove('selected')
      this.refs.searchEditor.setPlaceholderText('Search themes')
      this.refs.publishedToText.textContent = 'Themes are published to '
      this.atomIoURL = 'https://pulsar-edit.dev/themes'
      this.loadFeaturedPackages(true)
    } else if (searchType === 'package') {
      this.searchType = 'packages'
      this.refs.searchPackagesButton.classList.add('selected')
      this.refs.searchThemesButton.classList.remove('selected')
      this.refs.searchEditor.setPlaceholderText('Search packages')
      this.refs.publishedToText.textContent = 'Packages are published to '
      this.atomIoURL = 'https://web.pulsar-edit.dev/packages'
      this.loadFeaturedPackages()
    }
  }

  beforeShow (options) {
    if (options && options.uri) {
      const query = this.extractQueryFromURI(options.uri)
      if (query != null) {
        const {searchType, packageName} = query
        this.setSearchType(searchType)
        this.refs.searchEditor.setText(packageName)
        this.performSearch()
      }
    }
  }

  extractQueryFromURI (uri) {
    const matches = PackageNameRegex.exec(uri)
    if (matches) {
      const [, searchType, packageName] = Array.from(matches)
      return {searchType, packageName}
    } else {
      return null
    }
  }

  performSearch () {
    const query = this.refs.searchEditor.getText().trim().toLowerCase()
    if (query) {
      this.performSearchForQuery(query)
    }
  }

  performSearchForQuery (query) {
    const gitUrlInfo = hostedGitInfo.fromUrl(query)
    if (gitUrlInfo) {
      const type = gitUrlInfo.default
      if (type === 'sshurl' || type === 'https' || type === 'shortcut') {
        this.showGitInstallPackageCard({name: query, gitUrlInfo})
      }
    } else {
      this.search(query)
    }
  }

  showGitInstallPackageCard (pack) {
    if (this.currentGitPackageCard) {
      this.currentGitPackageCard.destroy()
    }

    this.currentGitPackageCard = this.getPackageCardView(pack)
    this.currentGitPackageCard.displayGitPackageInstallInformation()
    this.replaceCurrentGitPackageCardView()
  }

  updateGitPackageCard (pack) {
    if (this.currentGitPackageCard) {
      this.currentGitPackageCard.destroy()
    }

    this.currentGitPackageCard = this.getPackageCardView(pack)
    this.replaceCurrentGitPackageCardView()
  }

  replaceCurrentGitPackageCardView () {
    this.refs.resultsContainer.innerHTML = ''
    this.addPackageCardView(this.refs.resultsContainer, this.currentGitPackageCard)
  }

  async search (query) {
    this.refs.resultsContainer.innerHTML = ''
    this.refs.searchMessage.textContent = `Searching ${this.searchType} for \u201C${query}\u201D\u2026`
    this.refs.searchMessage.style.display = ''

    const options = {}
    options[this.searchType] = true

    try {
      const packages = (await this.client.search(query, options)) || []
      this.refs.resultsContainer.innerHTML = ''
      this.refs.searchMessage.style.display = 'none'
      if (packages.length === 0) {
        this.refs.searchMessage.textContent = `No ${this.searchType.replace(/s$/, '')} results for \u201C${query}\u201D`
        this.refs.searchMessage.style.display = ''
      }

      this.addPackageViews(this.refs.resultsContainer, packages)
    } catch (error) {
      this.refs.searchMessage.style.display = 'none'
      this.refs.searchErrors.appendChild(new ErrorView(this.packageManager, error).element)
    }
  }

  addPackageViews (container, packages) {
    for (const pack of packages) {
      this.addPackageCardView(container, this.getPackageCardView(pack))
    }
  }

  addPackageCardView (container, packageCard) {
    const packageRow = document.createElement('div')
    packageRow.classList.add('row')
    packageRow.appendChild(packageCard.element)
    container.appendChild(packageRow)
  }

  getPackageCardView (pack) {
    return new PackageCard(pack, this.settingsView, this.packageManager, {back: 'Install'})
  }

  filterPackages (packages, themes) {
    return packages.filter(({theme}) => themes ? theme : !theme)
  }

  // Load and display the featured packages that are available to install.
  loadFeaturedPackages (loadThemes) {
    if (loadThemes == null) {
      loadThemes = false
    }
    this.refs.featuredContainer.innerHTML = ''

    if (loadThemes) {
      this.refs.installHeading.textContent = 'Install Themes'
      this.refs.featuredHeading.textContent = 'Featured Themes'
      this.refs.loadingMessage.textContent = 'Loading featured themes\u2026'
    } else {
      this.refs.installHeading.textContent = 'Install Packages'
      this.refs.featuredHeading.textContent = 'Featured Packages'
      this.refs.loadingMessage.textContent = 'Loading featured packages\u2026'
    }

    this.refs.loadingMessage.style.display = ''

    const handle = error => {
      this.refs.loadingMessage.style.display = 'none'
      this.refs.featuredErrors.appendChild(new ErrorView(this.packageManager, error).element)
    }

    if (loadThemes) {
      this.client.featuredThemes((error, themes) => {
        if (error) {
          handle(error)
        } else {
          this.refs.loadingMessage.style.display = 'none'
          this.refs.featuredHeading.textContent = 'Featured Themes'
          this.addPackageViews(this.refs.featuredContainer, themes)
        }
      })
    } else {
      this.client.featuredPackages((error, packages) => {
        if (error) {
          handle(error)
        } else {
          this.refs.loadingMessage.style.display = 'none'
          this.refs.featuredHeading.textContent = 'Featured Packages'
          this.addPackageViews(this.refs.featuredContainer, packages)
        }
      })
    }
  }

  didClickOpenAtomIo (event) {
    event.preventDefault()
    electron.shell.openExternal(this.atomIoURL)
  }

  didClickSearchPackagesButton () {
    if (!this.refs.searchPackagesButton.classList.contains('selected')) {
      this.setSearchType('package')
    }

    this.performSearch()
  }

  didClickSearchThemesButton () {
    if (!this.refs.searchThemesButton.classList.contains('selected')) {
      this.setSearchType('theme')
    }

    this.performSearch()
  }

  scrollUp () {
    this.element.scrollTop -= document.body.offsetHeight / 20
  }

  scrollDown () {
    this.element.scrollTop += document.body.offsetHeight / 20
  }

  pageUp () {
    this.element.scrollTop -= this.element.offsetHeight
  }

  pageDown () {
    this.element.scrollTop += this.element.offsetHeight
  }

  scrollToTop () {
    this.element.scrollTop = 0
  }

  scrollToBottom () {
    this.element.scrollTop = this.element.scrollHeight
  }
}

================
File: packages/settings-view/lib/installed-packages-panel.js
================
/** @babel */
/** @jsx etch.dom */

import {CompositeDisposable, TextEditor} from 'atom'
import etch from 'etch'

import CollapsibleSectionPanel from './collapsible-section-panel'
import PackageCard from './package-card'
import ErrorView from './error-view'

import List from './list'
import ListView from './list-view'
import {ownerFromRepository, packageComparatorAscending} from './utils'

export default class InstalledPackagesPanel extends CollapsibleSectionPanel {
  static loadPackagesDelay () {
    return 300
  }

  constructor (settingsView, packageManager) {
    super()
    etch.initialize(this)
    this.settingsView = settingsView
    this.packageManager = packageManager
    this.items = {
      dev: new List('name'),
      core: new List('name'),
      user: new List('name'),
      git: new List('name')
    }
    this.itemViews = {
      dev: new ListView(this.items.dev, this.refs.devPackages, this.createPackageCard.bind(this)),
      core: new ListView(this.items.core, this.refs.corePackages, this.createPackageCard.bind(this)),
      user: new ListView(this.items.user, this.refs.communityPackages, this.createPackageCard.bind(this)),
      git: new ListView(this.items.git, this.refs.gitPackages, this.createPackageCard.bind(this))
    }

    this.subscriptions = new CompositeDisposable()
    this.subscriptions.add(
      this.refs.filterEditor.onDidStopChanging(() => { this.matchPackages() })
    )
    this.subscriptions.add(
      this.packageManager.on('package-install-failed theme-install-failed package-uninstall-failed theme-uninstall-failed package-update-failed theme-update-failed', ({pack, error}) => {
        this.refs.updateErrors.appendChild(new ErrorView(this.packageManager, error).element)
      })
    )

    let loadPackagesTimeout
    this.subscriptions.add(
      this.packageManager.on('package-updated package-installed package-uninstalled', () => {
        clearTimeout(loadPackagesTimeout)
        loadPackagesTimeout = setTimeout(this.loadPackages.bind(this), InstalledPackagesPanel.loadPackagesDelay())
      })
    )

    this.subscriptions.add(this.handleEvents())
    this.subscriptions.add(atom.commands.add(this.element, {
      'core:move-up': () => { this.scrollUp() },
      'core:move-down': () => { this.scrollDown() },
      'core:page-up': () => { this.pageUp() },
      'core:page-down': () => { this.pageDown() },
      'core:move-to-top': () => { this.scrollToTop() },
      'core:move-to-bottom': () => { this.scrollToBottom() }
    }))

    this.loadPackages()
  }

  focus () {
    this.refs.filterEditor.element.focus()
  }

  show () {
    this.element.style.display = ''
  }

  destroy () {
    this.subscriptions.dispose()
    return etch.destroy(this)
  }

  update () {}

  render () {
    return (
      <div className='panels-item' tabIndex='-1'>
        <section className='section'>
          <div className='section-container'>
            <div className='section-heading icon icon-package'>
              Installed Packages
              <span ref='totalPackages' className='section-heading-count badge badge-flexible'>…</span>
            </div>
            <div className='editor-container'>
              <TextEditor ref='filterEditor' mini placeholderText='Filter packages by name' />
            </div>

            <div ref='updateErrors' />

            <section className='sub-section installed-packages'>
              <h3 ref='communityPackagesHeader' className='sub-section-heading icon icon-package'>
                Community Packages
                <span ref='communityCount' className='section-heading-count badge badge-flexible'>…</span>
              </h3>
              <div ref='communityPackages' className='container package-container'>
                <div ref='communityLoadingArea' className='alert alert-info loading-area icon icon-hourglass'>Loading packages…</div>
              </div>
            </section>

            <section className='sub-section core-packages'>
              <h3 ref='corePackagesHeader' className='sub-section-heading icon icon-package'>
                Core Packages
                <span ref='coreCount' className='section-heading-count badge badge-flexible'>…</span>
              </h3>
              <div ref='corePackages' className='container package-container'>
                <div ref='coreLoadingArea' className='alert alert-info loading-area icon icon-hourglass'>Loading packages…</div>
              </div>
            </section>

            <section className='sub-section dev-packages'>
              <h3 ref='devPackagesHeader' className='sub-section-heading icon icon-package'>
                Development Packages
                <span ref='devCount' className='section-heading-count badge badge-flexible'>…</span>
              </h3>
              <div ref='devPackages' className='container package-container'>
                <div ref='devLoadingArea' className='alert alert-info loading-area icon icon-hourglass'>Loading packages…</div>
              </div>
            </section>

            <section className='sub-section git-packages'>
              <h3 ref='gitPackagesHeader' className='sub-section-heading icon icon-package'>
                Git Packages
                <span ref='gitCount' className='section-heading-count badge badge-flexible'>…</span>
              </h3>
              <div ref='gitPackages' className='container package-container'>
                <div ref='gitLoadingArea' className='alert alert-info loading-area icon icon-hourglass'>Loading packages…</div>
              </div>
            </section>
          </div>
        </section>
      </div>
    )
  }

  filterPackages (packages) {
    packages.dev = packages.dev.filter(({theme}) => !theme)
    packages.user = packages.user.filter(({theme}) => !theme)
    packages.core = packages.core.filter(({theme}) => !theme)
    packages.git = (packages.git || []).filter(({theme}) => !theme)

    for (let packageType of ['dev', 'core', 'user', 'git']) {
      for (let pack of packages[packageType]) {
        pack.owner = ownerFromRepository(pack.repository)
      }
    }

    return packages
  }

  sortPackages (packages) {
    packages.dev.sort(packageComparatorAscending)
    packages.core.sort(packageComparatorAscending)
    packages.user.sort(packageComparatorAscending)
    packages.git.sort(packageComparatorAscending)
    return packages
  }

  loadPackages () {
    const packagesWithUpdates = {}
    this.packageManager.getOutdated().then((packages) => {
      for (let {name, latestVersion} of packages) {
        packagesWithUpdates[name] = latestVersion
      }
      this.displayPackageUpdates(packagesWithUpdates)
    })

    this.packageManager.getInstalled().then((packages) => {
      this.packages = this.sortPackages(this.filterPackages(packages))
      this.refs.devLoadingArea.remove()
      this.items.dev.setItems(this.packages.dev)

      this.refs.coreLoadingArea.remove()
      this.items.core.setItems(this.packages.core)

      this.refs.communityLoadingArea.remove()
      this.items.user.setItems(this.packages.user)

      this.refs.gitLoadingArea.remove()
      this.items.git.setItems(this.packages.git)

      // TODO show empty mesage per section

      this.updateSectionCounts()
      this.displayPackageUpdates(packagesWithUpdates)

      this.matchPackages()
    }).catch((error) => {
      console.error(error.message, error.stack)
    })
  }

  displayPackageUpdates (packagesWithUpdates) {
    for (const packageType of ['dev', 'core', 'user', 'git']) {
      for (const packageCard of this.itemViews[packageType].getViews()) {
        const newVersion = packagesWithUpdates[packageCard.pack.name]
        if (newVersion) {
          packageCard.displayAvailableUpdate(newVersion)
        }
      }
    }
  }

  createPackageCard (pack) {
    return new PackageCard(pack, this.settingsView, this.packageManager, {back: 'Packages'})
  }

  filterPackageListByText (text) {
    if (!this.packages) {
      return
    }

    for (let packageType of ['dev', 'core', 'user', 'git']) {
      const allViews = this.itemViews[packageType].getViews()
      const activeViews = this.itemViews[packageType].filterViews((pack) => {
        if (text === '') {
          return true
        } else {
          const owner = pack.owner != null ? pack.owner : ownerFromRepository(pack.repository)
          const filterText = `${pack.name} ${owner}`
          return atom.ui.fuzzyMatcher.score(filterText, text) > 0
        }
      })

      for (const view of allViews) {
        if (view) {
          view.element.style.display = 'none'
          view.element.classList.add('hidden')
        }
      }

      for (const view of activeViews) {
        if (view) {
          view.element.style.display = ''
          view.element.classList.remove('hidden')
        }
      }
    }

    this.updateSectionCounts()
  }

  updateUnfilteredSectionCounts () {
    this.updateSectionCount(this.refs.communityPackagesHeader, this.refs.communityCount, this.packages.user.length)
    this.updateSectionCount(this.refs.corePackagesHeader, this.refs.coreCount, this.packages.core.length)
    this.updateSectionCount(this.refs.devPackagesHeader, this.refs.devCount, this.packages.dev.length)
    this.updateSectionCount(this.refs.gitPackagesHeader, this.refs.gitCount, this.packages.git.length)

    const totalPackages =
      this.packages.user.length +
      this.packages.core.length +
      this.packages.dev.length +
      this.packages.git.length
    this.refs.totalPackages.textContent = totalPackages.toString()
  }

  updateFilteredSectionCounts () {
    const community = this.notHiddenCardsLength(this.refs.communityPackages)
    this.updateSectionCount(this.refs.communityPackagesHeader, this.refs.communityCount, community, this.packages.user.length)

    const core = this.notHiddenCardsLength(this.refs.corePackages)
    this.updateSectionCount(this.refs.corePackagesHeader, this.refs.coreCount, core, this.packages.core.length)

    const dev = this.notHiddenCardsLength(this.refs.devPackages)
    this.updateSectionCount(this.refs.devPackagesHeader, this.refs.devCount, dev, this.packages.dev.length)

    const git = this.notHiddenCardsLength(this.refs.gitPackages)
    this.updateSectionCount(this.refs.gitPackagesHeader, this.refs.gitCount, git, this.packages.git.length)

    const shownPackages = dev + core + community + git
    const totalPackages = this.packages.user.length + this.packages.core.length + this.packages.dev.length + this.packages.git.length
    this.refs.totalPackages.textContent = `${shownPackages}/${totalPackages}`
  }

  resetSectionHasItems () {
    this.resetCollapsibleSections([this.refs.communityPackagesHeader, this.refs.corePackagesHeader, this.refs.devPackagesHeader, this.refs.gitPackagesHeader])
  }

  matchPackages () {
    this.filterPackageListByText(this.refs.filterEditor.getText())
  }

  scrollUp () {
    this.element.scrollTop -= document.body.offsetHeight / 20
  }

  scrollDown () {
    this.element.scrollTop += document.body.offsetHeight / 20
  }

  pageUp () {
    this.element.scrollTop -= this.element.offsetHeight
  }

  pageDown () {
    this.element.scrollTop += this.element.offsetHeight
  }

  scrollToTop () {
    this.element.scrollTop = 0
  }

  scrollToBottom () {
    this.element.scrollTop = this.element.scrollHeight
  }
}

================
File: packages/settings-view/lib/keybindings-panel.js
================
/** @babel */
/** @jsx etch.dom */

import {CompositeDisposable, TextEditor} from 'atom'
import etch from 'etch'
import _ from 'underscore-plus'
import path from 'path'

export default class KeybindingsPanel {
  constructor () {
    etch.initialize(this)
    this.disposables = new CompositeDisposable()
    this.disposables.add(atom.commands.add(this.element, {
      'core:move-up': () => { this.scrollUp() },
      'core:move-down': () => { this.scrollDown() },
      'core:page-up': () => { this.pageUp() },
      'core:page-down': () => { this.pageDown() },
      'core:move-to-top': () => { this.scrollToTop() },
      'core:move-to-bottom': () => { this.scrollToBottom() }
    }))
    this.otherPlatformPattern = new RegExp(`\\.platform-(?!${_.escapeRegExp(process.platform)}\\b)`)
    this.platformPattern = new RegExp(`\\.platform-${_.escapeRegExp(process.platform)}\\b`)

    this.disposables.add(this.refs.searchEditor.onDidStopChanging(() => {
      this.filterKeyBindings(this.keyBindings, this.refs.searchEditor.getText())
    }))

    this.disposables.add(atom.keymaps.onDidReloadKeymap(() => { this.loadKeyBindings() }))
    this.disposables.add(atom.keymaps.onDidUnloadKeymap(() => { this.loadKeyBindings() }))
    this.loadKeyBindings()
  }

  destroy () {
    this.disposables.dispose()
    return etch.destroy(this)
  }

  update () {}

  render () {
    return (
      <div className='panels-item' tabIndex='-1'>
        <section className='keybinding-panel section'>
          <div className='section-heading icon icon-keyboard'>Keybindings</div>
          <div className='text native-key-bindings' tabIndex='-1'>
            <span className='icon icon-question' />
            <span>You can override these keybindings by copying </span>
            <span className='icon icon-clippy' />
            <span>and pasting them into </span>
            <a className='link' onclick={this.didClickOpenKeymapFile}>your keymap file</a>
          </div>

          <div className='editor-container'>
            <TextEditor mini ref='searchEditor' placeholderText='Search keybindings' />
          </div>

          <table className='native-key-bindings table text' tabIndex='-1'>
            <col className='keystroke' />
            <col className='command' />
            <col className='source' />
            <col className='selector' />
            <thead>
              <tr>
                <th className='keystroke'>Keystroke</th>
                <th className='command'>Command</th>
                <th className='source'>Source</th>
                <th className='selector'>Selector</th>
              </tr>
            </thead>
            <tbody ref='keybindingRows' />
          </table>
        </section>
      </div>
    )
  }

  loadKeyBindings () {
    this.refs.keybindingRows.innerHTML = ''
    this.keyBindings = _.sortBy(atom.keymaps.getKeyBindings(), 'keystrokes')
    this.appendKeyBindings(this.keyBindings)
    this.filterKeyBindings(this.keyBindings, this.refs.searchEditor.getText())
  }

  focus () {
    this.refs.searchEditor.element.focus()
  }

  show () {
    this.element.style.display = ''
  }

  filterKeyBindings (keyBindings, filterString) {
    this.refs.keybindingRows.innerHTML = ''
    for (let keyBinding of keyBindings) {
      let {selector, keystrokes, command, source} = keyBinding
      source = KeybindingsPanel.determineSource(source)
      var searchString = `${selector}${keystrokes}${command}${source}`.toLowerCase()
      if (!searchString) {
        continue
      }

      const keywords = filterString.trim().toLowerCase().split(' ')
      if (keywords.every(keyword => searchString.indexOf(keyword) !== -1)) {
        this.appendKeyBinding(keyBinding)
      }
    }
  }

  appendKeyBindings (keyBindings) {
    for (const keyBinding of keyBindings) {
      this.appendKeyBinding(keyBinding)
    }
  }

  appendKeyBinding (keyBinding) {
    if (!this.showSelector(keyBinding.selector)) {
      return
    }

    const element = this.elementForKeyBinding(keyBinding)
    element.dataset.keyBinding = keyBinding
    this.refs.keybindingRows.appendChild(element)
  }

  showSelector (selector) {
    let segments
    if (selector) {
      segments = selector.split(',') || []
    } else {
      segments = []
    }

    return segments.some((s) => this.platformPattern.test(s) || !this.otherPlatformPattern.test(s))
  }

  elementForKeyBinding (keyBinding) {
    let {selector, keystrokes, command, source} = keyBinding
    source = KeybindingsPanel.determineSource(source)

    const tr = document.createElement('tr')
    if (source === 'User') {
      tr.classList.add('is-user')
    }

    const keystrokeTd = document.createElement('td')
    keystrokeTd.classList.add('keystroke')

    const copyIcon = document.createElement('span')
    copyIcon.classList.add('icon', 'icon-clippy', 'copy-icon')
    copyIcon.onclick = () => {
      let content
      const keymapExtension = path.extname(atom.keymaps.getUserKeymapPath())

      const escapeCSON = (input) => {
        return JSON.stringify(input)
          .slice(1, -1) // Remove wrapping double quotes
          .replace(/\\"/g, '"') // Unescape double quotes
          .replace(/'/g, '\\\'') // Escape single quotes
      }

      if (keymapExtension === '.cson') {
        content = `'${escapeCSON(selector)}':\n  '${escapeCSON(keystrokes)}': '${escapeCSON(command)}'`
      } else {
        content = `${JSON.stringify(selector)}: {\n  ${JSON.stringify(keystrokes)}: ${JSON.stringify(command)}\n}`
      }
      return atom.clipboard.write(content)
    }
    keystrokeTd.appendChild(copyIcon)

    const keystrokesSpan = document.createElement('span')
    keystrokesSpan.textContent = keystrokes
    keystrokeTd.appendChild(keystrokesSpan)
    tr.appendChild(keystrokeTd)

    const commandTd = document.createElement('td')
    commandTd.classList.add('command')
    commandTd.textContent = command
    tr.appendChild(commandTd)

    const sourceTd = document.createElement('td')
    sourceTd.classList.add('source')
    sourceTd.textContent = source
    tr.appendChild(sourceTd)

    const selectorTd = document.createElement('td')
    selectorTd.classList.add('selector')
    selectorTd.textContent = selector
    tr.appendChild(selectorTd)

    return tr
  }

  didClickOpenKeymapFile (e) {
    e.preventDefault()
    atom.commands.dispatch(atom.views.getView(atom.workspace), 'application:open-your-keymap')
  }

  scrollUp () {
    this.element.scrollTop -= document.body.offsetHeight / 20
  }

  scrollDown () {
    this.element.scrollTop += document.body.offsetHeight / 20
  }

  pageUp () {
    this.element.scrollTop -= this.element.offsetHeight
  }

  pageDown () {
    this.element.scrollTop += this.element.offsetHeight
  }

  scrollToTop () {
    this.element.scrollTop = 0
  }

  scrollToBottom () {
    this.element.scrollTop = this.element.scrollHeight
  }

  // Private: Returns a user friendly description of where a keybinding was
  // loaded from.
  //
  // * filePath:
  //   The absolute path from which the keymap was loaded
  //
  // Returns one of:
  // * `Core` indicates it comes from a bundled package.
  // * `User` indicates that it was defined by a user.
  // * `<package-name>` the package which defined it.
  // * `Unknown` if an invalid path was passed in.
  static determineSource (filePath) {
    if (!filePath) {
      return 'Unknown'
    }

    if (filePath.indexOf(path.join(atom.getLoadSettings().resourcePath, 'keymaps')) === 0) {
      return 'Core'
    } else if (filePath === atom.keymaps.getUserKeymapPath()) {
      return 'User'
    } else {
      const pathParts = filePath.split(path.sep)
      const packageNameIndex = pathParts.length - 3
      const packageName = pathParts[packageNameIndex] != null ? pathParts[packageNameIndex] : ''
      return _.undasherize(_.uncamelcase(packageName))
    }
  }
}

================
File: packages/settings-view/lib/list-view.js
================
module.exports =
class ListView {
  // * `list` a {List} object
  // * `container` a jQuery element
  // * `createView` a Function that returns a jQuery element / HTMLElement
  //   * `item` the item to create the view for
  constructor (list, container, createView) {
    this.list = list
    this.container = container
    this.createView = createView
    this.views = []
    this.viewMap = {}
    this.list.onDidAddItem(item => this.addView(item))
    this.list.onDidRemoveItem(item => this.removeView(item))
    this.addViews()
  }

  getViews () {
    return this.views
  }

  filterViews (filterFn) {
    return this.list.filterItems(filterFn).map((item) => this.viewMap[this.list.keyForItem(item)])
  }

  addViews () {
    for (const item of this.list.getItems()) {
      this.addView(item)
    }
  }

  addView (item) {
    const view = this.createView(item)
    this.views.push(view)
    this.viewMap[this.list.keyForItem(item)] = view

    const row = document.createElement('div')
    row.classList.add('row')
    row.appendChild(view.element)
    this.container.insertBefore(row, this.container.children[0])
  }

  removeView (item) {
    const key = this.list.keyForItem(item)
    const view = this.viewMap[key]
    if (view) {
      const index = this.views.indexOf(view)
      if (index > -1) this.views.splice(index, 1)
      delete this.viewMap[key]
      view.element.parentElement.remove()
      view.destroy()
    }
  }
}

================
File: packages/settings-view/lib/list.js
================
const {Emitter} = require('atom')

module.exports =
class List {
  constructor (key) {
    this.key = key
    this.items = []
    this.emitter = new Emitter()
  }

  getItems () {
    return this.items
  }

  filterItems (filterFn) {
    const result = []
    for (const item of this.items) {
      if (filterFn(item)) {
        result.push(item)
      }
    }
    return result
  }

  keyForItem (item) {
    return item[this.key]
  }

  setItems (items) {
    items = items.slice()
    const setToAdd = difference(items, this.items, this.key)
    const setToRemove = difference(this.items, items, this.key)

    this.items = items

    for (const item of setToAdd) {
      this.emitter.emit('did-add-item', item)
    }

    for (const item of setToRemove) {
      this.emitter.emit('did-remove-item', item)
    }
  }

  onDidAddItem (callback) {
    return this.emitter.on('did-add-item', callback)
  }

  onDidRemoveItem (callback) {
    return this.emitter.on('did-remove-item', callback)
  }
}

const difference = (array1, array2, key) => {
  const obj1 = {}
  for (const item of array1) {
    obj1[item[key]] = item
  }

  const obj2 = {}
  for (const item of array2) {
    obj2[item[key]] = item
  }

  const diff = []
  for (const k in obj1) {
    const v = obj1[k]
    if (obj2[k] == null) diff.push(v)
  }
  return diff
}

================
File: packages/settings-view/lib/main.js
================
let SettingsView = null
let settingsView = null

let statusView = null

const PackageManager = require('./package-manager')
let packageManager = null

const SnippetsProvider = {
  getSnippets () { return atom.config.scopedSettingsStore.propertySets }
}

const CONFIG_URI = 'atom://config'

module.exports = {
  handleURI (parsed) {
    switch (parsed.pathname) {
      case '/show-package': this.showPackage(parsed.query.package)
    }
  },

  showPackage (packageName) {
    atom.workspace.open(`atom://config/packages/${packageName}`)
  },

  activate () {
    atom.workspace.addOpener(uri => {
      if (uri.startsWith(CONFIG_URI)) {
        if (settingsView == null || settingsView.destroyed) {
          settingsView = this.createSettingsView({uri})
        } else {
          const pane = atom.workspace.paneForItem(settingsView)
          if (pane) pane.activate()
        }

        settingsView.showPanelForURI(uri)
        return settingsView
      }
    })

    atom.commands.add('atom-workspace', {
      'settings-view:open' () { atom.workspace.open(CONFIG_URI) },
      'settings-view:core' () { atom.workspace.open(`${CONFIG_URI}/core`) },
      'settings-view:editor' () { atom.workspace.open(`${CONFIG_URI}/editor`) },
      'settings-view:show-keybindings' () { atom.workspace.open(`${CONFIG_URI}/keybindings`) },
      'settings-view:change-themes' () { atom.workspace.open(`${CONFIG_URI}/themes`) },
      'settings-view:install-packages-and-themes' () { atom.workspace.open(`${CONFIG_URI}/install`) },
      'settings-view:view-installed-themes' () { atom.workspace.open(`${CONFIG_URI}/themes`) },
      'settings-view:uninstall-themes' () { atom.workspace.open(`${CONFIG_URI}/themes`) },
      'settings-view:view-installed-packages' () { atom.workspace.open(`${CONFIG_URI}/packages`) },
      'settings-view:uninstall-packages' () { atom.workspace.open(`${CONFIG_URI}/packages`) },
      'settings-view:check-for-package-updates' () { atom.workspace.open(`${CONFIG_URI}/updates`) }
    })

    if (process.platform === 'win32' && require('atom').WinShell != null) {
      atom.commands.add('atom-workspace', {'settings-view:system' () { atom.workspace.open(`${CONFIG_URI}/system`) }})
    }
  },

  deactivate () {
    if (settingsView) settingsView.destroy()
    if (statusView) statusView.destroy()
    settingsView = null
    packageManager = null
    statusView = null
    atom.notifications.addWarning("Warning! You have disabled the settings-view package. To enable it again, edit the [`config.cson`](https://pulsar-edit.dev/docs/launch-manual/sections/using-pulsar/#global-configuration-settings) by removing the `settings-view` entry from `core: disabled packages:`");
  },

  consumeStatusBar (statusBar) {
    if (packageManager == null) packageManager = new PackageManager()
    packageManager.getOutdated().then(updates => {
      if (packageManager) {
        const PackageUpdatesStatusView = require('./package-updates-status-view')
        statusView = new PackageUpdatesStatusView()
        statusView.initialize(statusBar, packageManager, updates)
      }
    })

    // Attach a settings button to the status bar
    if (atom.config.get("settings-view.showSettingsIconInStatusBar")) {
      const SettingsIconStatusView = require('./settings-icon-status-view')
      statusViewIcon = new SettingsIconStatusView(statusBar)
      statusViewIcon.attach()
    }
  },

  consumeSnippets (snippets) {
    if (typeof snippets.getUnparsedSnippets === 'function') {
      SnippetsProvider.getSnippets = snippets.getUnparsedSnippets.bind(snippets)
    }
    if (typeof snippets.getUserSnippetsPath === 'function') {
      SnippetsProvider.getUserSnippetsPath = snippets.getUserSnippetsPath.bind(snippets)
    }
  },

  createSettingsView (params) {
    if (SettingsView == null) SettingsView = require('./settings-view')
    if (packageManager == null) packageManager = new PackageManager()
    params.packageManager = packageManager
    params.snippetsProvider = SnippetsProvider
    settingsView = new SettingsView(params)
    return settingsView
  }
}

================
File: packages/settings-view/lib/package-card.js
================
/** @babel */
/** @jsx etch.dom */

import {CompositeDisposable, Disposable} from 'atom'
import {shell} from 'electron'
import etch from 'etch'
import BadgeView from './badge-view'
import path from 'path'

import {ownerFromRepository, repoUrlFromRepository} from './utils'

let marked = null

export default class PackageCard {
  constructor (pack, settingsView, packageManager, options = {}) {
    this.pack = pack
    this.settingsView = settingsView
    this.packageManager = packageManager
    this.disposables = new CompositeDisposable()

    // It might be useful to either wrap this.pack in a class that has a
    // ::validate method, or add a method here. At the moment I think all cases
    // of malformed package metadata are handled here and in ::content but belt
    // and suspenders, you know
    this.client = this.packageManager.getClient()
    this.type = this.pack.theme ? 'theme' : 'package'
    this.name = this.pack.name
    this.onSettingsView = options.onSettingsView

    if (this.pack.latestVersion !== this.pack.version) {
      this.newVersion = this.pack.latestVersion
    }

    if (this.pack.apmInstallSource && this.pack.apmInstallSource.type === 'git') {
      if (this.pack.apmInstallSource.sha !== this.pack.latestSha) {
        this.newSha = this.pack.latestSha
      }
    }

    // Default to displaying the download count
    if (!options.stats) {
      options.stats = {downloads: true}
    }

    etch.initialize(this)

    this.displayStats(options)
    this.handlePackageEvents()
    this.handleButtonEvents(options)
    this.loadCachedMetadata()
    this.addBadges()

    // themes have no status and cannot be dis/enabled
    if (this.type === 'theme') {
      this.refs.statusIndicator.remove()
      this.refs.enablementButton.remove()
    }

    if (atom.packages.isBundledPackage(this.pack.name)) {
      this.refs.installButtonGroup.remove()
      this.refs.uninstallButton.remove()
    }

    if (!this.newVersion && !this.newSha) {
      this.refs.updateButtonGroup.style.display = 'none'
    }

    this.hasCompatibleVersion = true
    this.updateInterfaceState()
  }

  render () {
    const displayName = (this.pack.gitUrlInfo ? this.pack.gitUrlInfo.project : this.pack.name) || ''
    const owner = ownerFromRepository(this.pack.repository)
    const description = this.pack.description || ''

    return (
      <div className='package-card col-lg-8'>
        <div ref='statsContainer' className='stats pull-right'>
          <span ref='packageStars' className='stats-item'>
            <span ref='stargazerIcon' className='icon icon-star' />
            <span ref='stargazerCount' className='value' />
          </span>

          <span ref='packageDownloads' className='stats-item'>
            <span ref='downloadIcon' className='icon icon-cloud-download' />
            <span ref='downloadCount' className='value' />
          </span>
        </div>

        <div className='body'>
          <h4 className='card-name'>
            <a className='package-name' ref='packageName'>{displayName}</a>
            <span className='package-version'>
              <span ref='versionValue' className='value'>{String(this.pack.version)}</span>
            </span>
            <span ref='badges'></span>
          </h4>
          <span ref='packageDescription' className='package-description'>{description}</span>
          <div ref='packageMessage' className='package-message' />
        </div>

        <div className='meta'>
          <div ref='metaUserContainer' className='meta-user'>
            <a ref='avatarLink'>
              {/* A transparent gif so there is no "broken border" */}
              <img ref='avatar' className='avatar' src='data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7' />
            </a>
            <a ref='loginLink' className='author'>{owner}</a>
          </div>
          <div className='meta-controls'>
            <div className='btn-toolbar'>
              <div ref='updateButtonGroup' className='btn-group'>
                <button type='button' className='btn btn-info icon icon-cloud-download install-button' ref='updateButton'>Update</button>
              </div>
              <div ref='installButtonGroup' className='btn-group'>
                <button type='button' className='btn btn-info icon icon-cloud-download install-button' ref='installButton'>Install</button>
              </div>
              <div ref='packageActionButtonGroup' className='btn-group'>
                <button type='button' className='btn icon icon-gear settings' ref='settingsButton'>Settings</button>
                <button type='button' className='btn icon icon-trashcan uninstall-button' ref='uninstallButton'>Uninstall</button>
                <button type='button' className='btn icon icon-playback-pause enablement' ref='enablementButton'>
                  <span className='disable-text'>Disable</span>
                </button>
                <button type='button' className='btn status-indicator' tabIndex='-1' ref='statusIndicator' />
              </div>
            </div>
          </div>
        </div>
      </div>
    )
  }

  locateCompatiblePackageVersion (callback) {
    this.packageManager.loadCompatiblePackageVersion(this.pack.name, (err, pack) => {
      if (err != null) {
        console.error(err)
      }

      const packageVersion = pack.version

      // A compatible version exist, we activate the install button and
      // set this.installablePack so that the install action installs the
      // compatible version of the package.
      if (packageVersion) {
        this.refs.versionValue.textContent = packageVersion
        if (packageVersion !== this.pack.version) {
          this.refs.versionValue.classList.add('text-warning')
          this.refs.packageMessage.classList.add('text-warning')
          this.refs.packageMessage.textContent = `Version ${packageVersion} is not the latest version available for this package, but it's the latest that is compatible with your version of Pulsar.`
        }

        this.installablePack = pack
        this.hasCompatibleVersion = true
      } else {
        this.hasCompatibleVersion = false
        this.refs.versionValue.classList.add('text-error')
        this.refs.packageMessage.classList.add('text-error')
        this.refs.packageMessage.insertAdjacentText(
          'beforeend',
          `There's no version of this package that is compatible with your Pulsar version. The version must satisfy ${this.pack.engines.atom}.`
        )
        console.error(`No available version compatible with the installed Pulsar version: ${atom.getVersion()}`)
      }

      callback()
    })
  }

  handleButtonEvents (options) {
    if (options && options.onSettingsView) {
      this.refs.settingsButton.style.display = 'none'
    } else {
      const clickHandler = (event) => {
        event.stopPropagation()
        this.settingsView.showPanel(this.pack.name, {back: options ? options.back : null, pack: this.pack})
      }

      this.element.addEventListener('click', clickHandler)
      this.disposables.add(new Disposable(() => { this.element.removeEventListener('click', clickHandler) }))

      this.refs.settingsButton.addEventListener('click', clickHandler)
      this.disposables.add(new Disposable(() => { this.refs.settingsButton.removeEventListener('click', clickHandler) }))
    }

    const installButtonClickHandler = (event) => {
      event.stopPropagation()
      this.install()
    }
    this.refs.installButton.addEventListener('click', installButtonClickHandler)
    this.disposables.add(new Disposable(() => { this.refs.installButton.removeEventListener('click', installButtonClickHandler) }))

    const uninstallButtonClickHandler = (event) => {
      event.stopPropagation()
      this.uninstall()
    }
    this.refs.uninstallButton.addEventListener('click', uninstallButtonClickHandler)
    this.disposables.add(new Disposable(() => { this.refs.uninstallButton.removeEventListener('click', uninstallButtonClickHandler) }))

    const updateButtonClickHandler = (event) => {
      event.stopPropagation()
      this.update().then(() => {
        let oldVersion = ''
        let newVersion = ''

        if (this.pack.apmInstallSource && this.pack.apmInstallSource.type === 'git') {
          oldVersion = this.pack.apmInstallSource.sha.substr(0, 8)
          newVersion = `${this.pack.latestSha.substr(0, 8)}`
        } else if (this.pack.version && this.pack.latestVersion) {
          oldVersion = this.pack.version
          newVersion = this.pack.latestVersion
        }

        let detail = ''
        if (oldVersion && newVersion) {
          detail = `${oldVersion} -> ${newVersion}`
        }

        const notification = atom.notifications.addSuccess(`Restart Pulsar to complete the update of \`${this.pack.name}\`.`, {
          dismissable: true,
          buttons: [{
            text: 'Restart now',
            onDidClick () { return atom.restartApplication() }
          },
          {
            text: 'I\'ll do it later',
            onDidClick () { notification.dismiss() }
          }],
          detail
        })
      })
    }
    this.refs.updateButton.addEventListener('click', updateButtonClickHandler)
    this.disposables.add(new Disposable(() => { this.refs.updateButton.removeEventListener('click', updateButtonClickHandler) }))

    const packageNameClickHandler = (event) => {
      event.stopPropagation()
      shell.openExternal(`https://web.pulsar-edit.dev/packages/${this.pack.name}`)
    }
    this.refs.packageName.addEventListener('click', packageNameClickHandler)
    this.disposables.add(new Disposable(() => { this.refs.packageName.removeEventListener('click', packageNameClickHandler) }))

    const packageAuthorClickHandler = (event) => {
      event.stopPropagation()
      shell.openExternal(`https://web.pulsar-edit.dev/users/${ownerFromRepository(this.pack.repository)}`) //TODO: Fix - This does not current exist but this will at least be more accurate
    }
    this.refs.loginLink.addEventListener('click', packageAuthorClickHandler)
    this.disposables.add(new Disposable(() => { this.refs.loginLink.removeEventListener('click', packageAuthorClickHandler) }))
    this.refs.avatarLink.addEventListener('click', packageAuthorClickHandler)
    this.disposables.add(new Disposable(() => { this.refs.avatarLink.removeEventListener('click', packageAuthorClickHandler) }))

    const enablementButtonClickHandler = (event) => {
      event.stopPropagation()
      event.preventDefault()
      if (this.isDisabled()) {
        atom.packages.enablePackage(this.pack.name)
      } else {
        atom.packages.disablePackage(this.pack.name)
      }
    }
    this.refs.enablementButton.addEventListener('click', enablementButtonClickHandler)
    this.disposables.add(new Disposable(() => { this.refs.enablementButton.removeEventListener('click', enablementButtonClickHandler) }))

    const packageMessageClickHandler = (event) => {
      const target = event.target.closest('a')
      if (target) {
        event.stopPropagation()
        event.preventDefault()
        if (target.href && target.href.startsWith('atom:')) {
          atom.workspace.open(target.href)
        }
      }
    }
    this.refs.packageMessage.addEventListener('click', packageMessageClickHandler)
    this.disposables.add(new Disposable(() => { this.refs.packageMessage.removeEventListener('click', packageMessageClickHandler) }))
  }

  destroy () {
    this.disposables.dispose()
    return etch.destroy(this)
  }

  loadCachedMetadata () {
    if (repoUrlFromRepository(this.pack.repository) === atom.branding.urlCoreRepo) {
      // Don't hit the web for our bundled packages. Just use the local image.
      this.refs.avatar.src = `file://${path.join(process.resourcesPath, "pulsar.png")}`;
    } else {
      this.client.avatar(ownerFromRepository(this.pack.repository), (err, avatarPath) => {
        if (!err && avatarPath) {
          this.refs.avatar.src = `file://${avatarPath}`
        }
      })
    }

    // We don't want to hit the API for this data, if it's a bundled package
    if (this.pack.repository !== atom.branding.urlCoreRepo) {
      this.client.package(this.pack.name, (err, data) => {
        // We don't need to actually handle the error here, we can just skip
        // showing the download count if there's a problem.
        if (!err) {
          if (data == null) {
            data = {}
          }

          if (this.pack.apmInstallSource && this.pack.apmInstallSource.type === 'git') {
            this.refs.downloadIcon.classList.remove('icon-cloud-download')
            this.refs.downloadIcon.classList.add('icon-git-branch')
            this.refs.downloadCount.textContent = this.pack.apmInstallSource.sha.substr(0, 8)
          } else {

            this.refs.stargazerCount.textContent = data.stargazers_count ? parseInt(data.stargazers_count).toLocaleString() : ''
            this.refs.downloadCount.textContent = data.downloads ? parseInt(data.downloads).toLocaleString() : ''
          }
        }
      })
    }
  }

  updateInterfaceState () {
    this.refs.versionValue.textContent = (this.installablePack ? this.installablePack.version : null) || this.pack.version
    if (this.pack.apmInstallSource && this.pack.apmInstallSource.type === 'git') {
      this.refs.downloadCount.textContent = this.pack.apmInstallSource.sha.substr(0, 8)
    }

    this.updateSettingsState()
    this.updateInstalledState()
    this.updateDisabledState()
  }

  updateSettingsState () {
    if (this.hasSettings() && !this.onSettingsView) {
      this.refs.settingsButton.style.display = ''
    } else {
      this.refs.settingsButton.style.display = 'none'
    }
  }

  addBadges() {
    if (Array.isArray(this.pack.badges)) {
      // This safety check is especially needed, as any cached package
      // data will not contain the badges field
      for (const badge of this.pack.badges) {
        let badgeView = new BadgeView(badge)
        this.refs.badges.appendChild(badgeView.element)
      }
    }
  }

  // Section: disabled state updates

  updateDisabledState () {
    if (this.isDisabled()) {
      this.displayDisabledState()
    } else if (this.element.classList.contains('disabled')) {
      this.displayEnabledState()
    }
  }

  displayEnabledState () {
    this.element.classList.remove('disabled')
    if (this.type === 'theme') {
      this.refs.enablementButton.style.display = 'none'
    }
    this.refs.enablementButton.querySelector('.disable-text').textContent = 'Disable'
    this.refs.enablementButton.classList.add('icon-playback-pause')
    this.refs.enablementButton.classList.remove('icon-playback-play')
    this.refs.statusIndicator.classList.remove('is-disabled')
  }

  displayDisabledState () {
    this.element.classList.add('disabled')
    this.refs.enablementButton.querySelector('.disable-text').textContent = 'Enable'
    this.refs.enablementButton.classList.add('icon-playback-play')
    this.refs.enablementButton.classList.remove('icon-playback-pause')
    this.refs.statusIndicator.classList.add('is-disabled')
    this.refs.enablementButton.disabled = false
  }

  // Section: installed state updates

  updateInstalledState () {
    if (this.isInstalled()) {
      this.displayInstalledState()
    } else {
      this.displayNotInstalledState()
    }
  }

  displayInstalledState () {
    if (this.newVersion || this.newSha) {
      this.refs.updateButtonGroup.style.display = ''
      if (this.newVersion) {
        this.refs.updateButton.textContent = `Update to ${this.newVersion}`
      } else if (this.newSha) {
        this.refs.updateButton.textContent = `Update to ${this.newSha.substr(0, 8)}`
      }
    } else {
      this.refs.updateButtonGroup.style.display = 'none'
    }

    this.refs.installButtonGroup.style.display = 'none'
    this.refs.packageActionButtonGroup.style.display = ''
    this.refs.uninstallButton.style.display = ''
  }

  displayNotInstalledState () {
    this.refs.uninstallButton.style.display = 'none'
    const atomVersion = this.packageManager.normalizeVersion(atom.getVersion())
    if (!this.packageManager.satisfiesVersion(atomVersion, this.pack)) {
      this.hasCompatibleVersion = false
      this.setNotInstalledStateButtons()
      this.locateCompatiblePackageVersion(() => { this.setNotInstalledStateButtons() })
    } else {
      this.setNotInstalledStateButtons()
    }
  }

  setNotInstalledStateButtons () {
    if (!this.hasCompatibleVersion) {
      this.refs.installButtonGroup.style.display = 'none'
      this.refs.updateButtonGroup.style.display = 'none'
    } else if (this.newVersion || this.newSha) {
      this.refs.updateButtonGroup.style.display = ''
      this.refs.installButtonGroup.style.display = 'none'
    } else {
      this.refs.updateButtonGroup.style.display = 'none'
      this.refs.installButtonGroup.style.display = ''
    }
    this.refs.packageActionButtonGroup.style.display = 'none'
  }

  displayStats (options) {
    if (options && options.stats && options.stats.downloads) {
      this.refs.packageDownloads.style.display = ''
    } else {
      this.refs.packageDownloads.style.display = 'none'
    }

    if (options && options.stats && options.stats.stars) {
      this.refs.packageStars.style.display = ''
    } else {
      this.refs.packageStars.style.display = 'none'
    }
  }

  displayGitPackageInstallInformation () {
    this.refs.metaUserContainer.remove()
    this.refs.statsContainer.remove()
    const {gitUrlInfo} = this.pack
    if (gitUrlInfo.default === 'shortcut') {
      this.refs.packageDescription.textContent = gitUrlInfo.https()
    } else {
      this.refs.packageDescription.textContent = gitUrlInfo.toString()
    }
    this.refs.installButton.classList.remove('icon-cloud-download')
    this.refs.installButton.classList.add('icon-git-commit')
    this.refs.updateButton.classList.remove('icon-cloud-download')
    this.refs.updateButton.classList.add('icon-git-commit')
  }

  displayAvailableUpdate (newVersion) {
    this.newVersion = newVersion
    this.updateInterfaceState()
  }

  handlePackageEvents () {
    this.disposables.add(atom.packages.onDidDeactivatePackage((pack) => {
      if (pack.name === this.pack.name) {
        this.updateDisabledState()
      }
    }))

    this.disposables.add(atom.packages.onDidActivatePackage((pack) => {
      if (pack.name === this.pack.name) {
        this.updateDisabledState()
      }
    }))

    this.disposables.add(atom.config.onDidChange('core.disabledPackages', () => {
      this.updateDisabledState()
    }))

    this.subscribeToPackageEvent('package-installing theme-installing', () => {
      this.updateInterfaceState()
      this.refs.installButton.disabled = true
      this.refs.installButton.classList.add('is-installing')
    })

    this.subscribeToPackageEvent('package-updating theme-updating', () => {
      this.updateInterfaceState()
      this.refs.updateButton.disabled = true
      this.refs.updateButton.classList.add('is-installing')
    })

    this.subscribeToPackageEvent('package-uninstalling theme-uninstalling', () => {
      this.updateInterfaceState()
      this.refs.enablementButton.disabled = true
      this.refs.uninstallButton.disabled = true
      this.refs.uninstallButton.classList.add('is-uninstalling')
    })

    this.subscribeToPackageEvent('package-installed package-install-failed theme-installed theme-install-failed', () => {
      const loadedPack = atom.packages.getLoadedPackage(this.pack.name)
      const version = loadedPack && loadedPack.metadata ? loadedPack.metadata.version : null
      if (version) {
        this.pack.version = version
      }
      this.refs.installButton.disabled = false
      this.refs.installButton.classList.remove('is-installing')
      this.updateInterfaceState()
    })

    this.subscribeToPackageEvent('package-updated theme-updated', () => {
      const loadedPack = atom.packages.getLoadedPackage(this.pack.name)
      const metadata = loadedPack ? loadedPack.metadata : null
      if (metadata && metadata.version) {
        this.pack.version = metadata.version
      }

      if (metadata && metadata.apmInstallSource) {
        this.pack.apmInstallSource = metadata.apmInstallSource
      }

      this.newVersion = null
      this.newSha = null
      this.refs.updateButton.disabled = false
      this.refs.updateButton.classList.remove('is-installing')
      this.updateInterfaceState()
    })

    this.subscribeToPackageEvent('package-update-failed theme-update-failed', () => {
      this.refs.updateButton.disabled = false
      this.refs.updateButton.classList.remove('is-installing')
      this.updateInterfaceState()
    })

    this.subscribeToPackageEvent('package-uninstalled package-uninstall-failed theme-uninstalled theme-uninstall-failed', () => {
      this.newVersion = null
      this.newSha = null
      this.refs.enablementButton.disabled = false
      this.refs.uninstallButton.disabled = false
      this.refs.uninstallButton.classList.remove('is-uninstalling')
      this.updateInterfaceState()
    })
  }

  isInstalled () {
    return this.packageManager.isPackageInstalled(this.pack.name)
  }

  isDisabled () {
    return atom.packages.isPackageDisabled(this.pack.name)
  }

  hasSettings () {
    return this.packageManager.packageHasSettings(this.pack.name)
  }

  subscribeToPackageEvent (event, callback) {
    this.disposables.add(this.packageManager.on(event, ({pack, error}) => {
      if (pack.pack != null) {
        pack = pack.pack
      }

      const packageName = pack.name
      if (packageName === this.pack.name) {
        callback(pack, error)
      }
    }))
  }

  /*
  Section: Methods that should be on a Package model
  */

  install () {
    this.packageManager.install(this.installablePack != null ? this.installablePack : this.pack, (error) => {
      if (error != null) {
        console.error(`Installing ${this.type} ${this.pack.name} failed`, error.stack != null ? error.stack : error, error.stderr)
      } else {
        // if a package was disabled before installing it, re-enable it
        if (this.isDisabled()) {
          atom.packages.enablePackage(this.pack.name)
        }
      }
    })
  }

  update () {
    if (!this.newVersion && !this.newSha) {
      return Promise.resolve()
    }

    const pack = this.installablePack != null ? this.installablePack : this.pack
    const version = this.newVersion ? `v${this.newVersion}` : `#${this.newSha.substr(0, 8)}`
    return new Promise((resolve, reject) => {
      this.packageManager.update(pack, this.newVersion, error => {
        if (error != null) {
          atom.assert(false, 'Package update failed', assertionError => {
            assertionError.metadata = {
              type: this.type,
              name: pack.name,
              version,
              errorMessage: error.message,
              errorStack: error.stack,
              errorStderr: error.stderr
            }
          })
          console.error(`Updating ${this.type} ${pack.name} to ${version} failed:\n`, error, error.stderr != null ? error.stderr : '')
          reject(error)
        } else {
          resolve()
        }
      })
    })
  }

  uninstall () {
    this.packageManager.uninstall(this.pack, (error) => {
      if (error != null) {
        console.error(`Uninstalling ${this.type} ${this.pack.name} failed`, error.stack != null ? error.stack : error, error.stderr)
      }
    })
  }
}

================
File: packages/settings-view/lib/package-detail-view.js
================
/** @babel */
/** @jsx etch.dom */

import path from 'path'
import url from 'url'

import _ from 'underscore-plus'
import fs from 'fs-plus'
import {shell} from 'electron'
import {CompositeDisposable, Disposable} from 'atom'
import etch from 'etch'

import PackageCard from './package-card'
import PackageGrammarsView from './package-grammars-view'
import PackageKeymapView from './package-keymap-view'
import PackageReadmeView from './package-readme-view'
import PackageSnippetsView from './package-snippets-view'
import SettingsPanel from './settings-panel'

const NORMALIZE_PACKAGE_DATA_README_ERROR = 'ERROR: No README data found!'

export default class PackageDetailView {
  constructor (pack, settingsView, packageManager, snippetsProvider) {
    this.pack = pack
    if (Array.isArray(pack.badges)) {
      // Badges are only available on the object when loading their data from the
      // API server. Once local the badge data is lost.
      // Plus we want to modify the original item to ensure further changes can take effect properly
      pack.metadata.badges = pack.badges;
    }
    this.settingsView = settingsView
    this.packageManager = packageManager
    this.snippetsProvider = snippetsProvider
    this.disposables = new CompositeDisposable()
    etch.initialize(this)
    this.loadPackage()

    this.disposables.add(atom.commands.add(this.element, {
      'core:move-up': () => { this.scrollUp() },
      'core:move-down': () => { this.scrollDown() },
      'core:page-up': () => { this.pageUp() },
      'core:page-down': () => { this.pageDown() },
      'core:move-to-top': () => { this.scrollToTop() },
      'core:move-to-bottom': () => { this.scrollToBottom() }
    }))

    const packageRepoClickHandler = (event) => {
      event.preventDefault()
      const repoUrl = this.packageManager.getRepositoryUrl(this.pack)
      if (typeof repoUrl === 'string') {
        if (url.parse(repoUrl).pathname === '/pulsar-edit/pulsar') {
          shell.openExternal(`${repoUrl}/tree/master/packages/${this.pack.name}`)
        } else {
          shell.openExternal(repoUrl)
        }
      }
    }
    this.refs.packageRepo.addEventListener('click', packageRepoClickHandler)
    this.disposables.add(new Disposable(() => { this.refs.packageRepo.removeEventListener('click', packageRepoClickHandler) }))

    const issueButtonClickHandler = (event) => {
      event.preventDefault()
      let bugUri = this.packageManager.getRepositoryBugUri(this.pack)
      if (bugUri) {
        shell.openExternal(bugUri)
      }
    }
    this.refs.issueButton.addEventListener('click', issueButtonClickHandler)
    this.disposables.add(new Disposable(() => { this.refs.issueButton.removeEventListener('click', issueButtonClickHandler) }))

    const changelogButtonClickHandler = (event) => {
      event.preventDefault()
      if (this.changelogPath) {
        this.openMarkdownFile(this.changelogPath)
      }
    }
    this.refs.changelogButton.addEventListener('click', changelogButtonClickHandler)
    this.disposables.add(new Disposable(() => { this.refs.changelogButton.removeEventListener('click', changelogButtonClickHandler) }))

    const licenseButtonClickHandler = (event) => {
      event.preventDefault()
      if (this.licensePath) {
        this.openMarkdownFile(this.licensePath)
      }
    }
    this.refs.licenseButton.addEventListener('click', licenseButtonClickHandler)
    this.disposables.add(new Disposable(() => { this.refs.licenseButton.removeEventListener('click', licenseButtonClickHandler) }))

    const openButtonClickHandler = (event) => {
      event.preventDefault()
      if (fs.existsSync(this.pack.path)) {
        atom.open({pathsToOpen: [this.pack.path]})
      }
    }
    this.refs.openButton.addEventListener('click', openButtonClickHandler)
    this.disposables.add(new Disposable(() => { this.refs.openButton.removeEventListener('click', openButtonClickHandler) }))

    const learnMoreButtonClickHandler = (event) => {
      event.preventDefault()
      shell.openExternal(`https://web.pulsar-edit.dev/packages/${this.pack.name}`)
    }
    this.refs.learnMoreButton.addEventListener('click', learnMoreButtonClickHandler)
    this.disposables.add(new Disposable(() => { this.refs.learnMoreButton.removeEventListener('click', learnMoreButtonClickHandler) }))

    const breadcrumbClickHandler = (event) => {
      event.preventDefault()
      this.settingsView.showPanel(this.breadcrumbBackPanel)
    }
    this.refs.breadcrumb.addEventListener('click', breadcrumbClickHandler)
    this.disposables.add(new Disposable(() => { this.refs.breadcrumb.removeEventListener('click', breadcrumbClickHandler) }))
  }

  completeInitialization () {
    if (this.refs.packageCard) {
      this.packageCard = this.refs.packageCard.packageCard
    } else if (!this.packageCard) { // Had to load this from the network
      this.packageCard = new PackageCard(this.pack.metadata, this.settingsView, this.packageManager, {onSettingsView: true})
      this.refs.packageCardParent.replaceChild(this.packageCard.element, this.refs.loadingMessage)
    }

    this.refs.packageRepo.classList.remove('hidden')
    this.refs.startupTime.classList.remove('hidden')
    this.refs.buttons.classList.remove('hidden')
    this.activateConfig()
    this.populate()
    this.updateFileButtons()
    this.subscribeToPackageManager()
    this.renderReadme()
  }

  loadPackage () {
    const loadedPackage = atom.packages.getLoadedPackage(this.pack.name)
    if (loadedPackage) {
      this.pack = loadedPackage
      this.completeInitialization()
    } else {
      // If the package metadata in `@pack` isn't complete, hit the network.
      if (!this.pack.metadata || !this.pack.metadata.owner) {
        this.fetchPackage()
      } else {
        this.completeInitialization()
      }
    }
  }

  fetchPackage () {
    this.showLoadingMessage()
    this.packageManager.getClient().package(this.pack.name, (err, packageData) => {
      if (err || !packageData || !packageData.name) {
        this.hideLoadingMessage()
        this.showErrorMessage()
      } else {
        this.pack = packageData
        // TODO: this should match Package.loadMetadata from core, but this is
        // an acceptable hacky workaround
        this.pack.metadata = _.extend(this.pack.metadata != null ? this.pack.metadata : {}, this.pack)
        this.completeInitialization()
      }
    })
  }

  showLoadingMessage () {
    this.refs.loadingMessage.classList.remove('hidden')
  }

  hideLoadingMessage () {
    this.refs.loadingMessage.classList.add('hidden')
  }

  showErrorMessage () {
    this.refs.errorMessage.classList.remove('hidden')
  }

  hideErrorMessage () {
    this.refs.errorMessage.classList.add('hidden')
  }

  activateConfig () {
    // Package.activateConfig() is part of the Private package API and should not be used outside of core.
    if (atom.packages.isPackageLoaded(this.pack.name) && !atom.packages.isPackageActive(this.pack.name)) {
      this.pack.activateConfig()
    }
  }

  destroy () {
    if (this.settingsPanel) {
      this.settingsPanel.destroy()
      this.settingsPanel = null
    }

    if (this.keymapView) {
      this.keymapView.destroy()
      this.keymapView = null
    }

    if (this.grammarsView) {
      this.grammarsView.destroy()
      this.grammarsView = null
    }

    if (this.snippetsView) {
      this.snippetsView.destroy()
      this.snippetsView = null
    }

    if (this.readmeView) {
      this.readmeView.destroy()
      this.readmeView = null
    }

    if (this.packageCard) {
      this.packageCard.destroy()
      this.packageCard = null
    }

    this.disposables.dispose()
    return etch.destroy(this)
  }

  update () {}

  beforeShow (opts) {
    if (opts.back == null) {
      opts.back = 'Install'
    }

    this.breadcrumbBackPanel = opts.back
    this.refs.breadcrumb.textContent = this.breadcrumbBackPanel
  }

  show () {
    this.element.style.display = ''
  }

  focus () {
    this.element.focus()
  }

  render () {
    let packageCardView
    if (this.pack && this.pack.metadata && this.pack.metadata.owner) {
      packageCardView = (
        <div ref='packageCardParent' className='row'>
          <PackageCardComponent
            ref='packageCard'
            settingsView={this.settingsView}
            packageManager={this.packageManager}
            metadata={this.pack.metadata}
            options={{onSettingsView: true}} />
        </div>
      )
    } else {
      packageCardView = (
        <div ref='packageCardParent' className='row'>
          <div ref='loadingMessage' className='alert alert-info icon icon-hourglass'>{`Loading ${this.pack.name}\u2026`}</div>
          <div ref='errorMessage' className='alert alert-danger icon icon-hourglass hidden'>Failed to load {this.pack.name} - try again later.</div>
        </div>
      )
    }
    return (
      <div tabIndex='0' className='package-detail'>
        <ol ref='breadcrumbContainer' className='native-key-bindings breadcrumb' tabIndex='-1'>
          <li>
            <a ref='breadcrumb' />
          </li>
          <li className='active'>
            <a ref='title' />
          </li>
        </ol>

        <div className='panels-item'>
          <section className='section'>
            <form className='section-container package-detail-view'>
              <div className='container package-container'>
                {packageCardView}
              </div>

              <p ref='packageRepo' className='link icon icon-repo repo-link hidden' />
              <p ref='startupTime' className='text icon icon-dashboard hidden' tabIndex='-1' />

              <div ref='buttons' className='btn-wrap-group hidden'>
                <button ref='learnMoreButton' className='btn btn-default icon icon-link'>View on pulsar-edit.dev</button>
                <button ref='issueButton' className='btn btn-default icon icon-bug'>Report Issue</button>
                <button ref='changelogButton' className='btn btn-default icon icon-squirrel'>CHANGELOG</button>
                <button ref='licenseButton' className='btn btn-default icon icon-law'>LICENSE</button>
                <button ref='openButton' className='btn btn-default icon icon-link-external'>View Code</button>
              </div>

              <div ref='errors' />
            </form>
          </section>

          <div ref='sections' />

        </div>
      </div>
    )
  }

  populate () {
    this.refs.title.textContent = `${_.undasherize(_.uncamelcase(this.pack.name))}`
    this.type = this.pack.metadata.theme ? 'theme' : 'package'

    const repoUrl = this.packageManager.getRepositoryUrl(this.pack)
    if (repoUrl) {
      const repoName = url.parse(repoUrl).pathname
      this.refs.packageRepo.textContent = repoName.substring(1)
      this.refs.packageRepo.style.display = ''
    } else {
      this.refs.packageRepo.style.display = 'none'
    }

    this.updateInstalledState()
  }

  updateInstalledState () {
    if (this.settingsPanel) {
      this.settingsPanel.destroy()
      this.settingsPanel = null
    }

    if (this.keymapView) {
      this.keymapView.destroy()
      this.keymapView = null
    }

    if (this.grammarsView) {
      this.grammarsView.destroy()
      this.grammarsView = null
    }

    if (this.snippetsView) {
      this.snippetsView.destroy()
      this.snippetsView = null
    }

    if (this.readmeView) {
      this.readmeView.destroy()
      this.readmeView = null
    }

    this.updateFileButtons()
    this.activateConfig()
    this.refs.startupTime.style.display = 'none'

    if (atom.packages.isPackageLoaded(this.pack.name)) {
      if (!atom.packages.isPackageDisabled(this.pack.name)) {
        this.settingsPanel = new SettingsPanel({namespace: this.pack.name, includeTitle: false})
        this.keymapView = new PackageKeymapView(this.pack)
        this.refs.sections.appendChild(this.settingsPanel.element)
        this.refs.sections.appendChild(this.keymapView.element)

        if (this.pack.path) {
          this.grammarsView = new PackageGrammarsView(this.pack.path)
          this.snippetsView = new PackageSnippetsView(this.pack, this.snippetsProvider)
          this.refs.sections.appendChild(this.grammarsView.element)
          this.refs.sections.appendChild(this.snippetsView.element)
        }

        this.refs.startupTime.innerHTML =
          `This ${this.type} added <span class='highlight'>${this.getStartupTime()}ms</span> to startup time.`
        this.refs.startupTime.style.display = ''
      }
    }

    const sourceIsAvailable = this.packageManager.isPackageInstalled(this.pack.name) && !atom.packages.isBundledPackage(this.pack.name)
    if (sourceIsAvailable) {
      this.refs.openButton.style.display = ''
    } else {
      this.refs.openButton.style.display = 'none'
    }

    this.renderReadme()
  }

  renderReadme () {
    let readme
    if (this.pack.metadata.readme && this.pack.metadata.readme.trim() !== NORMALIZE_PACKAGE_DATA_README_ERROR) {
      readme = this.pack.metadata.readme
    } else {
      readme = null
    }

    if (this.readmePath && fs.existsSync(this.readmePath) && fs.statSync(this.readmePath).isFile() && !readme) {
      readme = fs.readFileSync(this.readmePath, {encoding: 'utf8'})
    }

    let readmeSrc, readmeIsLocal;

    if (this.pack.path) {
      // If package is installed, use installed path
      readmeSrc = this.pack.path
      readmeIsLocal = true;
    } else {
      // If package isn't installed, use url path
      let repoUrl = this.packageManager.getRepositoryUrl(this.pack)
      readmeIsLocal = false;

      // Check if URL is undefined (i.e. package is unpublished)
      if (repoUrl) {
        readmeSrc = repoUrl;
      }
    }

    const readmeView = new PackageReadmeView(readme, readmeSrc, readmeIsLocal)
    if (this.readmeView) {
      this.readmeView.element.parentElement.replaceChild(readmeView.element, this.readmeView.element)
      this.readmeView.destroy()
    } else {
      this.refs.sections.appendChild(readmeView.element)
    }
    this.readmeView = readmeView
  }

  subscribeToPackageManager () {
    this.disposables.add(this.packageManager.on('theme-installed package-installed', ({pack}) => {
      if (this.pack.name === pack.name) {
        this.loadPackage()
        this.updateInstalledState()
      }
    }))

    this.disposables.add(this.packageManager.on('theme-uninstalled package-uninstalled', ({pack}) => {
      if (this.pack.name === pack.name) {
        return this.updateInstalledState()
      }
    }))

    this.disposables.add(this.packageManager.on('theme-updated package-updated', ({pack}) => {
      if (this.pack.name === pack.name) {
        this.loadPackage()
        this.updateFileButtons()
        this.populate()
      }
    }))
  }

  openMarkdownFile (path) {
    if (atom.packages.isPackageActive('markdown-preview')) {
      atom.workspace.open(encodeURI(`markdown-preview://${path}`))
    } else {
      atom.workspace.open(path)
    }
  }

  updateFileButtons () {
    this.changelogPath = null
    this.licensePath = null
    this.readmePath = null

    const packagePath = this.pack.path != null ? this.pack.path : atom.packages.resolvePackagePath(this.pack.name)
    for (const child of fs.listSync(packagePath)) {
      switch (path.basename(child, path.extname(child)).toLowerCase()) {
        case 'changelog':
        case 'history':
          this.changelogPath = child
          break
        case 'license':
        case 'licence':
          this.licensePath = child
          break
        case 'readme':
          this.readmePath = child
          break
      }

      if (this.readmePath && this.changelogPath && this.licensePath) {
        break
      }
    }

    if (this.changelogPath) {
      this.refs.changelogButton.style.display = ''
    } else {
      this.refs.changelogButton.style.display = 'none'
    }

    if (this.licensePath) {
      this.refs.licenseButton.style.display = ''
    } else {
      this.refs.licenseButton.style.display = 'none'
    }
  }

  getStartupTime () {
    const loadTime = this.pack.loadTime != null ? this.pack.loadTime : 0
    const activateTime = this.pack.activateTime != null ? this.pack.activateTime : 0
    return loadTime + activateTime
  }

  scrollUp () {
    this.element.scrollTop -= document.body.offsetHeight / 20
  }

  scrollDown () {
    this.element.scrollTop += document.body.offsetHeight / 20
  }

  pageUp () {
    this.element.scrollTop -= this.element.offsetHeight
  }

  pageDown () {
    this.element.scrollTop += this.element.offsetHeight
  }

  scrollToTop () {
    this.element.scrollTop = 0
  }

  scrollToBottom () {
    this.element.scrollTop = this.element.scrollHeight
  }
}

class PackageCardComponent {
  constructor (props) {
    this.packageCard = new PackageCard(props.metadata, props.settingsView, props.packageManager, props.options)
    this.element = this.packageCard.element
  }

  update () {}

  destroy () {}
}

================
File: packages/settings-view/lib/package-grammars-view.js
================
/** @babel */

import path from 'path'
import {CompositeDisposable} from 'atom'
import SettingsPanel from './settings-panel'

// View to display the grammars that a package has registered.
export default class PackageGrammarsView {
  constructor (packagePath) {
    this.element = document.createElement('section')
    this.element.classList.add('package-grammars')

    this.grammarSettings = document.createElement('div')
    this.element.appendChild(this.grammarSettings)

    this.disposables = new CompositeDisposable()
    this.packagePath = path.join(packagePath, path.sep)
    this.addGrammars()
    this.disposables.add(atom.grammars.onDidAddGrammar(() => this.addGrammars()))
    this.disposables.add(atom.grammars.onDidUpdateGrammar(() => this.addGrammars()))
  }

  destroy () {
    this.disposables.dispose()
    this.element.remove()
  }

  getPackageGrammars () {
    const packageGrammars = []
    const grammars = atom.grammars.grammars != null ? atom.grammars.grammars : []
    for (let grammar of grammars) {
      if (grammar.path) {
        if (grammar.path.indexOf(this.packagePath) === 0) {
          packageGrammars.push(grammar)
        }
      }
    }
    return packageGrammars.sort(function (grammar1, grammar2) {
      const name1 = grammar1.name || grammar1.scopeName || ''
      const name2 = grammar2.name || grammar2.scopeName || ''
      return name1.localeCompare(name2)
    })
  }

  addGrammarHeading (grammar, panel) {
    const container = document.createElement('div')
    container.classList.add('native-key-bindings', 'text')
    container.tabIndex = -1

    const grammarScope = document.createElement('div')
    grammarScope.classList.add('grammar-scope')

    const scopeStrong = document.createElement('strong')
    scopeStrong.textContent = 'Scope: '
    grammarScope.appendChild(scopeStrong)

    const scopeSpan = document.createElement('span')
    scopeSpan.textContent = grammar.scopeName != null ? grammar.scopeName : ''
    grammarScope.appendChild(scopeSpan)
    container.appendChild(grammarScope)

    const grammarFileTypes = document.createElement('div')
    grammarFileTypes.classList.add('grammar-filetypes')

    const fileTypesStrong = document.createElement('strong')
    fileTypesStrong.textContent = 'File Types: '
    grammarFileTypes.appendChild(fileTypesStrong)

    const fileTypes = grammar.fileTypes || []
    const fileTypesSpan = document.createElement('span')
    fileTypesSpan.textContent = fileTypes.join(', ')
    grammarFileTypes.appendChild(fileTypesSpan)
    container.appendChild(grammarFileTypes)

    const sectionBody = panel.element.querySelector('.section-body')
    sectionBody.parentElement.insertBefore(container, sectionBody)
  }

  addGrammars () {
    this.grammarSettings.innerHTML = ''
    for (let grammar of this.getPackageGrammars()) {
      let {scopeName, name} = grammar
      if (!scopeName || !name) {
        continue
      }

      if (!scopeName.startsWith('.')) {
        scopeName = `.${scopeName}`
      }

      const title = `${name} Grammar`
      const panel = new SettingsPanel({title, scopeName, icon: 'puzzle'})
      this.addGrammarHeading(grammar, panel)
      this.grammarSettings.appendChild(panel.element)
    }
  }
}

================
File: packages/settings-view/lib/package-keymap-view.js
================
/** @babel */
/** @jsx etch.dom */

import path from 'path'
import _ from 'underscore-plus'
import {Disposable, CompositeDisposable} from 'atom'
import etch from 'etch'
import KeybindingsPanel from './keybindings-panel'

// Displays the keybindings for a package namespace
export default class PackageKeymapView {
  constructor (pack) {
    this.pack = pack
    this.otherPlatformPattern = new RegExp(`\\.platform-(?!${_.escapeRegExp(process.platform)}\\b)`)
    this.namespace = this.pack.name
    this.disposables = new CompositeDisposable()
    etch.initialize(this)

    const packagesWithKeymapsDisabled = atom.config.get('core.packagesWithKeymapsDisabled') || []
    this.refs.keybindingToggle.checked = !packagesWithKeymapsDisabled.includes(this.namespace)

    const changeHandler = (event) => {
      event.stopPropagation()
      const value = this.refs.keybindingToggle.checked
      if (value) {
        atom.config.removeAtKeyPath('core.packagesWithKeymapsDisabled', this.namespace)
      } else {
        atom.config.pushAtKeyPath('core.packagesWithKeymapsDisabled', this.namespace)
      }

      this.updateKeyBindingView()
    }
    this.refs.keybindingToggle.addEventListener('change', changeHandler)
    this.disposables.add(new Disposable(() => { this.refs.keybindingToggle.removeEventListener('change', changeHandler) }))

    const copyIconClickHandler = (event) => {
      const target = event.target.closest('.copy-icon')
      if (target) {
        event.preventDefault()
        event.stopPropagation()
        this.writeKeyBindingToClipboard(target.closest('tr').dataset)
      }
    }
    this.element.addEventListener('click', copyIconClickHandler)
    this.disposables.add(new Disposable(() => { this.element.removeEventListener('click', copyIconClickHandler) }))

    this.updateKeyBindingView()

    let hasKeymaps = false
    // eslint-disable-next-line no-unused-vars
    for (let [packageKeymapsPath, keymap] of atom.packages.getLoadedPackage(this.namespace).keymaps) {
      if (keymap.length > 0) {
        hasKeymaps = true
        break
      }
    }

    if (this.refs.keybindingItems.children.length === 0 && !hasKeymaps) {
      this.element.style.display = 'none'
    }
  }

  update () {}

  destroy () {
    this.disposables.dispose()
    return etch.destroy(this)
  }

  render () {
    return (
      <section className='section'>
        <div className='section-heading icon icon-keyboard'>Keybindings</div>
        <div className='checkbox'>
          <label for='toggleKeybindings'>
            <input id='toggleKeybindings' className='input-checkbox' type='checkbox' ref='keybindingToggle' />
            <div className='setting-title'>Enable</div>
          </label>
          <div className='setting-description'>
            {"Disable this if you want to bind your own keystrokes for this package's commands in your keymap."}
          </div>
        </div>
        <table className='package-keymap-table table native-key-bindings text' tabIndex='-1'>
          <thead>
            <tr>
              <th>Keystroke</th>
              <th>Command</th>
              <th>Selector</th>
              <th>Source</th>
            </tr>
          </thead>
          <tbody ref='keybindingItems' />
        </table>
      </section>
    )
  }

  updateKeyBindingView () {
    this.refs.keybindingItems.innerHTML = ''

    const packagesWithKeymapsDisabled = atom.config.get('core.packagesWithKeymapsDisabled') || []
    const keybindingsDisabled = packagesWithKeymapsDisabled.includes(this.namespace)
    if (keybindingsDisabled) {
      this.refs.keybindingItems.classList.add('text-subtle')
    } else {
      this.refs.keybindingItems.classList.remove('text-subtle')
    }

    const keyBindings = []
    if (atom.keymaps.build) {
      // eslint-disable-next-line no-unused-vars
      for (const [keymapPath, keymap] of atom.packages.getLoadedPackage(this.namespace).keymaps) {
        keyBindings.push(...atom.keymaps.build(this.namespace, keymap, 0, false))
      }
    } else {
      // Backwards compatibility for Atom <= 1.19
      for (const keyBinding of atom.keymaps.getKeyBindings()) {
        const {command} = keyBinding
        if (command && command.indexOf && command.indexOf(`${this.namespace}:`) === 0) {
          keyBindings.push(keyBinding)
        }
      }
    }

    for (const keyBinding of keyBindings) {
      const {command, keystrokes, selector, source} = keyBinding
      if (!command) {
        continue
      }

      if (this.otherPlatformPattern.test(selector)) {
        continue
      }

      const keyBindingRow = document.createElement('tr')
      keyBindingRow.dataset.selector = selector
      keyBindingRow.dataset.keystrokes = keystrokes
      keyBindingRow.dataset.command = command

      const keystrokesTd = document.createElement('td')

      const copyIconSpan = document.createElement('span')
      copyIconSpan.classList.add('icon', 'icon-clippy', 'copy-icon')
      keystrokesTd.appendChild(copyIconSpan)

      const keystrokesSpan = document.createElement('span')
      keystrokesSpan.textContent = keystrokes
      keystrokesTd.appendChild(keystrokesSpan)

      keyBindingRow.appendChild(keystrokesTd)

      const commandTd = document.createElement('td')
      commandTd.textContent = command
      keyBindingRow.appendChild(commandTd)

      const selectorTd = document.createElement('td')
      selectorTd.textContent = selector
      keyBindingRow.appendChild(selectorTd)

      const sourceTd = document.createElement('td')
      sourceTd.textContent = KeybindingsPanel.determineSource(source)
      keyBindingRow.appendChild(sourceTd)

      this.refs.keybindingItems.appendChild(keyBindingRow)
    }
  }

  writeKeyBindingToClipboard ({selector, keystrokes, command}) {
    let content
    const keymapExtension = path.extname(atom.keymaps.getUserKeymapPath())
    if (keymapExtension === '.cson') {
      content = `\
'${selector}':
  '${keystrokes}': '${command}'\
`
    } else {
      content = `\
"${selector}": {
  "${keystrokes}": "${command}"
}\
`
    }

    atom.clipboard.write(content)
  }
}

================
File: packages/settings-view/lib/package-manager.js
================
const _ = require('underscore-plus');
const {BufferedProcess, CompositeDisposable, Emitter} = require('atom');
const semver = require('semver');

const Client = require('./atom-io-client');

module.exports = class PackageManager {
  constructor() {
    // Millisecond expiry for cached loadOutdated, etc. values
    this.CACHE_EXPIRY = 1000*60*10;
    this.setProxyServers = this.setProxyServers.bind(this);
    this.setProxyServersAsync = this.setProxyServersAsync.bind(this);
    this.packagePromises = [];
    this.apmCache = {
      loadOutdated: {
        value: null,
        expiry: 0
      }
    };

    this.emitter = new Emitter;
  }

  getClient() {
    return this.client != null ? this.client : (this.client = new Client(this));
  }

  isPackageInstalled(packageName) {
    if (atom.packages.isPackageLoaded(packageName)) {
      return true;
    } else {
      return atom.packages.getAvailablePackageNames().indexOf(packageName) > -1;
    }
  }

  packageHasSettings(packageName) {
    const grammars = (atom.grammars.getGrammars() != null) ? atom.grammars.getGrammars() : [];
    for (let grammar of Array.from(grammars)) {
      if (grammar.path) {
        if (grammar.packageName === packageName) { return true; }
      }
    }

    const pack = atom.packages.getLoadedPackage(packageName);
    if ((pack != null) && !atom.packages.isPackageActive(packageName)) { pack.activateConfig(); }
    const schema = atom.config.getSchema(packageName);
    return (schema != null) && (schema.type !== 'any');
  }

  setProxyServers(callback) {
    const {
      session
    } = atom.getCurrentWindow().webContents;
    session.resolveProxy('http://atom.io', httpProxy => {
      this.applyProxyToEnv('http_proxy', httpProxy);
      session.resolveProxy('https://pulsar-edit.dev', httpsProxy => {
        this.applyProxyToEnv('https_proxy', httpsProxy);
        return callback();
      });
    });
  }

  setProxyServersAsync(callback) {
    const httpProxyPromise = atom.resolveProxy('http://atom.io').then(proxy => this.applyProxyToEnv('http_proxy', proxy));
    const httpsProxyPromise = atom.resolveProxy('https://pulsar-edit.dev').then(proxy => this.applyProxyToEnv('https_proxy', proxy));
    return Promise.all([httpProxyPromise, httpsProxyPromise]).then(callback);
  }

  applyProxyToEnv(envName, proxy) {
    if (proxy != null) {
      proxy = proxy.split(' ');
      switch (proxy[0].trim().toUpperCase()) {
        case 'DIRECT': delete process.env[envName]; break;
        case 'PROXY':  process.env[envName] = 'http://' + proxy[1]; break;
      }
    }
  }

  runCommand(args, callback) {
    const command = atom.packages.getApmPath();
    const outputLines = [];
    const stdout = lines => outputLines.push(lines);
    const errorLines = [];
    const stderr = lines => errorLines.push(lines);
    const exit = code => callback(code, outputLines.join('\n'), errorLines.join('\n'));

    args.push('--no-color');

    if (atom.config.get('core.useProxySettingsWhenCallingApm')) {
      const bufferedProcess = new BufferedProcess({command, args, stdout, stderr, exit, autoStart: false});
      if (atom.resolveProxy != null) {
        this.setProxyServersAsync(() => bufferedProcess.start());
      } else {
        this.setProxyServers(() => bufferedProcess.start());
      }
      return bufferedProcess;
    } else {
      return new BufferedProcess({command, args, stdout, stderr, exit});
    }
  }

  loadInstalled(callback) {
    const args = ['ls', '--json'];
    const errorMessage = 'Fetching local packages failed.';
    const apmProcess = this.runCommand(args, function(code, stdout, stderr) {
      let error;
      if (code === 0) {
        let packages;
        try {
          packages = (JSON.parse(stdout) != null) ? JSON.parse(stdout) : [];
        } catch (parseError) {
          error = createJsonParseError(errorMessage, parseError, stdout);
          return callback(error);
        }
        return callback(null, packages);
      } else {
        error = new Error(errorMessage);
        error.stdout = stdout;
        error.stderr = stderr;
        return callback(error);
      }
    });

    return handleProcessErrors(apmProcess, errorMessage, callback);
  }

  loadFeatured(loadThemes, callback) {
    if (!callback) {
      callback = loadThemes;
      loadThemes = false;
    }

    const args = ['featured', '--json'];
    const version = atom.getVersion();
    if (loadThemes) { args.push('--themes'); }
    if (semver.valid(version)) { args.push('--compatible', version); }
    const errorMessage = 'Fetching featured packages failed.';

    const apmProcess = this.runCommand(args, function(code, stdout, stderr) {
      let error;
      if (code === 0) {
        let packages;
        try {
          let left;
          packages = (left = JSON.parse(stdout)) != null ? left : [];
        } catch (parseError) {
          error = createJsonParseError(errorMessage, parseError, stdout);
          return callback(error);
        }

        return callback(null, packages);
      } else {
        error = new Error(errorMessage);
        error.stdout = stdout;
        error.stderr = stderr;
        return callback(error);
      }
    });

    return handleProcessErrors(apmProcess, errorMessage, callback);
  }

  loadOutdated(clearCache, callback) {
    if (clearCache) {
      this.clearOutdatedCache();
    // Short circuit if we have cached data.
    } else if (this.apmCache.loadOutdated.value && (this.apmCache.loadOutdated.expiry > Date.now())) {
      return callback(null, this.apmCache.loadOutdated.value);
    }

    const args = ['outdated', '--json'];
    const version = atom.getVersion();
    if (semver.valid(version)) { args.push('--compatible', version); }
    const errorMessage = 'Fetching outdated packages and themes failed.';

    const apmProcess = this.runCommand(args, (code, stdout, stderr) => {
      let error;
      let pack;
      if (code === 0) {
        let packages;
        try {
          let left;
          packages = (left = JSON.parse(stdout)) != null ? left : [];
        } catch (parseError) {
          error = createJsonParseError(errorMessage, parseError, stdout);
          return callback(error);
        }

        const updatablePackages = ((() => {
          const result = [];
          for (pack of Array.from(packages)) {
            if (!this.getVersionPinnedPackages().includes(pack != null ? pack.name : undefined)) {
              result.push(pack);
            }
          }
          return result;
        })());

        this.apmCache.loadOutdated = {
          value: updatablePackages,
          expiry: Date.now() + this.CACHE_EXPIRY
        };

        for (pack of Array.from(updatablePackages)) {
          this.emitPackageEvent('update-available', pack);
        }

        return callback(null, updatablePackages);
      } else {
        error = new Error(errorMessage);
        error.stdout = stdout;
        error.stderr = stderr;
        return callback(error);
      }
    });

    return handleProcessErrors(apmProcess, errorMessage, callback);
  }

  getVersionPinnedPackages() {
    let left;
    return (left = atom.config.get('core.versionPinnedPackages')) != null ? left : [];
  }

  clearOutdatedCache() {
    return this.apmCache.loadOutdated = {
      value: null,
      expiry: 0
    };
  }

  loadPackage(packageName, callback) {
    const args = ['view', packageName, '--json'];
    const errorMessage = `Fetching package '${packageName}' failed.`;

    const apmProcess = this.runCommand(args, function(code, stdout, stderr) {
      let error;
      if (code === 0) {
        let packages;
        try {
          let left;
          packages = (left = JSON.parse(stdout)) != null ? left : [];
        } catch (parseError) {
          error = createJsonParseError(errorMessage, parseError, stdout);
          return callback(error);
        }

        return callback(null, packages);
      } else {
        error = new Error(errorMessage);
        error.stdout = stdout;
        error.stderr = stderr;
        return callback(error);
      }
    });

    return handleProcessErrors(apmProcess, errorMessage, callback);
  }

  loadCompatiblePackageVersion(packageName, callback) {
    const args = ['view', packageName, '--json', '--compatible', this.normalizeVersion(atom.getVersion())];
    const errorMessage = `Fetching package '${packageName}' failed.`;

    const apmProcess = this.runCommand(args, function(code, stdout, stderr) {
      let error;
      if (code === 0) {
        let packages;
        try {
          let left;
          packages = (left = JSON.parse(stdout)) != null ? left : [];
        } catch (parseError) {
          error = createJsonParseError(errorMessage, parseError, stdout);
          return callback(error);
        }

        return callback(null, packages);
      } else {
        error = new Error(errorMessage);
        error.stdout = stdout;
        error.stderr = stderr;
        return callback(error);
      }
    });

    return handleProcessErrors(apmProcess, errorMessage, callback);
  }

  getInstalled() {
    return new Promise((resolve, reject) => {
      this.loadInstalled(function(error, result) {
        if (error) {
          reject(error);
        } else {
          resolve(result);
        }
      });
    });
  }

  getFeatured(loadThemes) {
    return new Promise((resolve, reject) => {
      return this.loadFeatured(!!loadThemes, function(error, result) {
        if (error) {
          return reject(error);
        } else {
          return resolve(result);
        }
      });
    });
  }

  getOutdated(clearCache) {
    if (clearCache == null) { clearCache = false; }
    return new Promise((resolve, reject) => {
      this.loadOutdated(clearCache, function(error, result) {
        if (error) {
          reject(error);
        } else {
          resolve(result);
        }
      });
    });
  }

  getPackage(packageName) {
      return this.packagePromises[packageName] != null ?
        this.packagePromises[packageName] :
        (this.packagePromises[packageName] = new Promise((resolve, reject) => {
          this.loadPackage(packageName, function(error, result) {
            if (error) {
              return reject(error);
            } else {
              return resolve(result);
            }
          });
      }));
    }

  satisfiesVersion(version, metadata) {
    const engine = (metadata.engines != null ? metadata.engines.atom : undefined) != null ? (metadata.engines != null ? metadata.engines.atom : undefined) : '*';
    if (!semver.validRange(engine)) { return false; }
    return semver.satisfies(version, engine);
  }

  normalizeVersion(version) {
    if (typeof version === 'string') { [version] = Array.from(version.split('-')); }
    return version;
  }

  update(pack, newVersion, callback) {
    let args;
    const {name, theme, apmInstallSource} = pack;

    const errorMessage = newVersion ?
      `Updating to \u201C${name}@${newVersion}\u201D failed.`
    :
      "Updating to latest sha failed.";
    const onError = error => {
      error.packageInstallError = !theme;
      this.emitPackageEvent('update-failed', pack, error);
      return (typeof callback === 'function' ? callback(error) : undefined);
    };

    if ((apmInstallSource != null ? apmInstallSource.type : undefined) === 'git') {
      args = ['install', apmInstallSource.source];
    } else {
      args = ['install', `${name}@${newVersion}`];
    }

    const exit = (code, stdout, stderr) => {
      if (code === 0) {
        this.clearOutdatedCache();
        if (typeof callback === 'function') {
          callback();
        }
        return this.emitPackageEvent('updated', pack);
      } else {
        const error = new Error(errorMessage);
        error.stdout = stdout;
        error.stderr = stderr;
        return onError(error);
      }
    };

    this.emitPackageEvent('updating', pack);
    const apmProcess = this.runCommand(args, exit);
    return handleProcessErrors(apmProcess, errorMessage, onError);
  }

  unload(name) {
    if (atom.packages.isPackageLoaded(name)) {
      if (atom.packages.isPackageActive(name)) { atom.packages.deactivatePackage(name); }
      return atom.packages.unloadPackage(name);
    }
  }

  install(pack, callback) {
    let {name, version, theme} = pack;
    const activateOnSuccess = !theme && !atom.packages.isPackageDisabled(name);
    const activateOnFailure = atom.packages.isPackageActive(name);
    const nameWithVersion = (version != null) ? `${name}@${version}` : name;

    this.unload(name);
    const args = ['install', nameWithVersion, '--json'];

    const errorMessage = `Installing \u201C${nameWithVersion}\u201D failed.`;
    const onError = error => {
      error.packageInstallError = !theme;
      this.emitPackageEvent('install-failed', pack, error);
      return (typeof callback === 'function' ? callback(error) : undefined);
    };

    const exit = (code, stdout, stderr) => {
      if (code === 0) {
        // get real package name from package.json
        try {
          const packageInfo = JSON.parse(stdout)[0];
          pack = _.extend({}, pack, packageInfo.metadata);
          ({
            name
          } = pack);
        } catch (err) {}
          // using old apm without --json support
        this.clearOutdatedCache();
        if (activateOnSuccess) {
          atom.packages.activatePackage(name);
        } else {
          atom.packages.loadPackage(name);
        }

        if (typeof callback === 'function') {
          callback();
        }
        return this.emitPackageEvent('installed', pack);
      } else {
        if (activateOnFailure) { atom.packages.activatePackage(name); }
        const error = new Error(errorMessage);
        error.stdout = stdout;
        error.stderr = stderr;
        return onError(error);
      }
    };

    this.emitPackageEvent('installing', pack);
    const apmProcess = this.runCommand(args, exit);
    return handleProcessErrors(apmProcess, errorMessage, onError);
  }

  uninstall(pack, callback) {
    const {name} = pack;

    if (atom.packages.isPackageActive(name)) { atom.packages.deactivatePackage(name); }

    const errorMessage = `Uninstalling \u201C${name}\u201D failed.`;
    const onError = error => {
      this.emitPackageEvent('uninstall-failed', pack, error);
      return (typeof callback === 'function' ? callback(error) : undefined);
    };

    this.emitPackageEvent('uninstalling', pack);
    const apmProcess = this.runCommand(['uninstall', '--hard', name], (code, stdout, stderr) => {
      if (code === 0) {
        this.clearOutdatedCache();
        this.unload(name);
        this.removePackageNameFromDisabledPackages(name);
        if (typeof callback === 'function') {
          callback();
        }
        return this.emitPackageEvent('uninstalled', pack);
      } else {
        const error = new Error(errorMessage);
        error.stdout = stdout;
        error.stderr = stderr;
        return onError(error);
      }
    });

    return handleProcessErrors(apmProcess, errorMessage, onError);
  }

  canUpgrade(installedPackage, availableVersion) {
    if (installedPackage == null) { return false; }

    const installedVersion = installedPackage.metadata.version;
    if (!semver.valid(installedVersion)) { return false; }
    if (!semver.valid(availableVersion)) { return false; }

    return semver.gt(availableVersion, installedVersion);
  }

  getPackageTitle({name}) {
    return _.undasherize(_.uncamelcase(name));
  }

  getRepositoryUrl({metadata}) {
    let left;
    const {repository} = metadata;
    let repoUrl = (left = (repository != null ? repository.url : undefined) != null ? (repository != null ? repository.url : undefined) : repository) != null ? left : '';
    if (repoUrl.match('git@github')) {
      const repoName = repoUrl.split(':')[1];
      repoUrl = `https://github.com/${repoName}`;
    }
    return repoUrl.replace(/\.git$/, '').replace(/\/+$/, '').replace(/^git\+/, '');
  }

  getRepositoryBugUri({metadata}) {
    let bugUri;
    const {bugs} = metadata;
    if (typeof bugs === 'string') {
      bugUri = bugs;
    } else {
      let left;
      bugUri = (left = (bugs != null ? bugs.url : undefined) != null ? (bugs != null ? bugs.url : undefined) : (bugs != null ? bugs.email : undefined)) != null ? left : this.getRepositoryUrl({metadata}) + '/issues/new';
      if (bugUri.includes('@')) {
        bugUri = 'mailto:' + bugUri;
      }
    }
    return bugUri;
  }

  checkNativeBuildTools() {
    return new Promise((resolve, reject) => {
      const apmProcess = this.runCommand(['install', '--check'], function(code, stdout, stderr) {
        if (code === 0) {
          resolve();
        } else {
          reject(new Error());
        }
      });

      apmProcess.onWillThrowError(function({error, handle}) {
        handle();
        reject(error);
      });
    });
  }

  removePackageNameFromDisabledPackages(packageName) {
    return atom.config.removeAtKeyPath('core.disabledPackages', packageName);
  }

  // Emits the appropriate event for the given package.
  //
  // All events are either of the form `theme-foo` or `package-foo` depending on
  // whether the event is for a theme or a normal package. This method standardizes
  // the logic to determine if a package is a theme or not and formats the event
  // name appropriately.
  //
  // eventName - The event name suffix {String} of the event to emit.
  // pack - The package for which the event is being emitted.
  // error - Any error information to be included in the case of an error.
  emitPackageEvent(eventName, pack, error) {
    const theme = pack.theme != null ? pack.theme : (pack.metadata != null ? pack.metadata.theme : undefined);
    eventName = theme ? `theme-${eventName}` : `package-${eventName}`;
    return this.emitter.emit(eventName, {pack, error});
  }

  on(selectors, callback) {
    const subscriptions = new CompositeDisposable;
    for (let selector of Array.from(selectors.split(" "))) {
      subscriptions.add(this.emitter.on(selector, callback));
    }
    return subscriptions;
  }
}

const createJsonParseError = (message, parseError, stdout) => {
  const error = new Error(message);
  error.stdout = '';
  error.stderr = `${parseError.message}: ${stdout}`;
  return error;
};

const createProcessError = (message, processError) => {
  const error = new Error(message);
  error.stdout = '';
  error.stderr = processError.message;
  return error;
};

const handleProcessErrors = (apmProcess, message, callback) => apmProcess.onWillThrowError(function({error, handle}) {
  handle();
  return callback(createProcessError(message, error));
});

================
File: packages/settings-view/lib/package-readme-view.js
================
/** @babel */

// Displays the readme for a package, if it has one
// TODO Decide to keep this or current button-to-new-tab view
export default class PackageReadmeView {
  constructor (readme, readmeSrc, readmeIsLocal) {
    this.element = document.createElement('section')
    this.element.classList.add('section')

    const container = document.createElement('div')
    container.classList.add('section-container')

    const heading = document.createElement('div')
    heading.classList.add('section-heading', 'icon', 'icon-book')
    heading.textContent = 'README'
    container.appendChild(heading)

    this.packageReadme = document.createElement('div')
    this.packageReadme.classList.add('package-readme', 'native-key-bindings')
    this.packageReadme.tabIndex = -1
    container.appendChild(this.packageReadme)
    this.element.appendChild(container)

    readme ||= "### No README.";

    const markdownOpts = {
      breaks: false,
      taskCheckboxDisabled: true
    };

    if (readmeIsLocal) {
      markdownOpts.filePath = readmeSrc;
    } else {
      markdownOpts.rootDomain = readmeSrc;
    }

    try {
      this.packageReadme.innerHTML = atom.ui.markdown.render(readme, markdownOpts);
    } catch(err) {
      this.packageReadme.innerHTML = "<h3>Error parsing README</h3>";
    }
  }

  destroy () {
    this.element.remove()
  }
}

================
File: packages/settings-view/lib/package-snippets-view.js
================
/** @babel */
/** @jsx etch.dom */

import path from 'path'
import _ from 'underscore-plus'
import etch from 'etch'
import {CompositeDisposable, Disposable} from 'atom'

// View to display the snippets that a package has registered.
export default class PackageSnippetsView {
  constructor (pack, snippetsProvider) {
    this.pack = pack
    this.namespace = this.pack.name
    this.snippetsProvider = snippetsProvider
    this.packagePath = path.join(pack.path, path.sep)
    etch.initialize(this)
    this.disposables = new CompositeDisposable()
    this.updateSnippetsView()

    const packagesWithSnippetsDisabled = atom.config.get('core.packagesWithSnippetsDisabled') || []
    this.refs.snippetToggle.checked = !packagesWithSnippetsDisabled.includes(this.namespace)

    const changeHandler = (event) => {
      event.stopPropagation()
      const value = this.refs.snippetToggle.checked
      if (value) {
        atom.config.removeAtKeyPath('core.packagesWithSnippetsDisabled', this.namespace)
      } else {
        atom.config.pushAtKeyPath('core.packagesWithSnippetsDisabled', this.namespace)
      }
      this.updateSnippetsView()
    }

    this.refs.snippetToggle.addEventListener('change', changeHandler)
    this.disposables.add(new Disposable(() => { this.refs.snippetToggle.removeEventListener('change', changeHandler) }))
  }

  destroy () {
    this.disposables.dispose()
    return etch.destroy(this)
  }

  update () {}

  render () {
    return (
      <section className='section'>
        <div className='section-heading icon icon-code'>Snippets</div>
        <div className='checkbox'>
          <label for='toggleSnippets'>
            <input id='toggleSnippets' className='input-checkbox' type='checkbox' ref='snippetToggle' />
            <div className='setting-title'>Enable</div>
          </label>
          <div className='setting-description' ref='snippetSettingDescription'>
            <p>Disable this if you want to prevent this package’s snippets from appearing as suggestions or if you want to customize them in your snippets file.</p>

            <p>To <strong>disable</strong> most snippets and <strong>enable</strong> just a few, use the <kbd>Copy</kbd> button on any snippet you want to enable, then paste the result into your own snippets file.</p>

            <p>To <strong>enable</strong> most snippets and <strong>disable</strong> just a few, use the <kbd>Copy</kbd> button on any snippet you want to disable, paste the result into your own snippets file, and change the body to <code>null</code>.</p>
          </div>
        </div>

        <table className='package-snippets-table table native-key-bindings text' tabIndex={-1}>
          <thead>
            <tr>
              <th>Trigger</th>
              <th ref="headingCommand">Command</th>
              <th>Name</th>
              <th>Scope</th>
              <th>Body</th>
            </tr>
          </thead>
          <tbody ref='snippets' />
        </table>
      </section>
    )
  }

  getSnippetProperties () {
    const packageProperties = {}
    for (const {name, properties} of this.snippetsProvider.getSnippets()) {
      if (name && name.indexOf && name.indexOf(this.packagePath) === 0) {
        const object = properties.snippets != null ? properties.snippets : {}
        for (let key in object) {
          const snippet = object[key]
          if (snippet != null) {
            if (packageProperties[key] == null) {
              packageProperties[key] = snippet
            }
          }
        }
      }
    }

    return _.values(packageProperties).sort((snippet1, snippet2) => {
      const prefix1 = snippet1.prefix != null ? snippet1.prefix : ''
      const prefix2 = snippet2.prefix != null ? snippet2.prefix : ''
      return prefix1.localeCompare(prefix2)
    })
  }

  getSnippets (callback) {
    const snippetsPackage = atom.packages.getLoadedPackage('snippets')
    const snippetsModule = snippetsPackage ? snippetsPackage.mainModule : null
    if (snippetsModule) {
      if (snippetsModule.loaded) {
        callback(this.getSnippetProperties())
      } else {
        snippetsModule.onDidLoadSnippets(() => callback(this.getSnippetProperties()))
      }
    } else {
      callback([]) // eslint-disable-line standard/no-callback-literal
    }
  }

  updateSnippetsView () {
    const packagesWithSnippetsDisabled = atom.config.get('core.packagesWithSnippetsDisabled') || []
    const snippetsDisabled = packagesWithSnippetsDisabled.includes(this.namespace)

    this.getSnippets((snippets) => {
      this.refs.snippets.innerHTML = ''

      let anyWithCommand = snippets.some(s => ('command' in s))

      if (snippetsDisabled) {
        this.refs.snippets.classList.add('text-subtle')
      } else {
        this.refs.snippets.classList.remove('text-subtle')
      }

      for (let {body, bodyText, command, name, packageName, prefix, selector} of snippets) {
        if (name == null) {
          name = ''
        }

        if (prefix == null) {
          prefix = ''
        }

        if (body == null) {
          body = bodyText || ''
        }

        if (selector == null) {
          selector = ''
        }

        let commandName = ''
        if (packageName && command) {
          commandName = `${packageName}:${command}`
        }

        const row = document.createElement('tr')

        const prefixTd = document.createElement('td')
        prefixTd.classList.add('snippet-prefix')
        prefixTd.textContent = prefix
        row.appendChild(prefixTd)

        const commandTd = document.createElement('td')
        commandTd.textContent = commandName
        row.appendChild(commandTd)
        commandTd.style.display = anyWithCommand ? '' : 'none'

        const nameTd = document.createElement('td')
        nameTd.textContent = name
        row.appendChild(nameTd)

        const scopeTd = document.createElement('td')
        scopeTd.classList.add('snippet-scope-name')
        scopeTd.textContent = selector
        row.appendChild(scopeTd)

        const bodyTd = document.createElement('td')
        bodyTd.classList.add('snippet-body')
        row.appendChild(bodyTd)

        this.refs.snippets.appendChild(row)
        this.createButtonsForSnippetRow(bodyTd, {body, prefix, scope: selector, name, command})
      }

      if (this.refs.snippets.children.length > 0) {
        this.element.style.display = ''
      } else {
        this.element.style.display = 'none'
      }

      // The “Command” column should only be shown if at least one snippet is
      // mapped to a command name.
      this.refs.headingCommand.style.display = anyWithCommand ? '' : 'none'
    })
  }

  createButtonsForSnippetRow (td, {scope, body, name, prefix, command}) {
    let buttonContainer = document.createElement('div')
    buttonContainer.classList.add('btn-group', 'btn-group-xs')

    let viewButton = document.createElement('button')
    let copyButton = document.createElement('button')

    viewButton.setAttribute('type', 'button')
    viewButton.textContent = 'View'
    viewButton.classList.add('btn', 'snippet-view-btn')

    let tooltip = atom.tooltips.add(viewButton, {
      title: body,
      html: false,
      trigger: 'click',
      placement: 'auto left',
      'class': 'snippet-body-tooltip'
    })

    this.disposables.add(tooltip)

    copyButton.setAttribute('type', 'button')
    copyButton.textContent = 'Copy'
    copyButton.classList.add('btn', 'snippet-copy-btn')

    copyButton.addEventListener('click', (event) => {
      event.preventDefault()
      return this.writeSnippetToClipboard({scope, body, name, prefix, command})
    })

    buttonContainer.appendChild(viewButton)
    buttonContainer.appendChild(copyButton)

    td.appendChild(buttonContainer)
  }

  writeSnippetToClipboard ({scope, body, name, prefix, command}) {
    let content
    const extension = path.extname(this.snippetsProvider.getUserSnippetsPath())
    body = body.replace(/\n/g, '\\n').replace(/\t/g, '\\t')
    // Either `prefix` or `command` will be present, or else both. Only copy
    // the values that are present.
    let triggers = []
    if (extension === '.cson') {
      if (prefix) {
        triggers.push(`    'prefix': '${prefix}'`)
      }
      if (command) {
        triggers.push(`    'command': '${command}'`)
      }
      body = body.replace(/'/g, `\\'`)
      content = `
'${scope}':
  '${name}':
${triggers.join('\n')}
    'body': '${body}'
`
    } else {
      if (prefix) {
        triggers.push(`    "prefix": "${prefix}"`)
      }
      if (command) {
        triggers.push(`    "command": "${command}"`)
      }
      body = body.replace(/"/g, `\\"`)
      content = `
  "${scope}": {
    "${name}": {
${triggers.join(',\n')}
      "body": "${body}"
    }
  }
`
    }

    atom.clipboard.write(content)
  }
}

================
File: packages/settings-view/lib/package-updates-status-view.js
================
/** @babel */

import _ from 'underscore-plus'
import {CompositeDisposable, Disposable} from 'atom'

export default class PackageUpdatesStatusView {
  initialize (statusBar, packageManager, updates) {
    this.statusBar = statusBar
    this.updates = updates
    this.destroyed = true
    this.updatingPackages = []
    this.failedUpdates = []
    this.disposables = new CompositeDisposable()

    this.element = document.createElement('div')
    this.element.classList.add('package-updates-status-view', 'inline-block', 'text', 'text-info')

    const iconPackage = document.createElement('span')
    iconPackage.classList.add('icon', 'icon-package')
    this.element.appendChild(iconPackage)

    this.countLabel = document.createElement('span')
    this.countLabel.classList.add('available-updates-status')
    this.element.appendChild(this.countLabel)

    this.disposables.add(packageManager.on('package-update-available theme-update-available', ({pack, error}) => { this.onPackageUpdateAvailable(pack) }))
    this.disposables.add(packageManager.on('package-updating theme-updating', ({pack, error}) => { this.onPackageUpdating(pack) }))
    this.disposables.add(packageManager.on('package-updated theme-updated package-uninstalled theme-uninstalled', ({pack, error}) => { this.onPackageUpdated(pack) }))
    this.disposables.add(packageManager.on('package-update-failed theme-update-failed', ({pack, error}) => { this.onPackageUpdateFailed(pack) }))

    const clickHandler = () => {
      atom.commands.dispatch(atom.views.getView(atom.workspace), 'settings-view:check-for-package-updates')
    }
    this.element.addEventListener('click', clickHandler)
    this.disposables.add(new Disposable(() => { this.element.removeEventListener('click', clickHandler) }))

    this.updateTile()
  }

  destroy () {
    this.disposables.dispose()
    this.element.remove()

    if (this.tile) {
      this.tile.destroy()
      this.tile = null
    }

    if (this.tooltip) {
      this.tooltip.dispose()
      this.tooltip = null
    }
  }

  onPackageUpdateAvailable (pack) {
    for (const update of this.updates) {
      if (update.name === pack.name) {
        return
      }
    }

    this.updates.push(pack)
    this.updateTile()
  }

  onPackageUpdating (pack) {
    // Wipe failed status when an update is retried
    for (let index = 0; index < this.failedUpdates.length; index++) {
      const update = this.failedUpdates[index]
      if (update.name === pack.name) {
        this.failedUpdates.splice(index, 1)
      }
    }

    this.updatingPackages.push(pack)
    this.updateTile()
  }

  onPackageUpdated (pack) {
    for (let index = 0; index < this.updates.length; index++) {
      const update = this.updates[index]
      if (update.name === pack.name) {
        this.updates.splice(index, 1)
      }
    }

    for (let index = 0; index < this.updatingPackages.length; index++) {
      const update = this.updatingPackages[index]
      if (update.name === pack.name) {
        this.updatingPackages.splice(index, 1)
      }
    }

    for (let index = 0; index < this.failedUpdates.length; index++) {
      const update = this.failedUpdates[index]
      if (update.name === pack.name) {
        this.failedUpdates.splice(index, 1)
      }
    }

    this.updateTile()
  }

  onPackageUpdateFailed (pack) {
    for (const update of this.failedUpdates) {
      if (update.name === pack.name) {
        return
      }
    }

    for (let index = 0; index < this.updatingPackages.length; index++) {
      const update = this.updatingPackages[index]
      if (update.name === pack.name) {
        this.updatingPackages.splice(index, 1)
      }
    }

    this.failedUpdates.push(pack)
    this.updateTile()
  }

  updateTile () {
    if (this.updates.length) {
      if (this.tooltip) {
        this.tooltip.dispose()
        this.tooltip = null
      }

      if (this.destroyed) {
        // Priority of -99 should put us just to the left of the Squirrel icon, which displays when Atom has updates available
        this.tile = this.statusBar.addRightTile({item: this, priority: -99})
        this.destroyed = false
      }

      let labelText = `${_.pluralize(this.updates.length, 'update')}` // 5 updates
      let tooltipText = `${_.pluralize(this.updates.length, 'package update')} available`

      if (this.updatingPackages.length) {
        labelText = `${this.updatingPackages.length}/${this.updates.length} updating` // 3/5 updating
        tooltipText += `, ${_.pluralize(this.updatingPackages.length, 'package')} currently updating`
      }

      if (this.failedUpdates.length) {
        labelText += ` (${this.failedUpdates.length} failed)` // 1 update (1 failed), or 3/5 updating (1 failed)
        tooltipText += `, ${_.pluralize(this.failedUpdates.length, 'failed update')}`
      }

      this.countLabel.textContent = labelText
      this.tooltip = atom.tooltips.add(this.element, {title: tooltipText})
    } else if (!this.destroyed) {
      this.tile.destroy()
      this.tile = null
      this.destroyed = true
    }
  }
}

================
File: packages/settings-view/lib/rich-description.js
================
module.exports = {
  getSettingDescription (keyPath) {
    const schema = atom.config.getSchema(keyPath)
    let description = ''
    if (schema && schema.description) {
      description = schema.description
    }
    return atom.ui.markdown.render(
      description,
      {
        useTaskCheckbox: false,
        disableMode: "strict",
      }
    ).replace(/<p>(.*)<\/p>/, "$1").trim();
  }
}

================
File: packages/settings-view/lib/rich-title.js
================
const _ = require("underscore-plus")

module.exports = {
  getSettingTitle (keyPath, name) {
    if (name == null) {
      name = ''
    }
    const schema = atom.config.getSchema(keyPath)
    const title = schema != null ? schema.title : null
    return title || _.uncamelcase(name).split('.').map(_.capitalize).join(' ')
  }
}

================
File: packages/settings-view/lib/search-setting-view.js
================
/** @babel */
/** @jsx etch.dom */

import etch from 'etch'
import { shell } from 'electron'
import { Disposable, CompositeDisposable } from 'atom'
import { getSettingTitle } from './rich-title'

export default class SearchSettingView {
  constructor(setting, settingsView) {
    this.settingsView = settingsView
    this.setting = setting
    this.disposables = new CompositeDisposable()

    etch.initialize(this)

    this.handleButtonEvents()
  }

  render () {
    const title = this.setting.title ?? getSettingTitle(this.setting.path, this.setting.path.split(".")[1]);
    const path = atom.config.get("settings-view.searchSettingsMetadata") ? this.setting.path + ": " : "";
    const description = this.setting.description ?? "";
    const packageName = this.setting.path.split(".")[0];
    const icon = this.getIcon(packageName);
    const score = atom.config.get("settings-view.searchSettingsMetadata") ? this.setting.rank.totalScore.toFixed(2) + " Search Score" : "";

    return (
      <div className='search-result col-lg-8'>
        <span className='search-package-name pull-right'>
          <span className={icon}></span>
          {packageName}
        </span>
        <div className='body'>
          <h4 className='card-name'>
            <a ref='settingLink'>
              <span className='search-name'>{title}</span>
              <span className='search-id'>{path}{score}</span>
            </a>
          </h4>
          <span className='search-description'>{description}</span>

        </div>

      </div>
    )
  }

  update () {}

  destroy () {
    this.disposables.dispose()
    return etch.destroy(this)
  }

  getIcon(namespace) {
    // Takes a setting namespace and returns the appropriate icon for it.
    switch(namespace) {
      case "core":
        return "icon icon-settings search-result-icon";
        break;
      case "editor":
        return "icon icon-code search-result-icon";
        break;
      default:
        return "icon icon-package search-result-icon";
        break;
    }
  }

  handleButtonEvents () {
    const settingsClickHandler = (event) => {
      event.stopPropagation()

      // Lets check if the setting we want to open is built in or from a package
      const settingLocation = this.setting.path.split(".")[0]
      // The above is the location where the setting exists, such as Core, or a packages name

      switch(settingLocation) {
        case "core":
          // There are some special cases of settings broken off into other panels
          let settingName = this.setting.path.split(".")[1]
          if (settingName === 'uriHandlerRegistration') {
            // the URI handler doesn't have any registered uri to actually reach it
            // funnily enough. So we will prompt a notification to go there
            atom.notifications.addInfo("Sorry, Pulsar is unable to link to this setting. Please select 'URI Handling' on the sidebar.")
          } else {
            atom.workspace.open("atom://config/core")
          }
          break;
        case "editor":
          atom.workspace.open("atom://config/editor")
          break;
        default:
          // The handling for any packages name
          atom.workspace.open(`atom://config/packages/${settingLocation}`)
          break;
      }
    }

    this.refs.settingLink.addEventListener('click', settingsClickHandler)
    this.disposables.add(new Disposable(() => { this.refs.settingLink.removeEventListener('click', settingsClickHandler) }))
  }
}

================
File: packages/settings-view/lib/search-settings-panel.js
================
/** @babel */
/** @jsx etch.dom */

import { TextEditor, CompositeDisposable } from 'atom'
import etch from 'etch'
import CollapsibleSectionPanel from './collapsible-section-panel'
import SearchSettingView from './search-setting-view'

export default class SearchSettingsPanel extends CollapsibleSectionPanel {
  constructor(settingsView) {
    super()
    etch.initialize(this)
    this.settingsView = settingsView
    this.searchResults = []
    // Get all available settings
    this.settingsSchema = atom.config.schema.properties;

    this.subscriptions = new CompositeDisposable()
    this.subscriptions.add(this.handleEvents())
    this.subscriptions.add(atom.commands.add(this.element, {
      'core:move-up': () => { this.scrollUp() },
      'core:move-down': () => { this.scrollDown() },
      'core:page-up': () => { this.pageUp() },
      'core:page-down': () => { this.pageDown() },
      'core:move-to-top': () => { this.scrollToTop() },
      'core:move-to-bottom': () => { this.scrollToBottom() }
    }))

    this.subscriptions.add(
      this.refs.searchEditor.onDidStopChanging(() => { this.matchSettings() })
    )
  }

  focus () {
    this.refs.searchEditor.element.focus()
  }

  show () {
    this.element.style.display = ''
    // Don't show the loading for search results as soon as page appears
    this.refs.loadingArea.style.display = 'none'
  }

  destroy () {
    this.subscriptions.dispose()
    return etch.destroy(this)
  }

  update () {}

  render () {
    return (
      <div className='panels-item' tabIndex='-1'>
        <section className='section'>
          <div className='section-container'>
            <div className='section-heading icon icon-search-save'>
              Search Pulsar's Settings
            </div>
            <div className='alert alert-warning icon icon-info'>
              This feature is experimental.<br />
              If you have feedback/suggestions, or you encounter any issues, feel free to report them here:&nbsp;
              <a href="https://github.com/orgs/pulsar-edit/discussions/150" style="text-decoration: underline;">
                https://github.com/orgs/pulsar-edit/discussions/150
              </a>
            </div>
            <div className='editor-container'>
              <TextEditor ref='searchEditor' mini placeholderText='Start Searching for Settings' />
            </div>

            <section className='sub-section search-results'>
              <h3 ref='searchHeader' className='sub-section-heading icon icon-package'>
                Search Results
              </h3>
              <div ref='searchResults' className='container package-container'>
                <div ref='loadingArea' className='alert alert-info loading-area icon icon-hourglass'>
                  Loading Results...
                </div>
              </div>
            </section>

          </div>
        </section>
      </div>
    )
  }

  matchSettings () {
    // this is called after the user types.
    // So lets show our loading message after removing any previous results
    this.clearSearchResults()
    this.refs.loadingArea.style.display = ''
    this.filterSettings(this.refs.searchEditor.getText())
  }

  clearSearchResults () {
    for (let i = 0; i < this.searchResults.length; i++) {
      this.searchResults[i].destroy()
    }
    this.searchResults = []
  }

  filterSettings (text) {
    let rankedResults = [];

    let searchTerm = text;
    let namedFilter;
    let useFilter = false;

    // Now we will check if the user is filtering any results

    if (text.startsWith("core: ")) {
      searchTerm = text.replace("core: ", "");
      namedFilter = "core";
      useFilter = true;
    }

    if (text.startsWith("editor: ")) {
      searchTerm = text.replace("editor: ", "");
      namedFilter = "editor";
      useFilter = true;
    }

    for (const setting in this.settingsSchema) {
      // The top level item should always be an object, but just in case we will check.
      // If the top level item returned is not an object it will NOT be listed
      if (useFilter) {

        if (namedFilter !== setting) {
          continue;
          // We use this so that we can break out of our current loop iteration
          // when using a filter that doesn't match the current namespace.
          // But otherwise will process the settings when no filter is set
          // or when the filter set matches our current namespace.
          // This helps avoid processing any namespace that doesn't match our filter
          // or process all of them as default.
        }
      }

      if (this.settingsSchema[setting].type === "object") {
        for (const item in this.settingsSchema[setting].properties) {

          let schema = this.settingsSchema[setting].properties[item];

          schema.rank = this.generateRanks(text, schema.title, schema.description, setting, item)

          schema.path = `${setting}.${item}`

          rankedResults.push(schema)
        }
      }

    }

    this.processRanks(rankedResults)
  }

  handleSettingsString (string) {
    return string?.toLowerCase() ?? "";
  }

  generateRanks (searchText, title, description, settingName, settingItem) {
    // In charge of generating each setting entry's rank
    let rankedTitle = this.getScore(this.handleSettingsString(searchText), this.handleSettingsString(title))
    let rankedDescription = this.getScore(this.handleSettingsString(searchText), this.handleSettingsString(description))
    let rankedSettingName = this.getScore(this.handleSettingsString(searchText), this.handleSettingsString(settingName))
    let rankedSettingItem = this.getScore(this.handleSettingsString(searchText), this.handleSettingsString(settingItem))

    let rank = {
      title: rankedTitle,
      description: rankedDescription,
      settingName: rankedSettingName,
      settingItem: rankedSettingItem
    };

    // Now to calculate the total score of the search resutls.
    // The total score will be a sume of all individual scores,
    // with weighted bonus' for higher matches depending on where the match was
    let titleBonus = (rank.title.score > 0.8) ? 0.2 : 0;
    let perfectTitleBonus = (rank.title.score === 1) ? 0.2 : 0;
    let descriptionBonus = (rank.description.score > 0.5) ? 0.1 : 0;
    let perfectDescriptionBonus = (rank.title.score === 1) ? 0.1 : 0;
    let settingNameBonus = (rank.settingName.score > 0.8) ? 0.2 : 0;
    let perfectSettingNameBonus = (rank.settingName.score === 1) ? 0.3 : 0;
    let settingItemBonus = (rank.settingItem.score > 0.8) ? 0.2 : 0;
    let perfectSettingItemBonus = (rank.settingItem.score === 1) ? 0.1 : 0;

    let totalScore =
      rank.title.score + titleBonus + perfectTitleBonus
      + rank.description.score + descriptionBonus + perfectDescriptionBonus
      + rank.settingName.score + settingNameBonus + perfectSettingNameBonus
      + rank.settingItem.score + settingItemBonus + perfectSettingItemBonus;

    rank.totalScore = totalScore;

    return rank;
  }

  processRanks (ranks) {
    // Gets an array of schemas with ranks included

    // Removes any scores below a specific limit
    let filteredRanks = ranks.filter(item => item.rank.totalScore > atom.config.get("settings-view.searchSettingsMinimumScore"));

    // Sorts the array from highest score to lowest score
    filteredRanks.sort((a, b) => {
      if (a.rank.totalScore < b.rank.totalScore) {
        return 1;
      }
      if (a.rank.totalScore > b.rank.totalScore) {
        return -1;
      }
      return 0;
    });

    // Remove our loading symbol
    this.refs.loadingArea.style.display = 'none'

    for (const setting of filteredRanks) {
      let searchView = new SearchSettingView(setting, this.settingsView)
      this.refs.searchResults.appendChild(searchView.element)
      this.searchResults.push(searchView)
    }

  }

  getScore (s1, s2) {
    // s1 is the text we are calculating the score against
    // s2 is the text the user typed
    // Below is an exact implmentation of Longest Common Subsequence

    let height = s1.length + 1;
    let width = s2.length + 1;
    let matrix = Array(height)
      .fill(0)
      .map(() => Array(width).fill(0));

    for (let row = 1; row < height; row++) {
      for (let col = 1; col < width; col++) {
        if (s1[row - 1] == s2[col - 1]) {
          matrix[row][col] = matrix[row - 1][col - 1] + 1;
        } else {
          matrix[row][col] = Math.max(matrix[row][col - 1], matrix[row - 1][col]);
        }
      }
    }

    let longest = this.lcsTraceback(matrix, s1, s2, height, width);
    // Now longest is a literal string of the longest common subsequence.
    // We will now assign a score to help ranking, but will still return the
    // text sequence, in case we want to use that for display purposes
    return {
      score: longest.length / s1.length,
      sequence: longest
    };
  }

  lcsTraceback (matrix, s1, s2, height, width) {
    if (height === 0 || width === 0) {
      return "";
    }
    if (s1[height - 1] == s2[width - 1]) {
      return (
        this.lcsTraceback(matrix, s1, s2, height - 1, width - 1) +
          (s1[height - 1] ? s1[height - 1] : "")
      );
    }
    if (matrix[height][width - 1] > matrix[height - 1][width]) {
      return this.lcsTraceback(matrix, s1, s2, height, width - 1);
    }
    return this.lcsTraceback(matrix, s1, s2, height - 1, width);
  }

  // Boiler Plate Functions
  scrollUp () {
    this.element.scrollTop -= document.body.offsetHeight / 20
  }

  scrollDown () {
    this.element.scrollTop += document.body.offsetHeight / 20
  }

  pageUp () {
    this.element.scrollTop -= this.element.offsetHeight
  }

  pageDown () {
    this.element.scrollTop += this.element.offsetHeight
  }

  scrollToTop () {
    this.element.scrollTop = 0
  }

  scrollToBottom () {
    this.element.scrollTop = this.element.scrollHeight
  }
}

================
File: packages/settings-view/lib/settings-icon-status-view.js
================
/** @babel */

import {Disposable, CompositeDisposable} from 'atom'

export default class SettingsIconStatusView {
  constructor(statusBar) {
    this.statusBar = statusBar
    this.disposables = new CompositeDisposable()

    this.element = document.createElement('div')
    this.element.classList.add('settings-icon', 'inline-block')

    const iconPackage = document.createElement('span')
    iconPackage.classList.add('icon', 'icon-gear', 'is-icon-only')
    this.element.appendChild(iconPackage)

    const clickHandler = () => {
      atom.workspace.open("atom://config")
    }
    this.element.addEventListener('click', clickHandler)
    this.disposables.add(new Disposable(() => { this.element.removeEventListener('click', clickHandler) }))

  }

  attach () {
    this.tile = this.statusBar.addRightTile({
      item: this,
      priority: -99
    })
  }

  destroy () {
    this.disposables.dispose()
    this.element.remove()
    if (this.tile) {
      this.tile.destroy()
      this.tile = null
    }
  }
}

================
File: packages/settings-view/lib/settings-panel.js
================
/** @babel */

import {CompositeDisposable, Disposable, TextEditor} from 'atom'
import _ from 'underscore-plus'
import CollapsibleSectionPanel from './collapsible-section-panel'
import {getSettingDescription} from './rich-description'
import {getSettingTitle} from './rich-title'

const SCOPED_SETTINGS = [
  'autoIndent',
  'autoIndentOnPaste',
  'invisibles',
  'nonWordCharacters',
  'preferredLineLength',
  'scrollPastEnd',
  'showIndentGuide',
  'showInvisibles',
  'softWrap',
  'softWrapAtPreferredLineLength',
  'softWrapHangingIndent',
  'tabLength',
  'tabType'
]


export default class SettingsPanel extends CollapsibleSectionPanel {
  constructor (options = {}) {
    super()
    let namespace = options.namespace
    this.element = document.createElement('section')
    this.element.classList.add('section', 'settings-panel')
    this.options = options
    this.disposables = new CompositeDisposable()
    let settings
    if (this.options.scopeName) {
      namespace = 'editor'
      settings = {}
      for (const name of SCOPED_SETTINGS) {
        settings[name] = getWithoutProjectOverride(name, {scope: [this.options.scopeName]})
      }
    } else {
      settings = getWithoutProjectOverride(namespace)
    }

    this.element.appendChild(this.elementForSettings(namespace, settings))

    this.disposables.add(this.bindInputFields())
    this.disposables.add(this.bindSelectFields())
    this.disposables.add(this.bindEditors())
    this.disposables.add(this.bindTooltips())
    this.disposables.add(this.handleEvents())
  }

  destroy () {
    this.disposables.dispose()
    this.element.remove()
  }

  updateOverrideMessage (name) {
    let hasOverride = settingHasProjectOverride(name)
    let message = this.element.querySelector(`div.setting-override-warning[data-setting-key="${name}"]`)
    if (!message) return
    message.style.display = hasOverride ? 'block' : 'none'
  }

  elementForSettings (namespace, settings) {
    if (_.isEmpty(settings)) {
      return document.createDocumentFragment()
    }

    let {title} = this.options
    const includeTitle = this.options.includeTitle != null ? this.options.includeTitle : true
    if (includeTitle) {
      if (title == null) {
        title = `${_.undasherize(_.uncamelcase(namespace))} Settings`
      }
    } else {
      if (title == null) {
        title = 'Settings'
      }
    }

    const icon = this.options.icon != null ? this.options.icon : 'gear'
    const {note} = this.options
    const sortedSettings = this.sortSettings(namespace, settings)

    const container = document.createElement('div')
    container.classList.add('section-container')

    const heading = document.createElement('div')
    heading.classList.add('block', 'section-heading', 'icon', `icon-${icon}`)
    heading.textContent = title
    container.appendChild(heading)

    if (note) {
      container.insertAdjacentHTML('beforeend', note)
    }

    const body = document.createElement('div')
    body.classList.add('section-body')
    for (const name of sortedSettings) {
      body.appendChild(elementForSetting(namespace, name, settings[name]))
    }
    container.appendChild(body)

    return container
  }

  sortSettings (namespace, settings) {
    return sortSettings(namespace, settings)
  }

  bindInputFields () {
    const disposables = Array.from(this.element.querySelectorAll('input[id]')).map((input) => {
      let type = input.type
      let name = type === 'radio' ? input.name : input.id

      this.observe(name, (value) => {
        this.updateOverrideMessage(name)
        if (type === 'checkbox') {
          input.checked = value
        } else if (type === 'radio') {
          input.checked = (value === this.parseValue(atom.config.getSchema(name).type, input.value))
        } else {
          if (type === 'color') {
            if (value && value.toHexString && value.toHexString()) {
              value = value.toHexString()
            }
          }

          if (value) {
            input.value = value
          }
        }
      })

      const changeHandler = () => {
        let value = input.value
        if (type === 'checkbox') {
          value = input.checked
        } else if (type === 'radio') {
          value = this.parseValue(atom.config.getSchema(name).type, value)
        } else {
          value = this.parseValue(type, value)
        }

        if (type === 'color') {
          // This is debounced since the color wheel fires lots of events
          // as you are dragging it around
          clearTimeout(this.colorDebounceTimeout)
          this.colorDebounceTimeout = setTimeout(() => { this.set(name, value) }, 100)
        } else {
          this.set(name, value)
        }
      }

      input.addEventListener('change', changeHandler)
      return new Disposable(() => input.removeEventListener('change', changeHandler))
    })

    return new CompositeDisposable(...disposables)
  }

  observe (name, callback) {
    let params = {sources: [atom.config.getUserConfigPath()]}
    if (atom.config.projectFile) {
      params.excludeSources = [atom.config.projectFile]
    }
    if (this.options.scopeName != null) {
      params.scope = [this.options.scopeName]
    }

    // We need to be sure that project-specific config overrides are never
    // reflected in the settings panel. We use `observe` to hook into any
    // possible changes to our value, but we double-check it by looking up the
    // value ourselves.
    let wrappedCallback = (nv) => {
      let params = {}
      if (this.options.scopeName != null) {
        params.scope = [this.options.scopeName]
      }
      callback(getWithoutProjectOverride(name, params))
    }

    this.disposables.add(atom.config.observe(name, params, wrappedCallback))
  }

  isDefault (name) {
    let params = {sources: [atom.config.getUserConfigPath()]}
    if (this.options.scopeName != null) {
      params.scope = [this.options.scopeName]
    }
    let defaultValue = this.getDefault(name)
    let value = atom.config.get(name, params)
    return (value == null) || (defaultValue === value)
  }

  getDefault (name) {
    let params = {excludeSources: [atom.config.getUserConfigPath()]}
    if (this.options.scopeName != null) {
      params.scope = [this.options.scopeName]
    }

    let defaultValue = atom.config.get(name, params)
    if (this.options.scopeName != null) {
      // If the unscoped default is the same as the scoped default, check the actual config.cson
      // to make sure that there isn't a non-default value that is overriding the scoped value
      // For example: the default editor.tabLength is 2, but if someone sets it to 4
      // the above check still returns 2 and not 4 for a scoped editor.tabLength,
      // because it bypasses config.cson.
      if (atom.config.get(name, {excludeSources: [atom.config.getUserConfigPath()]}) === defaultValue) {
        defaultValue = atom.config.get(name)
      }
    }
    return defaultValue
  }

  set (name, value) {
    if (this.options.scopeName) {
      if (value === undefined) {
        atom.config.unset(name, {scopeSelector: this.options.scopeName})
        return true
      } else {
        return atom.config.set(name, value, {scopeSelector: this.options.scopeName})
      }
    } else {
      return atom.config.set(name, value)
    }
  }

  setText (editor, name, type, value) {
    let stringValue
    if (this.isDefault(name)) {
      stringValue = ''
    } else {
      stringValue = this.valueToString(value) || ''
    }

    if (stringValue === editor.getText() || _.isEqual(value, this.parseValue(type, editor.getText()))) {
      return
    }

    editor.setText(stringValue)
    editor.moveToEndOfLine()
  }

  bindSelectFields () {
    const disposables = Array.from(this.element.querySelectorAll('select[id]')).map((select) => {
      const name = select.id
      this.observe(name, value => {
        select.value = value
        this.updateOverrideMessage(name)
      })
      const changeHandler = () => {
        this.set(name, select.value)
      }
      select.addEventListener('change', changeHandler)
      return new Disposable(() => select.removeEventListener('change', changeHandler))
    })

    return new CompositeDisposable(...disposables)
  }

  bindEditors () {
    const disposables = Array.from(this.element.querySelectorAll('atom-text-editor')).map((editorElement) => {
      let editor = editorElement.getModel()
      let name = editorElement.id
      let type = editorElement.getAttribute('type')
      let defaultValue = this.valueToString(this.getDefault(name))

      if (defaultValue != null) {
        editor.setPlaceholderText(`Default: ${defaultValue}`)
      }

      const subscriptions = new CompositeDisposable()

      const focusHandler = () => {
        if (this.isDefault(name)) {
          editor.setText(this.valueToString(this.getDefault(name)) || '')
        }
      }
      editorElement.addEventListener('focus', focusHandler)
      subscriptions.add(new Disposable(() => editorElement.removeEventListener('focus', focusHandler)))

      const blurHandler = () => {
        if (this.isDefault(name)) {
          editor.setText('')
        }
      }
      editorElement.addEventListener('blur', blurHandler)
      subscriptions.add(new Disposable(() => editorElement.removeEventListener('blur', blurHandler)))

      this.observe(name, (value) => {
        this.setText(editor, name, type, value)
        this.updateOverrideMessage(name)
      })

      subscriptions.add(editor.onDidStopChanging(() => {
        const {minimum, maximum} = atom.config.getSchema(name)
        const value = this.parseValue(type, editor.getText())
        if (minimum != null && value < minimum) {
          this.set(name, minimum)
          this.setText(editor, name, type, minimum)
        } else if (maximum != null && value > maximum) {
          this.set(name, maximum)
          this.setText(editor, name, type, maximum)
        } else if (!this.set(name, value)) {
          this.setText(editor, name, type, atom.config.get(name))
        }
      }))

      return subscriptions
    })

    return new CompositeDisposable(...disposables)
  }

  bindTooltips () {
    const disposables = Array.from(this.element.querySelectorAll('input[id], select[id], atom-text-editor[id]')).map((element) => {
      const schema = atom.config.getSchema(element.id)
      let defaultValue = this.valueToString(this.getDefault(element.id))
      if (defaultValue != null) {
        if (schema.enum && _.findWhere(schema.enum, {value: defaultValue})) {
          defaultValue = _.findWhere(schema.enum, {value: defaultValue}).description
        }
        return atom.tooltips.add(element, {
          title: `Default: ${defaultValue}`,
          delay: {show: 100},
          placement: 'auto left'
        })
      } else {
        return new Disposable(() => {}) // no-op
      }
    })

    return new CompositeDisposable(...disposables)
  }

  valueToString (value) {
    if (Array.isArray(value)) {
      if (value.length === 0) {
        return null
      }
      return value.map((val) => val.toString().replace(/,/g, '\\,')).join(', ')
    } else if (value != null) {
      return value.toString()
    } else {
      return null
    }
  }

  parseValue (type, value) {
    if (value === '') {
      return undefined
    } else if (type === 'number') {
      let floatValue = parseFloat(value)
      if (isNaN(floatValue)) {
        return value
      } else {
        return floatValue
      }
    } else if (type === 'integer') {
      let intValue = parseInt(value)
      if (isNaN(intValue)) {
        return value
      } else {
        return intValue
      }
    } else if (type === 'array') {
      let arrayValue = (value || '').split(',')
      arrayValue = arrayValue.reduce((values, val) => {
        const last = values.length - 1
        if (last >= 0 && values[last].endsWith('\\')) {
          values[last] = values[last].replace(/\\$/, ',') + val
        } else {
          values.push(val)
        }
        return values
      }, [])
      return arrayValue.filter((val) => val).map((val) => val.trim())
    } else {
      return value
    }
  }
}

/*
 * Space Pen Helpers
 */

let isEditableArray = function (array) {
  for (let item of array) {
    if (!_.isString(item)) {
      return false
    }
  }
  return true
}

function sortSettings (namespace, settings) {
  return _.chain(settings)
    .keys()
    .sortBy((name) => name)
    .sortBy((name) => {
      const schema = atom.config.getSchema(`${namespace}.${name}`)
      return schema ? schema.order : null
    })
    .value()
}

function getWithoutProjectOverride (name, options = {}) {
  if (atom.config.projectFile) {
    options.excludeSources = [atom.config.projectFile]
  }
  return atom.config.get(name, options)
}

function getWithProjectOverride(name) {
  // Checking `atom.config.projectSettings` lets us skip value coercion and
  // find out whether a given value is defined.
  return _.get(atom.config.projectSettings, name.split('.'))
}

function settingHasProjectOverride (name) {
  return typeof getWithProjectOverride(name) !== 'undefined'
}

function addOverrideWarning (name, element) {
  let div = document.createElement('div')
  div.classList.add('text-warning', 'setting-override-warning')
  div.textContent = `This global setting has been overridden by a project-specific setting. Changing it will affect your global config file, but may not have any effect in this window.`
  div.dataset.settingKey = name

  element.appendChild(div)
  return div
}

function elementForSetting (namespace, name, value) {
  let hasOverride = settingHasProjectOverride(`${namespace}.${name}`)
  if (namespace === 'core') {
    if (name === 'themes') { return document.createDocumentFragment() } // Handled in the Themes panel
    if (name === 'disabledPackages') { return document.createDocumentFragment() } // Handled in the Packages panel
    if (name === 'customFileTypes') { return document.createDocumentFragment() }
    if (name === 'uriHandlerRegistration') { return document.createDocumentFragment() } // Handled in the URI Handler panel
  }

  if (namespace === 'editor') {
    // There's no global default for these, they are defined by language packages
    if (['commentStart', 'commentEnd', 'increaseIndentPattern', 'decreaseIndentPattern', 'foldEndPattern'].includes(name)) {
      return document.createDocumentFragment()
    }
  }

  const controlGroup = document.createElement('div')
  controlGroup.classList.add('control-group')

  const controls = document.createElement('div')
  controls.classList.add('controls')
  controlGroup.appendChild(controls)

  let el = addOverrideWarning(`${namespace}.${name}`, controlGroup)
  el.style.display = hasOverride ? 'block' : 'none'

  let schema = atom.config.getSchema(`${namespace}.${name}`)
  if (schema && schema.enum) {
    controls.appendChild(elementForOptions(namespace, name, value, {radio: schema.radio}))
  } else if (schema && schema.type === 'color') {
    controls.appendChild(elementForColor(namespace, name, value))
  } else if (_.isBoolean(value) || (schema && schema.type === 'boolean')) {
    controls.appendChild(elementForCheckbox(namespace, name, value))
  } else if (_.isArray(value) || (schema && schema.type === 'array')) {
    if (isEditableArray(value)) {
      controls.appendChild(elementForArray(namespace, name, value))
    }
  } else if (_.isObject(value) || (schema && schema.type === 'object')) {
    controls.appendChild(elementForObject(namespace, name, value))
  } else {
    controls.appendChild(elementForEditor(namespace, name, value))
  }

  return controlGroup
}

function elementForOptions (namespace, name, value, {radio = false}) {
  let keyPath = `${namespace}.${name}`
  let schema = atom.config.getSchema(keyPath)
  let options = (schema && schema.enum) ? schema.enum : []

  const fragment = document.createDocumentFragment()

  const label = document.createElement('label')
  label.classList.add('control-label')

  const titleDiv = document.createElement('div')
  titleDiv.classList.add('setting-title')
  titleDiv.textContent = getSettingTitle(keyPath, name)
  label.appendChild(titleDiv)

  const descriptionDiv = document.createElement('div')
  descriptionDiv.classList.add('setting-description')
  descriptionDiv.innerHTML = getSettingDescription(keyPath)
  label.appendChild(descriptionDiv)

  fragment.appendChild(label)
  fragment.appendChild(enumOptions(options, {keyPath, radio}))

  return fragment
}

function elementForCheckbox (namespace, name, value) {
  let keyPath = `${namespace}.${name}`

  const div = document.createElement('div')
  div.classList.add('checkbox')

  const label = document.createElement('label')
  label.for = keyPath

  const input = document.createElement('input')
  input.id = keyPath
  input.type = 'checkbox'
  input.classList.add('input-checkbox')
  label.appendChild(input)

  const titleDiv = document.createElement('div')
  titleDiv.classList.add('setting-title')
  titleDiv.textContent = getSettingTitle(keyPath, name)
  label.appendChild(titleDiv)
  div.appendChild(label)

  const descriptionDiv = document.createElement('div')
  descriptionDiv.classList.add('setting-description')
  descriptionDiv.innerHTML = getSettingDescription(keyPath)
  div.appendChild(descriptionDiv)

  return div
}

function elementForColor (namespace, name, value) {
  let keyPath = `${namespace}.${name}`

  const div = document.createElement('div')
  div.classList.add('color')

  const label = document.createElement('label')
  label.for = keyPath

  const input = document.createElement('input')
  input.id = keyPath
  input.type = 'color'
  label.appendChild(input)

  const titleDiv = document.createElement('div')
  titleDiv.classList.add('setting-title')
  titleDiv.textContent = getSettingTitle(keyPath, name)
  label.appendChild(titleDiv)
  div.appendChild(label)

  const descriptionDiv = document.createElement('div')
  descriptionDiv.classList.add('setting-description')
  descriptionDiv.innerHTML = getSettingDescription(keyPath)
  div.appendChild(descriptionDiv)

  return div
}

function elementForEditor (namespace, name, value) {
  let keyPath = `${namespace}.${name}`
  let type = _.isNumber(value) ? 'number' : 'string'

  const fragment = document.createDocumentFragment()

  const label = document.createElement('label')
  label.classList.add('control-label')

  const titleDiv = document.createElement('div')
  titleDiv.classList.add('setting-title')
  titleDiv.textContent = getSettingTitle(keyPath, name)
  label.appendChild(titleDiv)

  const descriptionDiv = document.createElement('div')
  descriptionDiv.classList.add('setting-description')
  descriptionDiv.innerHTML = getSettingDescription(keyPath)
  label.appendChild(descriptionDiv)
  fragment.appendChild(label)

  const controls = document.createElement('div')
  controls.classList.add('controls')

  const editorContainer = document.createElement('div')
  editorContainer.classList.add('editor-container')

  const editor = new TextEditor({mini: true})
  editor.element.id = keyPath
  editor.element.setAttribute('type', type)
  editorContainer.appendChild(editor.element)
  controls.appendChild(editorContainer)
  fragment.appendChild(controls)

  return fragment
}

function elementForArray (namespace, name, value) {
  let keyPath = `${namespace}.${name}`

  const fragment = document.createDocumentFragment()

  const label = document.createElement('label')
  label.classList.add('control-label')

  const titleDiv = document.createElement('div')
  titleDiv.classList.add('setting-title')
  titleDiv.textContent = getSettingTitle(keyPath, name)
  label.appendChild(titleDiv)

  const descriptionDiv = document.createElement('div')
  descriptionDiv.classList.add('setting-description')
  descriptionDiv.innerHTML = getSettingDescription(keyPath)
  label.appendChild(descriptionDiv)
  fragment.appendChild(label)

  const controls = document.createElement('div')
  controls.classList.add('controls')

  const editorContainer = document.createElement('div')
  editorContainer.classList.add('editor-container')

  const editor = new TextEditor({mini: true})
  editor.element.id = keyPath
  editor.element.setAttribute('type', 'array')
  editorContainer.appendChild(editor.element)
  controls.appendChild(editorContainer)
  fragment.appendChild(controls)

  return fragment
}

function elementForObject (namespace, name, value) {
  if (_.keys(value).length === 0) {
    return document.createDocumentFragment()
  } else {
    let keyPath = `${namespace}.${name}`
    let schema = atom.config.getSchema(keyPath)
    let isCollapsed = schema.collapsed === true

    const section = document.createElement('section')
    section.classList.add('sub-section')
    if (isCollapsed) {
      section.classList.add('collapsed')
    }

    const h3 = document.createElement('h3')
    h3.classList.add('sub-section-heading', 'has-items')
    h3.textContent = getSettingTitle(keyPath, name)
    section.appendChild(h3)

    const descriptionDiv = document.createElement('div')
    descriptionDiv.classList.add('setting-description')
    descriptionDiv.innerHTML = getSettingDescription(keyPath)
    section.appendChild(descriptionDiv)

    const div = document.createElement('div')
    div.classList.add('sub-section-body')
    for (const key of sortSettings(keyPath, value)) {
      div.appendChild(elementForSetting(namespace, `${name}.${key}`, value[key]))
    }
    section.appendChild(div)

    return section
  }
}

function enumOptions (options, {keyPath, radio}) {
  const containerTag = radio ? 'fieldset' : 'select'
  const container = document.createElement(containerTag)
  container.id = keyPath
  const containerClass = radio ? 'input-radio-group' : 'form-control'
  container.classList.add(containerClass)

  const conversion = radio ? optionToRadio : optionToSelect
  const optionElements = options.map(option => conversion(option, keyPath))

  for (const optionElement of optionElements) { container.appendChild(optionElement) }

  return container
}

function optionToRadio (option, keyPath) {
  const button = document.createElement('input')
  const label = document.createElement('label')
  label.classList.add('input-label')
  let value
  let description = ''
  if (option.hasOwnProperty('value')) {
    value = option.value
    description = option.description
  } else {
    value = option
    description = option
  }
  button.classList.add('input-radio')
  button.id = `${keyPath}[${value}]`
  button.name = keyPath
  button.type = 'radio'
  button.value = value
  label.appendChild(button)
  label.appendChild(document.createTextNode(description))
  return label
}

function optionToSelect (option, keyPath) {
  const optionElement = document.createElement('option')
  if (option.hasOwnProperty('value')) {
    optionElement.value = option.value
    optionElement.textContent = option.description
  } else {
    optionElement.value = option
    optionElement.textContent = option
  }
  return optionElement
}

================
File: packages/settings-view/lib/settings-view.js
================
/** @babel */
/** @jsx etch.dom */

import path from 'path'
import etch from 'etch'
import _ from 'underscore-plus'
import {CompositeDisposable, Disposable} from 'atom'

import GeneralPanel from './general-panel'
import EditorPanel from './editor-panel'
import PackageDetailView from './package-detail-view'
import KeybindingsPanel from './keybindings-panel'
import InstallPanel from './install-panel'
import ThemesPanel from './themes-panel'
import InstalledPackagesPanel from './installed-packages-panel'
import UpdatesPanel from './updates-panel'
import UriHandlerPanel from './uri-handler-panel'
import SearchSettingsPanel from './search-settings-panel'

export default class SettingsView {
  constructor ({uri, packageManager, snippetsProvider, activePanel} = {}) {
    this.uri = uri
    this.packageManager = packageManager
    this.snippetsProvider = snippetsProvider
    this.deferredPanel = activePanel
    this.destroyed = false
    this.panelsByName = {}
    this.panelCreateCallbacks = {}

    etch.initialize(this)
    this.disposables = new CompositeDisposable()
    this.disposables.add(atom.commands.add(this.element, {
      'core:move-up': () => { this.scrollUp() },
      'core:move-down': () => { this.scrollDown() },
      'core:page-up': () => { this.pageUp() },
      'core:page-down': () => { this.pageDown() },
      'core:move-to-top': () => { this.scrollToTop() },
      'core:move-to-bottom': () => { this.scrollToBottom() }
    }))

    this.disposables.add(atom.packages.onDidActivateInitialPackages(() => {
      this.disposables.add(
        atom.packages.onDidActivatePackage(pack => this.removePanelCache(pack.name)),
        atom.packages.onDidDeactivatePackage(pack => this.removePanelCache(pack.name))
      )
    }))

    process.nextTick(() => this.initializePanels())
  }

  removePanelCache (name) {
    delete this.panelsByName[name]
  }

  update () {}

  destroy () {
    this.destroyed = true
    this.disposables.dispose()
    for (let name in this.panelsByName) {
      const panel = this.panelsByName[name]
      panel.destroy()
    }

    return etch.destroy(this)
  }

  render () {
    return (
      <div className='settings-view pane-item' tabIndex='-1'>
        <div className='config-menu' ref='sidebar'>
          <ul className='panels-menu nav nav-pills nav-stacked' ref='panelMenu'>
            <div className='panel-menu-separator' ref='menuSeparator' />
          </ul>
          <div className='button-area'>
            <button className='btn btn-default icon icon-link-external' ref='openDotAtom'>Open Config Folder</button>
          </div>
        </div>
        {/* The tabindex attr below ensures that clicks in a panel item won't
        cause this view to gain focus. This is important because when this view
        gains focus (e.g. immediately after atom displays it), it focuses the
        currently active panel item. If that focusing causes the active panel to
        scroll (e.g. because the active panel itself passes focus on to a search
        box at the top of a scrolled panel), then the browser will not fire the
        click event on the element within the panel on which the user originally
        clicked (e.g. a package card). This would prevent us from showing a
        package detail view when clicking on a package card. Phew! */}
        <div className='panels' tabIndex='-1' ref='panels' />
      </div>
    )
  }

  // This prevents the view being actually disposed when closed
  // If you remove it you will need to ensure the cached settingsView
  // in main.coffee is correctly released on close as well...
  onDidChangeTitle () { return new Disposable() }

  initializePanels () {
    if (this.refs.panels.children.length > 1) {
      return
    }

    const clickHandler = (event) => {
      const target = event.target.closest('.panels-menu li a, .panels-packages li a')
      if (target) {
        this.showPanel(target.closest('li').name)
      }
    }
    this.element.addEventListener('click', clickHandler)
    this.disposables.add(new Disposable(() => this.element.removeEventListener('click', clickHandler)))

    const focusHandler = () => {
      this.focusActivePanel()
    }
    this.element.addEventListener('focus', focusHandler)
    this.disposables.add(new Disposable(() => this.element.removeEventListener('focus', focusHandler)))

    const openDotAtomClickHandler = () => {
      atom.open({pathsToOpen: [atom.getConfigDirPath()]})
    }
    this.refs.openDotAtom.addEventListener('click', openDotAtomClickHandler)
    this.disposables.add(new Disposable(() => this.refs.openDotAtom.removeEventListener('click', openDotAtomClickHandler)))

    if (atom.config.get("settings-view.enableSettingsSearch")) {
      this.addCorePanel('Search', 'search', () => new SearchSettingsPanel(this))
    }
    
    this.addCorePanel('Core', 'settings', () => new GeneralPanel())
    this.addCorePanel('Editor', 'code', () => new EditorPanel())
    if (atom.config.getSchema('core.uriHandlerRegistration').type !== 'any') {
      // "feature flag" based on core support for URI handling
      this.addCorePanel('URI Handling', 'link', () => new UriHandlerPanel())
    }
    if ((process.platform === 'win32') && (require('atom').WinShell != null)) {
      const SystemPanel = require('./system-windows-panel')
      this.addCorePanel('System', 'device-desktop', () => new SystemPanel())
    }
    this.addCorePanel('Keybindings', 'keyboard', () => new KeybindingsPanel())
    this.addCorePanel('Packages', 'package', () => new InstalledPackagesPanel(this, this.packageManager))
    this.addCorePanel('Themes', 'paintcan', () => new ThemesPanel(this, this.packageManager))
    this.addCorePanel('Updates', 'cloud-download', () => new UpdatesPanel(this, this.packageManager))
    this.addCorePanel('Install', 'plus', () => new InstallPanel(this, this.packageManager))

    this.showDeferredPanel()

    if (!this.activePanel) {
      this.showPanel('Core')
    }

    if (document.body.contains(this.element)) {
      this.refs.sidebar.style.width = this.refs.sidebar.offsetWidth
    }
  }

  serialize () {
    return {
      deserializer: 'SettingsView',
      version: 2,
      activePanel: this.activePanel != null ? this.activePanel : this.deferredPanel,
      uri: this.uri
    }
  }

  getPackages () {
    let bundledPackageMetadataCache
    if (this.packages != null) { return this.packages }

    this.packages = atom.packages.getLoadedPackages()

    try {
      const packageMetadata = require(path.join(atom.getLoadSettings().resourcePath, 'package.json'))
      bundledPackageMetadataCache = packageMetadata ? packageMetadata._atomPackages : null
    } catch (error) {}

    // Include disabled packages so they can be re-enabled from the UI
    const disabledPackages = atom.config.get('core.disabledPackages') || []
    for (const packageName of disabledPackages) {
      var metadata
      const packagePath = atom.packages.resolvePackagePath(packageName)
      if (!packagePath) {
        continue
      }

      try {
        metadata = require(path.join(packagePath, 'package.json'))
      } catch (error) {
        if (bundledPackageMetadataCache && bundledPackageMetadataCache[packageName]) {
          metadata = bundledPackageMetadataCache[packageName].metadata
        }
      }
      if (metadata == null) {
        continue
      }

      const name = metadata.name != null ? metadata.name : packageName
      if (!_.findWhere(this.packages, {name})) {
        this.packages.push({name, metadata, path: packagePath})
      }
    }

    this.packages.sort((pack1, pack2) => {
      const title1 = this.packageManager.getPackageTitle(pack1)
      const title2 = this.packageManager.getPackageTitle(pack2)
      return title1.localeCompare(title2)
    })

    return this.packages
  }

  addCorePanel (name, iconName, panelCreateCallback) {
    const panelMenuItem = document.createElement('li')
    panelMenuItem.name = name
    panelMenuItem.setAttribute('name', name)

    const a = document.createElement('a')
    a.classList.add('icon', `icon-${iconName}`)
    a.textContent = name
    panelMenuItem.appendChild(a)

    this.refs.menuSeparator.parentElement.insertBefore(panelMenuItem, this.refs.menuSeparator)
    this.addPanel(name, panelCreateCallback)
  }

  addPanel (name, panelCreateCallback) {
    this.panelCreateCallbacks[name] = panelCreateCallback
    if (this.deferredPanel && this.deferredPanel.name === name) {
      this.showDeferredPanel()
    }
  }

  getOrCreatePanel (name, options) {
    let panel = this.panelsByName[name]
    if (panel) return panel

    if (name in this.panelCreateCallbacks) {
      panel = this.panelCreateCallbacks[name]()
      delete this.panelCreateCallbacks[name]
    } else if (options && options.pack) {
      if (!options.pack.metadata) {
        options.pack.metadata = _.clone(options.pack)
      }
      panel = new PackageDetailView(options.pack, this, this.packageManager, this.snippetsProvider)
    }
    if (panel) {
      this.panelsByName[name] = panel
    }

    return panel
  }

  makePanelMenuActive (name) {
    const previouslyActivePanel = this.refs.sidebar.querySelector('.active')
    if (previouslyActivePanel) {
      previouslyActivePanel.classList.remove('active')
    }

    const newActivePanel = this.refs.sidebar.querySelector(`[name='${name}']`)
    if (newActivePanel) {
      newActivePanel.classList.add('active')
    }
  }

  focusActivePanel () {
    // Pass focus to panel that is currently visible
    for (let i = 0; i < this.refs.panels.children.length; i++) {
      const child = this.refs.panels.children[i]
      if (child.offsetWidth > 0) {
        child.focus()
      }
    }
  }

  showDeferredPanel () {
    if (this.deferredPanel) {
      const {name, options} = this.deferredPanel
      this.showPanel(name, options)
    }
  }

  // Public: show a panel.
  //
  // * `name` {String} the name of the panel to show
  // * `options` {Object} an options hash. Will be passed to `beforeShow()` on
  //   the panel. Options may include (but are not limited to):
  //   * `uri` the URI the panel was launched from
  showPanel (name, options) {
    if (this.activePanel) {
      const prev = this.panelsByName[this.activePanel.name]
      if (prev) {
        prev.scrollPosition = prev.element.scrollTop
      }
    }

    const panel = this.getOrCreatePanel(name, options)
    if (panel) {
      this.appendPanel(panel, options)
      this.makePanelMenuActive(name)
      this.setActivePanel(name, options)
      this.deferredPanel = null
    } else {
      this.deferredPanel = {name, options}
    }
  }

  showPanelForURI (uri) {
    const regex = /config\/([a-z]+)\/?([a-zA-Z0-9_-]+)?/i
    const match = regex.exec(uri)

    if (match) {
      const path1 = match[1]
      const path2 = match[2]

      if (path1 === 'packages' && path2 != null) {
        this.showPanel(path2, {
          uri: uri,
          pack: {name: path2},
          back: atom.packages.getLoadedPackage(path2) ? 'Packages' : null
        })
      } else {
        const panelName = path1[0].toUpperCase() + path1.slice(1)
        this.showPanel(panelName, {uri})
      }
    }
  }

  appendPanel (panel, options) {
    for (let i = 0; i < this.refs.panels.children.length; i++) {
      this.refs.panels.children[i].style.display = 'none'
    }

    if (!this.refs.panels.contains(panel.element)) {
      this.refs.panels.appendChild(panel.element)
    }

    if (panel.beforeShow) {
      panel.beforeShow(options)
    }
    panel.show()
    panel.focus()
  }

  setActivePanel (name, options = {}) {
    this.activePanel = {name, options}

    const panel = this.panelsByName[name]
    if (panel && panel.scrollPosition) {
      panel.element.scrollTop = panel.scrollPosition
      delete panel.scrollPosition
    }
  }

  removePanel (name) {
    const panel = this.panelsByName[name]
    if (panel) {
      panel.destroy()
      delete this.panelsByName[name]
    }
  }

  getTitle () {
    return 'Settings'
  }

  getIconName () {
    return 'tools'
  }

  getURI () {
    return this.uri
  }

  isEqual (other) {
    return other instanceof SettingsView
  }

  scrollUp () {
    this.element.scrollTop -= document.body.offsetHeight / 20
  }

  scrollDown () {
    this.element.scrollTop += document.body.offsetHeight / 20
  }

  pageUp () {
    this.element.scrollTop -= this.element.offsetHeight
  }

  pageDown () {
    this.element.scrollTop += this.element.offsetHeight
  }

  scrollToTop () {
    this.element.scrollTop = 0
  }

  scrollToBottom () {
    this.element.scrollTop = this.element.scrollHeight
  }
}

================
File: packages/settings-view/lib/system-windows-panel.js
================
/** @babel */
/** @jsx etch.dom */

import {WinShell, CompositeDisposable} from 'atom'
import etch from 'etch'

export default class SystemPanel {
  constructor () {
    etch.initialize(this)
    this.subscriptions = new CompositeDisposable()
    this.subscriptions.add(atom.commands.add(this.element, {
      'core:move-up': () => { this.scrollUp() },
      'core:move-down': () => { this.scrollDown() },
      'core:page-up': () => { this.pageUp() },
      'core:page-down': () => { this.pageDown() },
      'core:move-to-top': () => { this.scrollToTop() },
      'core:move-to-bottom': () => { this.scrollToBottom() }
    }))

    WinShell.fileHandler.isRegistered((i) => { this.refs.fileHandlerCheckbox.checked = i })
    WinShell.fileContextMenu.isRegistered((i) => { this.refs.fileContextMenuCheckbox.checked = i })
    WinShell.folderContextMenu.isRegistered((i) => { this.refs.folderContextMenuCheckbox.checked = i })
  }

  destroy () {
    this.subscriptions.dispose()
    return etch.destroy(this)
  }

  update () {}

  render () {
    return (
      <div className='panels-item' tabIndex='0'>
        <form className='general-panel section'>
          <div className='settings-panel'>
            <div className='section-container'>
              <div className='block section-heading icon icon-device-desktop'>System Settings</div>
              <div className='text icon icon-question'>These settings determine how Pulsar integrates with your operating system.</div>
              <div className='section-body'>
                <div className='control-group'>
                  <div className='controls'>
                    <div className='checkbox'>
                      <label for='system.windows.file-handler'>
                        <input
                          ref='fileHandlerCheckbox'
                          id='system.windows.file-handler'
                          className='input-checkbox'
                          type='checkbox'
                          onclick={(e) => { this.setRegistration(WinShell.fileHandler, e.target.checked) }} />
                        <div className='setting-title'>Register as file handler</div>
                        <div className='setting-description'>
                          Show {WinShell.appName} in the "Open with" application list for easy association with file types.
                        </div>
                      </label>
                    </div>
                  </div>
                </div>
                <div className='control-group'>
                  <div className='controls'>
                    <div className='checkbox'>
                      <label for='system.windows.shell-menu-files'>
                        <input
                          ref='fileContextMenuCheckbox'
                          id='system.windows.shell-menu-files'
                          className='input-checkbox'
                          type='checkbox'
                          onclick={(e) => { this.setRegistration(WinShell.fileContextMenu, e.target.checked) }} />
                        <div className='setting-title'>Show in file context menus</div>
                        <div className='setting-description'>
                          Add "Open with {WinShell.appName}" to the File Explorer context menu for files.
                        </div>
                      </label>
                    </div>
                  </div>
                </div>
                <div className='control-group'>
                  <div className='controls'>
                    <div className='checkbox'>
                      <label for='system.windows.shell-menu-folders'>
                        <input
                          ref='folderContextMenuCheckbox'
                          id='system.windows.shell-menu-folders'
                          className='input-checkbox'
                          type='checkbox'
                          onclick={(e) => {
                            this.setRegistration(WinShell.folderContextMenu, e.target.checked)
                            this.setRegistration(WinShell.folderBackgroundContextMenu, e.target.checked)
                          }} />
                        <div className='setting-title'>Show in folder context menus</div>
                        <div className='setting-description'>
                          Add "Open with {WinShell.appName}" to the File Explorer context menu for folders.
                        </div>
                      </label>
                    </div>
                  </div>
                </div>
                { this.getPathUI() }
              </div>
            </div>
          </div>
        </form>
      </div>
    )
  }

  setRegistration (option, shouldBeRegistered) {
    if (shouldBeRegistered) {
      return option.register(function () {})
    } else {
      return option.deregister(function () {})
    }
  }

  getPathUI() {
    // TODO: This section is no longer useful. Should be removed a few versions
    // after v1.120.0 to allow users to be informed.
    return (
      <div className='control-group'>
        <div className='controls'>
          <div className='checkbox'>
            <label for='system.windows.add-to-path'>
              <div className='setting-title'>Add Pulsar to PATH</div>
              <div className='setting-description'>
                Settings for adding Pulsar to the PATH have now been exclusively moved to the Pulsar windows installer.
                If you'd like to change your PATH addition options please rerun your original, or a new installer.
              </div>
            </label>
          </div>
        </div>
      </div>
    );
  }

  focus () {
    this.element.focus()
  }

  show () {
    this.element.style.display = ''
  }

  scrollUp () {
    this.element.scrollTop -= document.body.offsetHeight / 20
  }

  scrollDown () {
    this.element.scrollTop += document.body.offsetHeight / 20
  }

  pageUp () {
    this.element.scrollTop -= this.element.offsetHeight
  }

  pageDown () {
    this.element.scrollTop += this.element.offsetHeight
  }

  scrollToTop () {
    this.element.scrollTop = 0
  }

  scrollToBottom () {
    this.element.scrollTop = this.element.scrollHeight
  }
}

================
File: packages/settings-view/lib/themes-panel.js
================
/** @babel */
/** @jsx etch.dom */

import etch from 'etch'
import _ from 'underscore-plus'
import {CompositeDisposable, TextEditor} from 'atom'

import CollapsibleSectionPanel from './collapsible-section-panel'
import PackageCard from './package-card'
import ErrorView from './error-view'

import List from './list'
import ListView from './list-view'
import {ownerFromRepository, packageComparatorAscending} from './utils'

export default class ThemesPanel extends CollapsibleSectionPanel {
  static loadPackagesDelay () {
    return 300
  }

  constructor (settingsView, packageManager) {
    super()

    this.settingsView = settingsView
    this.packageManager = packageManager
    etch.initialize(this)
    this.items = {
      dev: new List('name'),
      core: new List('name'),
      user: new List('name'),
      git: new List('name')
    }
    this.itemViews = {
      dev: new ListView(this.items.dev, this.refs.devPackages, this.createPackageCard.bind(this)),
      core: new ListView(this.items.core, this.refs.corePackages, this.createPackageCard.bind(this)),
      user: new ListView(this.items.user, this.refs.communityPackages, this.createPackageCard.bind(this)),
      git: new ListView(this.items.git, this.refs.gitPackages, this.createPackageCard.bind(this))
    }

    this.disposables = new CompositeDisposable()
    this.disposables.add(
      this.packageManager.on('theme-install-failed theme-uninstall-failed', ({pack, error}) => {
        this.refs.themeErrors.appendChild(new ErrorView(this.packageManager, error).element)
      })
    )
    this.disposables.add(this.handleEvents())
    this.disposables.add(atom.commands.add(this.element, {
      'core:move-up': () => { this.scrollUp() },
      'core:move-down': () => { this.scrollDown() },
      'core:page-up': () => { this.pageUp() },
      'core:page-down': () => { this.pageDown() },
      'core:move-to-top': () => { this.scrollToTop() },
      'core:move-to-bottom': () => { this.scrollToBottom() }
    }))
    this.loadPackages()

    this.disposables.add(
      this.packageManager.on('theme-installed theme-uninstalled', () => {
        let loadPackagesTimeout
        clearTimeout(loadPackagesTimeout)
        loadPackagesTimeout = setTimeout(() => {
          this.populateThemeMenus()
          this.loadPackages()
        }, ThemesPanel.loadPackagesDelay())
      })
    )

    this.disposables.add(atom.themes.onDidChangeActiveThemes(() => this.updateActiveThemes()))
    this.disposables.add(atom.tooltips.add(this.refs.activeUiThemeSettings, {title: 'Settings'}))
    this.disposables.add(atom.tooltips.add(this.refs.activeSyntaxThemeSettings, {title: 'Settings'}))
    this.updateActiveThemes()

    this.disposables.add(this.refs.filterEditor.onDidStopChanging(() => { this.matchPackages() }))
  }

  update () {}

  focus () {
    this.refs.filterEditor.element.focus()
  }

  show () {
    this.element.style.display = ''
  }

  destroy () {
    this.disposables.dispose()
    return etch.destroy(this)
  }

  render () {
    return (
      <div className='panels-item' tabIndex='-1'>
        <div className='section packages themes-panel'>
          <div className='section-container'>
            <div className='section-heading icon icon-paintcan'>Choose a Theme</div>

            <div className='text native-key-bindings' tabIndex='-1'>
              <span className='icon icon-question'>You can also style Pulsar by editing </span>
              <a className='link' onclick={this.didClickOpenUserStyleSheet}>your stylesheet</a>
            </div>

            <div className='themes-picker'>
              <div className='themes-picker-item control-group'>
                <div className='controls'>
                  <label className='control-label'>
                    <div className='setting-title themes-label text'>UI Theme</div>
                    <div className='setting-description text theme-description'>This styles the tabs, status bar, tree view, and dropdowns</div>
                  </label>
                  <div className='select-container'>
                    <select ref='uiMenu' className='form-control' onchange={this.didChangeUiMenu.bind(this)} />
                    <button
                      ref='activeUiThemeSettings'
                      className='btn icon icon-gear active-theme-settings'
                      onclick={this.didClickActiveUiThemeSettings.bind(this)} />
                  </div>
                </div>
              </div>

              <div className='themes-picker-item control-group'>
                <div className='controls'>
                  <label className='control-label'>
                    <div className='setting-title themes-label text'>Syntax Theme</div>
                    <div className='setting-description text theme-description'>This styles the text inside the editor</div>
                  </label>
                  <div className='select-container'>
                    <select ref='syntaxMenu' className='form-control' onchange={this.didChangeSyntaxMenu.bind(this)} />
                    <button
                      ref='activeSyntaxThemeSettings'
                      className='btn icon icon-gear active-syntax-settings'
                      onclick={this.didClickActiveSyntaxThemeSettings.bind(this)} />
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <section className='section'>
          <div className='section-container'>
            <div className='section-heading icon icon-paintcan'>
              Installed Themes
              <span ref='totalPackages' className='section-heading-count badge badge-flexible'>…</span>
            </div>
            <div className='editor-container'>
              <TextEditor ref='filterEditor' mini placeholderText='Filter themes by name' />
            </div>

            <div ref='themeErrors' />

            <section className='sub-section installed-packages'>
              <h3 ref='communityThemesHeader' className='sub-section-heading icon icon-paintcan'>
                Community Themes
                <span ref='communityCount' className='section-heading-count badge badge-flexible'>…</span>
              </h3>
              <div ref='communityPackages' className='container package-container'>
                <div ref='communityLoadingArea' className='alert alert-info loading-area icon icon-hourglass'>Loading themes…</div>
              </div>
            </section>

            <section className='sub-section core-packages'>
              <h3 ref='coreThemesHeader' className='sub-section-heading icon icon-paintcan'>
                Core Themes
                <span ref='coreCount' className='section-heading-count badge badge-flexible'>…</span>
              </h3>
              <div ref='corePackages' className='container package-container'>
                <div ref='coreLoadingArea' className='alert alert-info loading-area icon icon-hourglass'>Loading themes…</div>
              </div>
            </section>

            <section className='sub-section dev-packages'>
              <h3 ref='developmentThemesHeader' className='sub-section-heading icon icon-paintcan'>
                Development Themes
                <span ref='devCount' className='section-heading-count badge badge-flexible'>…</span>
              </h3>
              <div ref='devPackages' className='container package-container'>
                <div ref='devLoadingArea' className='alert alert-info loading-area icon icon-hourglass'>Loading themes…</div>
              </div>
            </section>

            <section className='sub-section git-packages'>
              <h3 ref='gitThemesHeader' className='sub-section-heading icon icon-paintcan'>
                Git Themes
                <span ref='gitCount' className='section-heading-count badge badge-flexible'>…</span>
              </h3>
              <div ref='gitPackages' className='container package-container'>
                <div ref='gitLoadingArea' className='alert alert-info loading-area icon icon-hourglass'>Loading themes…</div>
              </div>
            </section>
          </div>
        </section>
      </div>
    )
  }

  filterThemes (packages) {
    packages.dev = packages.dev.filter(({theme}) => theme)
    packages.user = packages.user.filter(({theme}) => theme)
    packages.core = packages.core.filter(({theme}) => theme)
    packages.git = (packages.git || []).filter(({theme}) => theme)

    for (let packageType of ['dev', 'core', 'user', 'git']) {
      for (let pack of packages[packageType]) {
        pack.owner = ownerFromRepository(pack.repository)
      }
    }
    return packages
  }

  sortThemes (packages) {
    packages.dev.sort(packageComparatorAscending)
    packages.core.sort(packageComparatorAscending)
    packages.user.sort(packageComparatorAscending)
    packages.git.sort(packageComparatorAscending)
    return packages
  }

  loadPackages () {
    this.packageViews = []
    this.packageManager.getInstalled().then(packages => {
      this.packages = this.sortThemes(this.filterThemes(packages))

      this.refs.devLoadingArea.remove()
      this.items.dev.setItems(this.packages.dev)

      this.refs.coreLoadingArea.remove()
      this.items.core.setItems(this.packages.core)

      this.refs.communityLoadingArea.remove()
      this.items.user.setItems(this.packages.user)

      this.refs.gitLoadingArea.remove()
      this.items.git.setItems(this.packages.git)

      // TODO show empty mesage per section

      this.updateSectionCounts()
    }).catch((error) => {
      this.refs.themeErrors.appendChild(new ErrorView(this.packageManager, error).element)
    })
  }

  // Update the active UI and syntax themes and populate the menu
  updateActiveThemes () {
    this.activeUiTheme = this.getActiveUiTheme()
    this.activeSyntaxTheme = this.getActiveSyntaxTheme()
    this.populateThemeMenus()
    this.toggleActiveThemeButtons()
  }

  toggleActiveThemeButtons () {
    if (this.hasSettings(this.activeUiTheme)) {
      this.refs.activeUiThemeSettings.style.display = ''
    } else {
      this.refs.activeUiThemeSettings.style.display = 'none'
    }

    if (this.hasSettings(this.activeSyntaxTheme)) {
      this.refs.activeSyntaxThemeSettings.display = ''
    } else {
      this.refs.activeSyntaxThemeSettings.display = 'none'
    }
  }

  hasSettings (packageName) {
    return this.packageManager.packageHasSettings(packageName)
  }

  // Populate the theme menus from the theme manager's active themes
  populateThemeMenus () {
    this.refs.uiMenu.innerHTML = ''
    this.refs.syntaxMenu.innerHTML = ''
    const availableThemes = _.sortBy(atom.themes.getLoadedThemes(), 'name')
    for (let {name, metadata} of availableThemes) {
      switch (metadata.theme) {
        case 'ui': {
          const themeItem = this.createThemeMenuItem(name)
          if (name === this.activeUiTheme) {
            themeItem.selected = true
          }
          this.refs.uiMenu.appendChild(themeItem)
          break
        }
        case 'syntax': {
          const themeItem = this.createThemeMenuItem(name)
          if (name === this.activeSyntaxTheme) {
            themeItem.selected = true
          }
          this.refs.syntaxMenu.appendChild(themeItem)
          break
        }
      }
    }
  }

  // Get the name of the active ui theme.
  getActiveUiTheme () {
    for (let {name, metadata} of atom.themes.getActiveThemes()) {
      if (metadata.theme === 'ui') {
        return name
      }
    }
    return null
  }

  // Get the name of the active syntax theme.
  getActiveSyntaxTheme () {
    for (let {name, metadata} of atom.themes.getActiveThemes()) {
      if (metadata.theme === 'syntax') { return name }
    }
    return null
  }

  // Update the config with the selected themes
  updateThemeConfig () {
    const themes = []
    if (this.activeUiTheme) {
      themes.push(this.activeUiTheme)
    }
    if (this.activeSyntaxTheme) {
      themes.push(this.activeSyntaxTheme)
    }
    if (themes.length > 0) {
      atom.config.set('core.themes', themes)
    }
  }

  scheduleUpdateThemeConfig () {
    setTimeout(() => { this.updateThemeConfig() }, 100)
  }

  // Create a menu item for the given theme name.
  createThemeMenuItem (themeName) {
    const title = _.undasherize(_.uncamelcase(themeName.replace(/-(ui|syntax)/g, '').replace(/-theme$/g, '')))
    const option = document.createElement('option')
    option.value = themeName
    option.textContent = title
    return option
  }

  createPackageCard (pack) {
    return new PackageCard(pack, this.settingsView, this.packageManager, {back: 'Themes'})
  }

  filterPackageListByText (text) {
    if (!this.packages) {
      return
    }

    for (let packageType of ['dev', 'core', 'user', 'git']) {
      const allViews = this.itemViews[packageType].getViews()
      const activeViews = this.itemViews[packageType].filterViews((pack) => {
        if (text === '') {
          return true
        } else {
          const owner = pack.owner != null ? pack.owner : ownerFromRepository(pack.repository)
          const filterText = `${pack.name} ${owner}`
          return atom.ui.fuzzyMatcher.score(filterText, text) > 0
        }
      })

      for (const view of allViews) {
        if (view) {
          view.element.style.display = 'none'
          view.element.classList.add('hidden')
        }
      }

      for (const view of activeViews) {
        if (view) {
          view.element.style.display = ''
          view.element.classList.remove('hidden')
        }
      }
    }

    this.updateSectionCounts()
  }

  updateUnfilteredSectionCounts () {
    this.updateSectionCount(this.refs.communityThemesHeader, this.refs.communityCount, this.packages.user.length)
    this.updateSectionCount(this.refs.coreThemesHeader, this.refs.coreCount, this.packages.core.length)
    this.updateSectionCount(this.refs.developmentThemesHeader, this.refs.devCount, this.packages.dev.length)
    this.updateSectionCount(this.refs.gitThemesHeader, this.refs.gitCount, this.packages.git.length)

    this.refs.totalPackages.textContent = `${this.packages.user.length + this.packages.core.length + this.packages.dev.length + this.packages.git.length}`
  }

  updateFilteredSectionCounts () {
    const community = this.notHiddenCardsLength(this.refs.communityPackages)
    this.updateSectionCount(this.refs.communityThemesHeader, this.refs.communityCount, community, this.packages.user.length)

    const dev = this.notHiddenCardsLength(this.refs.devPackages)
    this.updateSectionCount(this.refs.developmentThemesHeader, this.refs.devCount, dev, this.packages.dev.length)

    const core = this.notHiddenCardsLength(this.refs.corePackages)
    this.updateSectionCount(this.refs.coreThemesHeader, this.refs.coreCount, core, this.packages.core.length)

    const git = this.notHiddenCardsLength(this.refs.gitPackages)
    this.updateSectionCount(this.refs.gitThemesHeader, this.refs.gitCount, git, this.packages.git.length)

    const shownThemes = dev + core + community + git
    const totalThemes = this.packages.user.length + this.packages.core.length + this.packages.dev.length + this.packages.git.length
    this.refs.totalPackages.textContent = `${shownThemes}/${totalThemes}`
  }

  resetSectionHasItems () {
    this.resetCollapsibleSections([this.refs.communityThemesHeader, this.refs.coreThemesHeader, this.refs.developmentThemesHeader, this.refs.gitThemesHeader])
  }

  matchPackages () {
    this.filterPackageListByText(this.refs.filterEditor.getText())
  }

  didClickOpenUserStyleSheet (e) {
    e.preventDefault()
    atom.commands.dispatch(atom.views.getView(atom.workspace), 'application:open-your-stylesheet')
  }

  didChangeUiMenu () {
    this.activeUiTheme = this.refs.uiMenu.value
    this.scheduleUpdateThemeConfig()
  }

  didChangeSyntaxMenu () {
    this.activeSyntaxTheme = this.refs.syntaxMenu.value
    this.scheduleUpdateThemeConfig()
  }

  didClickActiveUiThemeSettings (event) {
    event.stopPropagation()
    const theme = atom.themes.getActiveThemes().find((theme) => theme.metadata.theme === 'ui')
    const activeUiTheme = theme != null ? theme.metadata : null
    if (activeUiTheme != null) {
      this.settingsView.showPanel(this.activeUiTheme, {
        back: 'Themes',
        pack: activeUiTheme
      })
    }
  }

  didClickActiveSyntaxThemeSettings (event) {
    event.stopPropagation()
    const theme = atom.themes.getActiveThemes().find((theme) => theme.metadata.theme === 'syntax')
    const activeSyntaxTheme = theme != null ? theme.metadata : null
    if (activeSyntaxTheme != null) {
      this.settingsView.showPanel(this.activeSyntaxTheme, {
        back: 'Themes',
        pack: activeSyntaxTheme
      })
    }
  }

  scrollUp () {
    this.element.scrollTop -= document.body.offsetHeight / 20
  }

  scrollDown () {
    this.element.scrollTop += document.body.offsetHeight / 20
  }

  pageUp () {
    this.element.scrollTop -= this.element.offsetHeight
  }

  pageDown () {
    this.element.scrollTop += this.element.offsetHeight
  }

  scrollToTop () {
    this.element.scrollTop = 0
  }

  scrollToBottom () {
    this.element.scrollTop = this.element.scrollHeight
  }
}

================
File: packages/settings-view/lib/updates-panel.js
================
/** @babel */
/** @jsx etch.dom */

import {CompositeDisposable} from 'atom'
import asyncQueue from 'async/queue'
import etch from 'etch'

import ErrorView from './error-view'
import PackageCard from './package-card'

export default class UpdatesPanel {
  constructor (settingsView, packageManager) {
    this.settingsView = settingsView
    this.packageManager = packageManager
    this.disposables = new CompositeDisposable()
    this.updatingPackages = []
    this.packageCards = []

    etch.initialize(this)

    this.refs.updateAllButton.style.display = 'none'
    this.checkForUpdates()

    this.disposables.add(atom.commands.add(this.element, {
      'core:move-up': () => { this.scrollUp() },
      'core:move-down': () => { this.scrollDown() },
      'core:page-up': () => { this.pageUp() },
      'core:page-down': () => { this.pageDown() },
      'core:move-to-top': () => { this.scrollToTop() },
      'core:move-to-bottom': () => { this.scrollToBottom() }
    }))

    this.disposables.add(this.packageManager.on('package-updating theme-updating', ({pack, error}) => {
      this.refs.checkButton.disabled = true
      this.updatingPackages.push(pack)
    }))

    this.disposables.add(
      this.packageManager.on('package-updated theme-updated package-update-failed theme-update-failed', ({pack, error}) => {
        if (error != null) {
          this.refs.updateErrors.appendChild(new ErrorView(this.packageManager, error).element)
        }

        for (let i = 0; i < this.updatingPackages.length; i++) {
          const update = this.updatingPackages[i]
          if (update.name === pack.name) {
            this.updatingPackages.splice(i, 1)
          }
        }

        if (!this.updatingPackages.length) {
          this.refs.checkButton.disabled = false
        }
      })
    )
  }

  destroy () {
    this.clearPackageCards()
    this.disposables.dispose()
    return etch.destroy(this)
  }

  update () {}

  render () {
    return (
      <div tabIndex='0' className='panels-item'>
        <section className='section packages'>
          <div className='section-container updates-container'>
            <div className='updates-heading-container'>
              <h1 className='section-heading icon icon-cloud-download'>Available Updates</h1>
              <div className='section-heading updates-btn-group'>
                <button
                  ref='checkButton'
                  className='update-all-button btn'
                  onclick={() => { this.checkForUpdates(true) }}>Check for Updates</button>
                <button
                  ref='updateAllButton'
                  className='update-all-button btn btn-primary'
                  onclick={() => { this.updateAll() }}>Update All</button>
              </div>
            </div>

            <div ref='versionPinnedPackagesMessage' className='alert alert-warning icon icon-alert'>The following packages are pinned to their current version and are not being checked for updates: <strong>{ this.packageManager.getVersionPinnedPackages().join(', ') }</strong></div>
            <div ref='updateErrors' />
            <div ref='checkingMessage' className='alert alert-info icon icon-hourglass'>{`Checking for updates\u2026`}</div>
            <div ref='noUpdatesMessage' className='alert alert-info icon icon-heart'>All of your installed packages are up to date!</div>
            <div ref='updatesContainer' className='container package-container' />
          </div>
        </section>
      </div>
    )
  }

  focus () {
    this.element.focus()
  }

  show () {
    this.element.style.display = ''
  }

  beforeShow (opts) {
    if (opts && opts.back) {
      this.refs.breadcrumb.textContent = opts.back
      this.refs.breadcrumb.onclick = () => { this.settingsView.showPanel(opts.back) }
    }

    if (opts && opts.updates) {
      this.availableUpdates = opts.updates
      this.addUpdateViews()
    } else {
      this.availableUpdates = []
      this.clearPackageCards()
      this.checkForUpdates()
    }

    if (this.packageManager.getVersionPinnedPackages().length === 0) {
      this.refs.versionPinnedPackagesMessage.style.display = 'none'
    }
  }

  // Check for updates and display them
  async checkForUpdates (clearCache) {
    this.refs.noUpdatesMessage.style.display = 'none'
    this.refs.updateAllButton.disabled = true
    this.refs.checkButton.disabled = true
    this.refs.checkingMessage.style.display = ''

    try {
      this.availableUpdates = await this.packageManager.getOutdated(clearCache)
      this.refs.checkButton.disabled = false
      this.addUpdateViews()
    } catch (error) {
      this.refs.checkButton.disabled = false
      this.refs.checkingMessage.style.display = 'none'
      this.refs.updateErrors.appendChild(new ErrorView(this.packageManager, error).element)
    }
  }

  addUpdateViews () {
    if (this.availableUpdates.length > 0) {
      this.refs.updateAllButton.style.display = ''
      this.refs.updateAllButton.disabled = false
    }
    this.refs.checkingMessage.style.display = 'none'
    this.clearPackageCards()
    if (this.availableUpdates.length === 0) {
      this.refs.noUpdatesMessage.style.display = ''
    }

    for (const pack of this.availableUpdates) {
      const packageCard = new PackageCard(pack, this.settingsView, this.packageManager, {back: 'Updates'})
      this.refs.updatesContainer.appendChild(packageCard.element)
      this.packageCards.push(packageCard)
    }
  }

  async updateAll () {
    this.refs.checkButton.disabled = true
    this.refs.updateAllButton.disabled = true

    let updatingPackages = this.updatingPackages
    let successfulUpdatesCount = 0
    let failedUpdatesCount = 0

    const concurrency = atom.config.get('settings-view.packageUpdateConcurrency') > 0
      ? atom.config.get('settings-view.packageUpdateConcurrency')
      : Number.POSITIVE_INFINITY

    const queue = asyncQueue(function (packageCard, callback) {
      const onUpdateCompleted = function (err) {
        err == null ? successfulUpdatesCount++ : failedUpdatesCount++
      }

      if (updatingPackages.includes(packageCard.pack)) {
        callback()
      } else {
        packageCard.update().then(onUpdateCompleted, onUpdateCompleted).then(callback)
      }
    }, concurrency)

    queue.push(this.packageCards)

    await queue.drain()

    if (successfulUpdatesCount > 0) {
      const message = `Restart Atom to complete the update of ${successfulUpdatesCount} ${pluralize('package', successfulUpdatesCount)}:`
      let detail = ''
      this.packageCards.forEach((card) => {
        let oldVersion = ''
        let newVersion = ''

        if (card.pack.apmInstallSource && card.pack.apmInstallSource.type === 'git') {
          oldVersion = card.pack.apmInstallSource.sha.substr(0, 8)
          newVersion = `${card.pack.latestSha.substr(0, 8)}`
        } else if (card.pack.version && card.pack.latestVersion) {
          oldVersion = card.pack.version
          newVersion = card.pack.latestVersion
        }

        if (oldVersion && newVersion) {
          detail += `${card.pack.name}@${oldVersion} -> ${newVersion}\n`
        }
      })
      detail = detail.trim()

      const notification = atom.notifications.addSuccess(message, {
        dismissable: true,
        buttons: [{
          text: 'Restart now',
          onDidClick () { return atom.restartApplication() }
        },
        {
          text: 'I\'ll do it later',
          onDidClick () { notification.dismiss() }
        }],
        detail
      })
    }

    if (failedUpdatesCount === 0) {
      this.refs.checkButton.disabled = false
      this.refs.updateAllButton.style.display = 'none'
    } else {
      this.refs.checkButton.disabled = false
      this.refs.updateAllButton.disabled = false
    }
  }

  clearPackageCards () {
    while (this.packageCards.length) {
      this.packageCards.pop().destroy()
    }
  }

  scrollUp () {
    this.element.scrollTop -= document.body.offsetHeight / 20
  }

  scrollDown () {
    this.element.scrollTop += document.body.offsetHeight / 20
  }

  pageUp () {
    this.element.scrollTop -= this.element.offsetHeight
  }

  pageDown () {
    this.element.scrollTop += this.element.offsetHeight
  }

  scrollToTop () {
    this.element.scrollTop = 0
  }

  scrollToBottom () {
    this.element.scrollTop = this.element.scrollHeight
  }
}

function pluralize (word, count) {
  return (count > 1) ? `${word}s` : word
}

================
File: packages/settings-view/lib/uri-handler-panel.js
================
/** @babel */
/** @jsx etch.dom */

import {CompositeDisposable} from 'atom'
import etch from 'etch'

function isSupported () {
  return ['win32', 'darwin'].includes(process.platform)
}

function isDefaultProtocolClient () {
  return require('electron').remote.app.isDefaultProtocolClient('atom', process.execPath, ['--uri-handler', '--'])
}

function setAsDefaultProtocolClient () {
  // This Electron API is only available on Windows and macOS. There might be some
  // hacks to make it work on Linux; see https://github.com/electron/electron/issues/6440
  return isSupported() && require('electron').remote.app.setAsDefaultProtocolClient('atom', process.execPath, ['--uri-handler', '--'])
}

export default class UriHandlerPanel {
  constructor () {
    this.handleChange = this.handleChange.bind(this)
    this.handleBecomeProtocolClient = this.handleBecomeProtocolClient.bind(this)
    this.isDefaultProtocolClient = isDefaultProtocolClient()
    this.uriHistory = []
    etch.initialize(this)

    this.subscriptions = new CompositeDisposable()
    this.subscriptions.add(
      atom.commands.add(this.element, {
        'core:move-up': () => { this.scrollUp() },
        'core:move-down': () => { this.scrollDown() },
        'core:page-up': () => { this.pageUp() },
        'core:page-down': () => { this.pageDown() },
        'core:move-to-top': () => { this.scrollToTop() },
        'core:move-to-bottom': () => { this.scrollToBottom() }
      }),
      atom.uriHandlerRegistry.onHistoryChange(() => {
        this.uriHistory = atom.uriHandlerRegistry.getRecentlyHandledURIs()
        etch.update(this)
      })
    )
  }

  destroy () {
    this.subscriptions.dispose()
    return etch.destroy(this)
  }

  update () {}

  render () {
    const schema = atom.config.getSchema('core.uriHandlerRegistration')

    return (
      <div className='panels-item' tabIndex='0'>
        <form className='general-panel section'>
          <div className='settings-panel'>
            <div className='section-container'>
              <div className='block section-heading icon icon-device-desktop'>URI Handling</div>
              <div className='text icon icon-question'>These settings determine how Pulsar handles atom:// URIs.</div>
              <div className='section-body'>
                <div className='control-group'>
                  <div className='controls'>
                    <label className='control-label'>
                      <div className='setting-title'>URI Handler Registration</div>
                      <div className='setting-description'>
                        {this.renderRegistrationDescription()}
                      </div>
                    </label>
                    <button
                      className='btn btn-primary'
                      disabled={!isSupported() || this.isDefaultProtocolClient}
                      style={{fontSize: '1.25em', display: 'block'}}
                      onClick={this.handleBecomeProtocolClient}
                    >
                      Register as default atom:// protocol handler
                    </button>
                  </div>
                </div>

                <div className='control-group'>
                  <div className='controls'>
                    <label className='control-label'>
                      <div className='setting-title'>Default Registration</div>
                      <div className='setting-description'>
                        {schema.description}
                      </div>
                    </label>
                    <select
                      id='core.uriHandlerRegistration'
                      className='form-control'
                      onChange={this.handleChange}
                      value={atom.config.get('core.uriHandlerRegistration')}
                    >
                      {schema.enum.map(({description, value}) => (
                        <option value={value}>{description}</option>
                      ))}
                    </select>
                  </div>
                </div>

                <div className='control-group'>
                  <div className='controls'>
                    <label className='controls-label'>
                      <div className='setting-title'>Recent URIs</div>
                    </label>
                    <table className='uri-history'>
                      <tr>
                        <th>URI</th>
                        <th>Handled By</th>
                      </tr>
                      {this.uriHistory.map(this.renderHistoryRow.bind(this))}
                    </table>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </form>
      </div>
    )
  }

  renderHistoryRow (item, idx) {
    return (
      <tr
        key={item.id}
        className=''
      >
        <td>{item.uri}</td>
        <td>
          {item.handled
            ? this.renderItem(item)
            : <em>not handled</em>
          }</td>
      </tr>
    )
  }

  renderItem (item) {
    if (item.host === 'core') {
      return <em>core</em>
    } else {
      return <a href={`atom://config/packages/${item.host}`} onClick={this.handlePackageLinkClicked}>{item.host}</a>
    }
  }

  handlePackageLinkClicked (evt) {
    evt.preventDefault()
    atom.workspace.open(evt.target.getAttribute('href'))
  }

  renderRegistrationDescription () {
    if (this.isDefaultProtocolClient) {
      return 'Pulsar is already the default handler for atom:// URIs.'
    } else if (isSupported()) {
      return 'Register Pulsar as the default handler for atom:// URIs.'
    } else {
      return 'Registration as the default handler for atom:// URIs is only supported on Windows and macOS.'
    }
  }

  handleChange (evt) {
    atom.config.set('core.uriHandlerRegistration', evt.target.value)
  }

  handleBecomeProtocolClient (evt) {
    evt.preventDefault()
    if (setAsDefaultProtocolClient()) {
      this.isDefaultProtocolClient = isDefaultProtocolClient()
      etch.update(this)
    } else {
      atom.notifications.addError('Could not become default protocol client')
    }
  }

  focus () {
    this.element.focus()
  }

  show () {
    this.element.style.display = ''
  }

  scrollUp () {
    this.element.scrollTop -= document.body.offsetHeight / 20
  }

  scrollDown () {
    this.element.scrollTop += document.body.offsetHeight / 20
  }

  pageUp () {
    this.element.scrollTop -= this.element.offsetHeight
  }

  pageDown () {
    this.element.scrollTop += this.element.offsetHeight
  }

  scrollToTop () {
    this.element.scrollTop = 0
  }

  scrollToBottom () {
    this.element.scrollTop = this.element.scrollHeight
  }
}

================
File: packages/settings-view/lib/utils.js
================
const ownerFromRepository = repository => {
  if (!repository) return ''

  const loginRegex = /github\.com\/([\w-]+)\/.+/
  let repo = repository
  if (typeof repository !== 'string') {
    repo = repository.url
    if (repo.match('git@github')) {
      const repoName = repo.split(':')[1]
      repo = `https://github.com/${repoName}`
    }
  }

  if (!repo.match('github.com/')) {
    repo = `https://github.com/${repo}`
  }

  const match = repo.match(loginRegex)
  return match ? match[1] : ''
}

const repoUrlFromRepository = repository => {
  if (!repository) return ''

  let repo = repository

  if (typeof repository === 'string') {
    repo = repository
  } else if (typeof repository === 'object' && typeof repository.url === 'string') {
    repo = repository.url
  } else {
    repo = ''
  }

  if (repo.endsWith('.git')) {
    repo = repo.replace('.git', '')
  }

  return repo
}

const packageComparatorAscending = (left, right) => {
  const leftStatus = atom.packages.isPackageDisabled(left.name)
  const rightStatus = atom.packages.isPackageDisabled(right.name)
  if (leftStatus === rightStatus) {
    if (left.name > right.name) {
      return -1
    } else if (left.name < right.name) {
      return 1
    } else {
      return 0
    }
  } else if (leftStatus > rightStatus) {
    return -1
  } else {
    return 1
  }
}

module.exports = {ownerFromRepository, repoUrlFromRepository, packageComparatorAscending}

================
File: src/main-process/atom-window.js
================
const {
  BrowserWindow,
  app,
  dialog,
  ipcMain,
  nativeImage
} = require('electron');
const { getAppName } = require('../get-app-details.js');
const path = require('path');
const fs = require('fs');
const url = require('url');
const { EventEmitter } = require('events');
const StartupTime = require('../startup-time');

let ICON_PATH = path.resolve(process.resourcesPath, 'pulsar.png');
if(!fs.existsSync(ICON_PATH)) {
  ICON_PATH = path.resolve(__dirname, '..', '..', 'resources', 'pulsar.png');
}

let includeShellLoadTime = true;
let nextId = 0;

module.exports = class AtomWindow extends EventEmitter {
  constructor(atomApplication, fileRecoveryService, settings = {}) {
    StartupTime.addMarker('main-process:atom-window:start');

    super();

    this.id = nextId++;
    this.atomApplication = atomApplication;
    this.fileRecoveryService = fileRecoveryService;
    this.isSpec = settings.isSpec;
    this.headless = settings.headless;
    this.safeMode = settings.safeMode;
    this.devMode = settings.devMode;
    this.resourcePath = settings.resourcePath;

    const locationsToOpen = settings.locationsToOpen || [];

    this.loadedPromise = new Promise(resolve => {
      this.resolveLoadedPromise = resolve;
    });
    this.closedPromise = new Promise(resolve => {
      this.resolveClosedPromise = resolve;
    });

    const options = {
      show: false,
      title: getAppName(),
      tabbingIdentifier: 'atom',
      webPreferences: {
        // Prevent specs from throttling when the window is in the background:
        // this should result in faster CI builds, and an improvement in the
        // local development experience when running specs through the UI (which
        // now won't pause when e.g. minimizing the window).
        backgroundThrottling: !this.isSpec,
        // Disable the `auxclick` feature so that `click` events are triggered in
        // response to a middle-click.
        // (Ref: https://github.com/atom/atom/pull/12696#issuecomment-290496960)
        disableBlinkFeatures: 'Auxclick',
        nodeIntegration: true,
        contextIsolation: false,
        enableRemoteModule: true,
        webviewTag: true,

        // TodoElectronIssue: remote module is deprecated https://www.electronjs.org/docs/breaking-changes#default-changed-enableremotemodule-defaults-to-false
        enableRemoteModule: true,
        // node support in threads
        nodeIntegrationInWorker: true
      },
      simpleFullscreen: this.getSimpleFullscreen()
    };

    // Don't set icon on Windows so the exe's ico will be used as window and
    // taskbar's icon. See https://github.com/atom/atom/issues/4811 for more.
    if (process.platform === 'linux')
      options.icon = nativeImage.createFromPath(ICON_PATH);
    if (this.shouldAddCustomTitleBar()) options.titleBarStyle = 'hidden';
    if (this.shouldAddCustomInsetTitleBar())
      options.titleBarStyle = 'hiddenInset';
    if (this.shouldHideTitleBar()) options.frame = false;

    if(this.atomApplication.config.get('core.allowWindowTransparency')){
      options.transparent = true;
    }

    const BrowserWindowConstructor =
      settings.browserWindowConstructor || BrowserWindow;
    this.browserWindow = new BrowserWindowConstructor(options);

    Object.defineProperty(this.browserWindow, 'loadSettingsJSON', {
      get: () =>
        JSON.stringify(
          Object.assign(
            {
              userSettings: !this.isSpec
                ? this.atomApplication.configFile.get()
                : null
            },
            this.loadSettings
          )
        )
    });

    this.handleEvents();

    this.loadSettings = Object.assign({}, settings);
    this.loadSettings.appVersion = app.getVersion();
    this.loadSettings.appName = getAppName();
    this.loadSettings.resourcePath = this.resourcePath;
    this.loadSettings.atomHome = process.env.ATOM_HOME;
    if (this.loadSettings.devMode == null) this.loadSettings.devMode = false;
    if (this.loadSettings.safeMode == null) this.loadSettings.safeMode = false;
    if (this.loadSettings.clearWindowState == null)
      this.loadSettings.clearWindowState = false;

    this.addLocationsToOpen(locationsToOpen);

    this.loadSettings.hasOpenFiles = locationsToOpen.some(
      location => location.pathToOpen && !location.isDirectory
    );
    this.loadSettings.initialProjectRoots = this.projectRoots;

    StartupTime.addMarker('main-process:atom-window:end');

    // Expose the startup markers to the renderer process, so we can have unified
    // measures about startup time between the main process and the renderer process.
    Object.defineProperty(this.browserWindow, 'startupMarkers', {
      get: () => {
        // We only want to make the main process startup data available once,
        // so if the window is refreshed or a new window is opened, the
        // renderer process won't use it again.
        const timingData = StartupTime.exportData();
        StartupTime.deleteData();

        return timingData;
      }
    });

    // Only send to the first non-spec window created
    if (includeShellLoadTime && !this.isSpec) {
      includeShellLoadTime = false;
      if (!this.loadSettings.shellLoadTime) {
        this.loadSettings.shellLoadTime = Date.now() - global.shellStartTime;
      }
    }

    if (!this.loadSettings.env) this.env = this.loadSettings.env;

    this.browserWindow.on('window:loaded', () => {
      this.disableZoom();
      this.emit('window:loaded');
      this.resolveLoadedPromise();
    });

    this.browserWindow.on('window:locations-opened', () => {
      this.emit('window:locations-opened');
    });

    this.browserWindow.on('enter-full-screen', () => {
      this.browserWindow.webContents.send('did-enter-full-screen');
    });

    this.browserWindow.on('leave-full-screen', () => {
      this.browserWindow.webContents.send('did-leave-full-screen');
    });

    this.browserWindow.loadURL(
      url.format({
        protocol: 'file',
        pathname: `${this.resourcePath}/static/index.html`,
        slashes: true
      })
    );

    this.browserWindow.showSaveDialog = this.showSaveDialog.bind(this);

    if (this.isSpec) this.browserWindow.focusOnWebView();

    const hasPathToOpen = !(
      locationsToOpen.length === 1 && locationsToOpen[0].pathToOpen == null
    );
    if (hasPathToOpen && !this.isSpecWindow())
      this.openLocations(locationsToOpen);
  }

  hasProjectPaths() {
    return this.projectRoots.length > 0;
  }

  setupContextMenu() {
    const ContextMenu = require('./context-menu');

    this.browserWindow.on('context-menu', menuTemplate => {
      return new ContextMenu(menuTemplate, this);
    });
  }

  containsLocations(locations) {
    return locations.every(location => this.containsLocation(location));
  }

  containsLocation(location) {
    if (!location.pathToOpen) return false;

    return this.projectRoots.some(projectPath => {
      if (location.pathToOpen === projectPath) return true;
      if (location.pathToOpen.startsWith(path.join(projectPath, path.sep))) {
        if (!location.exists) return true;
        if (!location.isDirectory) return true;
      }
      return false;
    });
  }

  handleEvents() {
    this.browserWindow.on('close', async event => {
      if (
        (!this.atomApplication.quitting ||
          this.atomApplication.quittingForUpdate) &&
        !this.unloading
      ) {
        event.preventDefault();
        this.unloading = true;
        this.atomApplication.saveCurrentWindowOptions(false);
        if (await this.prepareToUnload()) this.close();
      }
    });

    this.browserWindow.on('closed', () => {
      this.fileRecoveryService.didCloseWindow(this);
      this.atomApplication.removeWindow(this);
      this.resolveClosedPromise();
    });

    this.browserWindow.on('unresponsive', async () => {
      if (this.isSpec) return;
      const result = await dialog.showMessageBox(this.browserWindow, {
        type: 'warning',
        buttons: ['Force Close', 'Keep Waiting'],
        cancelId: 1, // Canceling should be the least destructive action
        message: 'Editor is not responding',
        detail:
          'The editor is not responding. Would you like to force close it or just keep waiting?'
      });
      if (result.response === 0) this.browserWindow.destroy();
    });

    this.browserWindow.webContents.on('render-process-gone', async () => {
      if (this.headless) {
        console.log('Renderer process crashed, exiting');
        this.atomApplication.exit(100);
        return;
      }

      await this.fileRecoveryService.didCrashWindow(this);

      const result = await dialog.showMessageBox(this.browserWindow, {
        type: 'warning',
        buttons: ['Close Window', 'Reload', 'Keep It Open'],
        cancelId: 2, // Canceling should be the least destructive action
        message: 'The editor has crashed',
        detail: 'Please report this issue to https://github.com/pulsar-edit/pulsar'
      });

      switch (result.response) {
        case 0:
          this.browserWindow.destroy();
          break;
        case 1:
          this.browserWindow.reload();
          break;
      }
    });

    this.browserWindow.webContents.on('will-navigate', (event, url) => {
      if (url !== this.browserWindow.webContents.getURL())
        event.preventDefault();
    });

    this.setupContextMenu();

    // Spec window's web view should always have focus
    if (this.isSpec)
      this.browserWindow.on('blur', () => this.browserWindow.focusOnWebView());
  }

  async prepareToUnload() {
    if (this.isSpecWindow()) return true;

    this.lastPrepareToUnloadPromise = new Promise(resolve => {
      const callback = (event, result) => {
        if (
          BrowserWindow.fromWebContents(event.sender) === this.browserWindow
        ) {
          ipcMain.removeListener('did-prepare-to-unload', callback);
          if (!result) {
            this.unloading = false;
            this.atomApplication.quitting = false;
          }
          resolve(result);
        }
      };
      ipcMain.on('did-prepare-to-unload', callback);
      this.browserWindow.webContents.send('prepare-to-unload');
    });

    return this.lastPrepareToUnloadPromise;
  }

  openPath(pathToOpen, initialLine, initialColumn) {
    return this.openLocations([{ pathToOpen, initialLine, initialColumn }]);
  }

  async openLocations(locationsToOpen) {
    this.addLocationsToOpen(locationsToOpen);
    await this.loadedPromise;
    this.sendMessage('open-locations', locationsToOpen);
  }

  didChangeUserSettings(settings) {
    this.sendMessage('did-change-user-settings', settings);
  }

  didFailToReadUserSettings(message) {
    this.sendMessage('did-fail-to-read-user-settings', message);
  }

  addLocationsToOpen(locationsToOpen) {
    const roots = new Set(this.projectRoots || []);
    for (const { pathToOpen, isDirectory } of locationsToOpen) {
      if (isDirectory) {
        roots.add(pathToOpen);
      }
    }

    this.projectRoots = Array.from(roots);
    this.projectRoots.sort();
  }

  replaceEnvironment(env) {
    const {
      NODE_ENV,
      NODE_PATH,
      ATOM_HOME,
      ATOM_DISABLE_SHELLING_OUT_FOR_ENVIRONMENT
    } = env;

    this.browserWindow.webContents.send('environment', {
      NODE_ENV,
      NODE_PATH,
      ATOM_HOME,
      ATOM_DISABLE_SHELLING_OUT_FOR_ENVIRONMENT
    });
  }

  sendMessage(message, detail) {
    this.browserWindow.webContents.send('message', message, detail);
  }

  sendCommand(command, ...args) {
    if (this.isSpecWindow()) {
      if (!this.atomApplication.sendCommandToFirstResponder(command)) {
        switch (command) {
          case 'window:reload':
            return this.reload();
          case 'window:toggle-dev-tools':
            return this.toggleDevTools();
          case 'window:close':
            return this.close();
        }
      }
    } else if (this.isWebViewFocused()) {
      this.sendCommandToBrowserWindow(command, ...args);
    } else if (!this.atomApplication.sendCommandToFirstResponder(command)) {
      this.sendCommandToBrowserWindow(command, ...args);
    }
  }

  sendURIMessage(uri) {
    this.browserWindow.webContents.send('uri-message', uri);
  }

  sendCommandToBrowserWindow(command, ...args) {
    const action =
      args[0] && args[0].contextCommand ? 'context-command' : 'command';
    this.browserWindow.webContents.send(action, command, ...args);
  }

  getDimensions() {
    const [x, y] = Array.from(this.browserWindow.getPosition());
    const [width, height] = Array.from(this.browserWindow.getSize());
    return { x, y, width, height };
  }

  getSimpleFullscreen() {
    return this.atomApplication.config.get('core.simpleFullScreenWindows');
  }

  shouldAddCustomTitleBar() {
    return (
      !this.isSpec &&
      process.platform === 'darwin' &&
      this.atomApplication.config.get('core.titleBar') === 'custom'
    );
  }

  shouldAddCustomInsetTitleBar() {
    return (
      !this.isSpec &&
      process.platform === 'darwin' &&
      this.atomApplication.config.get('core.titleBar') === 'custom-inset'
    );
  }

  shouldHideTitleBar() {
    return (
      !this.isSpec &&
      this.atomApplication.config.get('core.titleBar') === 'hidden'
    );
  }

  close() {
    return this.browserWindow.close();
  }

  focus() {
    return this.browserWindow.focus();
  }

  minimize() {
    return this.browserWindow.minimize();
  }

  maximize() {
    return this.browserWindow.maximize();
  }

  unmaximize() {
    return this.browserWindow.unmaximize();
  }

  restore() {
    return this.browserWindow.restore();
  }

  setFullScreen(fullScreen) {
    return this.browserWindow.setFullScreen(fullScreen);
  }

  setAutoHideMenuBar(autoHideMenuBar) {
    return this.browserWindow.setAutoHideMenuBar(autoHideMenuBar);
  }

  handlesAtomCommands() {
    return !this.isSpecWindow() && this.isWebViewFocused();
  }

  isFocused() {
    return this.browserWindow.isFocused();
  }

  isMaximized() {
    return this.browserWindow.isMaximized();
  }

  isMinimized() {
    return this.browserWindow.isMinimized();
  }

  isWebViewFocused() {
    return this.browserWindow.isWebViewFocused();
  }

  isSpecWindow() {
    return this.isSpec;
  }

  reload() {
    this.loadedPromise = new Promise(resolve => {
      this.resolveLoadedPromise = resolve;
    });
    this.prepareToUnload().then(canUnload => {
      if (canUnload) this.browserWindow.reload();
    });
    return this.loadedPromise;
  }

  showSaveDialog(options, callback) {
    options = Object.assign(
      {
        title: 'Save File',
        defaultPath: this.projectRoots[0]
      },
      options
    );

    let promise = dialog.showSaveDialog(this.browserWindow, options);
    if (typeof callback === 'function') {
      promise = promise.then(({ filePath, bookmark }) => {
        callback(filePath, bookmark);
      });
    }
    return promise;
  }

  toggleDevTools() {
    return this.browserWindow.toggleDevTools();
  }

  openDevTools() {
    return this.browserWindow.openDevTools();
  }

  closeDevTools() {
    return this.browserWindow.closeDevTools();
  }

  setDocumentEdited(documentEdited) {
    return this.browserWindow.setDocumentEdited(documentEdited);
  }

  setRepresentedFilename(representedFilename) {
    return this.browserWindow.setRepresentedFilename(representedFilename);
  }

  setProjectRoots(projectRootPaths) {
    this.projectRoots = projectRootPaths;
    this.projectRoots.sort();
    this.loadSettings.initialProjectRoots = this.projectRoots;
    return this.atomApplication.saveCurrentWindowOptions();
  }

  didClosePathWithWaitSession(path) {
    this.atomApplication.windowDidClosePathWithWaitSession(this, path);
  }

  copy() {
    return this.browserWindow.copy();
  }

  disableZoom() {
    return this.browserWindow.webContents.setVisualZoomLevelLimits(1, 1);
  }

  getLoadedPromise() {
    return this.loadedPromise;
  }
};

================
File: src/config-schema.js
================
// This is loaded by atom-environment.coffee. See
// https://atom.io/docs/api/latest/Config for more information about config TODO: Link to Pulsar API site when documented
// schemas.
const configSchema = {
  core: {
    type: 'object',
    properties: {
      ignoredNames: {
        type: 'array',
        default: [
          '.git',
          '.hg',
          '.svn',
          '.DS_Store',
          '._*',
          'Thumbs.db',
          'desktop.ini'
        ],
        items: {
          type: 'string'
        },
        description:
          'List of [glob patterns](https://en.wikipedia.org/wiki/Glob_%28programming%29). Files and directories matching these patterns will be ignored by some packages, such as the fuzzy finder and tree view. Individual packages might have additional config settings for ignoring names.'
      },
      excludeVcsIgnoredPaths: {
        type: 'boolean',
        default: true,
        title: 'Exclude VCS Ignored Paths',
        description:
          "Files and directories ignored by the current project's VCS will be ignored by some packages, such as the fuzzy finder and find and replace. For example, projects using Git have these paths defined in the .gitignore file. Individual packages might have additional config settings for ignoring VCS ignored files and folders."
      },
      followSymlinks: {
        type: 'boolean',
        default: true,
        description:
          'Follow symbolic links when searching files and when opening files with the fuzzy finder.'
      },
      disabledPackages: {
        type: 'array',
        default: [],

        items: {
          type: 'string'
        },

        description:
          'List of names of installed packages which are not loaded at startup.'
      },
      titleBar: {
        type: 'string',
        default: 'native',
        enum: ['native', 'hidden'],
        description:
          'Experimental:  The title bar can  be completely `hidden`.<br>This setting will require a relaunch of Pulsar to take effect.'
      },
      versionPinnedPackages: {
        type: 'array',
        default: [],

        items: {
          type: 'string'
        },

        description:
          'List of names of installed packages which are not automatically updated.'
      },
      customFileTypes: {
        type: 'object',
        default: {},
        description:
          'Associates scope names (e.g. `"source.js"`) with arrays of file extensions and file names (e.g. `["Somefile", ".js2"]`)',
        additionalProperties: {
          type: 'array',
          items: {
            type: 'string'
          }
        }
      },
      uriHandlerRegistration: {
        type: 'string',
        default: 'prompt',
        description:
          'When should Pulsar register itself as the default handler for atom:// URIs',
        enum: [
          {
            value: 'prompt',
            description:
              'Prompt to register Pulsar as the default atom:// URI handler'
          },
          {
            value: 'always',
            description:
              'Always become the default atom:// URI handler automatically'
          },
          {
            value: 'never',
            description: 'Never become the default atom:// URI handler'
          }
        ]
      },
      themes: {
        type: 'array',
        default: ['one-dark-ui', 'one-dark-syntax'],
        items: {
          type: 'string'
        },
        description:
          'Names of UI and syntax themes which will be used when Pulsar starts.'
      },
      audioBeep: {
        type: 'boolean',
        default: true,
        description:
          "Trigger the system's beep sound when certain actions cannot be executed or there are no results."
      },
      closeDeletedFileTabs: {
        type: 'boolean',
        default: false,
        title: 'Close Deleted File Tabs',
        description:
          'Close corresponding editors when a file is deleted outside Pulsar.'
      },
      destroyEmptyPanes: {
        type: 'boolean',
        default: true,
        title: 'Remove Empty Panes',
        description:
          'When the last tab of a pane is closed, remove that pane as well.'
      },
      closeEmptyWindows: {
        type: 'boolean',
        default: true,
        description:
          "When a window with no open tabs or panes is given the 'Close Tab' command, close that window."
      },
      fileEncoding: {
        description:
          'Default character set encoding to use when reading and writing files.',
        type: 'string',
        default: 'utf8',
        enum: [
          {
            value: 'iso88596',
            description: 'Arabic (ISO 8859-6)'
          },
          {
            value: 'windows1256',
            description: 'Arabic (Windows 1256)'
          },
          {
            value: 'iso88594',
            description: 'Baltic (ISO 8859-4)'
          },
          {
            value: 'windows1257',
            description: 'Baltic (Windows 1257)'
          },
          {
            value: 'iso885914',
            description: 'Celtic (ISO 8859-14)'
          },
          {
            value: 'iso88592',
            description: 'Central European (ISO 8859-2)'
          },
          {
            value: 'windows1250',
            description: 'Central European (Windows 1250)'
          },
          {
            value: 'gb18030',
            description: 'Chinese (GB18030)'
          },
          {
            value: 'gbk',
            description: 'Chinese (GBK)'
          },
          {
            value: 'cp950',
            description: 'Traditional Chinese (Big5)'
          },
          {
            value: 'big5hkscs',
            description: 'Traditional Chinese (Big5-HKSCS)'
          },
          {
            value: 'cp866',
            description: 'Cyrillic (CP 866)'
          },
          {
            value: 'iso88595',
            description: 'Cyrillic (ISO 8859-5)'
          },
          {
            value: 'koi8r',
            description: 'Cyrillic (KOI8-R)'
          },
          {
            value: 'koi8u',
            description: 'Cyrillic (KOI8-U)'
          },
          {
            value: 'windows1251',
            description: 'Cyrillic (Windows 1251)'
          },
          {
            value: 'cp437',
            description: 'DOS (CP 437)'
          },
          {
            value: 'cp850',
            description: 'DOS (CP 850)'
          },
          {
            value: 'iso885913',
            description: 'Estonian (ISO 8859-13)'
          },
          {
            value: 'iso88597',
            description: 'Greek (ISO 8859-7)'
          },
          {
            value: 'windows1253',
            description: 'Greek (Windows 1253)'
          },
          {
            value: 'iso88598',
            description: 'Hebrew (ISO 8859-8)'
          },
          {
            value: 'windows1255',
            description: 'Hebrew (Windows 1255)'
          },
          {
            value: 'cp932',
            description: 'Japanese (CP 932)'
          },
          {
            value: 'eucjp',
            description: 'Japanese (EUC-JP)'
          },
          {
            value: 'shiftjis',
            description: 'Japanese (Shift JIS)'
          },
          {
            value: 'euckr',
            description: 'Korean (EUC-KR)'
          },
          {
            value: 'iso885910',
            description: 'Nordic (ISO 8859-10)'
          },
          {
            value: 'iso885916',
            description: 'Romanian (ISO 8859-16)'
          },
          {
            value: 'iso88599',
            description: 'Turkish (ISO 8859-9)'
          },
          {
            value: 'windows1254',
            description: 'Turkish (Windows 1254)'
          },
          {
            value: 'utf8',
            description: 'Unicode (UTF-8)'
          },
          {
            value: 'utf16le',
            description: 'Unicode (UTF-16 LE)'
          },
          {
            value: 'utf16be',
            description: 'Unicode (UTF-16 BE)'
          },
          {
            value: 'windows1258',
            description: 'Vietnamese (Windows 1258)'
          },
          {
            value: 'iso88591',
            description: 'Western (ISO 8859-1)'
          },
          {
            value: 'iso88593',
            description: 'Western (ISO 8859-3)'
          },
          {
            value: 'iso885915',
            description: 'Western (ISO 8859-15)'
          },
          {
            value: 'macroman',
            description: 'Western (Mac Roman)'
          },
          {
            value: 'windows1252',
            description: 'Western (Windows 1252)'
          }
        ]
      },
      openEmptyEditorOnStart: {
        description:
          'When checked opens an untitled editor when loading a blank environment (such as with _File > New Window_ or when "Restore Previous Windows On Start" is unchecked); otherwise no editor is opened when loading a blank environment. This setting has no effect when restoring a previous state.',
        type: 'boolean',
        default: true
      },
      restorePreviousWindowsOnStart: {
        type: 'string',
        enum: ['no', 'yes', 'always'],
        default: 'yes',
        description:
          "When selected 'no', a blank environment is loaded. When selected 'yes' and Pulsar is started from the icon or `pulsar` by itself from the command line, restores the last state of all Pulsar windows; otherwise a blank environment is loaded. When selected 'always', restores the last state of all Pulsar windows always, no matter how Pulsar is started."
      },
      reopenProjectMenuCount: {
        description:
          'How many recent projects to show in the Reopen Project menu.',
        type: 'integer',
        default: 15
      },
      automaticallyUpdate: {
        description:
          'Automatically update Pulsar when a new release is available. **Note**: Currently not functional, please download new releases from [pulsar-edit.dev](https://pulsar-edit.dev/download.html)',
        type: 'boolean',
        default: false
      },
      useProxySettingsWhenCallingApm: {
        title: 'Use Proxy Settings When Calling PPM',
        description:
          'Use detected proxy settings when calling the `pulsar -p` or `ppm` command-line tool.',
        type: 'boolean',
        default: true
      },
      allowPendingPaneItems: {
        description:
          'Allow items to be previewed without adding them to a pane permanently, such as when single clicking files in the tree view.',
        type: 'boolean',
        default: true
      },
      warnOnLargeFileLimit: {
        description:
          'Warn before opening files larger than this number of megabytes.',
        type: 'number',
        default: 40
      },
      fileSystemWatcher: {
        description:
          'Choose the underlying implementation used to watch for filesystem changes. Emulating changes will miss any events caused by applications other than Pulsar, but may help prevent crashes or freezes.',
        type: 'string',
        default: 'native',
        enum: [
          {
            value: 'native',
            description: 'Native operating system APIs'
          }
        ]
      },
      useTreeSitterParsers: {
        type: 'boolean',
        default: true,
        title: 'Use Tree-sitter Parsers',
        description: 'Use Tree-sitter parsers for supported languages.'
      },
      useLegacyTreeSitter: {
        type: 'boolean',
        default: false,
        title: 'Use Legacy Tree-sitter Implementation',
        description: 'Opt into the legacy Atom Tree-sitter system instead of the modern system added by Pulsar. (We plan to remove this legacy system soon.) Has no effect unless “Use Tree-sitter Parsers” is also checked.'
      },
      colorProfile: {
        description:
          "Specify whether Pulsar should use the operating system's color profile (recommended) or an alternative color profile.<br>Changing this setting will require a relaunch of Pulsar to take effect.",
        type: 'string',
        default: 'default',
        enum: [
          {
            value: 'default',
            description: 'Use color profile configured in the operating system'
          },
          {
            value: 'srgb',
            description: 'Use sRGB color profile'
          }
        ]
      },
      transformDeprecatedStyleSheetSelectors: {
        description: 'Whether Pulsar should transform deprecated DOM Selectors in community package style sheets. Increases compatibility, as well as startup time.',
        type: 'boolean',
        default: true
      },
      transformDeprecatedStyleSheetMathExpressions: {
        description: 'Whether Pulsar should transform deprecated Mathematical Expressions in community package style sheets. Increases compatibility, as well as startup time.',
        type: 'boolean',
        default: true
      },
      addCurrentTabToWindowTitle: {
        description: 'Add the current tab title to the Pulsar Window title.',
        type: 'boolean',
        default: true
      },
      syncWindowThemeWithPulsarTheme: {
        description: 'When changing the theme within Pulsar also change the theme of the window on the operating system.',
        type: 'boolean',
        default: false
      },
      allowWindowTransparency: {
        type: 'boolean',
        default: false,
        title: 'Allow Window Transparency',
        description: `Allows editor windows to be see-through. When this setting is enabled, UI themes and user stylesheets can use background colors with an alpha channel to make editor windows translucent. Takes effect after a restart of Pulsar.`
      }
    }
  },
  editor: {
    type: 'object',
    // These settings are used in scoped fashion only. No defaults.
    properties: {
      commentStart: {
        type: ['string', 'null']
      },
      commentEnd: {
        type: ['string', 'null']
      },
      increaseIndentPattern: {
        type: ['string', 'null']
      },
      decreaseIndentPattern: {
        type: ['string', 'null']
      },
      foldEndPattern: {
        type: ['string', 'null']
      },
      // These can be used as globals or scoped, thus defaults.
      fontFamily: {
        type: 'string',
        default: 'Menlo, Consolas, DejaVu Sans Mono, monospace',
        description: 'The name of the font family used for editor text.'
      },
      fontSize: {
        type: 'integer',
        default: 14,
        minimum: 1,
        maximum: 100,
        description: 'Height in pixels of editor text.'
      },
      defaultFontSize: {
        type: 'integer',
        default: 14,
        minimum: 1,
        maximum: 100,
        description:
          'Default height in pixels of the editor text. Useful when resetting font size'
      },
      lineHeight: {
        type: ['string', 'number'],
        default: 1.5,
        description: 'Height of editor lines, as a multiplier of font size.'
      },
      showCursorOnSelection: {
        type: 'boolean',
        default: true,
        description: 'Show cursor while there is a selection.'
      },
      showInvisibles: {
        type: 'boolean',
        default: false,
        description:
          'Render placeholders for invisible characters, such as tabs, spaces and newlines.'
      },
      showIndentGuide: {
        type: 'boolean',
        default: false,
        description: 'Show indentation indicators in the editor.'
      },
      showLineNumbers: {
        type: 'boolean',
        default: true,
        description: "Show line numbers in the editor's gutter."
      },
      atomicSoftTabs: {
        type: 'boolean',
        default: true,
        description:
          'Skip over tab-length runs of leading whitespace when moving the cursor.'
      },
      autoIndent: {
        type: 'boolean',
        default: true,
        description: 'Automatically indent the cursor when inserting a newline.'
      },
      autoIndentOnPaste: {
        type: 'boolean',
        default: true,
        description:
          'Automatically indent pasted text based on the indentation of the previous line.'
      },
      nonWordCharacters: {
        type: 'string',
        default: '/\\()"\':,.;<>~!@#$%^&*|+=[]{}`?-…',
        description:
          'A string of non-word characters to define word boundaries.'
      },
      preferredLineLength: {
        type: 'integer',
        default: 80,
        minimum: 1,
        description:
          'Identifies the length of a line which is used when wrapping text with the `Soft Wrap At Preferred Line Length` setting enabled, in number of characters.'
      },
      maxScreenLineLength: {
        type: 'integer',
        default: 500,
        minimum: 500,
        description:
          'Defines the maximum width of the editor window before soft wrapping is enforced, in number of characters.'
      },
      tabLength: {
        type: 'integer',
        default: 2,
        minimum: 1,
        description: 'Number of spaces used to represent a tab.'
      },
      softWrap: {
        type: 'boolean',
        default: false,
        description:
          'Wraps lines that exceed the width of the window. When `Soft Wrap At Preferred Line Length` is set, it will wrap to the number of characters defined by the `Preferred Line Length` setting.'
      },
      softTabs: {
        type: 'boolean',
        default: true,
        description:
          'If the `Tab Type` config setting is set to "auto" and autodetection of tab type from buffer content fails, then this config setting determines whether a soft tab or a hard tab will be inserted when the Tab key is pressed.'
      },
      tabType: {
        type: 'string',
        default: 'auto',
        enum: ['auto', 'soft', 'hard'],
        description:
          'Determine character inserted when Tab key is pressed. Possible values: "auto", "soft" and "hard". When set to "soft" or "hard", soft tabs (spaces) or hard tabs (tab characters) are used. When set to "auto", the editor auto-detects the tab type based on the contents of the buffer (it uses the first leading whitespace on a non-comment line), or uses the value of the Soft Tabs config setting if auto-detection fails.'
      },
      softWrapAtPreferredLineLength: {
        type: 'boolean',
        default: false,
        description:
          "Instead of wrapping lines to the window's width, wrap lines to the number of characters defined by the `Preferred Line Length` setting. This will only take effect when the soft wrap config setting is enabled globally or for the current language. **Note:** If you want to hide the wrap guide (the vertical line) you can disable the `wrap-guide` package."
      },
      softWrapHangingIndent: {
        type: 'integer',
        default: 0,
        minimum: 0,
        description:
          'When soft wrap is enabled, defines length of additional indentation applied to wrapped lines, in number of characters.'
      },
      scrollSensitivity: {
        type: 'integer',
        default: 40,
        minimum: 10,
        maximum: 200,
        description:
          'Determines how fast the editor scrolls when using a mouse or trackpad.'
      },
      scrollPastEnd: {
        type: 'boolean',
        default: false,
        description:
          'Allow the editor to be scrolled past the end of the last line.'
      },
      undoGroupingInterval: {
        type: 'integer',
        default: 300,
        minimum: 0,
        description:
          'Time interval in milliseconds within which text editing operations will be grouped together in the undo history.'
      },
      confirmCheckoutHeadRevision: {
        type: 'boolean',
        default: true,
        title: 'Confirm Checkout HEAD Revision',
        description:
          'Show confirmation dialog when checking out the HEAD revision and discarding changes to current file since last commit.'
      },
      invisibles: {
        type: 'object',
        description:
          'A hash of characters Pulsar will use to render whitespace characters. Keys are whitespace character types, values are rendered characters (use value false to turn off individual whitespace character types).',
        properties: {
          eol: {
            type: ['boolean', 'string'],
            default: '¬',
            maximumLength: 1,
            description:
              'Character used to render newline characters (\\n) when the `Show Invisibles` setting is enabled. '
          },
          space: {
            type: ['boolean', 'string'],
            default: '·',
            maximumLength: 1,
            description:
              'Character used to render leading and trailing space characters when the `Show Invisibles` setting is enabled.'
          },
          tab: {
            type: ['boolean', 'string'],
            default: '»',
            maximumLength: 1,
            description:
              'Character used to render hard tab characters (\\t) when the `Show Invisibles` setting is enabled.'
          },
          cr: {
            type: ['boolean', 'string'],
            default: '¤',
            maximumLength: 1,
            description:
              'Character used to render carriage return characters (for Microsoft-style line endings) when the `Show Invisibles` setting is enabled.'
          }
        }
      },
      zoomFontWhenCtrlScrolling: {
        type: 'boolean',
        default: process.platform !== 'darwin',
        description:
          'Change the editor font size when pressing the Ctrl key and scrolling the mouse up/down.'
      },
      multiCursorOnClick: {
        type: 'boolean',
        default: true,
        description:
          'Add multiple cursors when pressing the Ctrl key (Command key on macOS) and clicking the editor.'
      }
    }
  }
};

if (['win32', 'linux'].includes(process.platform)) {
  configSchema.core.properties.autoHideMenuBar = {
    type: 'boolean',
    default: false,
    description:
      'Automatically hide the menu bar and toggle it by pressing Alt. This is only supported on Windows & Linux.'
  };
}

if (process.platform === 'darwin') {
  configSchema.core.properties.titleBar = {
    type: 'string',
    default: 'native',
    enum: ['native', 'custom', 'custom-inset', 'hidden'],
    description:
      'Experimental: A `custom` title bar adapts to theme colors. Choosing `custom-inset` adds a bit more padding. The title bar can also be completely `hidden`.<br>Note: Switching to a custom or hidden title bar will compromise some functionality.<br>This setting will require a relaunch of Pulsar to take effect.'
  };
  configSchema.core.properties.simpleFullScreenWindows = {
    type: 'boolean',
    default: false,
    description:
      'Use pre-Lion fullscreen on macOS. This does not create a new desktop space for Pulsar on fullscreen mode.'
  };
}

if (process.platform === 'linux') {
  configSchema.editor.properties.selectionClipboard = {
    type: 'boolean',
    default: true,
    description: 'Enable pasting on middle mouse button click'
  };
}

module.exports = configSchema;

================
File: src/notification-manager.js
================
const { Emitter } = require('event-kit');
const Notification = require('../src/notification');

// Public: A notification manager used to create {Notification}s to be shown
// to the user.
//
// An instance of this class is always available as the `atom.notifications`
// global.
module.exports = class NotificationManager {
  constructor() {
    this.notifications = [];
    this.emitter = new Emitter();
  }

  /*
  Section: Events
  */

  // Public: Invoke the given callback after a notification has been added.
  //
  // * `callback` {Function} to be called after the notification is added.
  //   * `notification` The {Notification} that was added.
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  onDidAddNotification(callback) {
    return this.emitter.on('did-add-notification', callback);
  }

  // Public: Invoke the given callback after the notifications have been cleared.
  //
  // * `callback` {Function} to be called after the notifications are cleared.
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  onDidClearNotifications(callback) {
    return this.emitter.on('did-clear-notifications', callback);
  }

  /*
  Section: Adding Notifications
  */

  // Public: Add a success notification.
  //
  // * `message` A {String} message
  // * `options` (optional) An options {Object} with the following keys:
  //    * `buttons` (optional) An {Array} of {Object} where each {Object} has
  //      the following options:
  //      * `className` (optional) {String} a class name to add to the button's
  //        default class name (`btn btn-success`).
  //      * `onDidClick` (optional) {Function} callback to call when the button
  //        has been clicked. The context will be set to the
  //        {NotificationElement} instance.
  //      * `text` {String} inner text for the button
  //    * `description` (optional) A Markdown {String} containing a longer
  //      description about the notification. By default, this **will not**
  //      preserve newlines and whitespace when it is rendered.
  //    * `detail` (optional) A plain-text {String} containing additional
  //      details about the notification. By default, this **will** preserve
  //      newlines and whitespace when it is rendered.
  //    * `dismissable` (optional) A {Boolean} indicating whether this
  //      notification can be dismissed by the user. Defaults to `false`.
  //    * `icon` (optional) A {String} name of an icon from Octicons to display
  //      in the notification header. Defaults to `'check'`.
  //
  // Returns the {Notification} that was added.
  addSuccess(message, options) {
    return this.addNotification(new Notification('success', message, options));
  }

  // Public: Add an informational notification.
  //
  // * `message` A {String} message
  // * `options` (optional) An options {Object} with the following keys:
  //    * `buttons` (optional) An {Array} of {Object} where each {Object} has
  //      the following options:
  //      * `className` (optional) {String} a class name to add to the button's
  //        default class name (`btn btn-info`).
  //      * `onDidClick` (optional) {Function} callback to call when the button
  //        has been clicked. The context will be set to the
  //        {NotificationElement} instance.
  //      * `text` {String} inner text for the button
  //    * `description` (optional) A Markdown {String} containing a longer
  //      description about the notification. By default, this **will not**
  //      preserve newlines and whitespace when it is rendered.
  //    * `detail` (optional) A plain-text {String} containing additional
  //      details about the notification. By default, this **will** preserve
  //      newlines and whitespace when it is rendered.
  //    * `dismissable` (optional) A {Boolean} indicating whether this
  //      notification can be dismissed by the user. Defaults to `false`.
  //    * `icon` (optional) A {String} name of an icon from Octicons to display
  //      in the notification header. Defaults to `'info'`.
  //
  // Returns the {Notification} that was added.
  addInfo(message, options) {
    return this.addNotification(new Notification('info', message, options));
  }

  // Public: Add a warning notification.
  //
  // * `message` A {String} message
  // * `options` (optional) An options {Object} with the following keys:
  //    * `buttons` (optional) An {Array} of {Object} where each {Object} has
  //      the following options:
  //      * `className` (optional) {String} a class name to add to the button's
  //        default class name (`btn btn-warning`).
  //      * `onDidClick` (optional) {Function} callback to call when the button
  //        has been clicked. The context will be set to the
  //        {NotificationElement} instance.
  //      * `text` {String} inner text for the button
  //    * `description` (optional) A Markdown {String} containing a longer
  //      description about the notification. By default, this **will not**
  //      preserve newlines and whitespace when it is rendered.
  //    * `detail` (optional) A plain-text {String} containing additional
  //      details about the notification. By default, this **will** preserve
  //      newlines and whitespace when it is rendered.
  //    * `dismissable` (optional) A {Boolean} indicating whether this
  //      notification can be dismissed by the user. Defaults to `false`.
  //    * `icon` (optional) A {String} name of an icon from Octicons to display
  //      in the notification header. Defaults to `'alert'`.
  //
  // Returns the {Notification} that was added.
  addWarning(message, options) {
    return this.addNotification(new Notification('warning', message, options));
  }

  // Public: Add an error notification.
  //
  // * `message` A {String} message
  // * `options` (optional) An options {Object} with the following keys:
  //    * `buttons` (optional) An {Array} of {Object} where each {Object} has
  //      the following options:
  //      * `className` (optional) {String} a class name to add to the button's
  //        default class name (`btn btn-error`).
  //      * `onDidClick` (optional) {Function} callback to call when the button
  //        has been clicked. The context will be set to the
  //        {NotificationElement} instance.
  //      * `text` {String} inner text for the button
  //    * `description` (optional) A Markdown {String} containing a longer
  //      description about the notification. By default, this **will not**
  //      preserve newlines and whitespace when it is rendered.
  //    * `detail` (optional) A plain-text {String} containing additional
  //      details about the notification. By default, this **will** preserve
  //      newlines and whitespace when it is rendered.
  //    * `dismissable` (optional) A {Boolean} indicating whether this
  //      notification can be dismissed by the user. Defaults to `false`.
  //    * `icon` (optional) A {String} name of an icon from Octicons to display
  //      in the notification header. Defaults to `'flame'`.
  //    * `stack` (optional) A preformatted {String} with stack trace
  //      information describing the location of the error.
  //      Requires `detail` to be set.
  //
  // Returns the {Notification} that was added.
  addError(message, options) {
    return this.addNotification(new Notification('error', message, options));
  }

  // Public: Add a fatal error notification.
  //
  // * `message` A {String} message
  // * `options` (optional) An options {Object} with the following keys:
  //    * `buttons` (optional) An {Array} of {Object} where each {Object} has
  //      the following options:
  //      * `className` (optional) {String} a class name to add to the button's
  //        default class name (`btn btn-error`).
  //      * `onDidClick` (optional) {Function} callback to call when the button
  //        has been clicked. The context will be set to the
  //        {NotificationElement} instance.
  //      * `text` {String} inner text for the button
  //    * `description` (optional) A Markdown {String} containing a longer
  //      description about the notification. By default, this **will not**
  //      preserve newlines and whitespace when it is rendered.
  //    * `detail` (optional) A plain-text {String} containing additional
  //      details about the notification. By default, this **will** preserve
  //      newlines and whitespace when it is rendered.
  //    * `dismissable` (optional) A {Boolean} indicating whether this
  //      notification can be dismissed by the user. Defaults to `false`.
  //    * `icon` (optional) A {String} name of an icon from Octicons to display
  //      in the notification header. Defaults to `'bug'`.
  //    * `stack` (optional) A preformatted {String} with stack trace
  //      information describing the location of the error.
  //      Requires `detail` to be set.
  //
  // Returns the {Notification} that was added.
  addFatalError(message, options) {
    return this.addNotification(new Notification('fatal', message, options));
  }

  add(type, message, options) {
    return this.addNotification(new Notification(type, message, options));
  }

  addNotification(notification) {
    this.notifications.push(notification);
    this.emitter.emit('did-add-notification', notification);
    return notification;
  }

  /*
  Section: Getting Notifications
  */

  // Public: Get all the notifications.
  //
  // Returns an {Array} of {Notification}s.
  getNotifications() {
    return this.notifications.slice();
  }

  /*
  Section: Managing Notifications
  */

  // Public: Clear all the notifications.
  clear() {
    this.notifications = [];
    this.emitter.emit('did-clear-notifications');
  }
};

================
File: src/notification.js
================
const { Emitter } = require('event-kit');
const _ = require('underscore-plus');

// Public: A notification to the user containing a message and type.
module.exports = class Notification {
  constructor(type, message, options = {}) {
    this.type = type;
    this.message = message;
    this.options = options;
    this.emitter = new Emitter();
    this.timestamp = new Date();
    this.dismissed = true;
    if (this.isDismissable()) this.dismissed = false;
    this.displayed = false;
    this.validate();
  }

  validate() {
    if (typeof this.message !== 'string') {
      throw new Error(
        `Notification must be created with string message: ${this.message}`
      );
    }

    if (!_.isObject(this.options) || Array.isArray(this.options)) {
      throw new Error(
        `Notification must be created with an options object: ${this.options}`
      );
    }
  }

  /*
  Section: Event Subscription
  */

  // Public: Invoke the given callback when the notification is dismissed.
  //
  // * `callback` {Function} to be called when the notification is dismissed.
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  onDidDismiss(callback) {
    return this.emitter.on('did-dismiss', callback);
  }

  // Public: Invoke the given callback when the notification is displayed.
  //
  // * `callback` {Function} to be called when the notification is displayed.
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  onDidDisplay(callback) {
    return this.emitter.on('did-display', callback);
  }

  getOptions() {
    return this.options;
  }

  /*
  Section: Methods
  */

  // Public: Returns the {String} type.
  getType() {
    return this.type;
  }

  // Public: Returns the {String} message.
  getMessage() {
    return this.message;
  }

  getTimestamp() {
    return this.timestamp;
  }

  getDetail() {
    return this.options.detail;
  }

  isEqual(other) {
    return (
      this.getMessage() === other.getMessage() &&
      this.getType() === other.getType() &&
      this.getDetail() === other.getDetail()
    );
  }

  // Extended: Dismisses the notification, removing it from the UI. Calling this
  // programmatically will call all callbacks added via `onDidDismiss`.
  dismiss() {
    if (!this.isDismissable() || this.isDismissed()) return;
    this.dismissed = true;
    this.emitter.emit('did-dismiss', this);
  }

  isDismissed() {
    return this.dismissed;
  }

  isDismissable() {
    return !!this.options.dismissable;
  }

  wasDisplayed() {
    return this.displayed;
  }

  setDisplayed(displayed) {
    this.displayed = displayed;
    this.emitter.emit('did-display', this);
  }

  getIcon() {
    if (this.options.icon != null) return this.options.icon;
    switch (this.type) {
      case 'fatal':
        return 'bug';
      case 'error':
        return 'flame';
      case 'warning':
        return 'alert';
      case 'info':
        return 'info';
      case 'success':
        return 'check';
    }
  }
};

================
File: src/package-manager.js
================
const path = require('path');
let normalizePackageData = null;

const _ = require('underscore-plus');
const { Emitter } = require('event-kit');
const fs = require('fs-plus');
const CSON = require('season');

const ServiceHub = require('service-hub');
const Package = require('./package');
const ThemePackage = require('./theme-package');
const ModuleCache = require('./module-cache');
const packageJSON = require('../package.json');

// Extended: Package manager for coordinating the lifecycle of Pulsar packages.
//
// An instance of this class is always available as the `atom.packages` global.
//
// Packages can be loaded, activated, and deactivated, and unloaded:
//  * Loading a package reads and parses the package's metadata and resources
//    such as keymaps, menus, stylesheets, etc.
//  * Activating a package registers the loaded resources and calls `activate()`
//    on the package's main module.
//  * Deactivating a package unregisters the package's resources  and calls
//    `deactivate()` on the package's main module.
//  * Unloading a package removes it completely from the package manager.
//
// Packages can be enabled/disabled via the `core.disabledPackages` config
// settings and also by calling `enablePackage()/disablePackage()`.
module.exports = class PackageManager {
  constructor(params) {
    ({
      config: this.config,
      styleManager: this.styleManager,
      notificationManager: this.notificationManager,
      keymapManager: this.keymapManager,
      commandRegistry: this.commandRegistry,
      grammarRegistry: this.grammarRegistry,
      deserializerManager: this.deserializerManager,
      viewRegistry: this.viewRegistry,
      uriHandlerRegistry: this.uriHandlerRegistry
    } = params);

    this.emitter = new Emitter();
    this.activationHookEmitter = new Emitter();
    this.packageDirPaths = [];
    this.deferredActivationHooks = [];
    this.triggeredActivationHooks = new Set();
    this.packagesCache =
      packageJSON._atomPackages != null ? packageJSON._atomPackages : {};
    this.packageDependencies =
      packageJSON.packageDependencies != null
        ? packageJSON.packageDependencies
        : {};
    this.initialPackagesLoaded = false;
    this.initialPackagesActivated = false;
    this.preloadedPackages = {};
    this.loadedPackages = {};
    this.activePackages = {};
    this.activatingPackages = {};
    this.packageStates = {};
    this.serviceHub = new ServiceHub();

    this.packageActivators = [];
    this.registerPackageActivator(this, ['atom', 'textmate']);
  }

  initialize(params) {
    this.devMode = params.devMode;
    this.resourcePath = params.resourcePath;
    if (params.configDirPath != null && !params.safeMode) {
      if (this.devMode) {
        this.packageDirPaths.push(
          path.join(params.configDirPath, 'dev', 'packages')
        );
        this.packageDirPaths.push(path.join(this.resourcePath, 'packages'));
      }
      this.packageDirPaths.push(path.join(params.configDirPath, 'packages'));
    }
  }

  setContextMenuManager(contextMenuManager) {
    this.contextMenuManager = contextMenuManager;
  }

  setMenuManager(menuManager) {
    this.menuManager = menuManager;
  }

  setThemeManager(themeManager) {
    this.themeManager = themeManager;
  }

  async reset() {
    this.serviceHub.clear();
    await this.deactivatePackages();
    this.loadedPackages = {};
    this.preloadedPackages = {};
    this.packageStates = {};
    this.packagesCache =
      packageJSON._atomPackages != null ? packageJSON._atomPackages : {};
    this.packageDependencies =
      packageJSON.packageDependencies != null
        ? packageJSON.packageDependencies
        : {};
    this.triggeredActivationHooks.clear();
    this.activatePromise = null;
  }

  /*
  Section: Event Subscription
  */

  // Public: Invoke the given callback when all packages have been loaded.
  //
  // * `callback` {Function}
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  onDidLoadInitialPackages(callback) {
    return this.emitter.on('did-load-initial-packages', callback);
  }

  // Public: Invoke the given callback when all packages have been activated.
  //
  // * `callback` {Function}
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  onDidActivateInitialPackages(callback) {
    return this.emitter.on('did-activate-initial-packages', callback);
  }

  getActivatePromise() {
    if (this.activatePromise) {
      return this.activatePromise;
    } else {
      return Promise.resolve();
    }
  }

  // Public: Invoke the given callback when a package is activated.
  //
  // * `callback` A {Function} to be invoked when a package is activated.
  //   * `package` The {Package} that was activated.
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  onDidActivatePackage(callback) {
    return this.emitter.on('did-activate-package', callback);
  }

  // Public: Invoke the given callback when a package is deactivated.
  //
  // * `callback` A {Function} to be invoked when a package is deactivated.
  //   * `package` The {Package} that was deactivated.
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  onDidDeactivatePackage(callback) {
    return this.emitter.on('did-deactivate-package', callback);
  }

  // Public: Invoke the given callback when a package is loaded.
  //
  // * `callback` A {Function} to be invoked when a package is loaded.
  //   * `package` The {Package} that was loaded.
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  onDidLoadPackage(callback) {
    return this.emitter.on('did-load-package', callback);
  }

  // Public: Invoke the given callback when a package is unloaded.
  //
  // * `callback` A {Function} to be invoked when a package is unloaded.
  //   * `package` The {Package} that was unloaded.
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  onDidUnloadPackage(callback) {
    return this.emitter.on('did-unload-package', callback);
  }

  static possibleApmPaths(configPath) {
    if (process.env.APM_PATH || configPath) {
      return process.env.APM_PATH || configPath;
    }

    const commandName = process.platform === 'win32' ? 'apm.cmd' : 'apm';
    const bundledPPMRoot = path.join(process.resourcesPath, 'app', 'ppm', 'bin', commandName);
    const unbundledPPMRoot = path.join(__dirname, '..', 'ppm', 'bin', commandName);

    if (fs.isFileSync(bundledPPMRoot)) {
      return bundledPPMRoot;
    } else {
      return unbundledPPMRoot;
    }
  }

  /*
  Section: Package system data
  */

  // Public: Get the path to the apm command.
  //
  // Uses the value of the `core.apmPath` config setting if it exists.
  //
  // Return a {String} file path to apm.
  getApmPath() {
    const configPath = atom.config.get('core.apmPath');
    if (configPath || this.apmPath) {
      return configPath || this.apmPath;
    } else {
       this.apmPath = PackageManager.possibleApmPaths();
       return this.apmPath
    }
  }

  // Public: Get the paths being used to look for packages.
  //
  // Returns an {Array} of {String} directory paths.
  getPackageDirPaths() {
    return _.clone(this.packageDirPaths);
  }

  /*
  Section: General package data
  */

  // Public: Resolve the given package name to a path on disk.
  //
  // * `name` - The {String} package name.
  //
  // Return a {String} folder path or undefined if it could not be resolved.
  resolvePackagePath(name) {
    if (fs.isDirectorySync(name)) {
      return name;
    }

    let packagePath = fs.resolve(...this.packageDirPaths, name);
    if (fs.isDirectorySync(packagePath)) {
      return packagePath;
    }

    packagePath = path.join(this.resourcePath, 'node_modules', name);
    if (this.hasAtomEngine(packagePath)) {
      return packagePath;
    }

    return null;
  }

  // Public: Is the package with the given name bundled with Pulsar?
  //
  // * `name` - The {String} package name.
  //
  // Returns a {Boolean}.
  isBundledPackage(name) {
    return this.getPackageDependencies().hasOwnProperty(name);
  }

  /*
  Section: Enabling and disabling packages
  */

  // Public: Enable the package with the given name.
  //
  // * `name` - The {String} package name.
  //
  // Returns the {Package} that was enabled or null if it isn't loaded.
  enablePackage(name) {
    const pack = this.loadPackage(name);
    if (pack != null) {
      pack.enable();
    }
    return pack;
  }

  // Public: Disable the package with the given name.
  //
  // * `name` - The {String} package name.
  //
  // Returns the {Package} that was disabled or null if it isn't loaded.
  disablePackage(name) {
    const pack = this.loadPackage(name);
    if (!this.isPackageDisabled(name) && pack != null) {
      pack.disable();
    }
    return pack;
  }

  // Public: Is the package with the given name disabled?
  //
  // * `name` - The {String} package name.
  //
  // Returns a {Boolean}.
  isPackageDisabled(name) {
    return _.include(this.config.get('core.disabledPackages') || [], name);
  }

  /*
  Section: Accessing active packages
  */

  // Public: Get an {Array} of all the active {Package}s.
  getActivePackages() {
    return _.values(this.activePackages);
  }

  // Public: Get the active {Package} with the given name.
  //
  // * `name` - The {String} package name.
  //
  // Returns a {Package} or undefined.
  getActivePackage(name) {
    return this.activePackages[name];
  }

  // Public: Is the {Package} with the given name active?
  //
  // * `name` - The {String} package name.
  //
  // Returns a {Boolean}.
  isPackageActive(name) {
    return this.getActivePackage(name) != null;
  }

  // Public: Returns a {Boolean} indicating whether package activation has occurred.
  hasActivatedInitialPackages() {
    return this.initialPackagesActivated;
  }

  /*
  Section: Accessing loaded packages
  */

  // Public: Get an {Array} of all the loaded {Package}s
  getLoadedPackages() {
    return _.values(this.loadedPackages);
  }

  // Get packages for a certain package type
  //
  // * `types` an {Array} of {String}s like ['atom', 'textmate'].
  getLoadedPackagesForTypes(types) {
    return this.getLoadedPackages().filter(p => types.includes(p.getType()));
  }

  // Public: Get the loaded {Package} with the given name.
  //
  // * `name` - The {String} package name.
  //
  // Returns a {Package} or undefined.
  getLoadedPackage(name) {
    return this.loadedPackages[name];
  }

  // Public: Is the package with the given name loaded?
  //
  // * `name` - The {String} package name.
  //
  // Returns a {Boolean}.
  isPackageLoaded(name) {
    return this.getLoadedPackage(name) != null;
  }

  // Public: Returns a {Boolean} indicating whether package loading has occurred.
  hasLoadedInitialPackages() {
    return this.initialPackagesLoaded;
  }

  /*
  Section: Accessing available packages
  */

  // Public: Returns an {Array} of {String}s of all the available package paths.
  getAvailablePackagePaths() {
    return this.getAvailablePackages().map(a => a.path);
  }

  // Public: Returns an {Array} of {String}s of all the available package names.
  getAvailablePackageNames() {
    return this.getAvailablePackages().map(a => a.name);
  }

  // Public: Returns an {Array} of {String}s of all the available package metadata.
  getAvailablePackageMetadata() {
    const packages = [];
    for (const pack of this.getAvailablePackages()) {
      const loadedPackage = this.getLoadedPackage(pack.name);
      const metadata =
        loadedPackage != null
          ? loadedPackage.metadata
          : this.loadPackageMetadata(pack, true);
      packages.push(metadata);
    }
    return packages;
  }

  getAvailablePackages() {
    const packages = [];
    const packagesByName = new Set();

    for (const packageDirPath of this.packageDirPaths) {
      if (fs.isDirectorySync(packageDirPath)) {
        // checks for directories.
        // dirent is faster, but for checking symbolic link we need stat.
        const packageNames = fs
          .readdirSync(packageDirPath, { withFileTypes: true })
          .filter(
            dirent =>
              dirent.isDirectory() ||
              (dirent.isSymbolicLink() &&
                fs.isDirectorySync(path.join(packageDirPath, dirent.name)))
          )
          .map(dirent => dirent.name);

        for (const packageName of packageNames) {
          if (
            !packageName.startsWith('.') &&
            !packagesByName.has(packageName)
          ) {
            const packagePath = path.join(packageDirPath, packageName);
            packages.push({
              name: packageName,
              path: packagePath,
              isBundled: false
            });
            packagesByName.add(packageName);
          }
        }
      }
    }

    for (const packageName in this.packageDependencies) {
      if (!packagesByName.has(packageName)) {
        packages.push({
          name: packageName,
          path: path.join(this.resourcePath, 'node_modules', packageName),
          isBundled: true
        });
      }
    }

    return packages.sort((a, b) => a.name.localeCompare(b.name));
  }

  /*
  Section: Private
  */

  getPackageState(name) {
    return this.packageStates[name];
  }

  setPackageState(name, state) {
    this.packageStates[name] = state;
  }

  getPackageDependencies() {
    return this.packageDependencies;
  }

  hasAtomEngine(packagePath) {
    const metadata = this.loadPackageMetadata(packagePath, true);
    return (
      metadata != null &&
      metadata.engines != null &&
      metadata.engines.atom != null
    );
  }

  unobserveDisabledPackages() {
    if (this.disabledPackagesSubscription != null) {
      this.disabledPackagesSubscription.dispose();
    }
    this.disabledPackagesSubscription = null;
  }

  observeDisabledPackages() {
    if (this.disabledPackagesSubscription != null) {
      return;
    }

    this.disabledPackagesSubscription = this.config.onDidChange(
      'core.disabledPackages',
      ({ newValue, oldValue }) => {
        const packagesToEnable = _.difference(oldValue, newValue);
        const packagesToDisable = _.difference(newValue, oldValue);
        packagesToDisable.forEach(name => {
          if (this.getActivePackage(name)) this.deactivatePackage(name);
        });
        packagesToEnable.forEach(name => this.activatePackage(name));
        return null;
      }
    );
  }

  unobservePackagesWithKeymapsDisabled() {
    if (this.packagesWithKeymapsDisabledSubscription != null) {
      this.packagesWithKeymapsDisabledSubscription.dispose();
    }
    this.packagesWithKeymapsDisabledSubscription = null;
  }

  observePackagesWithKeymapsDisabled() {
    if (this.packagesWithKeymapsDisabledSubscription != null) {
      return;
    }

    const performOnLoadedActivePackages = (
      packageNames,
      disabledPackageNames,
      action
    ) => {
      for (const packageName of packageNames) {
        if (!disabledPackageNames.has(packageName)) {
          const pack = this.getLoadedPackage(packageName);
          if (pack != null) {
            action(pack);
          }
        }
      }
    };

    this.packagesWithKeymapsDisabledSubscription = this.config.onDidChange(
      'core.packagesWithKeymapsDisabled',
      ({ newValue, oldValue }) => {
        const keymapsToEnable = _.difference(oldValue, newValue);
        const keymapsToDisable = _.difference(newValue, oldValue);

        const disabledPackageNames = new Set(
          this.config.get('core.disabledPackages')
        );
        performOnLoadedActivePackages(
          keymapsToDisable,
          disabledPackageNames,
          p => p.deactivateKeymaps()
        );
        performOnLoadedActivePackages(
          keymapsToEnable,
          disabledPackageNames,
          p => p.activateKeymaps()
        );
        return null;
      }
    );
  }

  preloadPackages() {
    const result = [];
    for (const packageName in this.packagesCache) {
      result.push(
        this.preloadPackage(packageName, this.packagesCache[packageName])
      );
    }
    return result;
  }

  preloadPackage(packageName, pack) {
    const metadata = pack.metadata || {};
    if (typeof metadata.name !== 'string' || metadata.name.length < 1) {
      metadata.name = packageName;
    }

    if (
      metadata.repository != null &&
      metadata.repository.type === 'git' &&
      typeof metadata.repository.url === 'string'
    ) {
      metadata.repository.url = metadata.repository.url.replace(
        /(^git\+)|(\.git$)/g,
        ''
      );
    }

    const options = {
      path: pack.rootDirPath,
      name: packageName,
      preloadedPackage: true,
      bundledPackage: true,
      metadata,
      packageManager: this,
      config: this.config,
      styleManager: this.styleManager,
      commandRegistry: this.commandRegistry,
      keymapManager: this.keymapManager,
      notificationManager: this.notificationManager,
      grammarRegistry: this.grammarRegistry,
      themeManager: this.themeManager,
      menuManager: this.menuManager,
      contextMenuManager: this.contextMenuManager,
      deserializerManager: this.deserializerManager,
      viewRegistry: this.viewRegistry
    };

    pack = metadata.theme ? new ThemePackage(options) : new Package(options);
    pack.preload();
    this.preloadedPackages[packageName] = pack;
    return pack;
  }

  loadPackages() {
    // Ensure atom exports is already in the require cache so the load time
    // of the first package isn't skewed by being the first to require atom
    require('../exports/atom');

    const disabledPackageNames = new Set(
      this.config.get('core.disabledPackages')
    );
    this.config.transact(() => {
      for (const pack of this.getAvailablePackages()) {
        this.loadAvailablePackage(pack, disabledPackageNames);
      }
    });
    this.initialPackagesLoaded = true;
    this.emitter.emit('did-load-initial-packages');
  }

  loadPackage(nameOrPath) {
    if (path.basename(nameOrPath)[0].match(/^\./)) {
      // primarily to skip .git folder
      return null;
    }

    const pack = this.getLoadedPackage(nameOrPath);
    if (pack) {
      return pack;
    }

    const packagePath = this.resolvePackagePath(nameOrPath);
    if (packagePath) {
      const name = path.basename(nameOrPath);
      return this.loadAvailablePackage({
        name,
        path: packagePath,
        isBundled: this.isBundledPackagePath(packagePath)
      });
    }

    console.warn(`Could not resolve '${nameOrPath}' to a package path`);
    return null;
  }

  loadAvailablePackage(availablePackage, disabledPackageNames) {
    const preloadedPackage = this.preloadedPackages[availablePackage.name];

    if (
      disabledPackageNames != null &&
      disabledPackageNames.has(availablePackage.name)
    ) {
      if (preloadedPackage != null) {
        preloadedPackage.deactivate();
        delete preloadedPackage[availablePackage.name];
      }
      return null;
    }

    const loadedPackage = this.getLoadedPackage(availablePackage.name);
    if (loadedPackage != null) {
      return loadedPackage;
    }

    if (preloadedPackage != null) {
      if (availablePackage.isBundled) {
        preloadedPackage.finishLoading();
        this.loadedPackages[availablePackage.name] = preloadedPackage;
        return preloadedPackage;
      } else {
        preloadedPackage.deactivate();
        delete preloadedPackage[availablePackage.name];
      }
    }

    let metadata;
    try {
      metadata = this.loadPackageMetadata(availablePackage) || {};
    } catch (error) {
      this.handleMetadataError(error, availablePackage.path);
      return null;
    }

    const options = {
      path: availablePackage.path,
      name: availablePackage.name,
      metadata,
      bundledPackage: availablePackage.isBundled,
      packageManager: this,
      config: this.config,
      styleManager: this.styleManager,
      commandRegistry: this.commandRegistry,
      keymapManager: this.keymapManager,
      notificationManager: this.notificationManager,
      grammarRegistry: this.grammarRegistry,
      themeManager: this.themeManager,
      menuManager: this.menuManager,
      contextMenuManager: this.contextMenuManager,
      deserializerManager: this.deserializerManager,
      viewRegistry: this.viewRegistry
    };

    const pack = metadata.theme
      ? new ThemePackage(options)
      : new Package(options);
    pack.load();
    this.loadedPackages[pack.name] = pack;
    this.emitter.emit('did-load-package', pack);
    return pack;
  }

  unloadPackages() {
    _.keys(this.loadedPackages).forEach(name => this.unloadPackage(name));
  }

  unloadPackage(name) {
    if (this.isPackageActive(name)) {
      throw new Error(`Tried to unload active package '${name}'`);
    }

    const pack = this.getLoadedPackage(name);
    if (pack) {
      delete this.loadedPackages[pack.name];
      this.emitter.emit('did-unload-package', pack);
    } else {
      throw new Error(`No loaded package for name '${name}'`);
    }
  }

  // Activate all the packages that should be activated.
  activate() {
    let promises = [];
    for (let [activator, types] of this.packageActivators) {
      const packages = this.getLoadedPackagesForTypes(types);
      promises = promises.concat(activator.activatePackages(packages));
    }
    this.activatePromise = Promise.all(promises).then(() => {
      this.triggerDeferredActivationHooks();
      this.initialPackagesActivated = true;
      this.emitter.emit('did-activate-initial-packages');
      this.activatePromise = null;
    });
    return this.activatePromise;
  }

  registerURIHandlerForPackage(packageName, handler) {
    return this.uriHandlerRegistry.registerHostHandler(packageName, handler);
  }

  // another type of package manager can handle other package types.
  // See ThemeManager
  registerPackageActivator(activator, types) {
    this.packageActivators.push([activator, types]);
  }

  activatePackages(packages) {
    const promises = [];
    this.config.transactAsync(() => {
      for (const pack of packages) {
        const promise = this.activatePackage(pack.name);
        if (!pack.activationShouldBeDeferred()) {
          promises.push(promise);
        }
      }
      return Promise.all(promises);
    });
    this.observeDisabledPackages();
    this.observePackagesWithKeymapsDisabled();
    return promises;
  }

  // Activate a single package by name
  activatePackage(name) {
    let pack = this.getActivePackage(name);
    if (pack) {
      return Promise.resolve(pack);
    }

    pack = this.loadPackage(name);
    if (!pack) {
      return Promise.reject(new Error(`Failed to load package '${name}'`));
    }

    this.activatingPackages[pack.name] = pack;
    const activationPromise = pack.activate().then(() => {
      if (this.activatingPackages[pack.name] != null) {
        delete this.activatingPackages[pack.name];
        this.activePackages[pack.name] = pack;
        this.emitter.emit('did-activate-package', pack);
      }
      return pack;
    });

    if (this.deferredActivationHooks == null) {
      this.triggeredActivationHooks.forEach(hook =>
        this.activationHookEmitter.emit(hook)
      );
    }

    return activationPromise;
  }

  triggerDeferredActivationHooks() {
    if (this.deferredActivationHooks == null) {
      return;
    }

    for (const hook of this.deferredActivationHooks) {
      this.activationHookEmitter.emit(hook);
    }

    this.deferredActivationHooks = null;
  }

  triggerActivationHook(hook) {
    if (hook == null || !_.isString(hook) || hook.length <= 0) {
      return new Error('Cannot trigger an empty activation hook');
    }

    this.triggeredActivationHooks.add(hook);
    if (this.deferredActivationHooks != null) {
      this.deferredActivationHooks.push(hook);
    } else {
      this.activationHookEmitter.emit(hook);
    }
  }

  onDidTriggerActivationHook(hook, callback) {
    if (hook == null || !_.isString(hook) || hook.length <= 0) {
      return;
    }
    return this.activationHookEmitter.on(hook, callback);
  }

  serialize() {
    for (const pack of this.getActivePackages()) {
      this.serializePackage(pack);
    }
    return this.packageStates;
  }

  serializePackage(pack) {
    if (typeof pack.serialize === 'function') {
      this.setPackageState(pack.name, pack.serialize());
    }
  }

  // Deactivate all packages
  async deactivatePackages() {
    await this.config.transactAsync(() =>
      Promise.all(
        this.getLoadedPackages().map(pack =>
          this.deactivatePackage(pack.name, true)
        )
      )
    );
    this.unobserveDisabledPackages();
    this.unobservePackagesWithKeymapsDisabled();
  }

  // Deactivate the package with the given name
  async deactivatePackage(name, suppressSerialization) {
    const pack = this.getLoadedPackage(name);
    if (pack == null) {
      return;
    }

    if (!suppressSerialization && this.isPackageActive(pack.name)) {
      this.serializePackage(pack);
    }

    const deactivationResult = pack.deactivate();
    if (deactivationResult && typeof deactivationResult.then === 'function') {
      await deactivationResult;
    }

    delete this.activePackages[pack.name];
    delete this.activatingPackages[pack.name];
    this.emitter.emit('did-deactivate-package', pack);
  }

  handleMetadataError(error, packagePath) {
    const metadataPath = path.join(packagePath, 'package.json');
    const detail = `${error.message} in ${metadataPath}`;
    const stack = `${error.stack}\n  at ${metadataPath}:1:1`;
    const message = `Failed to load the ${path.basename(packagePath)} package`;
    this.notificationManager.addError(message, {
      stack,
      detail,
      packageName: path.basename(packagePath),
      dismissable: true
    });
  }

  uninstallDirectory(directory) {
    const symlinkPromise = new Promise(resolve =>
      fs.isSymbolicLink(directory, isSymLink => resolve(isSymLink))
    );
    const dirPromise = new Promise(resolve =>
      fs.isDirectory(directory, isDir => resolve(isDir))
    );

    return Promise.all([symlinkPromise, dirPromise]).then(values => {
      const [isSymLink, isDir] = values;
      if (!isSymLink && isDir) {
        return fs.remove(directory, function() {});
      }
    });
  }

  reloadActivePackageStyleSheets() {
    for (const pack of this.getActivePackages()) {
      if (
        pack.getType() !== 'theme' &&
        typeof pack.reloadStylesheets === 'function'
      ) {
        pack.reloadStylesheets();
      }
    }
  }

  isBundledPackagePath(packagePath) {
    if (
      this.devMode &&
      !this.resourcePath.startsWith(`${process.resourcesPath}${path.sep}`)
    ) {
      return false;
    }

    if (this.resourcePathWithTrailingSlash == null) {
      this.resourcePathWithTrailingSlash = `${this.resourcePath}${path.sep}`;
    }

    return (
      packagePath != null &&
      packagePath.startsWith(this.resourcePathWithTrailingSlash)
    );
  }

  loadPackageMetadata(packagePathOrAvailablePackage, ignoreErrors = false) {
    let isBundled, packageName, packagePath;
    if (typeof packagePathOrAvailablePackage === 'object') {
      const availablePackage = packagePathOrAvailablePackage;
      packageName = availablePackage.name;
      packagePath = availablePackage.path;
      isBundled = availablePackage.isBundled;
    } else {
      packagePath = packagePathOrAvailablePackage;
      packageName = path.basename(packagePath);
      isBundled = this.isBundledPackagePath(packagePath);
    }

    let metadata;
    if (isBundled && this.packagesCache[packageName] != null) {
      metadata = this.packagesCache[packageName].metadata;
    }

    if (metadata == null) {
      const metadataPath = CSON.resolve(path.join(packagePath, 'package'));
      if (metadataPath) {
        try {
          metadata = CSON.readFileSync(metadataPath);
          this.normalizePackageMetadata(metadata);
        } catch (error) {
          if (!ignoreErrors) {
            throw error;
          }
        }
      }
    }

    if (metadata == null) {
      metadata = {};
    }

    if (typeof metadata.name !== 'string' || metadata.name.length <= 0) {
      metadata.name = packageName;
    }

    if (
      metadata.repository &&
      metadata.repository.type === 'git' &&
      typeof metadata.repository.url === 'string'
    ) {
      metadata.repository.url = metadata.repository.url.replace(
        /(^git\+)|(\.git$)/g,
        ''
      );
    }

    return metadata;
  }

  normalizePackageMetadata(metadata) {
    if (metadata != null) {
      normalizePackageData =
        normalizePackageData || require('normalize-package-data');
      normalizePackageData(metadata);
    }
  }
};

const NullVersionRange = {
  test() {
    return false;
  }
};

================
File: src/package-transpilation-registry.js
================
'use strict';
// This file is required by compile-cache, which is required directly from
// apm, so it can only use the subset of newer JavaScript features that apm's
// version of Node supports. Strict mode is required for block scoped declarations.

const crypto = require('crypto');
const fs = require('fs');
const path = require('path');

const minimatch = require('minimatch');

let Resolve = null;

class PackageTranspilationRegistry {
  constructor() {
    this.configByPackagePath = {};
    this.specByFilePath = {};
    this.transpilerPaths = {};
  }

  addTranspilerConfigForPath(packagePath, packageName, packageMeta, config) {
    this.configByPackagePath[packagePath] = {
      name: packageName,
      meta: packageMeta,
      path: packagePath,
      specs: config.map(spec => Object.assign({}, spec))
    };
  }

  removeTranspilerConfigForPath(packagePath) {
    delete this.configByPackagePath[packagePath];
    const packagePathWithSep = packagePath.endsWith(path.sep)
      ? path.join(packagePath)
      : path.join(packagePath) + path.sep;
    Object.keys(this.specByFilePath).forEach(filePath => {
      if (path.join(filePath).startsWith(packagePathWithSep)) {
        delete this.specByFilePath[filePath];
      }
    });
  }

  // Wraps the transpiler in an object with the same interface
  // that falls back to the original transpiler implementation if and
  // only if a package hasn't registered its desire to transpile its own source.
  wrapTranspiler(transpiler) {
    return {
      getCachePath: (sourceCode, filePath) => {
        const spec = this.getPackageTranspilerSpecForFilePath(filePath);
        if (spec) {
          return this.getCachePath(sourceCode, filePath, spec);
        }

        return transpiler.getCachePath(sourceCode, filePath);
      },

      compile: (sourceCode, filePath) => {
        const spec = this.getPackageTranspilerSpecForFilePath(filePath);
        if (spec) {
          return this.transpileWithPackageTranspiler(
            sourceCode,
            filePath,
            spec
          );
        }

        return transpiler.compile(sourceCode, filePath);
      },

      shouldCompile: (sourceCode, filePath) => {
        if (this.transpilerPaths[filePath]) {
          return false;
        }
        const spec = this.getPackageTranspilerSpecForFilePath(filePath);
        if (spec) {
          return true;
        }

        return transpiler.shouldCompile(sourceCode, filePath);
      }
    };
  }

  getPackageTranspilerSpecForFilePath(filePath) {
    if (this.specByFilePath[filePath] !== undefined)
      return this.specByFilePath[filePath];

    let thisPath = filePath;
    let lastPath = null;
    // Iterate parents from the file path to the root, checking at each level
    // to see if a package manages transpilation for that directory.
    // This means searching for a config for `/path/to/file/here.js` only
    // only iterates four times, even if there are hundreds of configs registered.
    while (thisPath !== lastPath) {
      // until we reach the root
      let config = this.configByPackagePath[thisPath];
      if (config) {
        const relativePath = path.relative(thisPath, filePath);
        if (
          relativePath.startsWith(`node_modules${path.sep}`) ||
          relativePath.indexOf(`${path.sep}node_modules${path.sep}`) > -1
        ) {
          return false;
        }
        for (let i = 0; i < config.specs.length; i++) {
          const spec = config.specs[i];
          if (minimatch(filePath, path.join(config.path, spec.glob))) {
            spec._config = config;
            this.specByFilePath[filePath] = spec;
            return spec;
          }
        }
      }

      lastPath = thisPath;
      thisPath = path.join(thisPath, '..');
    }

    this.specByFilePath[filePath] = null;
    return null;
  }

  getCachePath(sourceCode, filePath, spec) {
    const transpilerPath = this.getTranspilerPath(spec);
    const transpilerSource =
      spec._transpilerSource || fs.readFileSync(transpilerPath, 'utf8');
    spec._transpilerSource = transpilerSource;
    const transpiler = this.getTranspiler(spec);

    let hash = crypto
      .createHash('sha1')
      .update(JSON.stringify(spec.options || {}))
      .update(transpilerSource, 'utf8')
      .update(sourceCode, 'utf8');

    if (transpiler && transpiler.getCacheKeyData) {
      const meta = this.getMetadata(spec);
      const additionalCacheData = transpiler.getCacheKeyData(
        sourceCode,
        filePath,
        spec.options || {},
        meta
      );
      hash.update(additionalCacheData, 'utf8');
    }

    return path.join(
      'package-transpile',
      spec._config.name,
      hash.digest('hex')
    );
  }

  transpileWithPackageTranspiler(sourceCode, filePath, spec) {
    const transpiler = this.getTranspiler(spec);

    if (transpiler) {
      const meta = this.getMetadata(spec);
      const result = transpiler.transpile(
        sourceCode,
        filePath,
        spec.options || {},
        meta
      );
      if (result === undefined || (result && result.code === undefined)) {
        return sourceCode;
      } else if (result.code) {
        return result.code.toString();
      } else {
        throw new Error(
          'Could not find a property `.code` on the transpilation results of ' +
            filePath
        );
      }
    } else {
      const err = new Error(
        "Could not resolve transpiler '" +
          spec.transpiler +
          "' from '" +
          spec._config.path +
          "'"
      );
      throw err;
    }
  }

  getMetadata(spec) {
    return {
      name: spec._config.name,
      path: spec._config.path,
      meta: spec._config.meta
    };
  }

  getTranspilerPath(spec) {
    Resolve = Resolve || require('resolve');
    return Resolve.sync(spec.transpiler, {
      basedir: spec._config.path,
      extensions: Object.keys(require.extensions)
    });
  }

  getTranspiler(spec) {
    const transpilerPath = this.getTranspilerPath(spec);
    if (transpilerPath) {
      const transpiler = require(transpilerPath);
      this.transpilerPaths[transpilerPath] = true;
      return transpiler;
    }
  }
}

module.exports = PackageTranspilationRegistry;

================
File: src/package.js
================
const path = require('path');
const asyncEach = require('async/each');
const CSON = require('season');
const fs = require('fs-plus');
const { Emitter, CompositeDisposable } = require('event-kit');
const dedent = require('dedent');

const CompileCache = require('./compile-cache');
const ModuleCache = require('./module-cache');
const BufferedProcess = require('./buffered-process');
const { requireModule } = require('./module-utils');

// Extended: Loads and activates a package's main module and resources such as
// stylesheets, keymaps, grammar, editor properties, and menus.
module.exports = class Package {
  /*
  Section: Construction
  */

  constructor(params) {
    this.config = params.config;
    this.packageManager = params.packageManager;
    this.styleManager = params.styleManager;
    this.commandRegistry = params.commandRegistry;
    this.keymapManager = params.keymapManager;
    this.notificationManager = params.notificationManager;
    this.grammarRegistry = params.grammarRegistry;
    this.themeManager = params.themeManager;
    this.menuManager = params.menuManager;
    this.contextMenuManager = params.contextMenuManager;
    this.deserializerManager = params.deserializerManager;
    this.viewRegistry = params.viewRegistry;
    this.emitter = new Emitter();

    this.mainModule = null;
    this.path = params.path;
    this.preloadedPackage = params.preloadedPackage;
    this.metadata =
      params.metadata || this.packageManager.loadPackageMetadata(this.path);
    this.bundledPackage =
      params.bundledPackage != null
        ? params.bundledPackage
        : this.packageManager.isBundledPackagePath(this.path);
    this.name =
      (this.metadata && this.metadata.name) ||
      params.name ||
      path.basename(this.path);
    this.reset();
  }

  /*
  Section: Event Subscription
  */

  // Essential: Invoke the given callback when all packages have been activated.
  //
  // * `callback` {Function}
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  onDidDeactivate(callback) {
    return this.emitter.on('did-deactivate', callback);
  }

  /*
  Section: Instance Methods
  */

  enable() {
    return this.config.removeAtKeyPath('core.disabledPackages', this.name);
  }

  disable() {
    return this.config.pushAtKeyPath('core.disabledPackages', this.name);
  }

  isTheme() {
    return this.metadata && this.metadata.theme;
  }

  measure(key, fn) {
    const startTime = window.performance.now();
    const value = fn();
    this[key] = Math.round(window.performance.now() - startTime);
    return value;
  }

  getType() {
    return 'atom';
  }

  getStyleSheetPriority() {
    return 0;
  }

  preload() {
    this.loadKeymaps();
    this.loadMenus();
    this.registerDeserializerMethods();
    this.activateCoreStartupServices();
    this.registerURIHandler();
    this.configSchemaRegisteredOnLoad = this.registerConfigSchemaFromMetadata();
    this.requireMainModule();
    this.settingsPromise = this.loadSettings();

    this.activationDisposables = new CompositeDisposable();
    this.activateKeymaps();
    this.activateMenus();
    for (let settings of this.settings) {
      settings.activate(this.config);
    }
    this.settingsActivated = true;
  }

  finishLoading() {
    this.measure('loadTime', () => {
      this.path = path.join(this.packageManager.resourcePath, this.path);
      ModuleCache.add(this.path, this.metadata);

      this.loadStylesheets();
      // Unfortunately some packages are accessing `@mainModulePath`, so we need
      // to compute that variable eagerly also for preloaded packages.
      this.getMainModulePath();
    });
  }

  load() {
    this.measure('loadTime', () => {
      try {
        ModuleCache.add(this.path, this.metadata);

        this.loadKeymaps();
        this.loadMenus();
        this.loadStylesheets();
        this.registerDeserializerMethods();
        this.activateCoreStartupServices();
        this.registerURIHandler();
        this.registerTranspilerConfig();
        this.configSchemaRegisteredOnLoad = this.registerConfigSchemaFromMetadata();
        this.settingsPromise = this.loadSettings();
        if (this.shouldRequireMainModuleOnLoad() && this.mainModule == null) {
          this.requireMainModule();
        }
      } catch (error) {
        this.handleError(`Failed to load the ${this.name} package`, error);
      }
    });
    return this;
  }

  unload() {
    this.unregisterTranspilerConfig();
  }

  shouldRequireMainModuleOnLoad() {
    return !(
      this.metadata.deserializers ||
      this.metadata.viewProviders ||
      this.metadata.configSchema ||
      this.activationShouldBeDeferred() ||
      localStorage.getItem(this.getCanDeferMainModuleRequireStorageKey()) ===
        'true'
    );
  }

  reset() {
    this.stylesheets = [];
    this.keymaps = [];
    this.menus = [];
    this.grammars = [];
    this.settings = [];
    this.mainInitialized = false;
    this.mainActivated = false;
    this.deserialized = false;
  }

  initializeIfNeeded() {
    if (this.mainInitialized) return;
    this.measure('initializeTime', () => {
      try {
        // The main module's `initialize()` method is guaranteed to be called
        // before its `activate()`. This gives you a chance to handle the
        // serialized package state before the package's derserializers and view
        // providers are used.
        if (!this.mainModule) this.requireMainModule();
        if (typeof this.mainModule.initialize === 'function') {
          this.mainModule.initialize(
            this.packageManager.getPackageState(this.name) || {}
          );
        }
        this.mainInitialized = true;
      } catch (error) {
        this.handleError(
          `Failed to initialize the ${this.name} package`,
          error
        );
      }
    });
  }

  activate() {
    if (!this.grammarsPromise) this.grammarsPromise = this.loadGrammars();
    if (!this.activationPromise) {
      this.activationPromise = new Promise((resolve, reject) => {
        this.resolveActivationPromise = resolve;
        this.measure('activateTime', () => {
          try {
            this.activateResources();
            if (this.activationShouldBeDeferred()) {
              return this.subscribeToDeferredActivation();
            } else {
              return this.activateNow();
            }
          } catch (error) {
            return this.handleError(
              `Failed to activate the ${this.name} package`,
              error
            );
          }
        });
      });
    }

    return Promise.all([
      this.grammarsPromise,
      this.settingsPromise,
      this.activationPromise
    ]);
  }

  activateNow() {
    try {
      if (!this.mainModule) this.requireMainModule();
      this.configSchemaRegisteredOnActivate = this.registerConfigSchemaFromMainModule();
      this.registerViewProviders();
      this.activateStylesheets();
      if (this.mainModule && !this.mainActivated) {
        this.initializeIfNeeded();
        if (typeof this.mainModule.activateConfig === 'function') {
          this.mainModule.activateConfig();
        }
        if (typeof this.mainModule.activate === 'function') {
          this.mainModule.activate(
            this.packageManager.getPackageState(this.name) || {}
          );
        }
        this.mainActivated = true;
        this.activateServices();
      }
      if (this.activationCommandSubscriptions)
        this.activationCommandSubscriptions.dispose();
      if (this.activationHookSubscriptions)
        this.activationHookSubscriptions.dispose();
      if (this.workspaceOpenerSubscriptions)
        this.workspaceOpenerSubscriptions.dispose();
    } catch (error) {
      this.handleError(`Failed to activate the ${this.name} package`, error);
    }

    if (typeof this.resolveActivationPromise === 'function')
      this.resolveActivationPromise();
  }

  registerConfigSchemaFromMetadata() {
    const configSchema = this.metadata.configSchema;
    if (configSchema) {
      this.config.setSchema(this.name, {
        type: 'object',
        properties: configSchema
      });
      return true;
    } else {
      return false;
    }
  }

  registerConfigSchemaFromMainModule() {
    if (this.mainModule && !this.configSchemaRegisteredOnLoad) {
      if (typeof this.mainModule.config === 'object') {
        this.config.setSchema(this.name, {
          type: 'object',
          properties: this.mainModule.config
        });
        return true;
      }
    }
    return false;
  }

  // TODO: Remove. Settings view calls this method currently.
  activateConfig() {
    if (this.configSchemaRegisteredOnLoad) return;
    this.requireMainModule();
    this.registerConfigSchemaFromMainModule();
  }

  activateStylesheets() {
    if (this.stylesheetsActivated) return;

    this.stylesheetDisposables = new CompositeDisposable();

    const priority = this.getStyleSheetPriority();
    for (let [sourcePath, source] of this.stylesheets) {
      const match = path.basename(sourcePath).match(/[^.]*\.([^.]*)\./);

      let context;
      if (match) {
        context = match[1];
      } else if (this.metadata.theme === 'syntax') {
        context = 'atom-text-editor';
      }

      this.stylesheetDisposables.add(
        this.styleManager.addStyleSheet(source, {
          sourcePath,
          priority,
          context,
          skipDeprecatedSelectorsTransformation:
            this.bundledPackage ? this.bundledPackage : !this.config.get("core.transformDeprecatedStyleSheetSelectors"),
          skipDeprecatedMathUsageTransformation:
            this.bundledPackage ? this.bundledPackage : !this.config.get("core.transformDeprecatedStyleSheetMathExpressions")
        })
      );
    }

    this.stylesheetsActivated = true;
  }

  activateResources() {
    if (!this.activationDisposables)
      this.activationDisposables = new CompositeDisposable();

    const packagesWithKeymapsDisabled = this.config.get(
      'core.packagesWithKeymapsDisabled'
    );
    if (
      packagesWithKeymapsDisabled &&
      packagesWithKeymapsDisabled.includes(this.name)
    ) {
      this.deactivateKeymaps();
    } else if (!this.keymapActivated) {
      this.activateKeymaps();
    }

    if (!this.menusActivated) {
      this.activateMenus();
    }

    if (!this.grammarsActivated) {
      for (let grammar of this.grammars) {
        grammar.activate();
      }
      this.grammarsActivated = true;
    }

    if (!this.settingsActivated) {
      for (let settings of this.settings) {
        settings.activate(this.config);
      }
      this.settingsActivated = true;
    }
  }

  activateKeymaps() {
    if (this.keymapActivated) return;

    this.keymapDisposables = new CompositeDisposable();

    const validateSelectors = !this.preloadedPackage;
    for (let [keymapPath, map] of this.keymaps) {
      this.keymapDisposables.add(
        this.keymapManager.add(keymapPath, map, 0, validateSelectors)
      );
    }
    this.menuManager.update();

    this.keymapActivated = true;
  }

  deactivateKeymaps() {
    if (!this.keymapActivated) return;
    if (this.keymapDisposables) {
      this.keymapDisposables.dispose();
    }
    this.menuManager.update();
    this.keymapActivated = false;
  }

  hasKeymaps() {
    for (let [, map] of this.keymaps) {
      if (map.length > 0) return true;
    }
    return false;
  }

  activateMenus() {
    const validateSelectors = !this.preloadedPackage;
    for (const [menuPath, map] of this.menus) {
      if (map['context-menu']) {
        try {
          const itemsBySelector = map['context-menu'];
          this.activationDisposables.add(
            this.contextMenuManager.add(itemsBySelector, validateSelectors)
          );
        } catch (error) {
          if (error.code === 'EBADSELECTOR') {
            error.message += ` in ${menuPath}`;
            error.stack += `\n  at ${menuPath}:1:1`;
          }
          throw error;
        }
      }
    }

    for (const [, map] of this.menus) {
      if (map.menu)
        this.activationDisposables.add(this.menuManager.add(map.menu));
    }

    this.menusActivated = true;
  }

  activateServices() {
    let methodName, version, versions;
    for (var name in this.metadata.providedServices) {
      ({ versions } = this.metadata.providedServices[name]);
      const servicesByVersion = {};
      for (version in versions) {
        methodName = versions[version];
        if (typeof this.mainModule[methodName] === 'function') {
          servicesByVersion[version] = this.mainModule[methodName]();
        } else {
          console.warn(`Package ${this.name} declares it provides ${name}@${version} but it doesn't expose a function in ${methodName}`)
        }
      }
      this.activationDisposables.add(
        this.packageManager.serviceHub.provide(name, servicesByVersion)
      );
    }

    for (name in this.metadata.consumedServices) {
      ({ versions } = this.metadata.consumedServices[name]);
      for (version in versions) {
        methodName = versions[version];
        if (typeof this.mainModule[methodName] === 'function') {
          this.activationDisposables.add(
            this.packageManager.serviceHub.consume(
              name,
              version,
              this.mainModule[methodName].bind(this.mainModule)
            )
          );
        } else {
          console.warn(`Package ${this.name} declares it consumes ${name}@${version} but it doesn't expose a function in ${methodName}`)
        }
      }
    }
  }

  registerURIHandler() {
    const handlerConfig = this.getURIHandler();
    const methodName = handlerConfig && handlerConfig.method;
    if (methodName) {
      this.uriHandlerSubscription = this.packageManager.registerURIHandlerForPackage(
        this.name,
        (...args) => this.handleURI(methodName, args)
      );
    }
  }

  unregisterURIHandler() {
    if (this.uriHandlerSubscription) this.uriHandlerSubscription.dispose();
  }

  handleURI(methodName, args) {
    this.activate().then(() => {
      if (this.mainModule[methodName])
        this.mainModule[methodName].apply(this.mainModule, args);
    });
    if (!this.mainActivated) this.activateNow();
  }

  registerTranspilerConfig() {
    if (this.metadata.atomTranspilers) {
      CompileCache.addTranspilerConfigForPath(
        this.path,
        this.name,
        this.metadata,
        this.metadata.atomTranspilers
      );
    }
  }

  unregisterTranspilerConfig() {
    if (this.metadata.atomTranspilers) {
      CompileCache.removeTranspilerConfigForPath(this.path);
    }
  }

  loadKeymaps() {
    if (this.bundledPackage && this.packageManager.packagesCache[this.name]) {
      this.keymaps = [];
      for (const keymapPath in this.packageManager.packagesCache[this.name]
        .keymaps) {
        const keymapObject = this.packageManager.packagesCache[this.name]
          .keymaps[keymapPath];
        this.keymaps.push([`core:${keymapPath}`, keymapObject]);
      }
    } else {
      this.keymaps = this.getKeymapPaths().map(keymapPath => [
        keymapPath,
        CSON.readFileSync(keymapPath, { allowDuplicateKeys: false }) || {}
      ]);
    }
  }

  loadMenus() {
    if (this.bundledPackage && this.packageManager.packagesCache[this.name]) {
      this.menus = [];
      for (const menuPath in this.packageManager.packagesCache[this.name]
        .menus) {
        const menuObject = this.packageManager.packagesCache[this.name].menus[
          menuPath
        ];
        this.menus.push([`core:${menuPath}`, menuObject]);
      }
    } else {
      this.menus = this.getMenuPaths().map(menuPath => [
        menuPath,
        CSON.readFileSync(menuPath) || {}
      ]);
    }
  }

  getKeymapPaths() {
    const keymapsDirPath = path.join(this.path, 'keymaps');
    if (this.metadata.keymaps) {
      return this.metadata.keymaps.map(name =>
        fs.resolve(keymapsDirPath, name, ['json', 'cson', ''])
      );
    } else {
      return fs.listSync(keymapsDirPath, ['cson', 'json']);
    }
  }

  getMenuPaths() {
    const menusDirPath = path.join(this.path, 'menus');
    if (this.metadata.menus) {
      return this.metadata.menus.map(name =>
        fs.resolve(menusDirPath, name, ['json', 'cson', ''])
      );
    } else {
      return fs.listSync(menusDirPath, ['cson', 'json']);
    }
  }

  loadStylesheets() {
    this.stylesheets = this.getStylesheetPaths().map(stylesheetPath => [
      stylesheetPath,
      this.themeManager.loadStylesheet(stylesheetPath, true)
    ]);
  }

  registerDeserializerMethods() {
    if (this.metadata.deserializers) {
      Object.keys(this.metadata.deserializers).forEach(deserializerName => {
        const methodName = this.metadata.deserializers[deserializerName];
        this.deserializerManager.add({
          name: deserializerName,
          deserialize: (state, atomEnvironment) => {
            this.registerViewProviders();
            this.requireMainModule();
            this.initializeIfNeeded();
            if (atomEnvironment.packages.hasActivatedInitialPackages()) {
              // Only explicitly activate the package if initial packages
              // have finished activating. This is because deserialization
              // generally occurs at Pulsar startup, which happens before the
              // workspace element is added to the DOM and is inconsistent with
              // with when initial package activation occurs. Triggering activation
              // immediately may cause problems with packages that expect to
              // always have access to the workspace element.
              // Otherwise, we just set the deserialized flag and package-manager
              // will activate this package as normal during initial package activation.
              this.activateNow();
            }
            this.deserialized = true;
            return this.mainModule[methodName](state, atomEnvironment);
          }
        });
      });
    }
  }

  activateCoreStartupServices() {
    const directoryProviderService =
      this.metadata.providedServices &&
      this.metadata.providedServices['atom.directory-provider'];
    if (directoryProviderService) {
      this.requireMainModule();
      const servicesByVersion = {};
      for (let version in directoryProviderService.versions) {
        const methodName = directoryProviderService.versions[version];
        if (typeof this.mainModule[methodName] === 'function') {
          servicesByVersion[version] = this.mainModule[methodName]();
        }
      }
      this.packageManager.serviceHub.provide(
        'atom.directory-provider',
        servicesByVersion
      );
    }
  }

  registerViewProviders() {
    if (this.metadata.viewProviders && !this.registeredViewProviders) {
      this.requireMainModule();
      this.metadata.viewProviders.forEach(methodName => {
        this.viewRegistry.addViewProvider(model => {
          this.initializeIfNeeded();
          return this.mainModule[methodName](model);
        });
      });
      this.registeredViewProviders = true;
    }
  }

  getStylesheetsPath() {
    return path.join(this.path, 'styles');
  }

  getStylesheetPaths() {
    if (
      this.bundledPackage &&
      this.packageManager.packagesCache[this.name] &&
      this.packageManager.packagesCache[this.name].styleSheetPaths
    ) {
      const { styleSheetPaths } = this.packageManager.packagesCache[this.name];
      return styleSheetPaths.map(styleSheetPath =>
        path.join(this.path, styleSheetPath)
      );
    } else {
      let indexStylesheet;
      const stylesheetDirPath = this.getStylesheetsPath();
      if (this.metadata.mainStyleSheet) {
        return [fs.resolve(this.path, this.metadata.mainStyleSheet)];
      } else if (this.metadata.styleSheets) {
        return this.metadata.styleSheets.map(name =>
          fs.resolve(stylesheetDirPath, name, ['css', 'less', ''])
        );
      } else if (
        (indexStylesheet = fs.resolve(this.path, 'index', ['css', 'less']))
      ) {
        return [indexStylesheet];
      } else {
        return fs.listSync(stylesheetDirPath, ['css', 'less']);
      }
    }
  }

  loadGrammarsSync() {
    if (this.grammarsLoaded) return;

    let grammarPaths;
    if (this.preloadedPackage && this.packageManager.packagesCache[this.name]) {
      ({ grammarPaths } = this.packageManager.packagesCache[this.name]);
    } else {
      grammarPaths = fs.listSync(path.join(this.path, 'grammars'), [
        'json',
        'cson'
      ]);
    }

    for (let grammarPath of grammarPaths) {
      if (
        this.preloadedPackage &&
        this.packageManager.packagesCache[this.name]
      ) {
        grammarPath = path.resolve(
          this.packageManager.resourcePath,
          grammarPath
        );
      }

      try {
        const grammar = this.grammarRegistry.readGrammarSync(grammarPath);
        grammar.packageName = this.name;
        grammar.bundledPackage = this.bundledPackage;
        this.grammars.push(grammar);
        grammar.activate();
      } catch (error) {
        console.warn(
          `Failed to load grammar: ${grammarPath}`,
          error.stack || error
        );
      }
    }

    this.grammarsLoaded = true;
    this.grammarsActivated = true;
  }

  loadGrammars() {
    if (this.grammarsLoaded) return Promise.resolve();

    const loadGrammar = (grammarPath, callback) => {
      if (this.preloadedPackage) {
        grammarPath = path.resolve(
          this.packageManager.resourcePath,
          grammarPath
        );
      }

      return this.grammarRegistry.readGrammar(grammarPath, (error, grammar) => {
        if (error) {
          const detail = `${error.message} in ${grammarPath}`;
          const stack = `${error.stack}\n  at ${grammarPath}:1:1`;
          this.notificationManager.addFatalError(
            `Failed to load a ${this.name} package grammar`,
            { stack, detail, packageName: this.name, dismissable: true }
          );
        } else {
          grammar.packageName = this.name;
          grammar.bundledPackage = this.bundledPackage;
          this.grammars.push(grammar);
          if (this.grammarsActivated) grammar.activate();
        }
        return callback();
      });
    };

    return new Promise(resolve => {
      if (
        this.preloadedPackage &&
        this.packageManager.packagesCache[this.name]
      ) {
        const { grammarPaths } = this.packageManager.packagesCache[this.name];
        return asyncEach(grammarPaths, loadGrammar, () => resolve());
      } else {
        const grammarsDirPath = path.join(this.path, 'grammars');
        fs.exists(grammarsDirPath, grammarsDirExists => {
          if (!grammarsDirExists) return resolve();
          fs.list(grammarsDirPath, ['json', 'cson'], (error, grammarPaths) => {
            if (error || !grammarPaths) return resolve();
            asyncEach(grammarPaths, loadGrammar, () => resolve());
          });
        });
      }
    });
  }

  loadSettings() {
    this.settings = [];

    const loadSettingsFile = (settingsPath, callback) => {
      return SettingsFile.load(settingsPath, (error, settingsFile) => {
        if (error) {
          const detail = `${error.message} in ${settingsPath}`;
          const stack = `${error.stack}\n  at ${settingsPath}:1:1`;
          this.notificationManager.addFatalError(
            `Failed to load the ${this.name} package settings`,
            { stack, detail, packageName: this.name, dismissable: true }
          );
        } else {
          this.settings.push(settingsFile);
          if (this.settingsActivated) settingsFile.activate(this.config);
        }
        return callback();
      });
    };

    if (this.preloadedPackage && this.packageManager.packagesCache[this.name]) {
      for (let settingsPath in this.packageManager.packagesCache[this.name]
        .settings) {
        const properties = this.packageManager.packagesCache[this.name]
          .settings[settingsPath];
        const settingsFile = new SettingsFile(
          `core:${settingsPath}`,
          properties || {}
        );
        this.settings.push(settingsFile);
        if (this.settingsActivated) settingsFile.activate(this.config);
      }
    } else {
      return new Promise(resolve => {
        const settingsDirPath = path.join(this.path, 'settings');
        fs.exists(settingsDirPath, settingsDirExists => {
          if (!settingsDirExists) return resolve();
          fs.list(settingsDirPath, ['json', 'cson'], (error, settingsPaths) => {
            if (error || !settingsPaths) return resolve();
            asyncEach(settingsPaths, loadSettingsFile, () => resolve());
          });
        });
      });
    }
  }

  serialize() {
    if (this.mainActivated) {
      if (typeof this.mainModule.serialize === 'function') {
        try {
          return this.mainModule.serialize();
        } catch (error) {
          console.error(
            `Error serializing package '${this.name}'`,
            error.stack
          );
        }
      }
    }
  }

  async deactivate() {
    this.activationPromise = null;
    this.resolveActivationPromise = null;
    if (this.activationCommandSubscriptions)
      this.activationCommandSubscriptions.dispose();
    if (this.activationHookSubscriptions)
      this.activationHookSubscriptions.dispose();
    this.configSchemaRegisteredOnActivate = false;
    this.unregisterURIHandler();
    this.deactivateResources();
    this.deactivateKeymaps();

    if (!this.mainActivated) {
      this.emitter.emit('did-deactivate');
      return;
    }

    if (typeof this.mainModule.deactivate === 'function') {
      try {
        const deactivationResult = this.mainModule.deactivate();
        if (
          deactivationResult &&
          typeof deactivationResult.then === 'function'
        ) {
          await deactivationResult;
        }
      } catch (error) {
        console.error(`Error deactivating package '${this.name}'`, error.stack);
      }
    }

    if (typeof this.mainModule.deactivateConfig === 'function') {
      try {
        await this.mainModule.deactivateConfig();
      } catch (error) {
        console.error(`Error deactivating package '${this.name}'`, error.stack);
      }
    }

    this.mainActivated = false;
    this.mainInitialized = false;
    this.emitter.emit('did-deactivate');
  }

  deactivateResources() {
    for (let grammar of this.grammars) {
      grammar.deactivate();
    }
    for (let settings of this.settings) {
      settings.deactivate(this.config);
    }

    if (this.stylesheetDisposables) this.stylesheetDisposables.dispose();
    if (this.activationDisposables) this.activationDisposables.dispose();
    if (this.keymapDisposables) this.keymapDisposables.dispose();

    this.stylesheetsActivated = false;
    this.grammarsActivated = false;
    this.settingsActivated = false;
    this.menusActivated = false;
  }

  reloadStylesheets() {
    try {
      this.loadStylesheets();
    } catch (error) {
      this.handleError(
        `Failed to reload the ${this.name} package stylesheets`,
        error
      );
    }

    if (this.stylesheetDisposables) this.stylesheetDisposables.dispose();
    this.stylesheetDisposables = new CompositeDisposable();
    this.stylesheetsActivated = false;
    this.activateStylesheets();
  }

  requireMainModule() {
    if (this.bundledPackage && this.packageManager.packagesCache[this.name]) {
      if (this.packageManager.packagesCache[this.name].main) {
        this.mainModule = requireModule(
          this.packageManager.packagesCache[this.name].main
        );
        return this.mainModule;
      }
    } else if (this.mainModuleRequired) {
      return this.mainModule;
    } else if (!this.isCompatible()) {
      const nativeModuleNames = this.incompatibleModules
        .map(m => m.name)
        .join(', ');
      console.warn(dedent`
        Failed to require the main module of '${
          this.name
        }' because it requires one or more incompatible native modules (${nativeModuleNames}).
        Run \`pulsar -p rebuild\` in the package directory and restart Pulsar to resolve.\
      `);
    } else {
      const mainModulePath = this.getMainModulePath();
      if (fs.isFileSync(mainModulePath)) {
        this.mainModuleRequired = true;

        const previousViewProviderCount = this.viewRegistry.getViewProviderCount();
        const previousDeserializerCount = this.deserializerManager.getDeserializerCount();
        this.mainModule = requireModule(mainModulePath);
        if (
          this.viewRegistry.getViewProviderCount() ===
            previousViewProviderCount &&
          this.deserializerManager.getDeserializerCount() ===
            previousDeserializerCount
        ) {
          localStorage.setItem(
            this.getCanDeferMainModuleRequireStorageKey(),
            'true'
          );
        } else {
          localStorage.removeItem(
            this.getCanDeferMainModuleRequireStorageKey()
          );
        }
        return this.mainModule;
      }
    }
  }

  getMainModulePath() {
    if (this.resolvedMainModulePath) return this.mainModulePath;
    this.resolvedMainModulePath = true;

    if (this.bundledPackage && this.packageManager.packagesCache[this.name]) {
      if (this.packageManager.packagesCache[this.name].main) {
        this.mainModulePath = path.resolve(
          this.packageManager.resourcePath,
          'static',
          this.packageManager.packagesCache[this.name].main
        );
      } else {
        this.mainModulePath = null;
      }
    } else {
      const mainModulePath = this.metadata.main
        ? path.join(this.path, this.metadata.main)
        : path.join(this.path, 'index');
      this.mainModulePath = fs.resolveExtension(mainModulePath, [
        '',
        ...CompileCache.supportedExtensions
      ]);
    }
    return this.mainModulePath;
  }

  activationShouldBeDeferred() {
    return (
      !this.deserialized &&
      (this.hasActivationCommands() ||
        this.hasActivationHooks() ||
        this.hasWorkspaceOpeners() ||
        this.hasDeferredURIHandler())
    );
  }

  hasActivationHooks() {
    const hooks = this.getActivationHooks();
    return hooks && hooks.length > 0;
  }

  hasWorkspaceOpeners() {
    const openers = this.getWorkspaceOpeners();
    return openers && openers.length > 0;
  }

  hasActivationCommands() {
    const object = this.getActivationCommands();
    for (let selector in object) {
      const commands = object[selector];
      if (commands.length > 0) return true;
    }
    return false;
  }

  hasDeferredURIHandler() {
    const handler = this.getURIHandler();
    return handler && handler.deferActivation !== false;
  }

  subscribeToDeferredActivation() {
    this.subscribeToActivationCommands();
    this.subscribeToActivationHooks();
    this.subscribeToWorkspaceOpeners();
  }

  subscribeToActivationCommands() {
    this.activationCommandSubscriptions = new CompositeDisposable();
    const object = this.getActivationCommands();
    for (let selector in object) {
      const commands = object[selector];
      for (let command of commands) {
        ((selector, command) => {
          // Add dummy command so it appears in menu.
          // The real command will be registered on package activation
          try {
            this.activationCommandSubscriptions.add(
              this.commandRegistry.add(selector, command, function() {})
            );
          } catch (error) {
            if (error.code === 'EBADSELECTOR') {
              const metadataPath = path.join(this.path, 'package.json');
              error.message += ` in ${metadataPath}`;
              error.stack += `\n  at ${metadataPath}:1:1`;
            }
            throw error;
          }

          this.activationCommandSubscriptions.add(
            this.commandRegistry.onWillDispatch(event => {
              if (event.type !== command) return;
              let currentTarget = event.target;
              while (currentTarget) {
                if (currentTarget.webkitMatchesSelector(selector)) {
                  this.activationCommandSubscriptions.dispose();
                  this.activateNow();
                  break;
                }
                currentTarget = currentTarget.parentElement;
              }
            })
          );
        })(selector, command);
      }
    }
  }

  getActivationCommands() {
    if (this.activationCommands) return this.activationCommands;

    this.activationCommands = {};

    if (this.metadata.activationCommands) {
      for (let selector in this.metadata.activationCommands) {
        const commands = this.metadata.activationCommands[selector];
        if (!this.activationCommands[selector])
          this.activationCommands[selector] = [];
        if (typeof commands === 'string') {
          this.activationCommands[selector].push(commands);
        } else if (Array.isArray(commands)) {
          this.activationCommands[selector].push(...commands);
        }
      }
    }

    return this.activationCommands;
  }

  subscribeToActivationHooks() {
    this.activationHookSubscriptions = new CompositeDisposable();
    for (let hook of this.getActivationHooks()) {
      if (typeof hook === 'string' && hook.trim().length > 0) {
        this.activationHookSubscriptions.add(
          this.packageManager.onDidTriggerActivationHook(hook, () =>
            this.activateNow()
          )
        );
      }
    }
  }

  getActivationHooks() {
    if (this.metadata && this.activationHooks) return this.activationHooks;

    if (this.metadata.activationHooks) {
      if (Array.isArray(this.metadata.activationHooks)) {
        this.activationHooks = Array.from(
          new Set(this.metadata.activationHooks)
        );
      } else if (typeof this.metadata.activationHooks === 'string') {
        this.activationHooks = [this.metadata.activationHooks];
      } else {
        this.activationHooks = [];
      }
    } else {
      this.activationHooks = [];
    }

    return this.activationHooks;
  }

  subscribeToWorkspaceOpeners() {
    this.workspaceOpenerSubscriptions = new CompositeDisposable();
    for (let opener of this.getWorkspaceOpeners()) {
      this.workspaceOpenerSubscriptions.add(
        atom.workspace.addOpener(filePath => {
          if (filePath === opener) {
            this.activateNow();
            this.workspaceOpenerSubscriptions.dispose();
            return atom.workspace.createItemForURI(opener);
          }
        })
      );
    }
  }

  getWorkspaceOpeners() {
    if (this.workspaceOpeners) return this.workspaceOpeners;

    if (this.metadata.workspaceOpeners) {
      if (Array.isArray(this.metadata.workspaceOpeners)) {
        this.workspaceOpeners = Array.from(
          new Set(this.metadata.workspaceOpeners)
        );
      } else if (typeof this.metadata.workspaceOpeners === 'string') {
        this.workspaceOpeners = [this.metadata.workspaceOpeners];
      } else {
        this.workspaceOpeners = [];
      }
    } else {
      this.workspaceOpeners = [];
    }

    return this.workspaceOpeners;
  }

  getURIHandler() {
    return this.metadata && this.metadata.uriHandler;
  }

  // Does the given module path contain native code?
  isNativeModule(modulePath) {
    try {
      return this.getModulePathNodeFiles(modulePath).length > 0;
    } catch (error) {
      return false;
    }
  }

  // get the list of `.node` files for the given module path
  getModulePathNodeFiles(modulePath) {
    try {
      const modulePathNodeFiles = fs.listSync(
        path.join(modulePath, 'build', 'Release'),
        ['.node']
      );
      return modulePathNodeFiles;
    } catch (error) {
      return [];
    }
  }

  // Get a Map of all the native modules => the `.node` files that this package depends on.
  //
  // First try to get this information from
  // @metadata._atomModuleCache.extensions. If @metadata._atomModuleCache doesn't
  // exist, recurse through all dependencies.
  getNativeModuleDependencyPathsMap() {
    const nativeModulePaths = new Map();

    if (this.metadata._atomModuleCache) {
      const nodeFilePaths = [];
      const relativeNativeModuleBindingPaths =
        (this.metadata._atomModuleCache.extensions &&
          this.metadata._atomModuleCache.extensions['.node']) ||
        [];
      for (let relativeNativeModuleBindingPath of relativeNativeModuleBindingPaths) {
        const nodeFilePath = path.join(
          this.path,
          relativeNativeModuleBindingPath,
          '..',
          '..',
          '..'
        );
        nodeFilePaths.push(nodeFilePath);
      }
      nativeModulePaths.set(this.path, nodeFilePaths);
      return nativeModulePaths;
    }

    const traversePath = nodeModulesPath => {
      try {
        for (let modulePath of fs.listSync(nodeModulesPath)) {
          const modulePathNodeFiles = this.getModulePathNodeFiles(modulePath);
          if (modulePathNodeFiles) {
            nativeModulePaths.set(modulePath, modulePathNodeFiles);
          }
          traversePath(path.join(modulePath, 'node_modules'));
        }
      } catch (error) {}
    };

    traversePath(path.join(this.path, 'node_modules'));

    return nativeModulePaths;
  }

  // Get an array of all the native modules that this package depends on.
  // See `getNativeModuleDependencyPathsMap` for more information
  getNativeModuleDependencyPaths() {
    return [...this.getNativeModuleDependencyPathsMap().keys()];
  }

  /*
  Section: Native Module Compatibility
  */

  // Extended: Are all native modules depended on by this package correctly
  // compiled against the current version of Pulsar?
  //
  // Incompatible packages cannot be activated.
  //
  // Returns a {Boolean}, true if compatible, false if incompatible.
  isCompatible() {
    if (this.compatible == null) {
      if (this.preloadedPackage) {
        this.compatible = true;
      } else if (this.getMainModulePath()) {
        this.incompatibleModules = this.getIncompatibleNativeModules();
        this.compatible = this.incompatibleModules.length === 0;
      } else {
        this.compatible = true;
      }
    }
    return this.compatible;
  }

  // Extended: Rebuild native modules in this package's dependencies for the
  // current version of Pulsar.
  //
  // Returns a {Promise} that resolves with an object containing `code`,
  // `stdout`, and `stderr` properties based on the results of running
  // `pulsar -p rebuild` on the package.
  rebuild() {
    return new Promise(resolve =>
      this.runRebuildProcess(result => {
        if (result.code === 0) {
          global.localStorage.removeItem(
            this.getBuildFailureOutputStorageKey()
          );
        } else {
          this.compatible = false;
          global.localStorage.setItem(
            this.getBuildFailureOutputStorageKey(),
            result.stderr
          );
        }
        resolve(result);
      })
    );
  }

  // Extended: If a previous rebuild failed, get the contents of stderr.
  //
  // Returns a {String} or null if no previous build failure occurred.
  getBuildFailureOutput() {
    return global.localStorage.getItem(this.getBuildFailureOutputStorageKey());
  }

  runRebuildProcess(done) {
    let stderr = '';
    let stdout = '';
    return new BufferedProcess({
      command: this.packageManager.getApmPath(),
      args: ['rebuild', '--no-color'],
      options: { cwd: this.path },
      stderr(output) {
        stderr += output;
      },
      stdout(output) {
        stdout += output;
      },
      exit(code) {
        done({ code, stdout, stderr });
      }
    });
  }

  getBuildFailureOutputStorageKey() {
    return `installed-packages:${this.name}:${
      this.metadata.version
    }:build-error`;
  }

  getCanDeferMainModuleRequireStorageKey() {
    return `installed-packages:${this.name}:${
      this.metadata.version
    }:can-defer-main-module-require`;
  }

  // Get the incompatible native modules that this package depends on.
  // This recurses through all dependencies and requires all `.node` files.
  //
  // This information is cached in local storage on a per package/version basis
  // to minimize the impact on startup time.
  getIncompatibleNativeModules() {
    const incompatibleNativeModules = [];
    const nativeModulePaths = this.getNativeModuleDependencyPathsMap();
    for (const [nativeModulePath, nodeFilesPaths] of nativeModulePaths) {
      try {
        // require each .node file
        for (const nodeFilePath of nodeFilesPaths) {
          require(nodeFilePath);
        }
      } catch (error) {
        let version;
        try {
          ({ version } = require(`${nativeModulePath}/package.json`));
        } catch (error2) {}
        incompatibleNativeModules.push({
          path: nativeModulePath,
          name: path.basename(nativeModulePath),
          version,
          error: error.message
        });
      }
    }

    return incompatibleNativeModules;
  }

  handleError(message, error) {
    if (atom.inSpecMode()) throw error;

    let detail, location, stack;
    if (error.filename && error.location && error instanceof SyntaxError) {
      location = `${error.filename}:${error.location.first_line + 1}:${error
        .location.first_column + 1}`;
      detail = `${error.message} in ${location}`;
      stack = 'SyntaxError: ' + error.message + '\n' + 'at ' + location;
    } else if (
      error.less &&
      error.filename &&
      error.column != null &&
      error.line != null
    ) {
      location = `${error.filename}:${error.line}:${error.column}`;
      detail = `${error.message} in ${location}`;
      stack = 'LessError: ' + error.message + '\n' + 'at ' + location;
    } else {
      detail = error.message;
      stack = error.stack || error;
    }

    this.notificationManager.addFatalError(message, {
      stack,
      detail,
      packageName: this.name,
      dismissable: true
    });
  }
};

class SettingsFile {
  static load(path, callback) {
    CSON.readFile(path, (error, properties = {}) => {
      if (error) {
        callback(error);
      } else {
        callback(null, new SettingsFile(path, properties));
      }
    });
  }

  constructor(path, properties) {
    this.path = path;
    this.properties = properties;
  }

  activate(config) {
    for (let selector in this.properties) {
      config.set(null, this.properties[selector], {
        scopeSelector: selector,
        source: this.path
      });
    }
  }

  deactivate(config) {
    for (let selector in this.properties) {
      config.unset(null, { scopeSelector: selector, source: this.path });
    }
  }
}

================
File: src/pane-container.js
================
const { find } = require('underscore-plus');
const { Emitter, CompositeDisposable } = require('event-kit');
const Pane = require('./pane');
const ItemRegistry = require('./item-registry');
const { createPaneContainerElement } = require('./pane-container-element');

const SERIALIZATION_VERSION = 1;
const STOPPED_CHANGING_ACTIVE_PANE_ITEM_DELAY = 100;

module.exports = class PaneContainer {
  constructor(params) {
    let applicationDelegate, deserializerManager, notificationManager;
    ({
      config: this.config,
      applicationDelegate,
      notificationManager,
      deserializerManager,
      viewRegistry: this.viewRegistry,
      location: this.location
    } = params);
    this.emitter = new Emitter();
    this.subscriptions = new CompositeDisposable();
    this.itemRegistry = new ItemRegistry();
    this.alive = true;
    this.stoppedChangingActivePaneItemTimeout = null;

    this.setRoot(
      new Pane({
        container: this,
        config: this.config,
        applicationDelegate,
        notificationManager,
        deserializerManager,
        viewRegistry: this.viewRegistry
      })
    );
    this.didActivatePane(this.getRoot());
  }

  getLocation() {
    return this.location;
  }

  getElement() {
    return this.element != null
      ? this.element
      : (this.element = createPaneContainerElement().initialize(this, {
          views: this.viewRegistry
        }));
  }

  destroy() {
    this.alive = false;
    for (let pane of this.getRoot().getPanes()) {
      pane.destroy();
    }
    this.cancelStoppedChangingActivePaneItemTimeout();
    this.subscriptions.dispose();
    this.emitter.dispose();
  }

  isAlive() {
    return this.alive;
  }

  isDestroyed() {
    return !this.isAlive();
  }

  serialize(params) {
    return {
      deserializer: 'PaneContainer',
      version: SERIALIZATION_VERSION,
      root: this.root ? this.root.serialize() : null,
      activePaneId: this.activePane.id
    };
  }

  deserialize(state, deserializerManager) {
    if (state.version !== SERIALIZATION_VERSION) return;
    this.itemRegistry = new ItemRegistry();
    this.setRoot(deserializerManager.deserialize(state.root));
    this.activePane =
      find(this.getRoot().getPanes(), pane => pane.id === state.activePaneId) ||
      this.getPanes()[0];
    if (this.config.get('core.destroyEmptyPanes')) this.destroyEmptyPanes();
  }

  onDidChangeRoot(fn) {
    return this.emitter.on('did-change-root', fn);
  }

  observeRoot(fn) {
    fn(this.getRoot());
    return this.onDidChangeRoot(fn);
  }

  onDidAddPane(fn) {
    return this.emitter.on('did-add-pane', fn);
  }

  observePanes(fn) {
    for (let pane of this.getPanes()) {
      fn(pane);
    }
    return this.onDidAddPane(({ pane }) => fn(pane));
  }

  onDidDestroyPane(fn) {
    return this.emitter.on('did-destroy-pane', fn);
  }

  onWillDestroyPane(fn) {
    return this.emitter.on('will-destroy-pane', fn);
  }

  onDidChangeActivePane(fn) {
    return this.emitter.on('did-change-active-pane', fn);
  }

  onDidActivatePane(fn) {
    return this.emitter.on('did-activate-pane', fn);
  }

  observeActivePane(fn) {
    fn(this.getActivePane());
    return this.onDidChangeActivePane(fn);
  }

  onDidAddPaneItem(fn) {
    return this.emitter.on('did-add-pane-item', fn);
  }

  observePaneItems(fn) {
    for (let item of this.getPaneItems()) {
      fn(item);
    }
    return this.onDidAddPaneItem(({ item }) => fn(item));
  }

  onDidChangeActivePaneItem(fn) {
    return this.emitter.on('did-change-active-pane-item', fn);
  }

  onDidStopChangingActivePaneItem(fn) {
    return this.emitter.on('did-stop-changing-active-pane-item', fn);
  }

  observeActivePaneItem(fn) {
    fn(this.getActivePaneItem());
    return this.onDidChangeActivePaneItem(fn);
  }

  onWillDestroyPaneItem(fn) {
    return this.emitter.on('will-destroy-pane-item', fn);
  }

  onDidDestroyPaneItem(fn) {
    return this.emitter.on('did-destroy-pane-item', fn);
  }

  getRoot() {
    return this.root;
  }

  setRoot(root) {
    this.root = root;
    this.root.setParent(this);
    this.root.setContainer(this);
    this.emitter.emit('did-change-root', this.root);
    if (this.getActivePane() == null && this.root instanceof Pane) {
      this.didActivatePane(this.root);
    }
  }

  replaceChild(oldChild, newChild) {
    if (oldChild !== this.root) {
      throw new Error('Replacing non-existent child');
    }
    this.setRoot(newChild);
  }

  getPanes() {
    if (this.alive) {
      return this.getRoot().getPanes();
    } else {
      return [];
    }
  }

  getPaneItems() {
    return this.getRoot().getItems();
  }

  getActivePane() {
    return this.activePane;
  }

  getActivePaneItem() {
    return this.getActivePane().getActiveItem();
  }

  paneForURI(uri) {
    return find(this.getPanes(), pane => pane.itemForURI(uri) != null);
  }

  paneForItem(item) {
    return find(this.getPanes(), pane => pane.getItems().includes(item));
  }

  saveAll() {
    for (let pane of this.getPanes()) {
      pane.saveItems();
    }
  }

  confirmClose(options) {
    const promises = [];
    for (const pane of this.getPanes()) {
      for (const item of pane.getItems()) {
        promises.push(pane.promptToSaveItem(item, options));
      }
    }
    return Promise.all(promises).then(results => !results.includes(false));
  }

  activateNextPane() {
    const panes = this.getPanes();
    if (panes.length > 1) {
      const currentIndex = panes.indexOf(this.activePane);
      const nextIndex = (currentIndex + 1) % panes.length;
      panes[nextIndex].activate();
      return true;
    } else {
      return false;
    }
  }

  activatePreviousPane() {
    const panes = this.getPanes();
    if (panes.length > 1) {
      const currentIndex = panes.indexOf(this.activePane);
      let previousIndex = currentIndex - 1;
      if (previousIndex < 0) {
        previousIndex = panes.length - 1;
      }
      panes[previousIndex].activate();
      return true;
    } else {
      return false;
    }
  }

  moveActiveItemToPane(destPane) {
    const item = this.activePane.getActiveItem();

    if (!destPane.isItemAllowed(item)) {
      return;
    }

    this.activePane.moveItemToPane(item, destPane);
    destPane.setActiveItem(item);
  }

  copyActiveItemToPane(destPane) {
    const item = this.activePane.copyActiveItem();

    if (item && destPane.isItemAllowed(item)) {
      destPane.activateItem(item);
    }
  }

  destroyEmptyPanes() {
    for (let pane of this.getPanes()) {
      if (pane.items.length === 0) {
        pane.destroy();
      }
    }
  }

  didAddPane(event) {
    this.emitter.emit('did-add-pane', event);
    const items = event.pane.getItems();
    for (let i = 0, length = items.length; i < length; i++) {
      const item = items[i];
      this.didAddPaneItem(item, event.pane, i);
    }
  }

  willDestroyPane(event) {
    this.emitter.emit('will-destroy-pane', event);
  }

  didDestroyPane(event) {
    this.emitter.emit('did-destroy-pane', event);
  }

  didActivatePane(activePane) {
    if (activePane !== this.activePane) {
      if (!this.getPanes().includes(activePane)) {
        throw new Error(
          'Setting active pane that is not present in pane container'
        );
      }

      this.activePane = activePane;
      this.emitter.emit('did-change-active-pane', this.activePane);
      this.didChangeActiveItemOnPane(
        this.activePane,
        this.activePane.getActiveItem()
      );
    }
    this.emitter.emit('did-activate-pane', this.activePane);
    return this.activePane;
  }

  didAddPaneItem(item, pane, index) {
    this.itemRegistry.addItem(item);
    this.emitter.emit('did-add-pane-item', { item, pane, index });
  }

  willDestroyPaneItem(event) {
    return this.emitter.emitAsync('will-destroy-pane-item', event);
  }

  didDestroyPaneItem(event) {
    this.itemRegistry.removeItem(event.item);
    this.emitter.emit('did-destroy-pane-item', event);
  }

  didChangeActiveItemOnPane(pane, activeItem) {
    if (pane === this.getActivePane()) {
      this.emitter.emit('did-change-active-pane-item', activeItem);

      this.cancelStoppedChangingActivePaneItemTimeout();
      this.stoppedChangingActivePaneItemTimeout = setTimeout(() => {
        this.stoppedChangingActivePaneItemTimeout = null;
        this.emitter.emit('did-stop-changing-active-pane-item', activeItem);
      }, STOPPED_CHANGING_ACTIVE_PANE_ITEM_DELAY);
    }
  }

  cancelStoppedChangingActivePaneItemTimeout() {
    if (this.stoppedChangingActivePaneItemTimeout != null) {
      clearTimeout(this.stoppedChangingActivePaneItemTimeout);
    }
  }
};

================
File: src/pane.js
================
const Grim = require('grim');
const { CompositeDisposable, Emitter } = require('event-kit');
const PaneAxis = require('./pane-axis');
const TextEditor = require('./text-editor');
const { createPaneElement } = require('./pane-element');

let nextInstanceId = 1;

class SaveCancelledError extends Error {}

// Extended: A container for presenting content in the center of the workspace.
// Panes can contain multiple items, one of which is *active* at a given time.
// The view corresponding to the active item is displayed in the interface. In
// the default configuration, tabs are also displayed for each item.
//
// Each pane may also contain one *pending* item. When a pending item is added
// to a pane, it will replace the currently pending item, if any, instead of
// simply being added. In the default configuration, the text in the tab for
// pending items is shown in italics.
module.exports = class Pane {
  inspect() {
    return `Pane ${this.id}`;
  }

  static deserialize(
    state,
    { deserializers, applicationDelegate, config, notifications, views }
  ) {
    const { activeItemIndex } = state;
    const activeItemURI = state.activeItemURI || state.activeItemUri;

    const items = [];
    for (const itemState of state.items) {
      const item = deserializers.deserialize(itemState);
      if (item) items.push(item);
    }
    state.items = items;

    state.activeItem = items[activeItemIndex];
    if (!state.activeItem && activeItemURI) {
      state.activeItem = state.items.find(
        item =>
          typeof item.getURI === 'function' && item.getURI() === activeItemURI
      );
    }

    return new Pane(
      Object.assign(
        {
          deserializerManager: deserializers,
          notificationManager: notifications,
          viewRegistry: views,
          config,
          applicationDelegate
        },
        state
      )
    );
  }

  constructor(params = {}) {
    this.setPendingItem = this.setPendingItem.bind(this);
    this.getPendingItem = this.getPendingItem.bind(this);
    this.clearPendingItem = this.clearPendingItem.bind(this);
    this.onItemDidTerminatePendingState = this.onItemDidTerminatePendingState.bind(
      this
    );
    this.saveItem = this.saveItem.bind(this);
    this.saveItemAs = this.saveItemAs.bind(this);

    this.id = params.id;
    if (this.id != null) {
      nextInstanceId = Math.max(nextInstanceId, this.id + 1);
    } else {
      this.id = nextInstanceId++;
    }

    this.activeItem = params.activeItem;
    this.focused = params.focused != null ? params.focused : false;
    this.applicationDelegate = params.applicationDelegate;
    this.notificationManager = params.notificationManager;
    this.config = params.config;
    this.deserializerManager = params.deserializerManager;
    this.viewRegistry = params.viewRegistry;

    this.emitter = new Emitter();
    this.alive = true;
    this.subscriptionsPerItem = new WeakMap();
    this.items = [];
    this.itemStack = [];
    this.container = null;

    this.addItems((params.items || []).filter(item => item));
    if (!this.getActiveItem()) this.setActiveItem(this.items[0]);
    this.addItemsToStack(params.itemStackIndices || []);
    this.setFlexScale(params.flexScale || 1);
  }

  getElement() {
    if (!this.element) {
      this.element = createPaneElement().initialize(this, {
        views: this.viewRegistry,
        applicationDelegate: this.applicationDelegate
      });
    }
    return this.element;
  }

  serialize() {
    const itemsToBeSerialized = this.items.filter(
      item => item && typeof item.serialize === 'function'
    );

    const itemStackIndices = [];
    for (const item of this.itemStack) {
      if (typeof item.serialize === 'function') {
        itemStackIndices.push(itemsToBeSerialized.indexOf(item));
      }
    }

    const activeItemIndex = itemsToBeSerialized.indexOf(this.activeItem);

    return {
      deserializer: 'Pane',
      id: this.id,
      items: itemsToBeSerialized.map(item => item.serialize()),
      itemStackIndices,
      activeItemIndex,
      focused: this.focused,
      flexScale: this.flexScale
    };
  }

  getParent() {
    return this.parent;
  }

  setParent(parent) {
    this.parent = parent;
  }

  getContainer() {
    return this.container;
  }

  setContainer(container) {
    if (container && container !== this.container) {
      this.container = container;
      container.didAddPane({ pane: this });
    }
  }

  // Private: Determine whether the given item is allowed to exist in this pane.
  //
  // * `item` the Item
  //
  // Returns a {Boolean}.
  isItemAllowed(item) {
    if (typeof item.getAllowedLocations !== 'function') {
      return true;
    } else {
      return item
        .getAllowedLocations()
        .includes(this.getContainer().getLocation());
    }
  }

  setFlexScale(flexScale) {
    this.flexScale = flexScale;
    this.emitter.emit('did-change-flex-scale', this.flexScale);
    return this.flexScale;
  }

  getFlexScale() {
    return this.flexScale;
  }

  increaseSize() {
    if (this.getContainer().getPanes().length > 1) {
      this.setFlexScale(this.getFlexScale() * 1.1);
    }
  }

  decreaseSize() {
    if (this.getContainer().getPanes().length > 1) {
      this.setFlexScale(this.getFlexScale() / 1.1);
    }
  }

  /*
  Section: Event Subscription
  */

  // Public: Invoke the given callback when the pane resizes.
  //
  // The callback will be invoked when pane's `flexScale` property changes.
  // Use {::getFlexScale} to get the current value.
  //
  // * `callback` {Function} to be called when the pane is resized.
  //   * `flexScale` {Number} representing the pane's `flex-grow`; ability for
  //     a flex item to grow if necessary.
  //
  // Returns a {Disposable} on which '.dispose()' can be called to unsubscribe.
  onDidChangeFlexScale(callback) {
    return this.emitter.on('did-change-flex-scale', callback);
  }

  // Public: Invoke the given callback with the current and future values of
  // {::getFlexScale}.
  //
  // * `callback` {Function} to be called with the current and future values of
  //   the {::getFlexScale} property.
  //   * `flexScale` {Number} representing the panes `flex-grow`; ability for a
  //     flex item to grow if necessary.
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  observeFlexScale(callback) {
    callback(this.flexScale);
    return this.onDidChangeFlexScale(callback);
  }

  // Public: Invoke the given callback when the pane is activated.
  //
  // The given callback will be invoked whenever {::activate} is called on the
  // pane, even if it is already active at the time.
  //
  // * `callback` {Function} to be called when the pane is activated.
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  onDidActivate(callback) {
    return this.emitter.on('did-activate', callback);
  }

  // Public: Invoke the given callback before the pane is destroyed.
  //
  // * `callback` {Function} to be called before the pane is destroyed.
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  onWillDestroy(callback) {
    return this.emitter.on('will-destroy', callback);
  }

  // Public: Invoke the given callback when the pane is destroyed.
  //
  // * `callback` {Function} to be called when the pane is destroyed.
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  onDidDestroy(callback) {
    return this.emitter.once('did-destroy', callback);
  }

  // Public: Invoke the given callback when the value of the {::isActive}
  // property changes.
  //
  // * `callback` {Function} to be called when the value of the {::isActive}
  //   property changes.
  //   * `active` {Boolean} indicating whether the pane is active.
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  onDidChangeActive(callback) {
    return this.container.onDidChangeActivePane(activePane => {
      const isActive = this === activePane;
      callback(isActive);
    });
  }

  // Public: Invoke the given callback with the current and future values of the
  // {::isActive} property.
  //
  // * `callback` {Function} to be called with the current and future values of
  //   the {::isActive} property.
  //   * `active` {Boolean} indicating whether the pane is active.
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  observeActive(callback) {
    callback(this.isActive());
    return this.onDidChangeActive(callback);
  }

  // Public: Invoke the given callback when an item is added to the pane.
  //
  // * `callback` {Function} to be called with when items are added.
  //   * `event` {Object} with the following keys:
  //     * `item` The added pane item.
  //     * `index` {Number} indicating where the item is located.
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  onDidAddItem(callback) {
    return this.emitter.on('did-add-item', callback);
  }

  // Public: Invoke the given callback when an item is removed from the pane.
  //
  // * `callback` {Function} to be called with when items are removed.
  //   * `event` {Object} with the following keys:
  //     * `item` The removed pane item.
  //     * `index` {Number} indicating where the item was located.
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  onDidRemoveItem(callback) {
    return this.emitter.on('did-remove-item', callback);
  }

  // Public: Invoke the given callback before an item is removed from the pane.
  //
  // * `callback` {Function} to be called with when items are removed.
  //   * `event` {Object} with the following keys:
  //     * `item` The pane item to be removed.
  //     * `index` {Number} indicating where the item is located.
  onWillRemoveItem(callback) {
    return this.emitter.on('will-remove-item', callback);
  }

  // Public: Invoke the given callback when an item is moved within the pane.
  //
  // * `callback` {Function} to be called with when items are moved.
  //   * `event` {Object} with the following keys:
  //     * `item` The removed pane item.
  //     * `oldIndex` {Number} indicating where the item was located.
  //     * `newIndex` {Number} indicating where the item is now located.
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  onDidMoveItem(callback) {
    return this.emitter.on('did-move-item', callback);
  }

  // Public: Invoke the given callback with all current and future items.
  //
  // * `callback` {Function} to be called with current and future items.
  //   * `item` An item that is present in {::getItems} at the time of
  //     subscription or that is added at some later time.
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  observeItems(callback) {
    for (let item of this.getItems()) {
      callback(item);
    }
    return this.onDidAddItem(({ item }) => callback(item));
  }

  // Public: Invoke the given callback when the value of {::getActiveItem}
  // changes.
  //
  // * `callback` {Function} to be called with when the active item changes.
  //   * `activeItem` The current active item.
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  onDidChangeActiveItem(callback) {
    return this.emitter.on('did-change-active-item', callback);
  }

  // Public: Invoke the given callback when {::activateNextRecentlyUsedItem}
  // has been called, either initiating or continuing a forward MRU traversal of
  // pane items.
  //
  // * `callback` {Function} to be called with when the active item changes.
  //   * `nextRecentlyUsedItem` The next MRU item, now being set active
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  onChooseNextMRUItem(callback) {
    return this.emitter.on('choose-next-mru-item', callback);
  }

  // Public: Invoke the given callback when {::activatePreviousRecentlyUsedItem}
  // has been called, either initiating or continuing a reverse MRU traversal of
  // pane items.
  //
  // * `callback` {Function} to be called with when the active item changes.
  //   * `previousRecentlyUsedItem` The previous MRU item, now being set active
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  onChooseLastMRUItem(callback) {
    return this.emitter.on('choose-last-mru-item', callback);
  }

  // Public: Invoke the given callback when {::moveActiveItemToTopOfStack}
  // has been called, terminating an MRU traversal of pane items and moving the
  // current active item to the top of the stack. Typically bound to a modifier
  // (e.g. CTRL) key up event.
  //
  // * `callback` {Function} to be called with when the MRU traversal is done.
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  onDoneChoosingMRUItem(callback) {
    return this.emitter.on('done-choosing-mru-item', callback);
  }

  // Public: Invoke the given callback with the current and future values of
  // {::getActiveItem}.
  //
  // * `callback` {Function} to be called with the current and future active
  //   items.
  //   * `activeItem` The current active item.
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  observeActiveItem(callback) {
    callback(this.getActiveItem());
    return this.onDidChangeActiveItem(callback);
  }

  // Public: Invoke the given callback before items are destroyed.
  //
  // * `callback` {Function} to be called before items are destroyed.
  //   * `event` {Object} with the following keys:
  //     * `item` The item that will be destroyed.
  //     * `index` The location of the item.
  //
  // Returns a {Disposable} on which `.dispose()` can be called to
  // unsubscribe.
  onWillDestroyItem(callback) {
    return this.emitter.on('will-destroy-item', callback);
  }

  // Called by the view layer to indicate that the pane has gained focus.
  focus() {
    return this.activate();
  }

  // Called by the view layer to indicate that the pane has lost focus.
  blur() {
    this.focused = false;
    return true; // if this is called from an event handler, don't cancel it
  }

  isFocused() {
    return this.focused;
  }

  getPanes() {
    return [this];
  }

  unsubscribeFromItem(item) {
    const subscription = this.subscriptionsPerItem.get(item);
    if (subscription) {
      subscription.dispose();
      this.subscriptionsPerItem.delete(item);
    }
  }

  /*
  Section: Items
  */

  // Public: Get the items in this pane.
  //
  // Returns an {Array} of items.
  getItems() {
    return this.items.slice();
  }

  // Public: Get the active pane item in this pane.
  //
  // Returns a pane item.
  getActiveItem() {
    return this.activeItem;
  }

  setActiveItem(activeItem, options) {
    const modifyStack = options && options.modifyStack;
    if (activeItem !== this.activeItem) {
      if (modifyStack !== false) this.addItemToStack(activeItem);
      this.activeItem = activeItem;
      this.emitter.emit('did-change-active-item', this.activeItem);
      if (this.container)
        this.container.didChangeActiveItemOnPane(this, this.activeItem);
    }
    return this.activeItem;
  }

  // Build the itemStack after deserializing
  addItemsToStack(itemStackIndices) {
    if (this.items.length > 0) {
      if (
        itemStackIndices.length !== this.items.length ||
        itemStackIndices.includes(-1)
      ) {
        itemStackIndices = this.items.map((item, i) => i);
      }

      for (let itemIndex of itemStackIndices) {
        this.addItemToStack(this.items[itemIndex]);
      }
    }
  }

  // Add item (or move item) to the end of the itemStack
  addItemToStack(newItem) {
    if (newItem == null) {
      return;
    }
    const index = this.itemStack.indexOf(newItem);
    if (index !== -1) this.itemStack.splice(index, 1);
    return this.itemStack.push(newItem);
  }

  // Return an {TextEditor} if the pane item is an {TextEditor}, or null otherwise.
  getActiveEditor() {
    if (this.activeItem instanceof TextEditor) return this.activeItem;
  }

  // Public: Return the item at the given index.
  //
  // * `index` {Number}
  //
  // Returns an item or `null` if no item exists at the given index.
  itemAtIndex(index) {
    return this.items[index];
  }

  // Public: Makes the next item in the itemStack active.
  activateNextRecentlyUsedItem() {
    if (this.items.length > 1) {
      if (this.itemStackIndex == null)
        this.itemStackIndex = this.itemStack.length - 1;
      if (this.itemStackIndex === 0)
        this.itemStackIndex = this.itemStack.length;
      this.itemStackIndex--;
      const nextRecentlyUsedItem = this.itemStack[this.itemStackIndex];
      this.emitter.emit('choose-next-mru-item', nextRecentlyUsedItem);
      this.setActiveItem(nextRecentlyUsedItem, { modifyStack: false });
    }
  }

  // Public: Makes the previous item in the itemStack active.
  activatePreviousRecentlyUsedItem() {
    if (this.items.length > 1) {
      if (
        this.itemStackIndex + 1 === this.itemStack.length ||
        this.itemStackIndex == null
      ) {
        this.itemStackIndex = -1;
      }
      this.itemStackIndex++;
      const previousRecentlyUsedItem = this.itemStack[this.itemStackIndex];
      this.emitter.emit('choose-last-mru-item', previousRecentlyUsedItem);
      this.setActiveItem(previousRecentlyUsedItem, { modifyStack: false });
    }
  }

  // Public: Moves the active item to the end of the item stack once a modifier
  // key (typically <kbd>Ctrl</kbd>) is lifted.
  moveActiveItemToTopOfStack() {
    delete this.itemStackIndex;
    this.addItemToStack(this.activeItem);
    this.emitter.emit('done-choosing-mru-item');
  }

  // Public: Makes the next item active.
  activateNextItem() {
    const index = this.getActiveItemIndex();
    if (index < this.items.length - 1) {
      this.activateItemAtIndex(index + 1);
    } else {
      this.activateItemAtIndex(0);
    }
  }

  // Public: Makes the previous item active.
  activatePreviousItem() {
    const index = this.getActiveItemIndex();
    if (index > 0) {
      this.activateItemAtIndex(index - 1);
    } else {
      this.activateItemAtIndex(this.items.length - 1);
    }
  }

  activateLastItem() {
    this.activateItemAtIndex(this.items.length - 1);
  }

  // Public: Move the active tab to the right.
  moveItemRight() {
    const index = this.getActiveItemIndex();
    const rightItemIndex = index + 1;
    if (rightItemIndex <= this.items.length - 1)
      this.moveItem(this.getActiveItem(), rightItemIndex);
  }

  // Public: Move the active tab to the left
  moveItemLeft() {
    const index = this.getActiveItemIndex();
    const leftItemIndex = index - 1;
    if (leftItemIndex >= 0)
      return this.moveItem(this.getActiveItem(), leftItemIndex);
  }

  // Public: Get the index of the active item.
  //
  // Returns a {Number}.
  getActiveItemIndex() {
    return this.items.indexOf(this.activeItem);
  }

  // Public: Activate the item at the given index.
  //
  // * `index` {Number}
  activateItemAtIndex(index) {
    const item = this.itemAtIndex(index) || this.getActiveItem();
    return this.setActiveItem(item);
  }

  // Public: Make the given item *active*, causing it to be displayed by
  // the pane's view.
  //
  // * `item` The item to activate
  // * `options` (optional) {Object}
  //   * `pending` (optional) {Boolean} indicating that the item should be added
  //     in a pending state if it does not yet exist in the pane. Existing pending
  //     items in a pane are replaced with new pending items when they are opened.
  activateItem(item, options = {}) {
    if (item) {
      const index =
        this.getPendingItem() === this.activeItem
          ? this.getActiveItemIndex()
          : this.getActiveItemIndex() + 1;
      this.addItem(item, Object.assign({}, options, { index }));
      this.setActiveItem(item);
    }
  }

  // Public: Add the given item to the pane.
  //
  // * `item` The item to add. It can be a model with an associated view or a
  //   view.
  // * `options` (optional) {Object}
  //   * `index` (optional) {Number} indicating the index at which to add the item.
  //     If omitted, the item is added after the current active item.
  //   * `pending` (optional) {Boolean} indicating that the item should be
  //     added in a pending state. Existing pending items in a pane are replaced with
  //     new pending items when they are opened.
  //
  // Returns the added item.
  addItem(item, options = {}) {
    // Backward compat with old API:
    //   addItem(item, index=@getActiveItemIndex() + 1)
    if (typeof options === 'number') {
      Grim.deprecate(
        `Pane::addItem(item, ${options}) is deprecated in favor of Pane::addItem(item, {index: ${options}})`
      );
      options = { index: options };
    }

    const index =
      options.index != null ? options.index : this.getActiveItemIndex() + 1;
    const moved = options.moved != null ? options.moved : false;
    const pending = options.pending != null ? options.pending : false;

    if (!item || typeof item !== 'object') {
      throw new Error(
        `Pane items must be objects. Attempted to add item ${item}.`
      );
    }

    if (typeof item.isDestroyed === 'function' && item.isDestroyed()) {
      throw new Error(
        `Adding a pane item with URI '${typeof item.getURI === 'function' &&
          item.getURI()}' that has already been destroyed`
      );
    }

    if (this.items.includes(item)) return;

    const itemSubscriptions = new CompositeDisposable();
    this.subscriptionsPerItem.set(item, itemSubscriptions);
    if (typeof item.onDidDestroy === 'function') {
      itemSubscriptions.add(
        item.onDidDestroy(() => this.removeItem(item, false))
      );
    }
    if (typeof item.onDidTerminatePendingState === 'function') {
      itemSubscriptions.add(
        item.onDidTerminatePendingState(() => {
          if (this.getPendingItem() === item) this.clearPendingItem();
        })
      );
    }

    this.items.splice(index, 0, item);
    const lastPendingItem = this.getPendingItem();
    const replacingPendingItem = lastPendingItem != null && !moved;
    if (replacingPendingItem) this.pendingItem = null;
    if (pending) this.setPendingItem(item);

    this.emitter.emit('did-add-item', { item, index, moved });
    if (!moved) {
      if (this.container) this.container.didAddPaneItem(item, this, index);
    }

    if (replacingPendingItem) this.destroyItem(lastPendingItem);
    if (!this.getActiveItem()) this.setActiveItem(item);
    return item;
  }

  setPendingItem(item) {
    if (this.pendingItem !== item) {
      const mostRecentPendingItem = this.pendingItem;
      this.pendingItem = item;
      if (mostRecentPendingItem) {
        this.emitter.emit(
          'item-did-terminate-pending-state',
          mostRecentPendingItem
        );
      }
    }
  }

  getPendingItem() {
    return this.pendingItem || null;
  }

  clearPendingItem() {
    this.setPendingItem(null);
  }

  onItemDidTerminatePendingState(callback) {
    return this.emitter.on('item-did-terminate-pending-state', callback);
  }

  // Public: Add the given items to the pane.
  //
  // * `items` An {Array} of items to add. Items can be views or models with
  //   associated views. Any objects that are already present in the pane's
  //   current items will not be added again.
  // * `index` (optional) {Number} index at which to add the items. If omitted,
  //   the item is #   added after the current active item.
  //
  // Returns an {Array} of added items.
  addItems(items, index = this.getActiveItemIndex() + 1) {
    items = items.filter(item => !this.items.includes(item));
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      this.addItem(item, { index: index + i });
    }
    return items;
  }

  removeItem(item, moved) {
    const index = this.items.indexOf(item);
    if (index === -1) return;
    if (this.getPendingItem() === item) this.pendingItem = null;
    this.removeItemFromStack(item);
    this.emitter.emit('will-remove-item', {
      item,
      index,
      destroyed: !moved,
      moved
    });
    this.unsubscribeFromItem(item);

    if (item === this.activeItem) {
      if (this.items.length === 1) {
        this.setActiveItem(undefined);
      } else if (index === 0) {
        this.activateNextItem();
      } else {
        this.activatePreviousItem();
      }
    }
    this.items.splice(index, 1);
    this.emitter.emit('did-remove-item', {
      item,
      index,
      destroyed: !moved,
      moved
    });
    if (!moved && this.container)
      this.container.didDestroyPaneItem({ item, index, pane: this });
    if (this.items.length === 0 && this.config.get('core.destroyEmptyPanes'))
      this.destroy();
  }

  // Remove the given item from the itemStack.
  //
  // * `item` The item to remove.
  // * `index` {Number} indicating the index to which to remove the item from the itemStack.
  removeItemFromStack(item) {
    const index = this.itemStack.indexOf(item);
    if (index !== -1) this.itemStack.splice(index, 1);
  }

  // Public: Move the given item to the given index.
  //
  // * `item` The item to move.
  // * `index` {Number} indicating the index to which to move the item.
  moveItem(item, newIndex) {
    const oldIndex = this.items.indexOf(item);
    this.items.splice(oldIndex, 1);
    this.items.splice(newIndex, 0, item);
    this.emitter.emit('did-move-item', { item, oldIndex, newIndex });
  }

  // Public: Move the given item to the given index on another pane.
  //
  // * `item` The item to move.
  // * `pane` {Pane} to which to move the item.
  // * `index` {Number} indicating the index to which to move the item in the
  //   given pane.
  moveItemToPane(item, pane, index) {
    this.removeItem(item, true);
    return pane.addItem(item, { index, moved: true });
  }

  // Public: Destroy the active item and activate the next item.
  //
  // Returns a {Promise} that resolves when the item is destroyed.
  destroyActiveItem() {
    return this.destroyItem(this.activeItem);
  }

  // Public: Destroy the given item.
  //
  // If the item is active, the next item will be activated. If the item is the
  // last item, the pane will be destroyed if the `core.destroyEmptyPanes` config
  // setting is `true`.
  //
  // This action can be prevented by onWillDestroyPaneItem callbacks in which
  // case nothing happens.
  //
  // * `item` Item to destroy
  // * `force` (optional) {Boolean} Destroy the item without prompting to save
  //    it, even if the item's `isPermanentDockItem` method returns true.
  //
  // Returns a {Promise} that resolves with a {Boolean} indicating whether or not
  // the item was destroyed.
  async destroyItem(item, force) {
    const index = this.items.indexOf(item);
    if (index === -1) return false;

    if (
      !force &&
      typeof item.isPermanentDockItem === 'function' &&
      item.isPermanentDockItem() &&
      (!this.container || this.container.getLocation() !== 'center')
    ) {
      return false;
    }

    // In the case where there are no `onWillDestroyPaneItem` listeners, preserve the old behavior
    // where `Pane.destroyItem` and callers such as `Pane.close` take effect synchronously.
    if (this.emitter.listenerCountForEventName('will-destroy-item') > 0) {
      await this.emitter.emitAsync('will-destroy-item', { item, index });
    }
    if (
      this.container &&
      this.container.emitter.listenerCountForEventName(
        'will-destroy-pane-item'
      ) > 0
    ) {
      let preventClosing = false;
      await this.container.willDestroyPaneItem({
        item,
        index,
        pane: this,
        prevent: () => {
          preventClosing = true;
        }
      });
      if (preventClosing) return false;
    }

    if (
      !force &&
      typeof item.shouldPromptToSave === 'function' &&
      item.shouldPromptToSave()
    ) {
      if (!(await this.promptToSaveItem(item))) return false;
    }
    this.removeItem(item, false);
    if (typeof item.destroy === 'function') item.destroy();
    return true;
  }

  // Public: Destroy all items.
  destroyItems() {
    return Promise.all(this.getItems().map(item => this.destroyItem(item)));
  }

  // Public: Destroy all items except for the active item.
  destroyInactiveItems() {
    return Promise.all(
      this.getItems()
        .filter(item => item !== this.activeItem)
        .map(item => this.destroyItem(item))
    );
  }

  promptToSaveItem(item, options = {}) {
    return new Promise((resolve, reject) => {
      if (
        typeof item.shouldPromptToSave !== 'function' ||
        !item.shouldPromptToSave(options)
      ) {
        return resolve(true);
      }

      let uri;
      if (typeof item.getURI === 'function') {
        uri = item.getURI();
      } else if (typeof item.getUri === 'function') {
        uri = item.getUri();
      } else {
        return resolve(true);
      }

      const title =
        (typeof item.getTitle === 'function' && item.getTitle()) || uri;

      const saveDialog = (saveButtonText, saveFn, message) => {
        this.applicationDelegate.confirm(
          {
            message,
            detail:
              'Your changes will be lost if you close this item without saving.',
            buttons: [saveButtonText, 'Cancel', "&Don't Save"]
          },
          response => {
            switch (response) {
              case 0:
                return saveFn(item, error => {
                  if (error instanceof SaveCancelledError) {
                    resolve(false);
                  } else if (error) {
                    saveDialog(
                      'Save as',
                      this.saveItemAs,
                      `'${title}' could not be saved.\nError: ${this.getMessageForErrorCode(
                        error.code
                      )}`
                    );
                  } else {
                    resolve(true);
                  }
                });
              case 1:
                return resolve(false);
              case 2:
                return resolve(true);
            }
          }
        );
      };

      saveDialog(
        'Save',
        this.saveItem,
        `'${title}' has changes, do you want to save them?`
      );
    });
  }

  // Public: Save the active item.
  saveActiveItem(nextAction) {
    return this.saveItem(this.getActiveItem(), nextAction);
  }

  // Public: Prompt the user for a location and save the active item with the
  // path they select.
  //
  // * `nextAction` (optional) {Function} which will be called after the item is
  //   successfully saved.
  //
  // Returns a {Promise} that resolves when the save is complete
  saveActiveItemAs(nextAction) {
    return this.saveItemAs(this.getActiveItem(), nextAction);
  }

  // Public: Save the given item.
  //
  // * `item` The item to save.
  // * `nextAction` (optional) {Function} which will be called with no argument
  //   after the item is successfully saved, or with the error if it failed.
  //   The return value will be that of `nextAction` or `undefined` if it was not
  //   provided
  //
  // Returns a {Promise} that resolves when the save is complete
  saveItem(item, nextAction) {
    if (!item) return Promise.resolve();

    let itemURI;
    if (typeof item.getURI === 'function') {
      itemURI = item.getURI();
    } else if (typeof item.getUri === 'function') {
      itemURI = item.getUri();
    }

    if (itemURI != null) {
      if (typeof item.save === 'function') {
        return promisify(() => item.save())
          .then(() => {
            if (nextAction) nextAction();
          })
          .catch(error => {
            if (nextAction) {
              nextAction(error);
            } else {
              this.handleSaveError(error, item);
            }
          });
      } else if (nextAction) {
        nextAction();
        return Promise.resolve();
      }
    } else {
      return this.saveItemAs(item, nextAction);
    }
  }

  // Public: Prompt the user for a location and save the active item with the
  // path they select.
  //
  // * `item` The item to save.
  // * `nextAction` (optional) {Function} which will be called with no argument
  //   after the item is successfully saved, or with the error if it failed.
  //   The return value will be that of `nextAction` or `undefined` if it was not
  //   provided
  async saveItemAs(item, nextAction) {
    if (!item) return;
    if (typeof item.saveAs !== 'function') return;

    const saveOptions =
      typeof item.getSaveDialogOptions === 'function'
        ? item.getSaveDialogOptions()
        : {};

    const itemPath = item.getPath();
    if (itemPath && !saveOptions.defaultPath)
      saveOptions.defaultPath = itemPath;

    let resolveSaveDialogPromise = null;
    const saveDialogPromise = new Promise(resolve => {
      resolveSaveDialogPromise = resolve;
    });
    this.applicationDelegate.showSaveDialog(saveOptions, newItemPath => {
      if (newItemPath) {
        promisify(() => item.saveAs(newItemPath))
          .then(() => {
            if (nextAction) {
              resolveSaveDialogPromise(nextAction());
            } else {
              resolveSaveDialogPromise();
            }
          })
          .catch(error => {
            if (nextAction) {
              resolveSaveDialogPromise(nextAction(error));
            } else {
              this.handleSaveError(error, item);
              resolveSaveDialogPromise();
            }
          });
      } else if (nextAction) {
        resolveSaveDialogPromise(
          nextAction(new SaveCancelledError('Save Cancelled'))
        );
      } else {
        resolveSaveDialogPromise();
      }
    });

    return saveDialogPromise;
  }

  // Public: Save all items.
  saveItems() {
    for (let item of this.getItems()) {
      if (typeof item.isModified === 'function' && item.isModified()) {
        this.saveItem(item);
      }
    }
  }

  // Public: Return the first item that matches the given URI or undefined if
  // none exists.
  //
  // * `uri` {String} containing a URI.
  itemForURI(uri) {
    return this.items.find(item => {
      if (typeof item.getURI === 'function') {
        return item.getURI() === uri;
      } else if (typeof item.getUri === 'function') {
        return item.getUri() === uri;
      }
    });
  }

  // Public: Activate the first item that matches the given URI.
  //
  // * `uri` {String} containing a URI.
  //
  // Returns a {Boolean} indicating whether an item matching the URI was found.
  activateItemForURI(uri) {
    const item = this.itemForURI(uri);
    if (item) {
      this.activateItem(item);
      return true;
    } else {
      return false;
    }
  }

  copyActiveItem() {
    if (this.activeItem && typeof this.activeItem.copy === 'function') {
      return this.activeItem.copy();
    }
  }

  /*
  Section: Lifecycle
  */

  // Public: Determine whether the pane is active.
  //
  // Returns a {Boolean}.
  isActive() {
    return this.container && this.container.getActivePane() === this;
  }

  // Public: Makes this pane the *active* pane, causing it to gain focus.
  activate() {
    if (this.isDestroyed()) throw new Error('Pane has been destroyed');
    this.focused = true;

    if (this.container) this.container.didActivatePane(this);
    this.emitter.emit('did-activate');
  }

  // Public: Close the pane and destroy all its items.
  //
  // If this is the last pane, all the items will be destroyed but the pane
  // itself will not be destroyed.
  destroy() {
    if (
      this.container &&
      this.container.isAlive() &&
      this.container.getPanes().length === 1
    ) {
      return this.destroyItems();
    }

    this.emitter.emit('will-destroy');
    this.alive = false;
    if (this.container) {
      this.container.willDestroyPane({ pane: this });
      if (this.isActive()) this.container.activateNextPane();
    }
    this.emitter.emit('did-destroy');
    this.emitter.dispose();
    for (let item of this.items.slice()) {
      if (typeof item.destroy === 'function') item.destroy();
    }
    if (this.container) this.container.didDestroyPane({ pane: this });
  }

  isAlive() {
    return this.alive;
  }

  // Public: Determine whether this pane has been destroyed.
  //
  // Returns a {Boolean}.
  isDestroyed() {
    return !this.isAlive();
  }

  /*
  Section: Splitting
  */

  // Public: Create a new pane to the left of this pane.
  //
  // * `params` (optional) {Object} with the following keys:
  //   * `items` (optional) {Array} of items to add to the new pane.
  //   * `copyActiveItem` (optional) {Boolean} true will copy the active item into the new split pane
  //
  // Returns the new {Pane}.
  splitLeft(params) {
    return this.split('horizontal', 'before', params);
  }

  // Public: Create a new pane to the right of this pane.
  //
  // * `params` (optional) {Object} with the following keys:
  //   * `items` (optional) {Array} of items to add to the new pane.
  //   * `copyActiveItem` (optional) {Boolean} true will copy the active item into the new split pane
  //
  // Returns the new {Pane}.
  splitRight(params) {
    return this.split('horizontal', 'after', params);
  }

  // Public: Creates a new pane above the receiver.
  //
  // * `params` (optional) {Object} with the following keys:
  //   * `items` (optional) {Array} of items to add to the new pane.
  //   * `copyActiveItem` (optional) {Boolean} true will copy the active item into the new split pane
  //
  // Returns the new {Pane}.
  splitUp(params) {
    return this.split('vertical', 'before', params);
  }

  // Public: Creates a new pane below the receiver.
  //
  // * `params` (optional) {Object} with the following keys:
  //   * `items` (optional) {Array} of items to add to the new pane.
  //   * `copyActiveItem` (optional) {Boolean} true will copy the active item into the new split pane
  //
  // Returns the new {Pane}.
  splitDown(params) {
    return this.split('vertical', 'after', params);
  }

  split(orientation, side, params) {
    if (params && params.copyActiveItem) {
      if (!params.items) params.items = [];
      params.items.push(this.copyActiveItem());
    }

    if (this.parent.orientation !== orientation) {
      this.parent.replaceChild(
        this,
        new PaneAxis(
          {
            container: this.container,
            orientation,
            children: [this],
            flexScale: this.flexScale
          },
          this.viewRegistry
        )
      );
      this.setFlexScale(1);
    }

    const newPane = new Pane(
      Object.assign(
        {
          applicationDelegate: this.applicationDelegate,
          notificationManager: this.notificationManager,
          deserializerManager: this.deserializerManager,
          config: this.config,
          viewRegistry: this.viewRegistry
        },
        params
      )
    );

    switch (side) {
      case 'before':
        this.parent.insertChildBefore(this, newPane);
        break;
      case 'after':
        this.parent.insertChildAfter(this, newPane);
        break;
    }

    if (params && params.moveActiveItem && this.activeItem)
      this.moveItemToPane(this.activeItem, newPane);

    newPane.activate();
    return newPane;
  }

  // If the parent is a horizontal axis, returns its first child if it is a pane;
  // otherwise returns this pane.
  findLeftmostSibling() {
    if (this.parent.orientation === 'horizontal') {
      const [leftmostSibling] = this.parent.children;
      if (leftmostSibling instanceof PaneAxis) {
        return this;
      } else {
        return leftmostSibling;
      }
    } else {
      return this;
    }
  }

  findRightmostSibling() {
    if (this.parent.orientation === 'horizontal') {
      const rightmostSibling = this.parent.children[
        this.parent.children.length - 1
      ];
      if (rightmostSibling instanceof PaneAxis) {
        return this;
      } else {
        return rightmostSibling;
      }
    } else {
      return this;
    }
  }

  // If the parent is a horizontal axis, returns its last child if it is a pane;
  // otherwise returns a new pane created by splitting this pane rightward.
  findOrCreateRightmostSibling() {
    const rightmostSibling = this.findRightmostSibling();
    if (rightmostSibling === this) {
      return this.splitRight();
    } else {
      return rightmostSibling;
    }
  }

  // If the parent is a vertical axis, returns its first child if it is a pane;
  // otherwise returns this pane.
  findTopmostSibling() {
    if (this.parent.orientation === 'vertical') {
      const [topmostSibling] = this.parent.children;
      if (topmostSibling instanceof PaneAxis) {
        return this;
      } else {
        return topmostSibling;
      }
    } else {
      return this;
    }
  }

  findBottommostSibling() {
    if (this.parent.orientation === 'vertical') {
      const bottommostSibling = this.parent.children[
        this.parent.children.length - 1
      ];
      if (bottommostSibling instanceof PaneAxis) {
        return this;
      } else {
        return bottommostSibling;
      }
    } else {
      return this;
    }
  }

  // If the parent is a vertical axis, returns its last child if it is a pane;
  // otherwise returns a new pane created by splitting this pane bottomward.
  findOrCreateBottommostSibling() {
    const bottommostSibling = this.findBottommostSibling();
    if (bottommostSibling === this) {
      return this.splitDown();
    } else {
      return bottommostSibling;
    }
  }

  // Private: Close the pane unless the user cancels the action via a dialog.
  //
  // Returns a {Promise} that resolves once the pane is either closed, or the
  // closing has been cancelled.
  close() {
    return Promise.all(
      this.getItems().map(item => this.promptToSaveItem(item))
    ).then(results => {
      if (!results.includes(false)) return this.destroy();
    });
  }

  handleSaveError(error, item) {
    const itemPath =
      error.path || (typeof item.getPath === 'function' && item.getPath());
    const addWarningWithPath = (message, options) => {
      if (itemPath) message = `${message} '${itemPath}'`;
      this.notificationManager.addWarning(message, options);
    };

    const customMessage = this.getMessageForErrorCode(error.code);
    if (customMessage != null) {
      addWarningWithPath(`Unable to save file: ${customMessage}`);
    } else if (
      error.code === 'EISDIR' ||
      (error.message && error.message.endsWith('is a directory'))
    ) {
      return this.notificationManager.addWarning(
        `Unable to save file: ${error.message}`
      );
    } else if (
      ['EPERM', 'EBUSY', 'UNKNOWN', 'EEXIST', 'ELOOP', 'EAGAIN'].includes(
        error.code
      )
    ) {
      addWarningWithPath('Unable to save file', { detail: error.message });
    } else {
      const errorMatch = /ENOTDIR, not a directory '([^']+)'/.exec(
        error.message
      );
      if (errorMatch) {
        const fileName = errorMatch[1];
        this.notificationManager.addWarning(
          `Unable to save file: A directory in the path '${fileName}' could not be written to`
        );
      } else {
        throw error;
      }
    }
  }

  getMessageForErrorCode(errorCode) {
    switch (errorCode) {
      case 'EACCES':
        return 'Permission denied';
      case 'ECONNRESET':
        return 'Connection reset';
      case 'EINTR':
        return 'Interrupted system call';
      case 'EIO':
        return 'I/O error writing file';
      case 'ENOSPC':
        return 'No space left on device';
      case 'ENOTSUP':
        return 'Operation not supported on socket';
      case 'ENXIO':
        return 'No such device or address';
      case 'EROFS':
        return 'Read-only file system';
      case 'ESPIPE':
        return 'Invalid seek';
      case 'ETIMEDOUT':
        return 'Connection timed out';
    }
  }
};

function promisify(callback) {
  try {
    return Promise.resolve(callback());
  } catch (error) {
    return Promise.reject(error);
  }
}

================
File: src/text-editor-component.js
================
/* global ResizeObserver */

const etch = require('etch');
const { Point, Range } = require('text-buffer');
const LineTopIndex = require('line-top-index');
const TextEditor = require('./text-editor');
const { isPairedCharacter } = require('./text-utils');
const electron = require('electron');
const clipboard = electron.clipboard;
const $ = etch.dom;

let TextEditorElement;

const DEFAULT_ROWS_PER_TILE = 6;
const NORMAL_WIDTH_CHARACTER = 'x';
const DOUBLE_WIDTH_CHARACTER = '我';
const HALF_WIDTH_CHARACTER = 'ﾊ';
const KOREAN_CHARACTER = '세';
const NBSP_CHARACTER = '\u00a0';
const ZERO_WIDTH_NBSP_CHARACTER = '\ufeff';
const MOUSE_DRAG_AUTOSCROLL_MARGIN = 40;
const CURSOR_BLINK_RESUME_DELAY = 300;
const CURSOR_BLINK_PERIOD = 800;

function scaleMouseDragAutoscrollDelta(delta) {
  return Math.pow(delta / 3, 3) / 280;
}

module.exports = class TextEditorComponent {
  static setScheduler(scheduler) {
    etch.setScheduler(scheduler);
  }

  static getScheduler() {
    return etch.getScheduler();
  }

  static didUpdateStyles() {
    if (this.attachedComponents) {
      this.attachedComponents.forEach(component => {
        component.didUpdateStyles();
      });
    }
  }

  static didUpdateScrollbarStyles() {
    if (this.attachedComponents) {
      this.attachedComponents.forEach(component => {
        component.didUpdateScrollbarStyles();
      });
    }
  }

  constructor(props) {
    this.props = props;

    if (!props.model) {
      props.model = new TextEditor({
        mini: props.mini,
        readOnly: props.readOnly
      });
    }
    this.props.model.component = this;

    if (props.element) {
      this.element = props.element;
    } else {
      if (!TextEditorElement)
        TextEditorElement = require('./text-editor-element');
      this.element = TextEditorElement.createTextEditorElement();
    }
    this.element.initialize(this);
    this.virtualNode = $('atom-text-editor');
    this.virtualNode.domNode = this.element;
    this.refs = {};

    this.updateSync = this.updateSync.bind(this);
    this.didBlurHiddenInput = this.didBlurHiddenInput.bind(this);
    this.didFocusHiddenInput = this.didFocusHiddenInput.bind(this);
    this.didPaste = this.didPaste.bind(this);
    this.didTextInput = this.didTextInput.bind(this);
    this.didKeydown = this.didKeydown.bind(this);
    this.didKeyup = this.didKeyup.bind(this);
    this.didKeypress = this.didKeypress.bind(this);
    this.didCompositionStart = this.didCompositionStart.bind(this);
    this.didCompositionUpdate = this.didCompositionUpdate.bind(this);
    this.didCompositionEnd = this.didCompositionEnd.bind(this);

    this.updatedSynchronously = this.props.updatedSynchronously;
    this.didScrollDummyScrollbar = this.didScrollDummyScrollbar.bind(this);
    this.didMouseDownOnContent = this.didMouseDownOnContent.bind(this);
    this.debouncedResumeCursorBlinking = debounce(
      this.resumeCursorBlinking.bind(this),
      this.props.cursorBlinkResumeDelay || CURSOR_BLINK_RESUME_DELAY
    );
    this.lineTopIndex = new LineTopIndex();
    this.lineNodesPool = new NodePool();
    this.updateScheduled = false;
    this.suppressUpdates = false;
    this.hasInitialMeasurements = false;
    this.measurements = {
      lineHeight: 0,
      baseCharacterWidth: 0,
      doubleWidthCharacterWidth: 0,
      halfWidthCharacterWidth: 0,
      koreanCharacterWidth: 0,
      gutterContainerWidth: 0,
      lineNumberGutterWidth: 0,
      clientContainerHeight: 0,
      clientContainerWidth: 0,
      verticalScrollbarWidth: 0,
      horizontalScrollbarHeight: 0,
      longestLineWidth: 0
    };
    this.derivedDimensionsCache = {};
    this.visible = false;
    this.cursorsBlinking = false;
    this.cursorsBlinkedOff = false;
    this.nextUpdateOnlyBlinksCursors = null;
    this.linesToMeasure = new Map();
    this.extraRenderedScreenLines = new Map();
    this.horizontalPositionsToMeasure = new Map(); // Keys are rows with positions we want to measure, values are arrays of columns to measure
    this.horizontalPixelPositionsByScreenLineId = new Map(); // Values are maps from column to horizontal pixel positions
    this.blockDecorationsToMeasure = new Set();
    this.blockDecorationsByElement = new WeakMap();
    this.blockDecorationSentinel = document.createElement('div');
    this.blockDecorationSentinel.style.height = '1px';
    this.heightsByBlockDecoration = new WeakMap();
    this.blockDecorationResizeObserver = new ResizeObserver(
      this.didResizeBlockDecorations.bind(this)
    );
    this.lineComponentsByScreenLineId = new Map();
    this.overlayComponents = new Set();
    this.shouldRenderDummyScrollbars = true;
    this.remeasureScrollbars = false;
    this.pendingAutoscroll = null;
    this.scrollTopPending = false;
    this.scrollLeftPending = false;
    this.scrollTop = 0;
    this.scrollLeft = 0;
    this.previousScrollWidth = 0;
    this.previousScrollHeight = 0;
    this.lastKeydown = null;
    this.lastKeydownBeforeKeypress = null;
    this.accentedCharacterMenuIsOpen = false;
    this.remeasureGutterDimensions = false;
    this.guttersToRender = [this.props.model.getLineNumberGutter()];
    this.guttersVisibility = [this.guttersToRender[0].visible];
    this.idsByTileStartRow = new Map();
    this.nextTileId = 0;
    this.renderedTileStartRows = [];
    this.showLineNumbers = this.props.model.doesShowLineNumbers();
    this.lineNumbersToRender = {
      maxDigits: 2,
      bufferRows: [],
      screenRows: [],
      keys: [],
      softWrappedFlags: [],
      foldableFlags: []
    };
    this.decorationsToRender = {
      lineNumbers: new Map(),
      lines: null,
      highlights: [],
      cursors: [],
      overlays: [],
      customGutter: new Map(),
      blocks: new Map(),
      text: []
    };
    this.decorationsToMeasure = {
      highlights: [],
      cursors: new Map()
    };
    this.textDecorationsByMarker = new Map();
    this.textDecorationBoundaries = [];
    this.pendingScrollTopRow = this.props.initialScrollTopRow;
    this.pendingScrollLeftColumn = this.props.initialScrollLeftColumn;
    this.tabIndex =
      this.props.element && this.props.element.tabIndex
        ? this.props.element.tabIndex
        : -1;

    this.measuredContent = false;
    this.queryGuttersToRender();
    this.queryMaxLineNumberDigits();
    this.observeBlockDecorations();
    this.updateClassList();
    etch.updateSync(this);
  }

  update(props) {
    if (props.model !== this.props.model) {
      this.props.model.component = null;
      props.model.component = this;
    }
    this.props = props;
    this.scheduleUpdate();
  }

  pixelPositionForScreenPosition({ row, column }) {
    const top = this.pixelPositionAfterBlocksForRow(row);
    let left = column === 0 ? 0 : this.pixelLeftForRowAndColumn(row, column);
    if (left == null) {
      this.requestHorizontalMeasurement(row, column);
      this.updateSync();
      left = this.pixelLeftForRowAndColumn(row, column);
    }
    return { top, left };
  }

  scheduleUpdate(nextUpdateOnlyBlinksCursors = false) {
    if (!this.visible) return;
    if (this.suppressUpdates) return;

    this.nextUpdateOnlyBlinksCursors =
      this.nextUpdateOnlyBlinksCursors !== false &&
      nextUpdateOnlyBlinksCursors === true;

    if (this.updatedSynchronously) {
      this.updateSync();
    } else if (!this.updateScheduled) {
      this.updateScheduled = true;
      etch.getScheduler().updateDocument(() => {
        if (this.updateScheduled) this.updateSync(true);
      });
    }
  }

  updateSync(useScheduler = false) {
    // Don't proceed if we know we are not visible
    if (!this.visible) {
      this.updateScheduled = false;
      return;
    }

    // Don't proceed if we have to pay for a measurement anyway and detect
    // that we are no longer visible.
    if (
      (this.remeasureCharacterDimensions ||
        this.remeasureAllBlockDecorations) &&
      !this.isVisible()
    ) {
      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise();
      this.updateScheduled = false;
      return;
    }

    const onlyBlinkingCursors = this.nextUpdateOnlyBlinksCursors;
    this.nextUpdateOnlyBlinksCursors = null;
    if (useScheduler && onlyBlinkingCursors) {
      this.refs.cursorsAndInput.updateCursorBlinkSync(this.cursorsBlinkedOff);
      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise();
      this.updateScheduled = false;
      return;
    }

    if (this.remeasureCharacterDimensions) {
      const originalLineHeight = this.getLineHeight();
      const originalBaseCharacterWidth = this.getBaseCharacterWidth();
      const scrollTopRow = this.getScrollTopRow();
      const scrollLeftColumn = this.getScrollLeftColumn();

      this.measureCharacterDimensions();
      this.measureGutterDimensions();
      this.queryLongestLine();

      if (this.getLineHeight() !== originalLineHeight) {
        this.setScrollTopRow(scrollTopRow);
      }
      if (this.getBaseCharacterWidth() !== originalBaseCharacterWidth) {
        this.setScrollLeftColumn(scrollLeftColumn);
      }
      this.remeasureCharacterDimensions = false;
    }

    if (this.isVisible()) this.measureBlockDecorations();

    this.updateSyncBeforeMeasuringContent();
    if (useScheduler === true) {
      const scheduler = etch.getScheduler();
      scheduler.readDocument(() => {
        const restartFrame = this.measureContentDuringUpdateSync();
        scheduler.updateDocument(() => {
          if (restartFrame) {
            this.updateSync(true);
          } else {
            this.updateSyncAfterMeasuringContent();
          }
        });
      });
    } else {
      const restartFrame = this.measureContentDuringUpdateSync();
      if (restartFrame) {
        this.updateSync(false);
      } else {
        this.updateSyncAfterMeasuringContent();
      }
    }

    this.updateScheduled = false;
  }

  measureBlockDecorations() {
    if (this.remeasureAllBlockDecorations) {
      this.remeasureAllBlockDecorations = false;

      const decorations = this.props.model.getDecorations();
      for (let i = 0; i < decorations.length; i++) {
        const decoration = decorations[i];
        const marker = decoration.getMarker();
        if (marker.isValid() && decoration.getProperties().type === 'block') {
          this.blockDecorationsToMeasure.add(decoration);
        }
      }

      // Update the width of the line tiles to ensure block decorations are
      // measured with the most recent width.
      if (this.blockDecorationsToMeasure.size > 0) {
        this.updateSyncBeforeMeasuringContent();
      }
    }

    if (this.blockDecorationsToMeasure.size > 0) {
      const { blockDecorationMeasurementArea } = this.refs;
      const sentinelElements = new Set();

      blockDecorationMeasurementArea.appendChild(document.createElement('div'));
      this.blockDecorationsToMeasure.forEach(decoration => {
        const { item } = decoration.getProperties();
        const decorationElement = TextEditor.viewForItem(item);
        if (document.contains(decorationElement)) {
          const parentElement = decorationElement.parentElement;

          if (!decorationElement.previousSibling) {
            const sentinelElement = this.blockDecorationSentinel.cloneNode();
            parentElement.insertBefore(sentinelElement, decorationElement);
            sentinelElements.add(sentinelElement);
          }

          if (!decorationElement.nextSibling) {
            const sentinelElement = this.blockDecorationSentinel.cloneNode();
            parentElement.appendChild(sentinelElement);
            sentinelElements.add(sentinelElement);
          }

          this.didMeasureVisibleBlockDecoration = true;
        } else {
          blockDecorationMeasurementArea.appendChild(
            this.blockDecorationSentinel.cloneNode()
          );
          blockDecorationMeasurementArea.appendChild(decorationElement);
          blockDecorationMeasurementArea.appendChild(
            this.blockDecorationSentinel.cloneNode()
          );
        }
      });

      if (this.resizeBlockDecorationMeasurementsArea) {
        this.resizeBlockDecorationMeasurementsArea = false;
        this.refs.blockDecorationMeasurementArea.style.width =
          this.getScrollWidth() + 'px';
      }

      this.blockDecorationsToMeasure.forEach(decoration => {
        const { item } = decoration.getProperties();
        const decorationElement = TextEditor.viewForItem(item);
        const { previousSibling, nextSibling } = decorationElement;
        const height =
          nextSibling.getBoundingClientRect().top -
          previousSibling.getBoundingClientRect().bottom;
        this.heightsByBlockDecoration.set(decoration, height);
        this.lineTopIndex.resizeBlock(decoration, height);
      });

      sentinelElements.forEach(sentinelElement => sentinelElement.remove());
      while (blockDecorationMeasurementArea.firstChild) {
        blockDecorationMeasurementArea.firstChild.remove();
      }
      this.blockDecorationsToMeasure.clear();
    }
  }

  updateSyncBeforeMeasuringContent() {
    this.measuredContent = false;
    this.derivedDimensionsCache = {};
    this.updateModelSoftWrapColumn();
    if (this.pendingAutoscroll) {
      let { screenRange, options } = this.pendingAutoscroll;
      this.autoscrollVertically(screenRange, options);
      this.requestHorizontalMeasurement(
        screenRange.start.row,
        screenRange.start.column
      );
      this.requestHorizontalMeasurement(
        screenRange.end.row,
        screenRange.end.column
      );
    }
    this.populateVisibleRowRange(this.getRenderedStartRow());
    this.populateVisibleTiles();
    this.queryScreenLinesToRender();
    this.queryLongestLine();
    this.queryLineNumbersToRender();
    this.queryGuttersToRender();
    this.queryDecorationsToRender();
    this.queryExtraScreenLinesToRender();
    this.shouldRenderDummyScrollbars = !this.remeasureScrollbars;
    etch.updateSync(this);
    this.updateClassList();
    this.shouldRenderDummyScrollbars = true;
    this.didMeasureVisibleBlockDecoration = false;
  }

  measureContentDuringUpdateSync() {
    let gutterDimensionsChanged = false;
    if (this.remeasureGutterDimensions) {
      gutterDimensionsChanged = this.measureGutterDimensions();
      this.remeasureGutterDimensions = false;
    }
    const wasHorizontalScrollbarVisible =
      this.canScrollHorizontally() && this.getHorizontalScrollbarHeight() > 0;

    this.measureLongestLineWidth();
    this.measureHorizontalPositions();
    this.updateAbsolutePositionedDecorations();

    const isHorizontalScrollbarVisible =
      this.canScrollHorizontally() && this.getHorizontalScrollbarHeight() > 0;

    if (this.pendingAutoscroll) {
      this.derivedDimensionsCache = {};
      const { screenRange, options } = this.pendingAutoscroll;
      this.autoscrollHorizontally(screenRange, options);

      if (!wasHorizontalScrollbarVisible && isHorizontalScrollbarVisible) {
        this.autoscrollVertically(screenRange, options);
      }
      this.pendingAutoscroll = null;
    }

    this.linesToMeasure.clear();
    this.measuredContent = true;

    return (
      gutterDimensionsChanged ||
      wasHorizontalScrollbarVisible !== isHorizontalScrollbarVisible
    );
  }

  updateSyncAfterMeasuringContent() {
    this.derivedDimensionsCache = {};
    etch.updateSync(this);

    this.currentFrameLineNumberGutterProps = null;
    this.scrollTopPending = false;
    this.scrollLeftPending = false;
    if (this.remeasureScrollbars) {
      // Flush stored scroll positions to the vertical and the horizontal
      // scrollbars. This is because they have just been destroyed and recreated
      // as a result of their remeasurement, but we could not assign the scroll
      // top while they were initialized because they were not attached to the
      // DOM yet.
      this.refs.verticalScrollbar.flushScrollPosition();
      this.refs.horizontalScrollbar.flushScrollPosition();

      this.measureScrollbarDimensions();
      this.remeasureScrollbars = false;
      etch.updateSync(this);
    }

    this.derivedDimensionsCache = {};
    if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise();
  }

  render() {
    const { model } = this.props;
    const style = {};

    if (!model.getAutoHeight() && !model.getAutoWidth()) {
      style.contain = 'size';
    }

    let clientContainerHeight = '100%';
    let clientContainerWidth = '100%';
    if (this.hasInitialMeasurements) {
      if (model.getAutoHeight()) {
        clientContainerHeight =
          this.getContentHeight() + this.getHorizontalScrollbarHeight() + 'px';
      }
      if (model.getAutoWidth()) {
        style.width = 'min-content';
        clientContainerWidth =
          this.getGutterContainerWidth() +
          this.getContentWidth() +
          this.getVerticalScrollbarWidth() +
          'px';
      } else {
        style.width = this.element.style.width;
      }
    }

    let attributes = {};
    if (model.isMini()) {
      attributes.mini = '';
    }

    if (model.isReadOnly()) {
      attributes.readonly = '';
    }

    const dataset = { encoding: model.getEncoding() };
    const grammar = model.getGrammar();
    if (grammar && grammar.scopeName) {
      dataset.grammar = grammar.scopeName.replace(/\./g, ' ');
    }

    return $(
      'atom-text-editor',
      {
        // See this.updateClassList() for construction of the class name
        style,
        attributes,
        dataset,
        tabIndex: -1,
        on: { mousewheel: this.didMouseWheel }
      },
      $.div(
        {
          ref: 'clientContainer',
          style: {
            position: 'relative',
            contain: 'strict',
            overflow: 'hidden',
            backgroundColor: 'inherit',
            height: clientContainerHeight,
            width: clientContainerWidth
          }
        },
        this.renderGutterContainer(),
        this.renderScrollContainer()
      ),
      this.renderOverlayDecorations()
    );
  }

  renderGutterContainer() {
    if (this.props.model.isMini()) {
      return null;
    } else {
      return $(GutterContainerComponent, {
        ref: 'gutterContainer',
        key: 'gutterContainer',
        rootComponent: this,
        hasInitialMeasurements: this.hasInitialMeasurements,
        measuredContent: this.measuredContent,
        scrollTop: this.getScrollTop(),
        scrollHeight: this.getScrollHeight(),
        lineNumberGutterWidth: this.getLineNumberGutterWidth(),
        lineHeight: this.getLineHeight(),
        renderedStartRow: this.getRenderedStartRow(),
        renderedEndRow: this.getRenderedEndRow(),
        rowsPerTile: this.getRowsPerTile(),
        guttersToRender: this.guttersToRender,
        decorationsToRender: this.decorationsToRender,
        isLineNumberGutterVisible: this.props.model.isLineNumberGutterVisible(),
        showLineNumbers: this.showLineNumbers,
        lineNumbersToRender: this.lineNumbersToRender,
        didMeasureVisibleBlockDecoration: this.didMeasureVisibleBlockDecoration
      });
    }
  }

  renderScrollContainer() {
    const style = {
      position: 'absolute',
      contain: 'strict',
      overflow: 'hidden',
      top: 0,
      bottom: 0,
      backgroundColor: 'inherit'
    };

    if (this.hasInitialMeasurements) {
      style.left = this.getGutterContainerWidth() + 'px';
      style.width = this.getScrollContainerWidth() + 'px';
    }

    return $.div(
      {
        ref: 'scrollContainer',
        key: 'scrollContainer',
        className: 'scroll-view',
        style
      },
      this.renderContent(),
      this.renderDummyScrollbars()
    );
  }

  renderContent() {
    let style = {
      contain: 'strict',
      overflow: 'hidden',
      backgroundColor: 'inherit'
    };
    if (this.hasInitialMeasurements) {
      style.width = ceilToPhysicalPixelBoundary(this.getScrollWidth()) + 'px';
      style.height = ceilToPhysicalPixelBoundary(this.getScrollHeight()) + 'px';
      style.willChange = 'transform';
      style.transform = `translate(${-roundToPhysicalPixelBoundary(
        this.getScrollLeft()
      )}px, ${-roundToPhysicalPixelBoundary(this.getScrollTop())}px)`;
    }

    return $.div(
      {
        ref: 'content',
        on: { mousedown: this.didMouseDownOnContent },
        style
      },
      this.renderLineTiles(),
      this.renderBlockDecorationMeasurementArea(),
      this.renderCharacterMeasurementLine()
    );
  }

  renderHighlightDecorations() {
    return $(HighlightsComponent, {
      hasInitialMeasurements: this.hasInitialMeasurements,
      highlightDecorations: this.decorationsToRender.highlights.slice(),
      width: this.getScrollWidth(),
      height: this.getScrollHeight(),
      lineHeight: this.getLineHeight()
    });
  }

  renderLineTiles() {
    const style = {
      position: 'absolute',
      contain: 'strict',
      overflow: 'hidden'
    };

    const children = [];
    children.push(this.renderHighlightDecorations());

    if (this.hasInitialMeasurements) {
      const { lineComponentsByScreenLineId } = this;

      const startRow = this.getRenderedStartRow();
      const endRow = this.getRenderedEndRow();
      const rowsPerTile = this.getRowsPerTile();
      const tileWidth = this.getScrollWidth();

      for (let i = 0; i < this.renderedTileStartRows.length; i++) {
        const tileStartRow = this.renderedTileStartRows[i];
        const tileEndRow = Math.min(endRow, tileStartRow + rowsPerTile);
        const tileHeight =
          this.pixelPositionBeforeBlocksForRow(tileEndRow) -
          this.pixelPositionBeforeBlocksForRow(tileStartRow);

        children.push(
          $(LinesTileComponent, {
            key: this.idsByTileStartRow.get(tileStartRow),
            measuredContent: this.measuredContent,
            height: tileHeight,
            width: tileWidth,
            top: this.pixelPositionBeforeBlocksForRow(tileStartRow),
            lineHeight: this.getLineHeight(),
            renderedStartRow: startRow,
            tileStartRow,
            tileEndRow,
            screenLines: this.renderedScreenLines.slice(
              tileStartRow - startRow,
              tileEndRow - startRow
            ),
            lineDecorations: this.decorationsToRender.lines.slice(
              tileStartRow - startRow,
              tileEndRow - startRow
            ),
            textDecorations: this.decorationsToRender.text.slice(
              tileStartRow - startRow,
              tileEndRow - startRow
            ),
            blockDecorations: this.decorationsToRender.blocks.get(tileStartRow),
            displayLayer: this.props.model.displayLayer,
            nodePool: this.lineNodesPool,
            lineComponentsByScreenLineId
          })
        );
      }

      this.extraRenderedScreenLines.forEach((screenLine, screenRow) => {
        if (screenRow < startRow || screenRow >= endRow) {
          children.push(
            $(LineComponent, {
              key: 'extra-' + screenLine.id,
              offScreen: true,
              screenLine,
              screenRow,
              displayLayer: this.props.model.displayLayer,
              nodePool: this.lineNodesPool,
              lineComponentsByScreenLineId
            })
          );
        }
      });

      style.width = this.getScrollWidth() + 'px';
      style.height = this.getScrollHeight() + 'px';
    }

    children.push(this.renderPlaceholderText());
    children.push(this.renderCursorsAndInput());

    return $.div(
      { key: 'lineTiles', ref: 'lineTiles', className: 'lines', style },
      children
    );
  }

  renderCursorsAndInput() {
    return $(CursorsAndInputComponent, {
      ref: 'cursorsAndInput',
      key: 'cursorsAndInput',
      didBlurHiddenInput: this.didBlurHiddenInput,
      didFocusHiddenInput: this.didFocusHiddenInput,
      didTextInput: this.didTextInput,
      didPaste: this.didPaste,
      didKeydown: this.didKeydown,
      didKeyup: this.didKeyup,
      didKeypress: this.didKeypress,
      didCompositionStart: this.didCompositionStart,
      didCompositionUpdate: this.didCompositionUpdate,
      didCompositionEnd: this.didCompositionEnd,
      measuredContent: this.measuredContent,
      lineHeight: this.getLineHeight(),
      scrollHeight: this.getScrollHeight(),
      scrollWidth: this.getScrollWidth(),
      decorationsToRender: this.decorationsToRender,
      cursorsBlinkedOff: this.cursorsBlinkedOff,
      hiddenInputPosition: this.hiddenInputPosition,
      tabIndex: this.tabIndex
    });
  }

  renderPlaceholderText() {
    const { model } = this.props;
    if (model.isEmpty()) {
      const placeholderText = model.getPlaceholderText();
      if (placeholderText != null) {
        return $.div({ className: 'placeholder-text' }, placeholderText);
      }
    }
    return null;
  }

  renderCharacterMeasurementLine() {
    return $.div(
      {
        key: 'characterMeasurementLine',
        ref: 'characterMeasurementLine',
        className: 'line dummy',
        style: { position: 'absolute', visibility: 'hidden' }
      },
      $.span({ ref: 'normalWidthCharacterSpan' }, NORMAL_WIDTH_CHARACTER),
      $.span({ ref: 'doubleWidthCharacterSpan' }, DOUBLE_WIDTH_CHARACTER),
      $.span({ ref: 'halfWidthCharacterSpan' }, HALF_WIDTH_CHARACTER),
      $.span({ ref: 'koreanCharacterSpan' }, KOREAN_CHARACTER)
    );
  }

  renderBlockDecorationMeasurementArea() {
    return $.div({
      ref: 'blockDecorationMeasurementArea',
      key: 'blockDecorationMeasurementArea',
      style: {
        contain: 'strict',
        position: 'absolute',
        visibility: 'hidden',
        width: this.getScrollWidth() + 'px'
      }
    });
  }

  renderDummyScrollbars() {
    if (this.shouldRenderDummyScrollbars && !this.props.model.isMini()) {
      let scrollHeight, scrollTop, horizontalScrollbarHeight;
      let scrollWidth,
        scrollLeft,
        verticalScrollbarWidth,
        forceScrollbarVisible;
      let canScrollHorizontally, canScrollVertically;

      if (this.hasInitialMeasurements) {
        scrollHeight = this.getScrollHeight();
        scrollWidth = this.getScrollWidth();
        scrollTop = this.getScrollTop();
        scrollLeft = this.getScrollLeft();
        canScrollHorizontally = this.canScrollHorizontally();
        canScrollVertically = this.canScrollVertically();
        horizontalScrollbarHeight = this.getHorizontalScrollbarHeight();
        verticalScrollbarWidth = this.getVerticalScrollbarWidth();
        forceScrollbarVisible = this.remeasureScrollbars;
      } else {
        forceScrollbarVisible = true;
      }

      return [
        $(DummyScrollbarComponent, {
          ref: 'verticalScrollbar',
          orientation: 'vertical',
          didScroll: this.didScrollDummyScrollbar,
          didMouseDown: this.didMouseDownOnContent,
          canScroll: canScrollVertically,
          scrollHeight,
          scrollTop,
          horizontalScrollbarHeight,
          forceScrollbarVisible
        }),
        $(DummyScrollbarComponent, {
          ref: 'horizontalScrollbar',
          orientation: 'horizontal',
          didScroll: this.didScrollDummyScrollbar,
          didMouseDown: this.didMouseDownOnContent,
          canScroll: canScrollHorizontally,
          scrollWidth,
          scrollLeft,
          verticalScrollbarWidth,
          forceScrollbarVisible
        }),

        // Force a "corner" to render where the two scrollbars meet at the lower right
        $.div({
          ref: 'scrollbarCorner',
          className: 'scrollbar-corner',
          style: {
            position: 'absolute',
            height: '20px',
            width: '20px',
            bottom: 0,
            right: 0,
            overflow: 'scroll'
          }
        })
      ];
    } else {
      return null;
    }
  }

  renderOverlayDecorations() {
    return this.decorationsToRender.overlays.map(overlayProps =>
      $(
        OverlayComponent,
        Object.assign(
          {
            key: overlayProps.element,
            overlayComponents: this.overlayComponents,
            didResize: overlayComponent => {
              this.updateOverlayToRender(overlayProps);
              overlayComponent.update(overlayProps);
            }
          },
          overlayProps
        )
      )
    );
  }

  // Imperatively manipulate the class list of the root element to avoid
  // clearing classes assigned by package authors.
  updateClassList() {
    const { model } = this.props;

    const oldClassList = this.classList;
    const newClassList = ['editor'];
    if (this.focused) newClassList.push('is-focused');
    if (model.isMini()) newClassList.push('mini');
    for (var i = 0; i < model.selections.length; i++) {
      if (!model.selections[i].isEmpty()) {
        newClassList.push('has-selection');
        break;
      }
    }

    if (oldClassList) {
      for (let i = 0; i < oldClassList.length; i++) {
        const className = oldClassList[i];
        if (!newClassList.includes(className)) {
          this.element.classList.remove(className);
        }
      }
    }

    for (let i = 0; i < newClassList.length; i++) {
      this.element.classList.add(newClassList[i]);
    }

    this.classList = newClassList;
  }

  queryScreenLinesToRender() {
    const { model } = this.props;

    this.renderedScreenLines = model.displayLayer.getScreenLines(
      this.getRenderedStartRow(),
      this.getRenderedEndRow()
    );
  }

  queryLongestLine() {
    const { model } = this.props;

    const longestLineRow = model.getApproximateLongestScreenRow();
    const longestLine = model.screenLineForScreenRow(longestLineRow);
    if (
      longestLine !== this.previousLongestLine ||
      this.remeasureCharacterDimensions
    ) {
      this.requestLineToMeasure(longestLineRow, longestLine);
      this.longestLineToMeasure = longestLine;
      this.previousLongestLine = longestLine;
    }
  }

  queryExtraScreenLinesToRender() {
    this.extraRenderedScreenLines.clear();
    this.linesToMeasure.forEach((screenLine, row) => {
      if (row < this.getRenderedStartRow() || row >= this.getRenderedEndRow()) {
        this.extraRenderedScreenLines.set(row, screenLine);
      }
    });
  }

  queryLineNumbersToRender() {
    const { model } = this.props;
    if (!model.anyLineNumberGutterVisible()) return;
    if (this.showLineNumbers !== model.doesShowLineNumbers()) {
      this.remeasureGutterDimensions = true;
      this.showLineNumbers = model.doesShowLineNumbers();
    }

    this.queryMaxLineNumberDigits();

    const startRow = this.getRenderedStartRow();
    const endRow = this.getRenderedEndRow();
    const renderedRowCount = this.getRenderedRowCount();

    const bufferRows = model.bufferRowsForScreenRows(startRow, endRow);
    const screenRows = new Array(renderedRowCount);
    const keys = new Array(renderedRowCount);
    const foldableFlags = new Array(renderedRowCount);
    const softWrappedFlags = new Array(renderedRowCount);

    let previousBufferRow =
      startRow > 0 ? model.bufferRowForScreenRow(startRow - 1) : -1;
    let softWrapCount = 0;
    for (let row = startRow; row < endRow; row++) {
      const i = row - startRow;
      const bufferRow = bufferRows[i];
      if (bufferRow === previousBufferRow) {
        softWrapCount++;
        softWrappedFlags[i] = true;
        keys[i] = bufferRow + '-' + softWrapCount;
      } else {
        softWrapCount = 0;
        softWrappedFlags[i] = false;
        keys[i] = bufferRow;
      }

      const nextBufferRow = bufferRows[i + 1];
      if (bufferRow !== nextBufferRow) {
        foldableFlags[i] = model.isFoldableAtBufferRow(bufferRow);
      } else {
        foldableFlags[i] = false;
      }

      screenRows[i] = row;
      previousBufferRow = bufferRow;
    }

    // Delete extra buffer row at the end because it's not currently on screen.
    bufferRows.pop();

    this.lineNumbersToRender.bufferRows = bufferRows;
    this.lineNumbersToRender.screenRows = screenRows;
    this.lineNumbersToRender.keys = keys;
    this.lineNumbersToRender.foldableFlags = foldableFlags;
    this.lineNumbersToRender.softWrappedFlags = softWrappedFlags;
  }

  queryMaxLineNumberDigits() {
    const { model } = this.props;
    if (model.anyLineNumberGutterVisible()) {
      const maxDigits = Math.max(2, model.getLineCount().toString().length);
      if (maxDigits !== this.lineNumbersToRender.maxDigits) {
        this.remeasureGutterDimensions = true;
        this.lineNumbersToRender.maxDigits = maxDigits;
      }
    }
  }

  renderedScreenLineForRow(row) {
    return (
      this.renderedScreenLines[row - this.getRenderedStartRow()] ||
      this.extraRenderedScreenLines.get(row)
    );
  }

  queryGuttersToRender() {
    const oldGuttersToRender = this.guttersToRender;
    const oldGuttersVisibility = this.guttersVisibility;
    this.guttersToRender = this.props.model.getGutters();
    this.guttersVisibility = this.guttersToRender.map(g => g.visible);

    if (
      !oldGuttersToRender ||
      oldGuttersToRender.length !== this.guttersToRender.length
    ) {
      this.remeasureGutterDimensions = true;
    } else {
      for (let i = 0, length = this.guttersToRender.length; i < length; i++) {
        if (
          this.guttersToRender[i] !== oldGuttersToRender[i] ||
          this.guttersVisibility[i] !== oldGuttersVisibility[i]
        ) {
          this.remeasureGutterDimensions = true;
          break;
        }
      }
    }
  }

  queryDecorationsToRender() {
    this.decorationsToRender.lineNumbers.clear();
    this.decorationsToRender.lines = [];
    this.decorationsToRender.overlays.length = 0;
    this.decorationsToRender.customGutter.clear();
    this.decorationsToRender.blocks = new Map();
    this.decorationsToRender.text = [];
    this.decorationsToMeasure.highlights.length = 0;
    this.decorationsToMeasure.cursors.clear();
    this.textDecorationsByMarker.clear();
    this.textDecorationBoundaries.length = 0;

    const decorationsByMarker = this.props.model.decorationManager.decorationPropertiesByMarkerForScreenRowRange(
      this.getRenderedStartRow(),
      this.getRenderedEndRow()
    );

    decorationsByMarker.forEach((decorations, marker) => {
      const screenRange = marker.getScreenRange();
      const reversed = marker.isReversed();
      for (let i = 0; i < decorations.length; i++) {
        const decoration = decorations[i];
        this.addDecorationToRender(
          decoration.type,
          decoration,
          marker,
          screenRange,
          reversed
        );
      }
    });

    this.populateTextDecorationsToRender();
  }

  addDecorationToRender(type, decoration, marker, screenRange, reversed) {
    if (Array.isArray(type)) {
      for (let i = 0, length = type.length; i < length; i++) {
        this.addDecorationToRender(
          type[i],
          decoration,
          marker,
          screenRange,
          reversed
        );
      }
    } else {
      switch (type) {
        case 'line':
        case 'line-number':
          this.addLineDecorationToRender(
            type,
            decoration,
            screenRange,
            reversed
          );
          break;
        case 'highlight':
          this.addHighlightDecorationToMeasure(
            decoration,
            screenRange,
            marker.id
          );
          break;
        case 'cursor':
          this.addCursorDecorationToMeasure(
            decoration,
            marker,
            screenRange,
            reversed
          );
          break;
        case 'overlay':
          this.addOverlayDecorationToRender(decoration, marker);
          break;
        case 'gutter':
          this.addCustomGutterDecorationToRender(decoration, screenRange);
          break;
        case 'block':
          this.addBlockDecorationToRender(decoration, screenRange, reversed);
          break;
        case 'text':
          this.addTextDecorationToRender(decoration, screenRange, marker);
          break;
      }
    }
  }

  addLineDecorationToRender(type, decoration, screenRange, reversed) {
    let decorationsToRender;
    if (type === 'line') {
      decorationsToRender = this.decorationsToRender.lines;
    } else {
      const gutterName = decoration.gutterName || 'line-number';
      decorationsToRender = this.decorationsToRender.lineNumbers.get(
        gutterName
      );
      if (!decorationsToRender) {
        decorationsToRender = [];
        this.decorationsToRender.lineNumbers.set(
          gutterName,
          decorationsToRender
        );
      }
    }

    let omitLastRow = false;
    if (screenRange.isEmpty()) {
      if (decoration.onlyNonEmpty) return;
    } else {
      if (decoration.onlyEmpty) return;
      if (decoration.omitEmptyLastRow !== false) {
        omitLastRow = screenRange.end.column === 0;
      }
    }

    const renderedStartRow = this.getRenderedStartRow();
    let rangeStartRow = screenRange.start.row;
    let rangeEndRow = screenRange.end.row;

    if (decoration.onlyHead) {
      if (reversed) {
        rangeEndRow = rangeStartRow;
      } else {
        rangeStartRow = rangeEndRow;
      }
    }

    rangeStartRow = Math.max(rangeStartRow, this.getRenderedStartRow());
    rangeEndRow = Math.min(rangeEndRow, this.getRenderedEndRow() - 1);

    for (let row = rangeStartRow; row <= rangeEndRow; row++) {
      if (omitLastRow && row === screenRange.end.row) break;
      const currentClassName = decorationsToRender[row - renderedStartRow];
      const newClassName = currentClassName
        ? currentClassName + ' ' + decoration.class
        : decoration.class;
      decorationsToRender[row - renderedStartRow] = newClassName;
    }
  }

  addHighlightDecorationToMeasure(decoration, screenRange, key) {
    screenRange = constrainRangeToRows(
      screenRange,
      this.getRenderedStartRow(),
      this.getRenderedEndRow()
    );
    if (screenRange.isEmpty()) return;

    const {
      class: className,
      flashRequested,
      flashClass,
      flashDuration
    } = decoration;
    decoration.flashRequested = false;
    this.decorationsToMeasure.highlights.push({
      screenRange,
      key,
      className,
      flashRequested,
      flashClass,
      flashDuration
    });
    this.requestHorizontalMeasurement(
      screenRange.start.row,
      screenRange.start.column
    );
    this.requestHorizontalMeasurement(
      screenRange.end.row,
      screenRange.end.column
    );
  }

  addCursorDecorationToMeasure(decoration, marker, screenRange, reversed) {
    const { model } = this.props;
    if (!model.getShowCursorOnSelection() && !screenRange.isEmpty()) return;

    let decorationToMeasure = this.decorationsToMeasure.cursors.get(marker);
    if (!decorationToMeasure) {
      const isLastCursor = model.getLastCursor().getMarker() === marker;
      const screenPosition = reversed ? screenRange.start : screenRange.end;
      const { row, column } = screenPosition;

      if (row < this.getRenderedStartRow() || row >= this.getRenderedEndRow())
        return;

      this.requestHorizontalMeasurement(row, column);
      let columnWidth = 0;
      if (model.lineLengthForScreenRow(row) > column) {
        columnWidth = 1;
        this.requestHorizontalMeasurement(row, column + 1);
      }
      decorationToMeasure = { screenPosition, columnWidth, isLastCursor };
      this.decorationsToMeasure.cursors.set(marker, decorationToMeasure);
    }

    if (decoration.class) {
      if (decorationToMeasure.className) {
        decorationToMeasure.className += ' ' + decoration.class;
      } else {
        decorationToMeasure.className = decoration.class;
      }
    }

    if (decoration.style) {
      if (decorationToMeasure.style) {
        Object.assign(decorationToMeasure.style, decoration.style);
      } else {
        decorationToMeasure.style = Object.assign({}, decoration.style);
      }
    }
  }

  addOverlayDecorationToRender(decoration, marker) {
    const { class: className, item, position, avoidOverflow } = decoration;
    const element = TextEditor.viewForItem(item);
    const screenPosition =
      position === 'tail'
        ? marker.getTailScreenPosition()
        : marker.getHeadScreenPosition();

    this.requestHorizontalMeasurement(
      screenPosition.row,
      screenPosition.column
    );
    this.decorationsToRender.overlays.push({
      className,
      element,
      avoidOverflow,
      screenPosition
    });
  }

  addCustomGutterDecorationToRender(decoration, screenRange) {
    let decorations = this.decorationsToRender.customGutter.get(
      decoration.gutterName
    );
    if (!decorations) {
      decorations = [];
      this.decorationsToRender.customGutter.set(
        decoration.gutterName,
        decorations
      );
    }
    const top = this.pixelPositionAfterBlocksForRow(screenRange.start.row);
    const height =
      this.pixelPositionBeforeBlocksForRow(screenRange.end.row + 1) - top;

    decorations.push({
      className:
        'decoration' + (decoration.class ? ' ' + decoration.class : ''),
      element: TextEditor.viewForItem(decoration.item),
      top,
      height
    });
  }

  addBlockDecorationToRender(decoration, screenRange, reversed) {
    const { row } = reversed ? screenRange.start : screenRange.end;
    if (row < this.getRenderedStartRow() || row >= this.getRenderedEndRow())
      return;

    const tileStartRow = this.tileStartRowForRow(row);
    const screenLine = this.renderedScreenLines[
      row - this.getRenderedStartRow()
    ];

    let decorationsByScreenLine = this.decorationsToRender.blocks.get(
      tileStartRow
    );
    if (!decorationsByScreenLine) {
      decorationsByScreenLine = new Map();
      this.decorationsToRender.blocks.set(
        tileStartRow,
        decorationsByScreenLine
      );
    }

    let decorations = decorationsByScreenLine.get(screenLine.id);
    if (!decorations) {
      decorations = [];
      decorationsByScreenLine.set(screenLine.id, decorations);
    }
    decorations.push(decoration);

    // Order block decorations by increasing values of their "order" property. Break ties with "id", which mirrors
    // their creation sequence.
    decorations.sort((a, b) =>
      a.order !== b.order ? a.order - b.order : a.id - b.id
    );
  }

  addTextDecorationToRender(decoration, screenRange, marker) {
    if (screenRange.isEmpty()) return;

    let decorationsForMarker = this.textDecorationsByMarker.get(marker);
    if (!decorationsForMarker) {
      decorationsForMarker = [];
      this.textDecorationsByMarker.set(marker, decorationsForMarker);
      this.textDecorationBoundaries.push({
        position: screenRange.start,
        starting: [marker]
      });
      this.textDecorationBoundaries.push({
        position: screenRange.end,
        ending: [marker]
      });
    }
    decorationsForMarker.push(decoration);
  }

  populateTextDecorationsToRender() {
    // Sort all boundaries in ascending order of position
    this.textDecorationBoundaries.sort((a, b) =>
      a.position.compare(b.position)
    );

    // Combine adjacent boundaries with the same position
    for (let i = 0; i < this.textDecorationBoundaries.length; ) {
      const boundary = this.textDecorationBoundaries[i];
      const nextBoundary = this.textDecorationBoundaries[i + 1];
      if (nextBoundary && nextBoundary.position.isEqual(boundary.position)) {
        if (nextBoundary.starting) {
          if (boundary.starting) {
            boundary.starting.push(...nextBoundary.starting);
          } else {
            boundary.starting = nextBoundary.starting;
          }
        }

        if (nextBoundary.ending) {
          if (boundary.ending) {
            boundary.ending.push(...nextBoundary.ending);
          } else {
            boundary.ending = nextBoundary.ending;
          }
        }

        this.textDecorationBoundaries.splice(i + 1, 1);
      } else {
        i++;
      }
    }

    const renderedStartRow = this.getRenderedStartRow();
    const renderedEndRow = this.getRenderedEndRow();
    const containingMarkers = [];

    // Iterate over boundaries to build up text decorations.
    for (let i = 0; i < this.textDecorationBoundaries.length; i++) {
      const boundary = this.textDecorationBoundaries[i];

      // If multiple markers start here, sort them by order of nesting (markers ending later come first)
      if (boundary.starting && boundary.starting.length > 1) {
        boundary.starting.sort((a, b) => a.compare(b));
      }

      // If multiple markers start here, sort them by order of nesting (markers starting earlier come first)
      if (boundary.ending && boundary.ending.length > 1) {
        boundary.ending.sort((a, b) => b.compare(a));
      }

      // Remove markers ending here from containing markers array
      if (boundary.ending) {
        for (let j = boundary.ending.length - 1; j >= 0; j--) {
          containingMarkers.splice(
            containingMarkers.lastIndexOf(boundary.ending[j]),
            1
          );
        }
      }
      // Add markers starting here to containing markers array
      if (boundary.starting) containingMarkers.push(...boundary.starting);

      // Determine desired className and style based on containing markers
      let className, style;
      for (let j = 0; j < containingMarkers.length; j++) {
        const marker = containingMarkers[j];
        const decorations = this.textDecorationsByMarker.get(marker);
        for (let k = 0; k < decorations.length; k++) {
          const decoration = decorations[k];
          if (decoration.class) {
            if (className) {
              className += ' ' + decoration.class;
            } else {
              className = decoration.class;
            }
          }
          if (decoration.style) {
            if (style) {
              Object.assign(style, decoration.style);
            } else {
              style = Object.assign({}, decoration.style);
            }
          }
        }
      }

      // Add decoration start with className/style for current position's column,
      // and also for the start of every row up until the next decoration boundary
      if (boundary.position.row >= renderedStartRow) {
        this.addTextDecorationStart(
          boundary.position.row,
          boundary.position.column,
          className,
          style
        );
      }
      const nextBoundary = this.textDecorationBoundaries[i + 1];
      if (nextBoundary) {
        let row = Math.max(boundary.position.row + 1, renderedStartRow);
        const endRow = Math.min(nextBoundary.position.row, renderedEndRow);
        for (; row < endRow; row++) {
          this.addTextDecorationStart(row, 0, className, style);
        }

        if (
          row === nextBoundary.position.row &&
          nextBoundary.position.column !== 0
        ) {
          this.addTextDecorationStart(row, 0, className, style);
        }
      }
    }
  }

  addTextDecorationStart(row, column, className, style) {
    const renderedStartRow = this.getRenderedStartRow();
    let decorationStarts = this.decorationsToRender.text[
      row - renderedStartRow
    ];
    if (!decorationStarts) {
      decorationStarts = [];
      this.decorationsToRender.text[row - renderedStartRow] = decorationStarts;
    }
    decorationStarts.push({ column, className, style });
  }

  updateAbsolutePositionedDecorations() {
    this.updateHighlightsToRender();
    this.updateCursorsToRender();
    this.updateOverlaysToRender();
  }

  updateHighlightsToRender() {
    this.decorationsToRender.highlights.length = 0;
    for (let i = 0; i < this.decorationsToMeasure.highlights.length; i++) {
      const highlight = this.decorationsToMeasure.highlights[i];
      const { start, end } = highlight.screenRange;
      highlight.startPixelTop = this.pixelPositionAfterBlocksForRow(start.row);
      highlight.startPixelLeft = this.pixelLeftForRowAndColumn(
        start.row,
        start.column
      );
      highlight.endPixelTop =
        this.pixelPositionAfterBlocksForRow(end.row) + this.getLineHeight();
      highlight.endPixelLeft = this.pixelLeftForRowAndColumn(
        end.row,
        end.column
      );
      this.decorationsToRender.highlights.push(highlight);
    }
  }

  updateCursorsToRender() {
    this.decorationsToRender.cursors.length = 0;

    this.decorationsToMeasure.cursors.forEach(cursor => {
      const { screenPosition, className, style } = cursor;
      const { row, column } = screenPosition;

      const pixelTop = this.pixelPositionAfterBlocksForRow(row);
      const pixelLeft = this.pixelLeftForRowAndColumn(row, column);
      let pixelWidth;
      if (cursor.columnWidth === 0) {
        pixelWidth = this.getBaseCharacterWidth();
      } else {
        pixelWidth = this.pixelLeftForRowAndColumn(row, column + 1) - pixelLeft;
      }

      const cursorPosition = {
        pixelTop,
        pixelLeft,
        pixelWidth,
        className,
        style
      };
      this.decorationsToRender.cursors.push(cursorPosition);
      if (cursor.isLastCursor) this.hiddenInputPosition = cursorPosition;
    });
  }

  updateOverlayToRender(decoration) {
    const windowInnerHeight = this.getWindowInnerHeight();
    const windowInnerWidth = this.getWindowInnerWidth();
    const contentClientRect = this.refs.content.getBoundingClientRect();

    const { element, screenPosition, avoidOverflow } = decoration;
    const { row, column } = screenPosition;
    let wrapperTop =
      contentClientRect.top +
      this.pixelPositionAfterBlocksForRow(row) +
      this.getLineHeight();
    let wrapperLeft =
      contentClientRect.left + this.pixelLeftForRowAndColumn(row, column);
    const clientRect = element.getBoundingClientRect();

    if (avoidOverflow !== false) {
      const computedStyle = window.getComputedStyle(element);
      const elementTop = wrapperTop + parseInt(computedStyle.marginTop);
      const elementBottom = elementTop + clientRect.height;
      const flippedElementTop =
        wrapperTop -
        this.getLineHeight() -
        clientRect.height -
        parseInt(computedStyle.marginBottom);
      const elementLeft = wrapperLeft + parseInt(computedStyle.marginLeft);
      const elementRight = elementLeft + clientRect.width;

      if (elementBottom > windowInnerHeight && flippedElementTop >= 0) {
        wrapperTop -= elementTop - flippedElementTop;
      }
      if (elementLeft < 0) {
        wrapperLeft -= elementLeft;
      } else if (elementRight > windowInnerWidth) {
        wrapperLeft -= elementRight - windowInnerWidth;
      }
    }

    decoration.pixelTop = Math.round(wrapperTop);
    decoration.pixelLeft = Math.round(wrapperLeft);
  }

  updateOverlaysToRender() {
    const overlayCount = this.decorationsToRender.overlays.length;
    if (overlayCount === 0) return null;

    for (let i = 0; i < overlayCount; i++) {
      const decoration = this.decorationsToRender.overlays[i];
      this.updateOverlayToRender(decoration);
    }
  }

  didAttach() {
    if (!this.attached) {
      this.attached = true;
      this.intersectionObserver = new IntersectionObserver(entries => {
        const { intersectionRect } = entries[entries.length - 1];
        if (intersectionRect.width > 0 || intersectionRect.height > 0) {
          this.didShow();
        } else {
          this.didHide();
        }
      });
      this.intersectionObserver.observe(this.element);

      this.resizeObserver = new ResizeObserver(this.didResize.bind(this));
      this.resizeObserver.observe(this.element);

      if (this.refs.gutterContainer) {
        this.gutterContainerResizeObserver = new ResizeObserver(
          this.didResizeGutterContainer.bind(this)
        );
        this.gutterContainerResizeObserver.observe(
          this.refs.gutterContainer.element
        );
      }

      this.overlayComponents.forEach(component => component.didAttach());

      if (this.isVisible()) {
        this.didShow();

        if (this.refs.verticalScrollbar)
          this.refs.verticalScrollbar.flushScrollPosition();
        if (this.refs.horizontalScrollbar)
          this.refs.horizontalScrollbar.flushScrollPosition();
      } else {
        this.didHide();
      }
      if (!this.constructor.attachedComponents) {
        this.constructor.attachedComponents = new Set();
      }
      this.constructor.attachedComponents.add(this);
    }
  }

  didDetach() {
    if (this.attached) {
      this.intersectionObserver.disconnect();
      this.resizeObserver.disconnect();
      if (this.gutterContainerResizeObserver)
        this.gutterContainerResizeObserver.disconnect();
      this.overlayComponents.forEach(component => component.didDetach());

      this.didHide();
      this.attached = false;
      this.constructor.attachedComponents.delete(this);
    }
  }

  didShow() {
    if (!this.visible && this.isVisible()) {
      if (!this.hasInitialMeasurements) this.measureDimensions();
      this.visible = true;
      this.props.model.setVisible(true);
      this.resizeBlockDecorationMeasurementsArea = true;
      this.updateSync();
      this.flushPendingLogicalScrollPosition();
    }
  }

  didHide() {
    if (this.visible) {
      this.visible = false;
      this.props.model.setVisible(false);
    }
  }

  // Called by TextEditorElement so that focus events can be handled before
  // the element is attached to the DOM.
  didFocus() {
    if (!this.visible) this.didShow();

    if (!this.focused) {
      this.focused = true;
      this.startCursorBlinking();
      this.scheduleUpdate();
    }

    this.getHiddenInput().focus({ preventScroll: true });
  }

  // Called by TextEditorElement so that this function is always the first
  // listener to be fired, even if other listeners are bound before creating
  // the component.
  didBlur(event) {
    if (event.relatedTarget === this.getHiddenInput()) {
      event.stopImmediatePropagation();
    }
  }

  didBlurHiddenInput(event) {
    if (
      this.element !== event.relatedTarget &&
      !this.element.contains(event.relatedTarget)
    ) {
      this.focused = false;
      this.stopCursorBlinking();
      this.scheduleUpdate();
      this.element.dispatchEvent(new FocusEvent(event.type, event));
    }
  }

  didFocusHiddenInput() {
    // Focusing the hidden input when it is off-screen causes the browser to
    // scroll it into view. Since we use synthetic scrolling this behavior
    // causes all the lines to disappear so we counteract it by always setting
    // the scroll position to 0.
    this.refs.scrollContainer.scrollTop = 0;
    this.refs.scrollContainer.scrollLeft = 0;

    if (!this.focused) {
      this.focused = true;
      this.startCursorBlinking();
      this.scheduleUpdate();
    }
  }

  didMouseWheel(event) {
    const scrollSensitivity = this.props.model.getScrollSensitivity() / 100;

    let { wheelDeltaX, wheelDeltaY } = event;

    if (Math.abs(wheelDeltaX) > Math.abs(wheelDeltaY)) {
      wheelDeltaX = wheelDeltaX * scrollSensitivity;
      wheelDeltaY = 0;
    } else {
      wheelDeltaX = 0;
      wheelDeltaY = wheelDeltaY * scrollSensitivity;
    }

    if (this.getPlatform() !== 'darwin' && event.shiftKey) {
      let temp = wheelDeltaX;
      wheelDeltaX = wheelDeltaY;
      wheelDeltaY = temp;
    }

    const scrollLeftChanged =
      wheelDeltaX !== 0 &&
      this.setScrollLeft(this.getScrollLeft() - wheelDeltaX);
    const scrollTopChanged =
      wheelDeltaY !== 0 && this.setScrollTop(this.getScrollTop() - wheelDeltaY);

    if (scrollLeftChanged || scrollTopChanged) {
      event.preventDefault();
      this.updateSync();
    }
  }

  didResize() {
    // Prevent the component from measuring the client container dimensions when
    // getting spurious resize events.
    if (this.isVisible()) {
      const clientContainerWidthChanged = this.measureClientContainerWidth();
      const clientContainerHeightChanged = this.measureClientContainerHeight();
      if (clientContainerWidthChanged || clientContainerHeightChanged) {
        if (clientContainerWidthChanged) {
          this.remeasureAllBlockDecorations = true;
        }

        this.resizeObserver.disconnect();
        this.scheduleUpdate();
        process.nextTick(() => {
          this.resizeObserver.observe(this.element);
        });
      }
    }
  }

  didResizeGutterContainer() {
    // Prevent the component from measuring the gutter dimensions when getting
    // spurious resize events.
    if (this.isVisible() && this.measureGutterDimensions()) {
      this.gutterContainerResizeObserver.disconnect();
      this.scheduleUpdate();
      process.nextTick(() => {
        this.gutterContainerResizeObserver.observe(
          this.refs.gutterContainer.element
        );
      });
    }
  }

  didScrollDummyScrollbar() {
    let scrollTopChanged = false;
    let scrollLeftChanged = false;
    if (!this.scrollTopPending) {
      scrollTopChanged = this.setScrollTop(
        this.refs.verticalScrollbar.element.scrollTop
      );
    }
    if (!this.scrollLeftPending) {
      scrollLeftChanged = this.setScrollLeft(
        this.refs.horizontalScrollbar.element.scrollLeft
      );
    }
    if (scrollTopChanged || scrollLeftChanged) this.updateSync();
  }

  didUpdateStyles() {
    this.remeasureCharacterDimensions = true;
    this.horizontalPixelPositionsByScreenLineId.clear();
    this.scheduleUpdate();
  }

  didUpdateScrollbarStyles() {
    if (!this.props.model.isMini()) {
      this.remeasureScrollbars = true;
      this.scheduleUpdate();
    }
  }

  didPaste(event) {
    // On Linux, Chromium translates a middle-button mouse click into a
    // mousedown event *and* a paste event. Since Pulsar supports the middle mouse
    // click as a way of closing a tab, we only want the mousedown event, not
    // the paste event. And since we don't use the `paste` event for any
    // behavior in Pulsar, we can no-op the event to eliminate this issue.
    // See https://github.com/atom/atom/pull/15183#issue-248432413.
    if (this.getPlatform() === 'linux') event.preventDefault();
  }

  didTextInput(event) {
    if (this.compositionCheckpoint) {
      this.props.model.revertToCheckpoint(this.compositionCheckpoint);
      this.compositionCheckpoint = null;
    }

    if (this.isInputEnabled()) {
      event.stopPropagation();

      // WARNING: If we call preventDefault on the input of a space
      // character, then the browser interprets the spacebar keypress as a
      // page-down command, causing spaces to scroll elements containing
      // editors. This means typing space will actually change the contents
      // of the hidden input, which will cause the browser to autoscroll the
      // scroll container to reveal the input if it is off screen (See
      // https://github.com/atom/atom/issues/16046). To correct for this
      // situation, we automatically reset the scroll position to 0,0 after
      // typing a space. None of this can really be tested.
      if (event.data === ' ') {
        window.setImmediate(() => {
          this.refs.scrollContainer.scrollTop = 0;
          this.refs.scrollContainer.scrollLeft = 0;
        });
      } else {
        event.preventDefault();
      }

      // If the input event is fired while the accented character menu is open it
      // means that the user has chosen one of the accented alternatives. Thus, we
      // will replace the original non accented character with the selected
      // alternative.
      if (this.accentedCharacterMenuIsOpen) {
        this.props.model.selectLeft();
      }

      this.props.model.insertText(event.data, { groupUndo: true });
    }
  }

  // We need to get clever to detect when the accented character menu is
  // opened on macOS. Usually, every keydown event that could cause input is
  // followed by a corresponding keypress. However, pressing and holding
  // long enough to open the accented character menu causes additional keydown
  // events to fire that aren't followed by their own keypress and textInput
  // events.
  //
  // Therefore, we assume the accented character menu has been deployed if,
  // before observing any keyup event, we observe events in the following
  // sequence:
  //
  // keydown(code: X), keypress, keydown(code: X)
  //
  // The code X must be the same in the keydown events that bracket the
  // keypress, meaning we're *holding* the _same_ key we initially pressed.
  // Got that?
  didKeydown(event) {
    // Stop dragging when user interacts with the keyboard. This prevents
    // unwanted selections in the case edits are performed while selecting text
    // at the same time. Modifier keys are exempt to preserve the ability to
    // add selections, shift-scroll horizontally while selecting.
    if (
      this.stopDragging &&
      event.key !== 'Control' &&
      event.key !== 'Alt' &&
      event.key !== 'Meta' &&
      event.key !== 'Shift'
    ) {
      this.stopDragging();
    }

    if (this.lastKeydownBeforeKeypress != null) {
      if (this.lastKeydownBeforeKeypress.code === event.code) {
        this.accentedCharacterMenuIsOpen = true;
      }

      this.lastKeydownBeforeKeypress = null;
    }

    this.lastKeydown = event;
  }

  didKeypress(event) {
    this.lastKeydownBeforeKeypress = this.lastKeydown;

    // This cancels the accented character behavior if we type a key normally
    // with the menu open.
    this.accentedCharacterMenuIsOpen = false;
  }

  didKeyup(event) {
    if (
      this.lastKeydownBeforeKeypress &&
      this.lastKeydownBeforeKeypress.code === event.code
    ) {
      this.lastKeydownBeforeKeypress = null;
    }
  }

  // The IME composition events work like this:
  //
  // User types 's', chromium pops up the completion helper
  //   1. compositionstart fired
  //   2. compositionupdate fired; event.data == 's'
  // User hits arrow keys to move around in completion helper
  //   3. compositionupdate fired; event.data == 's' for each arry key press
  // User escape to cancel OR User chooses a completion
  //   4. compositionend fired
  //   5. textInput fired; event.data == the completion string
  didCompositionStart() {
    // Workaround for Chromium not preventing composition events when
    // preventDefault is called on the keydown event that precipitated them.
    if (this.lastKeydown && this.lastKeydown.defaultPrevented) {
      this.getHiddenInput().disabled = true;
      process.nextTick(() => {
        // Disabling the hidden input makes it lose focus as well, so we have to
        // re-enable and re-focus it.
        this.getHiddenInput().disabled = false;
        this.getHiddenInput().focus({ preventScroll: true });
      });
      return;
    }

    this.compositionCheckpoint = this.props.model.createCheckpoint();
    if (this.accentedCharacterMenuIsOpen) {
      this.props.model.selectLeft();
    }
  }

  didCompositionUpdate(event) {
    this.props.model.insertText(event.data, { select: true });
  }

  didCompositionEnd(event) {
    event.target.value = '';
  }

  didMouseDownOnContent(event) {
    const { model } = this.props;
    const { target, button, detail, ctrlKey, shiftKey, metaKey } = event;
    const platform = this.getPlatform();

    // Ignore clicks on block decorations.
    if (target) {
      let element = target;
      while (element && element !== this.element) {
        if (this.blockDecorationsByElement.has(element)) {
          return;
        }

        element = element.parentElement;
      }
    }

    const screenPosition = this.screenPositionForMouseEvent(event);

    if (button === 1) {
      model.setCursorScreenPosition(screenPosition, { autoscroll: false });

      // On Linux, pasting happens on middle click. A textInput event with the
      // contents of the selection clipboard will be dispatched by the browser
      // automatically on mouseup if editor.selectionClipboard is set to true.
      if (
        platform === 'linux' &&
        this.isInputEnabled() &&
        atom.config.get('editor.selectionClipboard')
      )
        model.insertText(clipboard.readText('selection'));
      return;
    }

    if (button !== 0) return;

    // Ctrl-click brings up the context menu on macOS
    if (platform === 'darwin' && ctrlKey) return;

    if (target && target.matches('.fold-marker')) {
      const bufferPosition = model.bufferPositionForScreenPosition(
        screenPosition
      );
      model.destroyFoldsContainingBufferPositions([bufferPosition], false);
      return;
    }

    const allowMultiCursor = atom.config.get('editor.multiCursorOnClick');
    const addOrRemoveSelection =
      allowMultiCursor && (metaKey || (ctrlKey && platform !== 'darwin'));

    switch (detail) {
      case 1:
        if (addOrRemoveSelection) {
          const existingSelection = model.getSelectionAtScreenPosition(
            screenPosition
          );
          if (existingSelection) {
            if (model.hasMultipleCursors()) existingSelection.destroy();
          } else {
            model.addCursorAtScreenPosition(screenPosition, {
              autoscroll: false
            });
          }
        } else {
          if (shiftKey) {
            model.selectToScreenPosition(screenPosition, { autoscroll: false });
          } else {
            model.setCursorScreenPosition(screenPosition, {
              autoscroll: false
            });
          }
        }
        break;
      case 2:
        if (addOrRemoveSelection)
          model.addCursorAtScreenPosition(screenPosition, {
            autoscroll: false
          });
        model.getLastSelection().selectWord({ autoscroll: false });
        break;
      case 3:
        if (addOrRemoveSelection)
          model.addCursorAtScreenPosition(screenPosition, {
            autoscroll: false
          });
        model.getLastSelection().selectLine(null, { autoscroll: false });
        break;
    }

    this.handleMouseDragUntilMouseUp({
      didDrag: event => {
        this.autoscrollOnMouseDrag(event);
        const screenPosition = this.screenPositionForMouseEvent(event);
        model.selectToScreenPosition(screenPosition, {
          suppressSelectionMerge: true,
          autoscroll: false
        });
        this.updateSync();
      },
      didStopDragging: () => {
        model.finalizeSelections();
        model.mergeIntersectingSelections();
        this.updateSync();
      }
    });
  }

  didMouseDownOnLineNumberGutter(event) {
    const { model } = this.props;
    const { target, button, ctrlKey, shiftKey, metaKey } = event;

    // Only handle mousedown events for left mouse button
    if (button !== 0) return;

    const clickedScreenRow = this.screenPositionForMouseEvent(event).row;
    const startBufferRow = model.bufferPositionForScreenPosition([
      clickedScreenRow,
      0
    ]).row;

    if (
      target &&
      (target.matches('.foldable .icon-right') ||
        target.matches('.folded .icon-right'))
    ) {
      model.toggleFoldAtBufferRow(startBufferRow);
      return;
    }

    const addOrRemoveSelection =
      metaKey || (ctrlKey && this.getPlatform() !== 'darwin');
    const endBufferRow = model.bufferPositionForScreenPosition([
      clickedScreenRow,
      Infinity
    ]).row;
    const clickedLineBufferRange = Range(
      Point(startBufferRow, 0),
      Point(endBufferRow + 1, 0)
    );

    let initialBufferRange;
    if (shiftKey) {
      const lastSelection = model.getLastSelection();
      initialBufferRange = lastSelection.getBufferRange();
      lastSelection.setBufferRange(
        initialBufferRange.union(clickedLineBufferRange),
        {
          reversed: clickedScreenRow < lastSelection.getScreenRange().start.row,
          autoscroll: false,
          preserveFolds: true,
          suppressSelectionMerge: true
        }
      );
    } else {
      initialBufferRange = clickedLineBufferRange;
      if (addOrRemoveSelection) {
        model.addSelectionForBufferRange(clickedLineBufferRange, {
          autoscroll: false,
          preserveFolds: true
        });
      } else {
        model.setSelectedBufferRange(clickedLineBufferRange, {
          autoscroll: false,
          preserveFolds: true
        });
      }
    }

    const initialScreenRange = model.screenRangeForBufferRange(
      initialBufferRange
    );
    this.handleMouseDragUntilMouseUp({
      didDrag: event => {
        this.autoscrollOnMouseDrag(event, true);
        const dragRow = this.screenPositionForMouseEvent(event).row;
        const draggedLineScreenRange = Range(
          Point(dragRow, 0),
          Point(dragRow + 1, 0)
        );
        model
          .getLastSelection()
          .setScreenRange(draggedLineScreenRange.union(initialScreenRange), {
            reversed: dragRow < initialScreenRange.start.row,
            autoscroll: false,
            preserveFolds: true
          });
        this.updateSync();
      },
      didStopDragging: () => {
        model.mergeIntersectingSelections();
        this.updateSync();
      }
    });
  }

  handleMouseDragUntilMouseUp({ didDrag, didStopDragging }) {
    let dragging = false;
    let lastMousemoveEvent;

    const animationFrameLoop = () => {
      window.requestAnimationFrame(() => {
        if (dragging && this.visible) {
          didDrag(lastMousemoveEvent);
          animationFrameLoop();
        }
      });
    };

    function didMouseMove(event) {
      lastMousemoveEvent = event;
      if (!dragging) {
        dragging = true;
        animationFrameLoop();
      }
    }

    function didMouseUp() {
      this.stopDragging = null;
      window.removeEventListener('mousemove', didMouseMove);
      window.removeEventListener('mouseup', didMouseUp, { capture: true });
      if (dragging) {
        dragging = false;
        didStopDragging();
      }
    }

    window.addEventListener('mousemove', didMouseMove);
    window.addEventListener('mouseup', didMouseUp, { capture: true });
    this.stopDragging = didMouseUp;
  }

  autoscrollOnMouseDrag({ clientX, clientY }, verticalOnly = false) {
    let {
      top,
      bottom,
      left,
      right
    } = this.refs.scrollContainer.getBoundingClientRect(); // Using var to avoid deopt on += assignments below
    top += MOUSE_DRAG_AUTOSCROLL_MARGIN;
    bottom -= MOUSE_DRAG_AUTOSCROLL_MARGIN;
    left += MOUSE_DRAG_AUTOSCROLL_MARGIN;
    right -= MOUSE_DRAG_AUTOSCROLL_MARGIN;

    let yDelta, yDirection;
    if (clientY < top) {
      yDelta = top - clientY;
      yDirection = -1;
    } else if (clientY > bottom) {
      yDelta = clientY - bottom;
      yDirection = 1;
    }

    let xDelta, xDirection;
    if (clientX < left) {
      xDelta = left - clientX;
      xDirection = -1;
    } else if (clientX > right) {
      xDelta = clientX - right;
      xDirection = 1;
    }

    let scrolled = false;
    if (yDelta != null) {
      const scaledDelta = scaleMouseDragAutoscrollDelta(yDelta) * yDirection;
      scrolled = this.setScrollTop(this.getScrollTop() + scaledDelta);
    }

    if (!verticalOnly && xDelta != null) {
      const scaledDelta = scaleMouseDragAutoscrollDelta(xDelta) * xDirection;
      scrolled = this.setScrollLeft(this.getScrollLeft() + scaledDelta);
    }

    if (scrolled) this.updateSync();
  }

  screenPositionForMouseEvent(event) {
    return this.screenPositionForPixelPosition(
      this.pixelPositionForMouseEvent(event)
    );
  }

  pixelPositionForMouseEvent({ clientX, clientY }) {
    const scrollContainerRect = this.refs.scrollContainer.getBoundingClientRect();
    clientX = Math.min(
      scrollContainerRect.right,
      Math.max(scrollContainerRect.left, clientX)
    );
    clientY = Math.min(
      scrollContainerRect.bottom,
      Math.max(scrollContainerRect.top, clientY)
    );
    const linesRect = this.refs.lineTiles.getBoundingClientRect();
    return {
      top: clientY - linesRect.top,
      left: clientX - linesRect.left
    };
  }

  didUpdateSelections() {
    this.pauseCursorBlinking();
    this.scheduleUpdate();
  }

  pauseCursorBlinking() {
    this.stopCursorBlinking();
    this.debouncedResumeCursorBlinking();
  }

  resumeCursorBlinking() {
    this.cursorsBlinkedOff = true;
    this.startCursorBlinking();
  }

  stopCursorBlinking() {
    if (this.cursorsBlinking) {
      this.cursorsBlinkedOff = false;
      this.cursorsBlinking = false;
      window.clearInterval(this.cursorBlinkIntervalHandle);
      this.cursorBlinkIntervalHandle = null;
      this.scheduleUpdate();
    }
  }

  startCursorBlinking() {
    if (!this.cursorsBlinking) {
      this.cursorBlinkIntervalHandle = window.setInterval(() => {
        this.cursorsBlinkedOff = !this.cursorsBlinkedOff;
        this.scheduleUpdate(true);
      }, (this.props.cursorBlinkPeriod || CURSOR_BLINK_PERIOD) / 2);
      this.cursorsBlinking = true;
      this.scheduleUpdate(true);
    }
  }

  didRequestAutoscroll(autoscroll) {
    this.pendingAutoscroll = autoscroll;
    this.scheduleUpdate();
  }

  flushPendingLogicalScrollPosition() {
    let changedScrollTop = false;
    if (this.pendingScrollTopRow > 0) {
      changedScrollTop = this.setScrollTopRow(this.pendingScrollTopRow, false);
      this.pendingScrollTopRow = null;
    }

    let changedScrollLeft = false;
    if (this.pendingScrollLeftColumn > 0) {
      changedScrollLeft = this.setScrollLeftColumn(
        this.pendingScrollLeftColumn,
        false
      );
      this.pendingScrollLeftColumn = null;
    }

    if (changedScrollTop || changedScrollLeft) {
      this.updateSync();
    }
  }

  autoscrollVertically(screenRange, options) {
    const screenRangeTop = this.pixelPositionAfterBlocksForRow(
      screenRange.start.row
    );
    const screenRangeBottom =
      this.pixelPositionAfterBlocksForRow(screenRange.end.row) +
      this.getLineHeight();
    const verticalScrollMargin = this.getVerticalAutoscrollMargin();

    let desiredScrollTop, desiredScrollBottom;
    if (options && options.center) {
      const desiredScrollCenter = (screenRangeTop + screenRangeBottom) / 2;
      desiredScrollTop =
        desiredScrollCenter - this.getScrollContainerClientHeight() / 2;
      desiredScrollBottom =
        desiredScrollCenter + this.getScrollContainerClientHeight() / 2;
    } else {
      desiredScrollTop = screenRangeTop - verticalScrollMargin;
      desiredScrollBottom = screenRangeBottom + verticalScrollMargin;
    }

    if (!options || options.reversed !== false) {
      if (desiredScrollBottom > this.getScrollBottom()) {
        this.setScrollBottom(desiredScrollBottom);
      }
      if (desiredScrollTop < this.getScrollTop()) {
        this.setScrollTop(desiredScrollTop);
      }
    } else {
      if (desiredScrollTop < this.getScrollTop()) {
        this.setScrollTop(desiredScrollTop);
      }
      if (desiredScrollBottom > this.getScrollBottom()) {
        this.setScrollBottom(desiredScrollBottom);
      }
    }

    return false;
  }

  autoscrollHorizontally(screenRange, options) {
    const horizontalScrollMargin = this.getHorizontalAutoscrollMargin();

    const gutterContainerWidth = this.getGutterContainerWidth();
    let left =
      this.pixelLeftForRowAndColumn(
        screenRange.start.row,
        screenRange.start.column
      ) + gutterContainerWidth;
    let right =
      this.pixelLeftForRowAndColumn(
        screenRange.end.row,
        screenRange.end.column
      ) + gutterContainerWidth;
    const desiredScrollLeft = Math.max(
      0,
      left - horizontalScrollMargin - gutterContainerWidth
    );
    const desiredScrollRight = Math.min(
      this.getScrollWidth(),
      right + horizontalScrollMargin
    );

    if (!options || options.reversed !== false) {
      if (desiredScrollRight > this.getScrollRight()) {
        this.setScrollRight(desiredScrollRight);
      }
      if (desiredScrollLeft < this.getScrollLeft()) {
        this.setScrollLeft(desiredScrollLeft);
      }
    } else {
      if (desiredScrollLeft < this.getScrollLeft()) {
        this.setScrollLeft(desiredScrollLeft);
      }
      if (desiredScrollRight > this.getScrollRight()) {
        this.setScrollRight(desiredScrollRight);
      }
    }
  }

  getVerticalAutoscrollMargin() {
    const maxMarginInLines = Math.floor(
      (this.getScrollContainerClientHeight() / this.getLineHeight() - 1) / 2
    );
    const marginInLines = Math.min(
      this.props.model.verticalScrollMargin,
      maxMarginInLines
    );
    return marginInLines * this.getLineHeight();
  }

  getHorizontalAutoscrollMargin() {
    const maxMarginInBaseCharacters = Math.floor(
      (this.getScrollContainerClientWidth() / this.getBaseCharacterWidth() -
        1) /
        2
    );
    const marginInBaseCharacters = Math.min(
      this.props.model.horizontalScrollMargin,
      maxMarginInBaseCharacters
    );
    return marginInBaseCharacters * this.getBaseCharacterWidth();
  }

  // This method is called at the beginning of a frame render to relay any
  // potential changes in the editor's width into the model before proceeding.
  updateModelSoftWrapColumn() {
    const { model } = this.props;
    const newEditorWidthInChars = this.getScrollContainerClientWidthInBaseCharacters();
    if (newEditorWidthInChars !== model.getEditorWidthInChars()) {
      this.suppressUpdates = true;

      const renderedStartRow = this.getRenderedStartRow();
      this.props.model.setEditorWidthInChars(newEditorWidthInChars);

      // Relaying a change in to the editor's client width may cause the
      // vertical scrollbar to appear or disappear, which causes the editor's
      // client width to change *again*. Make sure the display layer is fully
      // populated for the visible area before recalculating the editor's
      // width in characters. Then update the display layer *again* just in
      // case a change in scrollbar visibility causes lines to wrap
      // differently. We capture the renderedStartRow before resetting the
      // display layer because once it has been reset, we can't compute the
      // rendered start row accurately. 😥
      this.populateVisibleRowRange(renderedStartRow);
      this.props.model.setEditorWidthInChars(
        this.getScrollContainerClientWidthInBaseCharacters()
      );
      this.derivedDimensionsCache = {};

      this.suppressUpdates = false;
    }
  }

  // This method exists because it existed in the previous implementation and some
  // package tests relied on it
  measureDimensions() {
    this.measureCharacterDimensions();
    this.measureGutterDimensions();
    this.measureClientContainerHeight();
    this.measureClientContainerWidth();
    this.measureScrollbarDimensions();
    this.hasInitialMeasurements = true;
  }

  measureCharacterDimensions() {
    this.measurements.lineHeight = Math.max(
      1,
      this.refs.characterMeasurementLine.getBoundingClientRect().height
    );
    this.measurements.baseCharacterWidth = this.refs.normalWidthCharacterSpan.getBoundingClientRect().width;
    this.measurements.doubleWidthCharacterWidth = this.refs.doubleWidthCharacterSpan.getBoundingClientRect().width;
    this.measurements.halfWidthCharacterWidth = this.refs.halfWidthCharacterSpan.getBoundingClientRect().width;
    this.measurements.koreanCharacterWidth = this.refs.koreanCharacterSpan.getBoundingClientRect().width;

    this.props.model.setLineHeightInPixels(this.measurements.lineHeight);
    this.props.model.setDefaultCharWidth(
      this.measurements.baseCharacterWidth,
      this.measurements.doubleWidthCharacterWidth,
      this.measurements.halfWidthCharacterWidth,
      this.measurements.koreanCharacterWidth
    );
    this.lineTopIndex.setDefaultLineHeight(this.measurements.lineHeight);
  }

  measureGutterDimensions() {
    let dimensionsChanged = false;

    if (this.refs.gutterContainer) {
      const gutterContainerWidth = this.refs.gutterContainer.element
        .offsetWidth;
      if (gutterContainerWidth !== this.measurements.gutterContainerWidth) {
        dimensionsChanged = true;
        this.measurements.gutterContainerWidth = gutterContainerWidth;
      }
    } else {
      this.measurements.gutterContainerWidth = 0;
    }

    if (
      this.refs.gutterContainer &&
      this.refs.gutterContainer.refs.lineNumberGutter
    ) {
      const lineNumberGutterWidth = this.refs.gutterContainer.refs
        .lineNumberGutter.element.offsetWidth;
      if (lineNumberGutterWidth !== this.measurements.lineNumberGutterWidth) {
        dimensionsChanged = true;
        this.measurements.lineNumberGutterWidth = lineNumberGutterWidth;
      }
    } else {
      this.measurements.lineNumberGutterWidth = 0;
    }

    return dimensionsChanged;
  }

  measureClientContainerHeight() {
    const clientContainerHeight = this.refs.clientContainer.offsetHeight;
    if (clientContainerHeight !== this.measurements.clientContainerHeight) {
      this.measurements.clientContainerHeight = clientContainerHeight;
      return true;
    } else {
      return false;
    }
  }

  measureClientContainerWidth() {
    const clientContainerWidth = this.refs.clientContainer.offsetWidth;
    if (clientContainerWidth !== this.measurements.clientContainerWidth) {
      this.measurements.clientContainerWidth = clientContainerWidth;
      return true;
    } else {
      return false;
    }
  }

  measureScrollbarDimensions() {
    if (this.props.model.isMini()) {
      this.measurements.verticalScrollbarWidth = 0;
      this.measurements.horizontalScrollbarHeight = 0;
    } else {
      this.measurements.verticalScrollbarWidth = this.refs.verticalScrollbar.getRealScrollbarWidth();
      this.measurements.horizontalScrollbarHeight = this.refs.horizontalScrollbar.getRealScrollbarHeight();
    }
  }

  measureLongestLineWidth() {
    if (this.longestLineToMeasure) {
      const lineComponent = this.lineComponentsByScreenLineId.get(
        this.longestLineToMeasure.id
      );
      this.measurements.longestLineWidth =
        lineComponent.element.firstChild.offsetWidth;
      this.longestLineToMeasure = null;
    }
  }

  requestLineToMeasure(row, screenLine) {
    this.linesToMeasure.set(row, screenLine);
  }

  requestHorizontalMeasurement(row, column) {
    if (column === 0) return;

    const screenLine = this.props.model.screenLineForScreenRow(row);
    if (screenLine) {
      this.requestLineToMeasure(row, screenLine);

      let columns = this.horizontalPositionsToMeasure.get(row);
      if (columns == null) {
        columns = [];
        this.horizontalPositionsToMeasure.set(row, columns);
      }
      columns.push(column);
    }
  }

  measureHorizontalPositions() {
    this.horizontalPositionsToMeasure.forEach((columnsToMeasure, row) => {
      columnsToMeasure.sort((a, b) => a - b);

      const screenLine = this.renderedScreenLineForRow(row);
      const lineComponent = this.lineComponentsByScreenLineId.get(
        screenLine.id
      );

      if (!lineComponent) {
        const error = new Error(
          'Requested measurement of a line component that is not currently rendered'
        );
        error.metadata = {
          row,
          columnsToMeasure,
          renderedScreenLineIds: this.renderedScreenLines.map(line => line.id),
          extraRenderedScreenLineIds: Array.from(
            this.extraRenderedScreenLines.keys()
          ),
          lineComponentScreenLineIds: Array.from(
            this.lineComponentsByScreenLineId.keys()
          ),
          renderedStartRow: this.getRenderedStartRow(),
          renderedEndRow: this.getRenderedEndRow(),
          requestedScreenLineId: screenLine.id
        };
        throw error;
      }

      const lineNode = lineComponent.element;
      const textNodes = lineComponent.textNodes;
      let positionsForLine = this.horizontalPixelPositionsByScreenLineId.get(
        screenLine.id
      );
      if (positionsForLine == null) {
        positionsForLine = new Map();
        this.horizontalPixelPositionsByScreenLineId.set(
          screenLine.id,
          positionsForLine
        );
      }

      this.measureHorizontalPositionsOnLine(
        lineNode,
        textNodes,
        columnsToMeasure,
        positionsForLine
      );
    });
    this.horizontalPositionsToMeasure.clear();
  }

  measureHorizontalPositionsOnLine(
    lineNode,
    textNodes,
    columnsToMeasure,
    positions
  ) {
    let lineNodeClientLeft = -1;
    let textNodeStartColumn = 0;
    let textNodesIndex = 0;
    let lastTextNodeRight = null;

    // eslint-disable-next-line no-labels
    columnLoop: for (
      let columnsIndex = 0;
      columnsIndex < columnsToMeasure.length;
      columnsIndex++
    ) {
      const nextColumnToMeasure = columnsToMeasure[columnsIndex];
      while (textNodesIndex < textNodes.length) {
        if (nextColumnToMeasure === 0) {
          positions.set(0, 0);
          continue columnLoop; // eslint-disable-line no-labels
        }

        if (positions.has(nextColumnToMeasure)) continue columnLoop; // eslint-disable-line no-labels
        const textNode = textNodes[textNodesIndex];
        const textNodeEndColumn =
          textNodeStartColumn + textNode.textContent.length;

        if (nextColumnToMeasure < textNodeEndColumn) {
          let clientPixelPosition;
          if (nextColumnToMeasure === textNodeStartColumn) {
            clientPixelPosition = clientRectForRange(textNode, 0, 1).left;
          } else {
            clientPixelPosition = clientRectForRange(
              textNode,
              0,
              nextColumnToMeasure - textNodeStartColumn
            ).right;
          }

          if (lineNodeClientLeft === -1) {
            lineNodeClientLeft = lineNode.getBoundingClientRect().left;
          }

          positions.set(
            nextColumnToMeasure,
            Math.round(clientPixelPosition - lineNodeClientLeft)
          );
          continue columnLoop; // eslint-disable-line no-labels
        } else {
          textNodesIndex++;
          textNodeStartColumn = textNodeEndColumn;
        }
      }

      if (lastTextNodeRight == null) {
        const lastTextNode = textNodes[textNodes.length - 1];
        lastTextNodeRight = clientRectForRange(
          lastTextNode,
          0,
          lastTextNode.textContent.length
        ).right;
      }

      if (lineNodeClientLeft === -1) {
        lineNodeClientLeft = lineNode.getBoundingClientRect().left;
      }

      positions.set(
        nextColumnToMeasure,
        Math.round(lastTextNodeRight - lineNodeClientLeft)
      );
    }
  }

  rowForPixelPosition(pixelPosition) {
    return Math.max(0, this.lineTopIndex.rowForPixelPosition(pixelPosition));
  }

  heightForBlockDecorationsBeforeRow(row) {
    return (
      this.pixelPositionAfterBlocksForRow(row) -
      this.pixelPositionBeforeBlocksForRow(row)
    );
  }

  heightForBlockDecorationsAfterRow(row) {
    const currentRowBottom =
      this.pixelPositionAfterBlocksForRow(row) + this.getLineHeight();
    const nextRowTop = this.pixelPositionBeforeBlocksForRow(row + 1);
    return nextRowTop - currentRowBottom;
  }

  pixelPositionBeforeBlocksForRow(row) {
    return this.lineTopIndex.pixelPositionBeforeBlocksForRow(row);
  }

  pixelPositionAfterBlocksForRow(row) {
    return this.lineTopIndex.pixelPositionAfterBlocksForRow(row);
  }

  pixelLeftForRowAndColumn(row, column) {
    if (column === 0) return 0;
    const screenLine = this.renderedScreenLineForRow(row);
    if (screenLine) {
      const horizontalPositionsByColumn = this.horizontalPixelPositionsByScreenLineId.get(
        screenLine.id
      );
      if (horizontalPositionsByColumn) {
        return horizontalPositionsByColumn.get(column);
      }
    }
  }

  screenPositionForPixelPosition({ top, left }) {
    const { model } = this.props;

    const row = Math.min(
      this.rowForPixelPosition(top),
      model.getApproximateScreenLineCount() - 1
    );

    let screenLine = this.renderedScreenLineForRow(row);
    if (!screenLine) {
      this.requestLineToMeasure(row, model.screenLineForScreenRow(row));
      this.updateSyncBeforeMeasuringContent();
      this.measureContentDuringUpdateSync();
      screenLine = this.renderedScreenLineForRow(row);
    }

    const linesClientLeft = this.refs.lineTiles.getBoundingClientRect().left;
    const targetClientLeft = linesClientLeft + Math.max(0, left);
    const { textNodes } = this.lineComponentsByScreenLineId.get(screenLine.id);

    let containingTextNodeIndex;
    {
      let low = 0;
      let high = textNodes.length - 1;
      while (low <= high) {
        const mid = low + ((high - low) >> 1);
        const textNode = textNodes[mid];
        const textNodeRect = clientRectForRange(textNode, 0, textNode.length);

        if (targetClientLeft < textNodeRect.left) {
          high = mid - 1;
          containingTextNodeIndex = Math.max(0, mid - 1);
        } else if (targetClientLeft > textNodeRect.right) {
          low = mid + 1;
          containingTextNodeIndex = Math.min(textNodes.length - 1, mid + 1);
        } else {
          containingTextNodeIndex = mid;
          break;
        }
      }
    }
    const containingTextNode = textNodes[containingTextNodeIndex];
    let characterIndex = 0;
    {
      let low = 0;
      let high = containingTextNode.length - 1;
      while (low <= high) {
        const charIndex = low + ((high - low) >> 1);
        const nextCharIndex = isPairedCharacter(
          containingTextNode.textContent,
          charIndex
        )
          ? charIndex + 2
          : charIndex + 1;

        const rangeRect = clientRectForRange(
          containingTextNode,
          charIndex,
          nextCharIndex
        );
        if (targetClientLeft < rangeRect.left) {
          high = charIndex - 1;
          characterIndex = Math.max(0, charIndex - 1);
        } else if (targetClientLeft > rangeRect.right) {
          low = nextCharIndex;
          characterIndex = Math.min(
            containingTextNode.textContent.length,
            nextCharIndex
          );
        } else {
          if (targetClientLeft <= (rangeRect.left + rangeRect.right) / 2) {
            characterIndex = charIndex;
          } else {
            characterIndex = nextCharIndex;
          }
          break;
        }
      }
    }

    let textNodeStartColumn = 0;
    for (let i = 0; i < containingTextNodeIndex; i++) {
      textNodeStartColumn = textNodeStartColumn + textNodes[i].length;
    }
    const column = textNodeStartColumn + characterIndex;

    return Point(row, column);
  }

  didResetDisplayLayer() {
    this.spliceLineTopIndex(0, Infinity, Infinity);
    this.scheduleUpdate();
  }

  didChangeDisplayLayer(changes) {
    for (let i = 0; i < changes.length; i++) {
      const { oldRange, newRange } = changes[i];
      this.spliceLineTopIndex(
        newRange.start.row,
        oldRange.end.row - oldRange.start.row,
        newRange.end.row - newRange.start.row
      );
    }

    this.scheduleUpdate();
  }

  didChangeSelectionRange() {
    const { model } = this.props;

    if (this.getPlatform() === 'linux') {
      if (this.selectionClipboardImmediateId) {
        clearImmediate(this.selectionClipboardImmediateId);
      }

      this.selectionClipboardImmediateId = setImmediate(() => {
        this.selectionClipboardImmediateId = null;

        if (model.isDestroyed()) return;

        const selectedText = model.getSelectedText();
        if (selectedText) {
          // This uses ipcRenderer.send instead of clipboard.writeText because
          // clipboard.writeText is a sync ipcRenderer call on Linux and that
          // will slow down selections.
          electron.ipcRenderer.send(
            'write-text-to-selection-clipboard',
            selectedText
          );
        }
      });
    }
  }

  observeBlockDecorations() {
    const { model } = this.props;
    const decorations = model.getDecorations({ type: 'block' });
    for (let i = 0; i < decorations.length; i++) {
      this.addBlockDecoration(decorations[i]);
    }
  }

  addBlockDecoration(decoration, subscribeToChanges = true) {
    const marker = decoration.getMarker();
    const { item, position } = decoration.getProperties();
    const element = TextEditor.viewForItem(item);

    if (marker.isValid()) {
      const row = marker.getHeadScreenPosition().row;
      this.lineTopIndex.insertBlock(decoration, row, 0, position === 'after');
      this.blockDecorationsToMeasure.add(decoration);
      this.blockDecorationsByElement.set(element, decoration);
      this.blockDecorationResizeObserver.observe(element);

      this.scheduleUpdate();
    }

    if (subscribeToChanges) {
      let wasValid = marker.isValid();

      const didUpdateDisposable = marker.bufferMarker.onDidChange(
        ({ textChanged }) => {
          const isValid = marker.isValid();
          if (wasValid && !isValid) {
            wasValid = false;
            this.blockDecorationsToMeasure.delete(decoration);
            this.heightsByBlockDecoration.delete(decoration);
            this.blockDecorationsByElement.delete(element);
            this.blockDecorationResizeObserver.unobserve(element);
            this.lineTopIndex.removeBlock(decoration);
            this.scheduleUpdate();
          } else if (!wasValid && isValid) {
            wasValid = true;
            this.addBlockDecoration(decoration, false);
          } else if (isValid && !textChanged) {
            this.lineTopIndex.moveBlock(
              decoration,
              marker.getHeadScreenPosition().row
            );
            this.scheduleUpdate();
          }
        }
      );

      const didDestroyDisposable = decoration.onDidDestroy(() => {
        didUpdateDisposable.dispose();
        didDestroyDisposable.dispose();

        if (wasValid) {
          wasValid = false;
          this.blockDecorationsToMeasure.delete(decoration);
          this.heightsByBlockDecoration.delete(decoration);
          this.blockDecorationsByElement.delete(element);
          this.blockDecorationResizeObserver.unobserve(element);
          this.lineTopIndex.removeBlock(decoration);
          this.scheduleUpdate();
        }
      });
    }
  }

  didResizeBlockDecorations(entries) {
    if (!this.visible) return;

    for (let i = 0; i < entries.length; i++) {
      const { target, contentRect } = entries[i];
      const decoration = this.blockDecorationsByElement.get(target);
      const previousHeight = this.heightsByBlockDecoration.get(decoration);
      if (
        this.element.contains(target) &&
        contentRect.height !== previousHeight
      ) {
        this.invalidateBlockDecorationDimensions(decoration);
      }
    }
  }

  invalidateBlockDecorationDimensions(decoration) {
    this.blockDecorationsToMeasure.add(decoration);
    this.scheduleUpdate();
  }

  spliceLineTopIndex(startRow, oldExtent, newExtent) {
    const invalidatedBlockDecorations = this.lineTopIndex.splice(
      startRow,
      oldExtent,
      newExtent
    );
    invalidatedBlockDecorations.forEach(decoration => {
      const newPosition = decoration.getMarker().getHeadScreenPosition();
      this.lineTopIndex.moveBlock(decoration, newPosition.row);
    });
  }

  isVisible() {
    return this.element.offsetWidth > 0 || this.element.offsetHeight > 0;
  }

  getWindowInnerHeight() {
    return window.innerHeight;
  }

  getWindowInnerWidth() {
    return window.innerWidth;
  }

  getLineHeight() {
    return this.measurements.lineHeight;
  }

  getBaseCharacterWidth() {
    return this.measurements.baseCharacterWidth;
  }

  getLongestLineWidth() {
    return this.measurements.longestLineWidth;
  }

  getClientContainerHeight() {
    return this.measurements.clientContainerHeight;
  }

  getClientContainerWidth() {
    return this.measurements.clientContainerWidth;
  }

  getScrollContainerWidth() {
    if (this.props.model.getAutoWidth()) {
      return this.getScrollWidth();
    } else {
      return this.getClientContainerWidth() - this.getGutterContainerWidth();
    }
  }

  getScrollContainerHeight() {
    if (this.props.model.getAutoHeight()) {
      return this.getScrollHeight() + this.getHorizontalScrollbarHeight();
    } else {
      return this.getClientContainerHeight();
    }
  }

  getScrollContainerClientWidth() {
    return this.getScrollContainerWidth() - this.getVerticalScrollbarWidth();
  }

  getScrollContainerClientHeight() {
    return (
      this.getScrollContainerHeight() - this.getHorizontalScrollbarHeight()
    );
  }

  canScrollVertically() {
    const { model } = this.props;
    if (model.isMini()) return false;
    if (model.getAutoHeight()) return false;
    return this.getContentHeight() > this.getScrollContainerClientHeight();
  }

  canScrollHorizontally() {
    const { model } = this.props;
    if (model.isMini()) return false;
    if (model.getAutoWidth()) return false;
    if (model.isSoftWrapped()) return false;
    return this.getContentWidth() > this.getScrollContainerClientWidth();
  }

  getScrollHeight() {
    if (this.props.model.getScrollPastEnd()) {
      return (
        this.getContentHeight() +
        Math.max(
          3 * this.getLineHeight(),
          this.getScrollContainerClientHeight() - 3 * this.getLineHeight()
        )
      );
    } else if (this.props.model.getAutoHeight()) {
      return this.getContentHeight();
    } else {
      return Math.max(
        this.getContentHeight(),
        this.getScrollContainerClientHeight()
      );
    }
  }

  getScrollWidth() {
    const { model } = this.props;

    if (model.isSoftWrapped()) {
      return this.getScrollContainerClientWidth();
    } else if (model.getAutoWidth()) {
      return this.getContentWidth();
    } else {
      return Math.max(
        this.getContentWidth(),
        this.getScrollContainerClientWidth()
      );
    }
  }

  getContentHeight() {
    return this.pixelPositionAfterBlocksForRow(
      this.props.model.getApproximateScreenLineCount()
    );
  }

  getContentWidth() {
    return Math.ceil(this.getLongestLineWidth() + this.getBaseCharacterWidth());
  }

  getScrollContainerClientWidthInBaseCharacters() {
    return Math.floor(
      this.getScrollContainerClientWidth() / this.getBaseCharacterWidth()
    );
  }

  getGutterContainerWidth() {
    return this.measurements.gutterContainerWidth;
  }

  getLineNumberGutterWidth() {
    return this.measurements.lineNumberGutterWidth;
  }

  getVerticalScrollbarWidth() {
    return this.measurements.verticalScrollbarWidth;
  }

  getHorizontalScrollbarHeight() {
    return this.measurements.horizontalScrollbarHeight;
  }

  getRowsPerTile() {
    return this.props.rowsPerTile || DEFAULT_ROWS_PER_TILE;
  }

  tileStartRowForRow(row) {
    return row - (row % this.getRowsPerTile());
  }

  getRenderedStartRow() {
    if (this.derivedDimensionsCache.renderedStartRow == null) {
      this.derivedDimensionsCache.renderedStartRow = this.tileStartRowForRow(
        this.getFirstVisibleRow()
      );
    }

    return this.derivedDimensionsCache.renderedStartRow;
  }

  getRenderedEndRow() {
    if (this.derivedDimensionsCache.renderedEndRow == null) {
      this.derivedDimensionsCache.renderedEndRow = Math.min(
        this.props.model.getApproximateScreenLineCount(),
        this.getRenderedStartRow() +
          this.getVisibleTileCount() * this.getRowsPerTile()
      );
    }

    return this.derivedDimensionsCache.renderedEndRow;
  }

  getRenderedRowCount() {
    if (this.derivedDimensionsCache.renderedRowCount == null) {
      this.derivedDimensionsCache.renderedRowCount = Math.max(
        0,
        this.getRenderedEndRow() - this.getRenderedStartRow()
      );
    }

    return this.derivedDimensionsCache.renderedRowCount;
  }

  getRenderedTileCount() {
    if (this.derivedDimensionsCache.renderedTileCount == null) {
      this.derivedDimensionsCache.renderedTileCount = Math.ceil(
        this.getRenderedRowCount() / this.getRowsPerTile()
      );
    }

    return this.derivedDimensionsCache.renderedTileCount;
  }

  getFirstVisibleRow() {
    if (this.derivedDimensionsCache.firstVisibleRow == null) {
      this.derivedDimensionsCache.firstVisibleRow = this.rowForPixelPosition(
        this.getScrollTop()
      );
    }

    return this.derivedDimensionsCache.firstVisibleRow;
  }

  getLastVisibleRow() {
    if (this.derivedDimensionsCache.lastVisibleRow == null) {
      this.derivedDimensionsCache.lastVisibleRow = Math.min(
        this.props.model.getApproximateScreenLineCount() - 1,
        this.rowForPixelPosition(this.getScrollBottom())
      );
    }

    return this.derivedDimensionsCache.lastVisibleRow;
  }

  // We may render more tiles than needed if some contain block decorations,
  // but keeping this calculation simple ensures the number of tiles remains
  // fixed for a given editor height, which eliminates situations where a
  // tile is repeatedly added and removed during scrolling in certain
  // combinations of editor height and line height.
  getVisibleTileCount() {
    if (this.derivedDimensionsCache.visibleTileCount == null) {
      const editorHeightInTiles =
        this.getScrollContainerHeight() /
        this.getLineHeight() /
        this.getRowsPerTile();
      this.derivedDimensionsCache.visibleTileCount =
        Math.ceil(editorHeightInTiles) + 1;
    }
    return this.derivedDimensionsCache.visibleTileCount;
  }

  getFirstVisibleColumn() {
    return Math.floor(this.getScrollLeft() / this.getBaseCharacterWidth());
  }

  getScrollTop() {
    this.scrollTop = Math.min(this.getMaxScrollTop(), this.scrollTop);
    return this.scrollTop;
  }

  setScrollTop(scrollTop) {
    if (Number.isNaN(scrollTop) || scrollTop == null) return false;

    scrollTop = roundToPhysicalPixelBoundary(
      Math.max(0, Math.min(this.getMaxScrollTop(), scrollTop))
    );
    if (scrollTop !== this.scrollTop) {
      this.derivedDimensionsCache = {};
      this.scrollTopPending = true;
      this.scrollTop = scrollTop;
      this.element.emitter.emit('did-change-scroll-top', scrollTop);
      return true;
    } else {
      return false;
    }
  }

  getMaxScrollTop() {
    return Math.round(
      Math.max(
        0,
        this.getScrollHeight() - this.getScrollContainerClientHeight()
      )
    );
  }

  getScrollBottom() {
    return this.getScrollTop() + this.getScrollContainerClientHeight();
  }

  setScrollBottom(scrollBottom) {
    return this.setScrollTop(
      scrollBottom - this.getScrollContainerClientHeight()
    );
  }

  getScrollLeft() {
    return this.scrollLeft;
  }

  setScrollLeft(scrollLeft) {
    if (Number.isNaN(scrollLeft) || scrollLeft == null) return false;

    scrollLeft = roundToPhysicalPixelBoundary(
      Math.max(0, Math.min(this.getMaxScrollLeft(), scrollLeft))
    );
    if (scrollLeft !== this.scrollLeft) {
      this.scrollLeftPending = true;
      this.scrollLeft = scrollLeft;
      this.element.emitter.emit('did-change-scroll-left', scrollLeft);
      return true;
    } else {
      return false;
    }
  }

  getMaxScrollLeft() {
    return Math.round(
      Math.max(0, this.getScrollWidth() - this.getScrollContainerClientWidth())
    );
  }

  getScrollRight() {
    return this.getScrollLeft() + this.getScrollContainerClientWidth();
  }

  setScrollRight(scrollRight) {
    return this.setScrollLeft(
      scrollRight - this.getScrollContainerClientWidth()
    );
  }

  setScrollTopRow(scrollTopRow, scheduleUpdate = true) {
    if (this.hasInitialMeasurements) {
      const didScroll = this.setScrollTop(
        this.pixelPositionBeforeBlocksForRow(scrollTopRow)
      );
      if (didScroll && scheduleUpdate) {
        this.scheduleUpdate();
      }
      return didScroll;
    } else {
      this.pendingScrollTopRow = scrollTopRow;
      return false;
    }
  }

  getScrollTopRow() {
    if (this.hasInitialMeasurements) {
      return this.rowForPixelPosition(this.getScrollTop());
    } else {
      return this.pendingScrollTopRow || 0;
    }
  }

  setScrollLeftColumn(scrollLeftColumn, scheduleUpdate = true) {
    if (this.hasInitialMeasurements && this.getLongestLineWidth() != null) {
      const didScroll = this.setScrollLeft(
        scrollLeftColumn * this.getBaseCharacterWidth()
      );
      if (didScroll && scheduleUpdate) {
        this.scheduleUpdate();
      }
      return didScroll;
    } else {
      this.pendingScrollLeftColumn = scrollLeftColumn;
      return false;
    }
  }

  getScrollLeftColumn() {
    if (this.hasInitialMeasurements && this.getLongestLineWidth() != null) {
      return Math.round(this.getScrollLeft() / this.getBaseCharacterWidth());
    } else {
      return this.pendingScrollLeftColumn || 0;
    }
  }

  // Ensure the spatial index is populated with rows that are currently visible
  populateVisibleRowRange(renderedStartRow) {
    const { model } = this.props;
    const previousScreenLineCount = model.getApproximateScreenLineCount();

    const renderedEndRow =
      renderedStartRow + this.getVisibleTileCount() * this.getRowsPerTile();
    this.props.model.displayLayer.populateSpatialIndexIfNeeded(
      Infinity,
      renderedEndRow
    );

    // If the approximate screen line count changes, previously-cached derived
    // dimensions could now be out of date.
    if (model.getApproximateScreenLineCount() !== previousScreenLineCount) {
      this.derivedDimensionsCache = {};
    }
  }

  populateVisibleTiles() {
    const startRow = this.getRenderedStartRow();
    const endRow = this.getRenderedEndRow();
    const freeTileIds = [];
    for (let i = 0; i < this.renderedTileStartRows.length; i++) {
      const tileStartRow = this.renderedTileStartRows[i];
      if (tileStartRow < startRow || tileStartRow >= endRow) {
        const tileId = this.idsByTileStartRow.get(tileStartRow);
        freeTileIds.push(tileId);
        this.idsByTileStartRow.delete(tileStartRow);
      }
    }

    const rowsPerTile = this.getRowsPerTile();
    this.renderedTileStartRows.length = this.getRenderedTileCount();
    for (
      let tileStartRow = startRow, i = 0;
      tileStartRow < endRow;
      tileStartRow = tileStartRow + rowsPerTile, i++
    ) {
      this.renderedTileStartRows[i] = tileStartRow;
      if (!this.idsByTileStartRow.has(tileStartRow)) {
        if (freeTileIds.length > 0) {
          this.idsByTileStartRow.set(tileStartRow, freeTileIds.shift());
        } else {
          this.idsByTileStartRow.set(tileStartRow, this.nextTileId++);
        }
      }
    }

    this.renderedTileStartRows.sort(
      (a, b) => this.idsByTileStartRow.get(a) - this.idsByTileStartRow.get(b)
    );
  }

  getNextUpdatePromise() {
    if (!this.nextUpdatePromise) {
      this.nextUpdatePromise = new Promise(resolve => {
        this.resolveNextUpdatePromise = () => {
          this.nextUpdatePromise = null;
          this.resolveNextUpdatePromise = null;
          resolve();
        };
      });
    }
    return this.nextUpdatePromise;
  }

  setInputEnabled(inputEnabled) {
    this.props.model.update({ keyboardInputEnabled: inputEnabled });
  }

  isInputEnabled() {
    return (
      !this.props.model.isReadOnly() &&
      this.props.model.isKeyboardInputEnabled()
    );
  }

  getHiddenInput() {
    return this.refs.cursorsAndInput.refs.hiddenInput;
  }

  getPlatform() {
    return this.props.platform || process.platform;
  }

  getChromeVersion() {
    return this.props.chromeVersion || parseInt(process.versions.chrome);
  }
};

class DummyScrollbarComponent {
  constructor(props) {
    this.props = props;
    etch.initialize(this);
  }

  update(newProps) {
    const oldProps = this.props;
    this.props = newProps;
    etch.updateSync(this);

    const shouldFlushScrollPosition =
      newProps.scrollTop !== oldProps.scrollTop ||
      newProps.scrollLeft !== oldProps.scrollLeft;
    if (shouldFlushScrollPosition) this.flushScrollPosition();
  }

  flushScrollPosition() {
    if (this.props.orientation === 'horizontal') {
      this.element.scrollLeft = this.props.scrollLeft;
    } else {
      this.element.scrollTop = this.props.scrollTop;
    }
  }

  render() {
    const {
      orientation,
      scrollWidth,
      scrollHeight,
      verticalScrollbarWidth,
      horizontalScrollbarHeight,
      canScroll,
      forceScrollbarVisible,
      didScroll
    } = this.props;

    const outerStyle = {
      position: 'absolute',
      contain: 'content',
      zIndex: 1,
      willChange: 'transform'
    };
    if (!canScroll) outerStyle.visibility = 'hidden';

    const innerStyle = {};
    if (orientation === 'horizontal') {
      let right = verticalScrollbarWidth || 0;
      outerStyle.bottom = 0;
      outerStyle.left = 0;
      outerStyle.right = right + 'px';
      outerStyle.height = '15px';
      outerStyle.overflowY = 'hidden';
      outerStyle.overflowX = forceScrollbarVisible ? 'scroll' : 'auto';
      outerStyle.cursor = 'default';
      innerStyle.height = '15px';
      innerStyle.width = (scrollWidth || 0) + 'px';
    } else {
      let bottom = horizontalScrollbarHeight || 0;
      outerStyle.right = 0;
      outerStyle.top = 0;
      outerStyle.bottom = bottom + 'px';
      outerStyle.width = '15px';
      outerStyle.overflowX = 'hidden';
      outerStyle.overflowY = forceScrollbarVisible ? 'scroll' : 'auto';
      outerStyle.cursor = 'default';
      innerStyle.width = '15px';
      innerStyle.height = (scrollHeight || 0) + 'px';
    }

    return $.div(
      {
        className: `${orientation}-scrollbar`,
        style: outerStyle,
        on: {
          scroll: didScroll,
          mousedown: this.didMouseDown
        }
      },
      $.div({ style: innerStyle })
    );
  }

  didMouseDown(event) {
    let { bottom, right } = this.element.getBoundingClientRect();
    const clickedOnScrollbar =
      this.props.orientation === 'horizontal'
        ? event.clientY >= bottom - this.getRealScrollbarHeight()
        : event.clientX >= right - this.getRealScrollbarWidth();
    if (!clickedOnScrollbar) this.props.didMouseDown(event);
  }

  getRealScrollbarWidth() {
    return this.element.offsetWidth - this.element.clientWidth;
  }

  getRealScrollbarHeight() {
    return this.element.offsetHeight - this.element.clientHeight;
  }
}

class GutterContainerComponent {
  constructor(props) {
    this.props = props;
    etch.initialize(this);
  }

  update(props) {
    if (this.shouldUpdate(props)) {
      this.props = props;
      etch.updateSync(this);
    }
  }

  shouldUpdate(props) {
    return (
      !props.measuredContent ||
      props.lineNumberGutterWidth !== this.props.lineNumberGutterWidth
    );
  }

  render() {
    const {
      hasInitialMeasurements,
      scrollTop,
      scrollHeight,
      guttersToRender,
      decorationsToRender
    } = this.props;

    const innerStyle = {
      willChange: 'transform',
      display: 'flex'
    };

    if (hasInitialMeasurements) {
      innerStyle.transform = `translateY(${-roundToPhysicalPixelBoundary(
        scrollTop
      )}px)`;
    }

    return $.div(
      {
        ref: 'gutterContainer',
        key: 'gutterContainer',
        className: 'gutter-container',
        style: {
          position: 'relative',
          zIndex: 1,
          backgroundColor: 'inherit'
        }
      },
      $.div(
        { style: innerStyle },
        guttersToRender.map(gutter => {
          if (gutter.type === 'line-number') {
            return this.renderLineNumberGutter(gutter);
          } else {
            return $(CustomGutterComponent, {
              key: gutter,
              element: gutter.getElement(),
              name: gutter.name,
              visible: gutter.isVisible(),
              height: scrollHeight,
              decorations: decorationsToRender.customGutter.get(gutter.name)
            });
          }
        })
      )
    );
  }

  renderLineNumberGutter(gutter) {
    const {
      rootComponent,
      showLineNumbers,
      hasInitialMeasurements,
      lineNumbersToRender,
      renderedStartRow,
      renderedEndRow,
      rowsPerTile,
      decorationsToRender,
      didMeasureVisibleBlockDecoration,
      scrollHeight,
      lineNumberGutterWidth,
      lineHeight
    } = this.props;

    if (!gutter.isVisible()) {
      return null;
    }

    const oneTrueLineNumberGutter = gutter.name === 'line-number';
    const ref = oneTrueLineNumberGutter ? 'lineNumberGutter' : undefined;
    const width = oneTrueLineNumberGutter ? lineNumberGutterWidth : undefined;

    if (hasInitialMeasurements) {
      const {
        maxDigits,
        keys,
        bufferRows,
        screenRows,
        softWrappedFlags,
        foldableFlags
      } = lineNumbersToRender;
      return $(LineNumberGutterComponent, {
        ref,
        element: gutter.getElement(),
        name: gutter.name,
        className: gutter.className,
        labelFn: gutter.labelFn,
        onMouseDown: gutter.onMouseDown,
        onMouseMove: gutter.onMouseMove,
        rootComponent: rootComponent,
        startRow: renderedStartRow,
        endRow: renderedEndRow,
        rowsPerTile: rowsPerTile,
        maxDigits: maxDigits,
        keys: keys,
        bufferRows: bufferRows,
        screenRows: screenRows,
        softWrappedFlags: softWrappedFlags,
        foldableFlags: foldableFlags,
        decorations: decorationsToRender.lineNumbers.get(gutter.name) || [],
        blockDecorations: decorationsToRender.blocks,
        didMeasureVisibleBlockDecoration: didMeasureVisibleBlockDecoration,
        height: scrollHeight,
        width,
        lineHeight: lineHeight,
        showLineNumbers
      });
    } else {
      return $(LineNumberGutterComponent, {
        ref,
        element: gutter.getElement(),
        name: gutter.name,
        className: gutter.className,
        onMouseDown: gutter.onMouseDown,
        onMouseMove: gutter.onMouseMove,
        maxDigits: lineNumbersToRender.maxDigits,
        showLineNumbers
      });
    }
  }
}

class LineNumberGutterComponent {
  constructor(props) {
    this.props = props;
    this.element = this.props.element;
    this.virtualNode = $.div(null);
    this.virtualNode.domNode = this.element;
    this.nodePool = new NodePool();
    etch.updateSync(this);
  }

  update(newProps) {
    if (this.shouldUpdate(newProps)) {
      this.props = newProps;
      etch.updateSync(this);
    }
  }

  render() {
    const {
      rootComponent,
      showLineNumbers,
      height,
      width,
      startRow,
      endRow,
      rowsPerTile,
      maxDigits,
      keys,
      bufferRows,
      screenRows,
      softWrappedFlags,
      foldableFlags,
      decorations,
      className
    } = this.props;

    let children = null;

    if (bufferRows) {
      children = new Array(rootComponent.renderedTileStartRows.length);
      for (let i = 0; i < rootComponent.renderedTileStartRows.length; i++) {
        const tileStartRow = rootComponent.renderedTileStartRows[i];
        const tileEndRow = Math.min(endRow, tileStartRow + rowsPerTile);
        const tileChildren = new Array(tileEndRow - tileStartRow);
        for (let row = tileStartRow; row < tileEndRow; row++) {
          const indexInTile = row - tileStartRow;
          const j = row - startRow;
          const key = keys[j];
          const softWrapped = softWrappedFlags[j];
          const foldable = foldableFlags[j];
          const bufferRow = bufferRows[j];
          const screenRow = screenRows[j];

          let className = 'line-number';
          if (foldable) className = className + ' foldable';

          const decorationsForRow = decorations[row - startRow];
          if (decorationsForRow)
            className = className + ' ' + decorationsForRow;

          let number = null;
          if (showLineNumbers) {
            if (this.props.labelFn == null) {
              number = softWrapped ? '•' : bufferRow + 1;
              number =
                NBSP_CHARACTER.repeat(maxDigits - number.length) + number;
            } else {
              number = this.props.labelFn({
                bufferRow,
                screenRow,
                foldable,
                softWrapped,
                maxDigits
              });
            }
          }

          // We need to adjust the line number position to account for block
          // decorations preceding the current row and following the preceding
          // row. Note that we ignore the latter when the line number starts at
          // the beginning of the tile, because the tile will already be
          // positioned to take into account block decorations added after the
          // last row of the previous tile.
          let marginTop = rootComponent.heightForBlockDecorationsBeforeRow(row);
          if (indexInTile > 0)
            marginTop += rootComponent.heightForBlockDecorationsAfterRow(
              row - 1
            );

          tileChildren[row - tileStartRow] = $(LineNumberComponent, {
            key,
            className,
            width,
            bufferRow,
            screenRow,
            number,
            marginTop,
            nodePool: this.nodePool
          });
        }

        const tileTop = rootComponent.pixelPositionBeforeBlocksForRow(
          tileStartRow
        );
        const tileBottom = rootComponent.pixelPositionBeforeBlocksForRow(
          tileEndRow
        );
        const tileHeight = tileBottom - tileTop;
        const tileWidth = width != null && width > 0 ? width + 'px' : '';

        children[i] = $.div(
          {
            key: rootComponent.idsByTileStartRow.get(tileStartRow),
            style: {
              contain: 'layout style',
              position: 'absolute',
              top: 0,
              height: tileHeight + 'px',
              width: tileWidth,
              transform: `translateY(${tileTop}px)`
            }
          },
          ...tileChildren
        );
      }
    }

    let rootClassName = 'gutter line-numbers';
    if (className) {
      rootClassName += ' ' + className;
    }

    return $.div(
      {
        className: rootClassName,
        attributes: { 'gutter-name': this.props.name },
        style: {
          position: 'relative',
          height: ceilToPhysicalPixelBoundary(height) + 'px'
        },
        on: {
          mousedown: this.didMouseDown,
          mousemove: this.didMouseMove
        }
      },
      $.div(
        {
          key: 'placeholder',
          className: 'line-number dummy',
          style: { visibility: 'hidden' }
        },
        showLineNumbers ? '0'.repeat(maxDigits) : null,
        $.div({ className: 'icon-right' })
      ),
      children
    );
  }

  shouldUpdate(newProps) {
    const oldProps = this.props;

    if (oldProps.showLineNumbers !== newProps.showLineNumbers) return true;
    if (oldProps.height !== newProps.height) return true;
    if (oldProps.width !== newProps.width) return true;
    if (oldProps.lineHeight !== newProps.lineHeight) return true;
    if (oldProps.startRow !== newProps.startRow) return true;
    if (oldProps.endRow !== newProps.endRow) return true;
    if (oldProps.rowsPerTile !== newProps.rowsPerTile) return true;
    if (oldProps.maxDigits !== newProps.maxDigits) return true;
    if (oldProps.labelFn !== newProps.labelFn) return true;
    if (oldProps.className !== newProps.className) return true;
    if (newProps.didMeasureVisibleBlockDecoration) return true;
    if (!arraysEqual(oldProps.keys, newProps.keys)) return true;
    if (!arraysEqual(oldProps.bufferRows, newProps.bufferRows)) return true;
    if (!arraysEqual(oldProps.foldableFlags, newProps.foldableFlags))
      return true;
    if (!arraysEqual(oldProps.decorations, newProps.decorations)) return true;

    let oldTileStartRow = oldProps.startRow;
    let newTileStartRow = newProps.startRow;
    while (
      oldTileStartRow < oldProps.endRow ||
      newTileStartRow < newProps.endRow
    ) {
      let oldTileBlockDecorations = oldProps.blockDecorations.get(
        oldTileStartRow
      );
      let newTileBlockDecorations = newProps.blockDecorations.get(
        newTileStartRow
      );

      if (oldTileBlockDecorations && newTileBlockDecorations) {
        if (oldTileBlockDecorations.size !== newTileBlockDecorations.size)
          return true;

        let blockDecorationsChanged = false;

        oldTileBlockDecorations.forEach((oldDecorations, screenLineId) => {
          if (!blockDecorationsChanged) {
            const newDecorations = newTileBlockDecorations.get(screenLineId);
            blockDecorationsChanged =
              newDecorations == null ||
              !arraysEqual(oldDecorations, newDecorations);
          }
        });
        if (blockDecorationsChanged) return true;

        newTileBlockDecorations.forEach((newDecorations, screenLineId) => {
          if (!blockDecorationsChanged) {
            const oldDecorations = oldTileBlockDecorations.get(screenLineId);
            blockDecorationsChanged = oldDecorations == null;
          }
        });
        if (blockDecorationsChanged) return true;
      } else if (oldTileBlockDecorations) {
        return true;
      } else if (newTileBlockDecorations) {
        return true;
      }

      oldTileStartRow += oldProps.rowsPerTile;
      newTileStartRow += newProps.rowsPerTile;
    }

    return false;
  }

  didMouseDown(event) {
    if (this.props.onMouseDown == null) {
      this.props.rootComponent.didMouseDownOnLineNumberGutter(event);
    } else {
      const { bufferRow, screenRow } = event.target.dataset;
      this.props.onMouseDown({
        bufferRow: parseInt(bufferRow, 10),
        screenRow: parseInt(screenRow, 10),
        domEvent: event
      });
    }
  }

  didMouseMove(event) {
    if (this.props.onMouseMove != null) {
      const { bufferRow, screenRow } = event.target.dataset;
      this.props.onMouseMove({
        bufferRow: parseInt(bufferRow, 10),
        screenRow: parseInt(screenRow, 10),
        domEvent: event
      });
    }
  }
}

class LineNumberComponent {
  constructor(props) {
    const {
      className,
      width,
      marginTop,
      bufferRow,
      screenRow,
      number,
      nodePool
    } = props;
    this.props = props;
    const style = {};
    if (width != null && width > 0) style.width = width + 'px';
    if (marginTop != null && marginTop > 0) style.marginTop = marginTop + 'px';
    this.element = nodePool.getElement('DIV', className, style);
    this.element.dataset.bufferRow = bufferRow;
    this.element.dataset.screenRow = screenRow;
    if (number) this.element.appendChild(nodePool.getTextNode(number));
    this.element.appendChild(nodePool.getElement('DIV', 'icon-right', null));
  }

  destroy() {
    this.element.remove();
    this.props.nodePool.release(this.element);
  }

  update(props) {
    const {
      nodePool,
      className,
      width,
      marginTop,
      bufferRow,
      screenRow,
      number
    } = props;

    if (this.props.bufferRow !== bufferRow)
      this.element.dataset.bufferRow = bufferRow;
    if (this.props.screenRow !== screenRow)
      this.element.dataset.screenRow = screenRow;
    if (this.props.className !== className) this.element.className = className;
    if (this.props.width !== width) {
      if (width != null && width > 0) {
        this.element.style.width = width + 'px';
      } else {
        this.element.style.width = '';
      }
    }
    if (this.props.marginTop !== marginTop) {
      if (marginTop != null && marginTop > 0) {
        this.element.style.marginTop = marginTop + 'px';
      } else {
        this.element.style.marginTop = '';
      }
    }

    if (this.props.number !== number) {
      if (this.props.number != null) {
        const numberNode = this.element.firstChild;
        numberNode.remove();
        nodePool.release(numberNode);
      }

      if (number != null) {
        this.element.insertBefore(
          nodePool.getTextNode(number),
          this.element.firstChild
        );
      }
    }

    this.props = props;
  }
}

class CustomGutterComponent {
  constructor(props) {
    this.props = props;
    this.element = this.props.element;
    this.virtualNode = $.div(null);
    this.virtualNode.domNode = this.element;
    etch.updateSync(this);
  }

  update(props) {
    this.props = props;
    etch.updateSync(this);
  }

  destroy() {
    etch.destroy(this);
  }

  render() {
    let className = 'gutter';
    if (this.props.className) {
      className += ' ' + this.props.className;
    }
    return $.div(
      {
        className,
        attributes: { 'gutter-name': this.props.name },
        style: {
          display: this.props.visible ? '' : 'none'
        }
      },
      $.div(
        {
          className: 'custom-decorations',
          style: { height: this.props.height + 'px' }
        },
        this.renderDecorations()
      )
    );
  }

  renderDecorations() {
    if (!this.props.decorations) return null;

    return this.props.decorations.map(({ className, element, top, height }) => {
      return $(CustomGutterDecorationComponent, {
        className,
        element,
        top,
        height
      });
    });
  }
}

class CustomGutterDecorationComponent {
  constructor(props) {
    this.props = props;
    this.element = document.createElement('div');
    const { top, height, className, element } = this.props;

    this.element.style.position = 'absolute';
    this.element.style.top = top + 'px';
    this.element.style.height = height + 'px';
    if (className != null) this.element.className = className;
    if (element != null) {
      this.element.appendChild(element);
      element.style.height = height + 'px';
    }
  }

  update(newProps) {
    const oldProps = this.props;
    this.props = newProps;

    if (newProps.top !== oldProps.top)
      this.element.style.top = newProps.top + 'px';
    if (newProps.height !== oldProps.height) {
      this.element.style.height = newProps.height + 'px';
      if (newProps.element)
        newProps.element.style.height = newProps.height + 'px';
    }
    if (newProps.className !== oldProps.className)
      this.element.className = newProps.className || '';
    if (newProps.element !== oldProps.element) {
      if (this.element.firstChild) this.element.firstChild.remove();
      if (newProps.element != null) {
        this.element.appendChild(newProps.element);
        newProps.element.style.height = newProps.height + 'px';
      }
    }
  }
}

class CursorsAndInputComponent {
  constructor(props) {
    this.props = props;
    etch.initialize(this);
  }

  update(props) {
    if (props.measuredContent) {
      this.props = props;
      etch.updateSync(this);
    }
  }

  updateCursorBlinkSync(cursorsBlinkedOff) {
    this.props.cursorsBlinkedOff = cursorsBlinkedOff;
    const className = this.getCursorsClassName();
    this.refs.cursors.className = className;
    this.virtualNode.props.className = className;
  }

  render() {
    const {
      lineHeight,
      decorationsToRender,
      scrollHeight,
      scrollWidth
    } = this.props;

    const className = this.getCursorsClassName();
    const cursorHeight = lineHeight + 'px';

    const children = [this.renderHiddenInput()];
    for (let i = 0; i < decorationsToRender.cursors.length; i++) {
      const {
        pixelLeft,
        pixelTop,
        pixelWidth,
        className: extraCursorClassName,
        style: extraCursorStyle
      } = decorationsToRender.cursors[i];
      let cursorClassName = 'cursor';
      if (extraCursorClassName) cursorClassName += ' ' + extraCursorClassName;

      const cursorStyle = {
        height: cursorHeight,
        width: Math.min(pixelWidth, scrollWidth - pixelLeft) + 'px',
        transform: `translate(${pixelLeft}px, ${pixelTop}px)`
      };
      if (extraCursorStyle) Object.assign(cursorStyle, extraCursorStyle);

      children.push(
        $.div({
          className: cursorClassName,
          style: cursorStyle
        })
      );
    }

    return $.div(
      {
        key: 'cursors',
        ref: 'cursors',
        className,
        style: {
          position: 'absolute',
          contain: 'strict',
          zIndex: 1,
          width: scrollWidth + 'px',
          height: scrollHeight + 'px',
          pointerEvents: 'none',
          userSelect: 'none'
        }
      },
      children
    );
  }

  getCursorsClassName() {
    return this.props.cursorsBlinkedOff ? 'cursors blink-off' : 'cursors';
  }

  renderHiddenInput() {
    const {
      lineHeight,
      hiddenInputPosition,
      didBlurHiddenInput,
      didFocusHiddenInput,
      didPaste,
      didTextInput,
      didKeydown,
      didKeyup,
      didKeypress,
      didCompositionStart,
      didCompositionUpdate,
      didCompositionEnd,
      tabIndex
    } = this.props;

    let top, left;
    if (hiddenInputPosition) {
      top = hiddenInputPosition.pixelTop;
      left = hiddenInputPosition.pixelLeft;
    } else {
      top = 0;
      left = 0;
    }

    return $.input({
      ref: 'hiddenInput',
      key: 'hiddenInput',
      className: 'hidden-input',
      on: {
        blur: didBlurHiddenInput,
        focus: didFocusHiddenInput,
        paste: didPaste,
        textInput: didTextInput,
        keydown: didKeydown,
        keyup: didKeyup,
        keypress: didKeypress,
        compositionstart: didCompositionStart,
        compositionupdate: didCompositionUpdate,
        compositionend: didCompositionEnd
      },
      tabIndex: tabIndex,
      style: {
        position: 'absolute',
        width: '1px',
        height: lineHeight + 'px',
        top: top + 'px',
        left: left + 'px',
        opacity: 0,
        padding: 0,
        border: 0
      }
    });
  }
}

class LinesTileComponent {
  constructor(props) {
    this.props = props;
    etch.initialize(this);
    this.createLines();
    this.updateBlockDecorations({}, props);
  }

  update(newProps) {
    if (this.shouldUpdate(newProps)) {
      const oldProps = this.props;
      this.props = newProps;
      etch.updateSync(this);
      if (!newProps.measuredContent) {
        this.updateLines(oldProps, newProps);
        this.updateBlockDecorations(oldProps, newProps);
      }
    }
  }

  destroy() {
    for (let i = 0; i < this.lineComponents.length; i++) {
      this.lineComponents[i].destroy();
    }
    this.lineComponents.length = 0;

    return etch.destroy(this);
  }

  render() {
    const { height, width, top } = this.props;

    return $.div(
      {
        style: {
          contain: 'layout style',
          position: 'absolute',
          height: height + 'px',
          width: width + 'px',
          transform: `translateY(${top}px)`
        }
      }
      // Lines and block decorations will be manually inserted here for efficiency
    );
  }

  createLines() {
    const {
      tileStartRow,
      screenLines,
      lineDecorations,
      textDecorations,
      nodePool,
      displayLayer,
      lineComponentsByScreenLineId
    } = this.props;

    this.lineComponents = [];
    for (let i = 0, length = screenLines.length; i < length; i++) {
      const component = new LineComponent({
        screenLine: screenLines[i],
        screenRow: tileStartRow + i,
        lineDecoration: lineDecorations[i],
        textDecorations: textDecorations[i],
        displayLayer,
        nodePool,
        lineComponentsByScreenLineId
      });
      this.element.appendChild(component.element);
      this.lineComponents.push(component);
    }
  }

  updateLines(oldProps, newProps) {
    const {
      screenLines,
      tileStartRow,
      lineDecorations,
      textDecorations,
      nodePool,
      displayLayer,
      lineComponentsByScreenLineId
    } = newProps;

    const oldScreenLines = oldProps.screenLines;
    const newScreenLines = screenLines;
    const oldScreenLinesEndIndex = oldScreenLines.length;
    const newScreenLinesEndIndex = newScreenLines.length;
    let oldScreenLineIndex = 0;
    let newScreenLineIndex = 0;
    let lineComponentIndex = 0;

    while (
      oldScreenLineIndex < oldScreenLinesEndIndex ||
      newScreenLineIndex < newScreenLinesEndIndex
    ) {
      const oldScreenLine = oldScreenLines[oldScreenLineIndex];
      const newScreenLine = newScreenLines[newScreenLineIndex];

      if (oldScreenLineIndex >= oldScreenLinesEndIndex) {
        var newScreenLineComponent = new LineComponent({
          screenLine: newScreenLine,
          screenRow: tileStartRow + newScreenLineIndex,
          lineDecoration: lineDecorations[newScreenLineIndex],
          textDecorations: textDecorations[newScreenLineIndex],
          displayLayer,
          nodePool,
          lineComponentsByScreenLineId
        });
        this.element.appendChild(newScreenLineComponent.element);
        this.lineComponents.push(newScreenLineComponent);

        newScreenLineIndex++;
        lineComponentIndex++;
      } else if (newScreenLineIndex >= newScreenLinesEndIndex) {
        this.lineComponents[lineComponentIndex].destroy();
        this.lineComponents.splice(lineComponentIndex, 1);

        oldScreenLineIndex++;
      } else if (oldScreenLine === newScreenLine) {
        const lineComponent = this.lineComponents[lineComponentIndex];
        lineComponent.update({
          screenRow: tileStartRow + newScreenLineIndex,
          lineDecoration: lineDecorations[newScreenLineIndex],
          textDecorations: textDecorations[newScreenLineIndex]
        });

        oldScreenLineIndex++;
        newScreenLineIndex++;
        lineComponentIndex++;
      } else {
        const oldScreenLineIndexInNewScreenLines = newScreenLines.indexOf(
          oldScreenLine
        );
        const newScreenLineIndexInOldScreenLines = oldScreenLines.indexOf(
          newScreenLine
        );
        if (
          newScreenLineIndex < oldScreenLineIndexInNewScreenLines &&
          oldScreenLineIndexInNewScreenLines < newScreenLinesEndIndex
        ) {
          const newScreenLineComponents = [];
          while (newScreenLineIndex < oldScreenLineIndexInNewScreenLines) {
            // eslint-disable-next-line no-redeclare
            var newScreenLineComponent = new LineComponent({
              screenLine: newScreenLines[newScreenLineIndex],
              screenRow: tileStartRow + newScreenLineIndex,
              lineDecoration: lineDecorations[newScreenLineIndex],
              textDecorations: textDecorations[newScreenLineIndex],
              displayLayer,
              nodePool,
              lineComponentsByScreenLineId
            });
            this.element.insertBefore(
              newScreenLineComponent.element,
              this.getFirstElementForScreenLine(oldProps, oldScreenLine)
            );
            newScreenLineComponents.push(newScreenLineComponent);

            newScreenLineIndex++;
          }

          this.lineComponents.splice(
            lineComponentIndex,
            0,
            ...newScreenLineComponents
          );
          lineComponentIndex =
            lineComponentIndex + newScreenLineComponents.length;
        } else if (
          oldScreenLineIndex < newScreenLineIndexInOldScreenLines &&
          newScreenLineIndexInOldScreenLines < oldScreenLinesEndIndex
        ) {
          while (oldScreenLineIndex < newScreenLineIndexInOldScreenLines) {
            this.lineComponents[lineComponentIndex].destroy();
            this.lineComponents.splice(lineComponentIndex, 1);

            oldScreenLineIndex++;
          }
        } else {
          const oldScreenLineComponent = this.lineComponents[
            lineComponentIndex
          ];
          // eslint-disable-next-line no-redeclare
          var newScreenLineComponent = new LineComponent({
            screenLine: newScreenLines[newScreenLineIndex],
            screenRow: tileStartRow + newScreenLineIndex,
            lineDecoration: lineDecorations[newScreenLineIndex],
            textDecorations: textDecorations[newScreenLineIndex],
            displayLayer,
            nodePool,
            lineComponentsByScreenLineId
          });
          this.element.insertBefore(
            newScreenLineComponent.element,
            oldScreenLineComponent.element
          );
          oldScreenLineComponent.destroy();
          this.lineComponents[lineComponentIndex] = newScreenLineComponent;

          oldScreenLineIndex++;
          newScreenLineIndex++;
          lineComponentIndex++;
        }
      }
    }
  }

  getFirstElementForScreenLine(oldProps, screenLine) {
    const blockDecorations = oldProps.blockDecorations
      ? oldProps.blockDecorations.get(screenLine.id)
      : null;
    if (blockDecorations) {
      const blockDecorationElementsBeforeOldScreenLine = [];
      for (let i = 0; i < blockDecorations.length; i++) {
        const decoration = blockDecorations[i];
        if (decoration.position !== 'after') {
          blockDecorationElementsBeforeOldScreenLine.push(
            TextEditor.viewForItem(decoration.item)
          );
        }
      }

      for (
        let i = 0;
        i < blockDecorationElementsBeforeOldScreenLine.length;
        i++
      ) {
        const blockDecorationElement =
          blockDecorationElementsBeforeOldScreenLine[i];
        if (
          !blockDecorationElementsBeforeOldScreenLine.includes(
            blockDecorationElement.previousSibling
          )
        ) {
          return blockDecorationElement;
        }
      }
    }

    return oldProps.lineComponentsByScreenLineId.get(screenLine.id).element;
  }

  updateBlockDecorations(oldProps, newProps) {
    const { blockDecorations, lineComponentsByScreenLineId } = newProps;

    if (oldProps.blockDecorations) {
      oldProps.blockDecorations.forEach((oldDecorations, screenLineId) => {
        const newDecorations = newProps.blockDecorations
          ? newProps.blockDecorations.get(screenLineId)
          : null;
        for (let i = 0; i < oldDecorations.length; i++) {
          const oldDecoration = oldDecorations[i];
          if (newDecorations && newDecorations.includes(oldDecoration))
            continue;

          const element = TextEditor.viewForItem(oldDecoration.item);
          if (element.parentElement !== this.element) continue;

          element.remove();
        }
      });
    }

    if (blockDecorations) {
      blockDecorations.forEach((newDecorations, screenLineId) => {
        const oldDecorations = oldProps.blockDecorations
          ? oldProps.blockDecorations.get(screenLineId)
          : null;
        const lineNode = lineComponentsByScreenLineId.get(screenLineId).element;
        let lastAfter = lineNode;

        for (let i = 0; i < newDecorations.length; i++) {
          const newDecoration = newDecorations[i];
          const element = TextEditor.viewForItem(newDecoration.item);

          if (oldDecorations && oldDecorations.includes(newDecoration)) {
            if (newDecoration.position === 'after') {
              lastAfter = element;
            }
            continue;
          }

          if (newDecoration.position === 'after') {
            this.element.insertBefore(element, lastAfter.nextSibling);
            lastAfter = element;
          } else {
            this.element.insertBefore(element, lineNode);
          }
        }
      });
    }
  }

  shouldUpdate(newProps) {
    const oldProps = this.props;
    if (oldProps.top !== newProps.top) return true;
    if (oldProps.height !== newProps.height) return true;
    if (oldProps.width !== newProps.width) return true;
    if (oldProps.lineHeight !== newProps.lineHeight) return true;
    if (oldProps.tileStartRow !== newProps.tileStartRow) return true;
    if (oldProps.tileEndRow !== newProps.tileEndRow) return true;
    if (!arraysEqual(oldProps.screenLines, newProps.screenLines)) return true;
    if (!arraysEqual(oldProps.lineDecorations, newProps.lineDecorations))
      return true;

    if (oldProps.blockDecorations && newProps.blockDecorations) {
      if (oldProps.blockDecorations.size !== newProps.blockDecorations.size)
        return true;

      let blockDecorationsChanged = false;

      oldProps.blockDecorations.forEach((oldDecorations, screenLineId) => {
        if (!blockDecorationsChanged) {
          const newDecorations = newProps.blockDecorations.get(screenLineId);
          blockDecorationsChanged =
            newDecorations == null ||
            !arraysEqual(oldDecorations, newDecorations);
        }
      });
      if (blockDecorationsChanged) return true;

      newProps.blockDecorations.forEach((newDecorations, screenLineId) => {
        if (!blockDecorationsChanged) {
          const oldDecorations = oldProps.blockDecorations.get(screenLineId);
          blockDecorationsChanged = oldDecorations == null;
        }
      });
      if (blockDecorationsChanged) return true;
    } else if (oldProps.blockDecorations) {
      return true;
    } else if (newProps.blockDecorations) {
      return true;
    }

    if (oldProps.textDecorations.length !== newProps.textDecorations.length)
      return true;
    for (let i = 0; i < oldProps.textDecorations.length; i++) {
      if (
        !textDecorationsEqual(
          oldProps.textDecorations[i],
          newProps.textDecorations[i]
        )
      )
        return true;
    }

    return false;
  }
}

class LineComponent {
  constructor(props) {
    const {
      nodePool,
      screenRow,
      screenLine,
      lineComponentsByScreenLineId,
      offScreen
    } = props;
    this.props = props;
    this.element = nodePool.getElement('DIV', this.buildClassName(), null);
    this.element.dataset.screenRow = screenRow;
    this.textNodes = [];

    if (offScreen) {
      this.element.style.position = 'absolute';
      this.element.style.visibility = 'hidden';
      this.element.dataset.offScreen = true;
    }

    this.appendContents();
    lineComponentsByScreenLineId.set(screenLine.id, this);
  }

  update(newProps) {
    if (this.props.lineDecoration !== newProps.lineDecoration) {
      this.props.lineDecoration = newProps.lineDecoration;
      this.element.className = this.buildClassName();
    }

    if (this.props.screenRow !== newProps.screenRow) {
      this.props.screenRow = newProps.screenRow;
      this.element.dataset.screenRow = newProps.screenRow;
    }

    if (
      !textDecorationsEqual(
        this.props.textDecorations,
        newProps.textDecorations
      )
    ) {
      this.props.textDecorations = newProps.textDecorations;
      this.element.firstChild.remove();
      this.appendContents();
    }
  }

  destroy() {
    const { nodePool, lineComponentsByScreenLineId, screenLine } = this.props;

    if (lineComponentsByScreenLineId.get(screenLine.id) === this) {
      lineComponentsByScreenLineId.delete(screenLine.id);
    }

    this.element.remove();
    nodePool.release(this.element);
  }

  appendContents() {
    const { displayLayer, nodePool, screenLine, textDecorations } = this.props;

    this.textNodes.length = 0;

    const { lineText, tags } = screenLine;
    let openScopeNode = nodePool.getElement('SPAN', null, null);
    this.element.appendChild(openScopeNode);

    let decorationIndex = 0;
    let column = 0;
    let activeClassName = null;
    let activeStyle = null;
    let nextDecoration = textDecorations
      ? textDecorations[decorationIndex]
      : null;
    if (nextDecoration && nextDecoration.column === 0) {
      column = nextDecoration.column;
      activeClassName = nextDecoration.className;
      activeStyle = nextDecoration.style;
      nextDecoration = textDecorations[++decorationIndex];
    }

    for (let i = 0; i < tags.length; i++) {
      const tag = tags[i];
      if (tag !== 0) {
        if (displayLayer.isCloseTag(tag)) {
          openScopeNode = openScopeNode.parentElement;
        } else if (displayLayer.isOpenTag(tag)) {
          const newScopeNode = nodePool.getElement(
            'SPAN',
            displayLayer.classNameForTag(tag),
            null
          );
          openScopeNode.appendChild(newScopeNode);
          openScopeNode = newScopeNode;
        } else {
          const nextTokenColumn = column + tag;
          while (nextDecoration && nextDecoration.column <= nextTokenColumn) {
            const text = lineText.substring(column, nextDecoration.column);
            this.appendTextNode(
              openScopeNode,
              text,
              activeClassName,
              activeStyle
            );
            column = nextDecoration.column;
            activeClassName = nextDecoration.className;
            activeStyle = nextDecoration.style;
            nextDecoration = textDecorations[++decorationIndex];
          }

          if (column < nextTokenColumn) {
            const text = lineText.substring(column, nextTokenColumn);
            this.appendTextNode(
              openScopeNode,
              text,
              activeClassName,
              activeStyle
            );
            column = nextTokenColumn;
          }
        }
      }
    }

    if (column === 0) {
      const textNode = nodePool.getTextNode(' ');
      this.element.appendChild(textNode);
      this.textNodes.push(textNode);
    }

    if (lineText.endsWith(displayLayer.foldCharacter)) {
      // Insert a zero-width non-breaking whitespace, so that LinesYardstick can
      // take the fold-marker::after pseudo-element into account during
      // measurements when such marker is the last character on the line.
      const textNode = nodePool.getTextNode(ZERO_WIDTH_NBSP_CHARACTER);
      this.element.appendChild(textNode);
      this.textNodes.push(textNode);
    }
  }

  appendTextNode(openScopeNode, text, activeClassName, activeStyle) {
    const { nodePool } = this.props;

    if (activeClassName || activeStyle) {
      const decorationNode = nodePool.getElement(
        'SPAN',
        activeClassName,
        activeStyle
      );
      openScopeNode.appendChild(decorationNode);
      openScopeNode = decorationNode;
    }

    const textNode = nodePool.getTextNode(text);
    openScopeNode.appendChild(textNode);
    this.textNodes.push(textNode);
  }

  buildClassName() {
    const { lineDecoration } = this.props;
    let className = 'line';
    if (lineDecoration != null) className = className + ' ' + lineDecoration;
    return className;
  }
}

class HighlightsComponent {
  constructor(props) {
    this.props = {};
    this.element = document.createElement('div');
    this.element.className = 'highlights';
    this.element.style.contain = 'strict';
    this.element.style.position = 'absolute';
    this.element.style.overflow = 'hidden';
    this.element.style.userSelect = 'none';
    this.highlightComponentsByKey = new Map();
    this.update(props);
  }

  destroy() {
    this.highlightComponentsByKey.forEach(highlightComponent => {
      highlightComponent.destroy();
    });
    this.highlightComponentsByKey.clear();
  }

  update(newProps) {
    if (this.shouldUpdate(newProps)) {
      this.props = newProps;
      const { height, width, lineHeight, highlightDecorations } = this.props;

      this.element.style.height = height + 'px';
      this.element.style.width = width + 'px';

      const visibleHighlightDecorations = new Set();
      if (highlightDecorations) {
        for (let i = 0; i < highlightDecorations.length; i++) {
          const highlightDecoration = highlightDecorations[i];
          const highlightProps = Object.assign(
            { lineHeight },
            highlightDecorations[i]
          );

          let highlightComponent = this.highlightComponentsByKey.get(
            highlightDecoration.key
          );
          if (highlightComponent) {
            highlightComponent.update(highlightProps);
          } else {
            highlightComponent = new HighlightComponent(highlightProps);
            this.element.appendChild(highlightComponent.element);
            this.highlightComponentsByKey.set(
              highlightDecoration.key,
              highlightComponent
            );
          }

          highlightDecorations[i].flashRequested = false;
          visibleHighlightDecorations.add(highlightDecoration.key);
        }
      }

      this.highlightComponentsByKey.forEach((highlightComponent, key) => {
        if (!visibleHighlightDecorations.has(key)) {
          highlightComponent.destroy();
          this.highlightComponentsByKey.delete(key);
        }
      });
    }
  }

  shouldUpdate(newProps) {
    const oldProps = this.props;

    if (!newProps.hasInitialMeasurements) return false;

    if (oldProps.width !== newProps.width) return true;
    if (oldProps.height !== newProps.height) return true;
    if (oldProps.lineHeight !== newProps.lineHeight) return true;
    if (!oldProps.highlightDecorations && newProps.highlightDecorations)
      return true;
    if (oldProps.highlightDecorations && !newProps.highlightDecorations)
      return true;
    if (oldProps.highlightDecorations && newProps.highlightDecorations) {
      if (
        oldProps.highlightDecorations.length !==
        newProps.highlightDecorations.length
      )
        return true;

      for (
        let i = 0, length = oldProps.highlightDecorations.length;
        i < length;
        i++
      ) {
        const oldHighlight = oldProps.highlightDecorations[i];
        const newHighlight = newProps.highlightDecorations[i];
        if (oldHighlight.className !== newHighlight.className) return true;
        if (newHighlight.flashRequested) return true;
        if (oldHighlight.startPixelTop !== newHighlight.startPixelTop)
          return true;
        if (oldHighlight.startPixelLeft !== newHighlight.startPixelLeft)
          return true;
        if (oldHighlight.endPixelTop !== newHighlight.endPixelTop) return true;
        if (oldHighlight.endPixelLeft !== newHighlight.endPixelLeft)
          return true;
        if (!oldHighlight.screenRange.isEqual(newHighlight.screenRange))
          return true;
      }
    }
  }
}

class HighlightComponent {
  constructor(props) {
    this.props = props;
    etch.initialize(this);
    if (this.props.flashRequested) this.performFlash();
  }

  destroy() {
    if (this.timeoutsByClassName) {
      this.timeoutsByClassName.forEach(timeout => {
        window.clearTimeout(timeout);
      });
      this.timeoutsByClassName.clear();
    }

    return etch.destroy(this);
  }

  update(newProps) {
    this.props = newProps;
    etch.updateSync(this);
    if (newProps.flashRequested) this.performFlash();
  }

  performFlash() {
    const { flashClass, flashDuration } = this.props;
    if (!this.timeoutsByClassName) this.timeoutsByClassName = new Map();

    // If a flash of this class is already in progress, clear it early and
    // flash again on the next frame to ensure CSS transitions apply to the
    // second flash.
    if (this.timeoutsByClassName.has(flashClass)) {
      window.clearTimeout(this.timeoutsByClassName.get(flashClass));
      this.timeoutsByClassName.delete(flashClass);
      this.element.classList.remove(flashClass);
      requestAnimationFrame(() => this.performFlash());
    } else {
      this.element.classList.add(flashClass);
      this.timeoutsByClassName.set(
        flashClass,
        window.setTimeout(() => {
          this.element.classList.remove(flashClass);
        }, flashDuration)
      );
    }
  }

  render() {
    const {
      className,
      screenRange,
      lineHeight,
      startPixelTop,
      startPixelLeft,
      endPixelTop,
      endPixelLeft
    } = this.props;
    const regionClassName = 'region ' + className;

    let children;
    if (screenRange.start.row === screenRange.end.row) {
      children = $.div({
        className: regionClassName,
        style: {
          position: 'absolute',
          boxSizing: 'border-box',
          top: startPixelTop + 'px',
          left: startPixelLeft + 'px',
          width: endPixelLeft - startPixelLeft + 'px',
          height: lineHeight + 'px'
        }
      });
    } else {
      children = [];
      children.push(
        $.div({
          className: regionClassName,
          style: {
            position: 'absolute',
            boxSizing: 'border-box',
            top: startPixelTop + 'px',
            left: startPixelLeft + 'px',
            right: 0,
            height: lineHeight + 'px'
          }
        })
      );

      if (screenRange.end.row - screenRange.start.row > 1) {
        children.push(
          $.div({
            className: regionClassName,
            style: {
              position: 'absolute',
              boxSizing: 'border-box',
              top: startPixelTop + lineHeight + 'px',
              left: 0,
              right: 0,
              height: endPixelTop - startPixelTop - lineHeight * 2 + 'px'
            }
          })
        );
      }

      if (endPixelLeft > 0) {
        children.push(
          $.div({
            className: regionClassName,
            style: {
              position: 'absolute',
              boxSizing: 'border-box',
              top: endPixelTop - lineHeight + 'px',
              left: 0,
              width: endPixelLeft + 'px',
              height: lineHeight + 'px'
            }
          })
        );
      }
    }

    return $.div({ className: 'highlight ' + className }, children);
  }
}

class OverlayComponent {
  constructor(props) {
    this.props = props;
    this.element = document.createElement('atom-overlay');
    if (this.props.className != null)
      this.element.classList.add(this.props.className);
    this.element.appendChild(this.props.element);
    this.element.style.position = 'fixed';
    this.element.style.zIndex = 4;
    this.element.style.top = (this.props.pixelTop || 0) + 'px';
    this.element.style.left = (this.props.pixelLeft || 0) + 'px';
    this.currentContentRect = null;

    // Synchronous DOM updates in response to resize events might trigger a
    // "loop limit exceeded" error. We disconnect the observer before
    // potentially mutating the DOM, and then reconnect it on the next tick.
    // Note: ResizeObserver calls its callback when .observe is called
    this.resizeObserver = new ResizeObserver(entries => {
      const { contentRect } = entries[0];

      if (
        this.currentContentRect &&
        (this.currentContentRect.width !== contentRect.width ||
          this.currentContentRect.height !== contentRect.height)
      ) {
        this.resizeObserver.disconnect();
        this.props.didResize(this);
        process.nextTick(() => {
          this.resizeObserver.observe(this.props.element);
        });
      }

      this.currentContentRect = contentRect;
    });
    this.didAttach();
    this.props.overlayComponents.add(this);
  }

  destroy() {
    this.props.overlayComponents.delete(this);
    this.didDetach();
  }

  getNextUpdatePromise() {
    if (!this.nextUpdatePromise) {
      this.nextUpdatePromise = new Promise(resolve => {
        this.resolveNextUpdatePromise = () => {
          this.nextUpdatePromise = null;
          this.resolveNextUpdatePromise = null;
          resolve();
        };
      });
    }
    return this.nextUpdatePromise;
  }

  update(newProps) {
    const oldProps = this.props;
    this.props = Object.assign({}, oldProps, newProps);
    if (this.props.pixelTop != null)
      this.element.style.top = this.props.pixelTop + 'px';
    if (this.props.pixelLeft != null)
      this.element.style.left = this.props.pixelLeft + 'px';
    if (newProps.className !== oldProps.className) {
      if (oldProps.className != null)
        this.element.classList.remove(oldProps.className);
      if (newProps.className != null)
        this.element.classList.add(newProps.className);
    }

    if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise();
  }

  didAttach() {
    this.resizeObserver.observe(this.props.element);
  }

  didDetach() {
    this.resizeObserver.disconnect();
  }
}

let rangeForMeasurement;
function clientRectForRange(textNode, startIndex, endIndex) {
  if (!rangeForMeasurement) rangeForMeasurement = document.createRange();
  rangeForMeasurement.setStart(textNode, startIndex);
  rangeForMeasurement.setEnd(textNode, endIndex);
  return rangeForMeasurement.getBoundingClientRect();
}

function textDecorationsEqual(oldDecorations, newDecorations) {
  if (!oldDecorations && newDecorations) return false;
  if (oldDecorations && !newDecorations) return false;
  if (oldDecorations && newDecorations) {
    if (oldDecorations.length !== newDecorations.length) return false;
    for (let j = 0; j < oldDecorations.length; j++) {
      if (oldDecorations[j].column !== newDecorations[j].column) return false;
      if (oldDecorations[j].className !== newDecorations[j].className)
        return false;
      if (!objectsEqual(oldDecorations[j].style, newDecorations[j].style))
        return false;
    }
  }
  return true;
}

function arraysEqual(a, b) {
  if (a.length !== b.length) return false;
  for (let i = 0, length = a.length; i < length; i++) {
    if (a[i] !== b[i]) return false;
  }
  return true;
}

function objectsEqual(a, b) {
  if (!a && b) return false;
  if (a && !b) return false;
  if (a && b) {
    for (const key in a) {
      if (a[key] !== b[key]) return false;
    }
    for (const key in b) {
      if (a[key] !== b[key]) return false;
    }
  }
  return true;
}

function constrainRangeToRows(range, startRow, endRow) {
  if (range.start.row < startRow || range.end.row >= endRow) {
    range = range.copy();
    if (range.start.row < startRow) {
      range.start.row = startRow;
      range.start.column = 0;
    }
    if (range.end.row >= endRow) {
      range.end.row = endRow;
      range.end.column = 0;
    }
  }
  return range;
}

function debounce(fn, wait) {
  let timestamp, timeout;

  function later() {
    const last = Date.now() - timestamp;
    if (last < wait && last >= 0) {
      timeout = setTimeout(later, wait - last);
    } else {
      timeout = null;
      fn();
    }
  }

  return function () {
    timestamp = Date.now();
    if (!timeout) timeout = setTimeout(later, wait);
  };
}

class NodePool {
  constructor() {
    this.elementsByType = {};
    this.textNodes = [];
  }

  getElement(type, className, style) {
    let element;
    const elementsByDepth = this.elementsByType[type];
    if (elementsByDepth) {
      while (elementsByDepth.length > 0) {
        const elements = elementsByDepth[elementsByDepth.length - 1];
        if (elements && elements.length > 0) {
          element = elements.pop();
          if (elements.length === 0) elementsByDepth.pop();
          break;
        } else {
          elementsByDepth.pop();
        }
      }
    }

    if (element) {
      element.className = className || '';
      element.attributeStyleMap.forEach((value, key) => {
        if (!style || style[key] == null) element.style[key] = '';
      });
      if (style) Object.assign(element.style, style);
      for (const key in element.dataset) delete element.dataset[key];
      while (element.firstChild) element.firstChild.remove();
      return element;
    } else {
      const newElement = document.createElement(type);
      if (className) newElement.className = className;
      if (style) Object.assign(newElement.style, style);
      return newElement;
    }
  }

  getTextNode(text) {
    if (this.textNodes.length > 0) {
      const node = this.textNodes.pop();
      node.textContent = text;
      return node;
    } else {
      return document.createTextNode(text);
    }
  }

  release(node, depth = 0) {
    const { nodeName } = node;
    if (nodeName === '#text') {
      this.textNodes.push(node);
    } else {
      let elementsByDepth = this.elementsByType[nodeName];
      if (!elementsByDepth) {
        elementsByDepth = [];
        this.elementsByType[nodeName] = elementsByDepth;
      }

      let elements = elementsByDepth[depth];
      if (!elements) {
        elements = [];
        elementsByDepth[depth] = elements;
      }

      elements.push(node);
      for (let i = 0; i < node.childNodes.length; i++) {
        this.release(node.childNodes[i], depth + 1);
      }
    }
  }
}

function roundToPhysicalPixelBoundary(virtualPixelPosition) {
  const virtualPixelsPerPhysicalPixel = 1 / window.devicePixelRatio;
  return (
    Math.round(virtualPixelPosition / virtualPixelsPerPhysicalPixel) *
    virtualPixelsPerPhysicalPixel
  );
}

function ceilToPhysicalPixelBoundary(virtualPixelPosition) {
  const virtualPixelsPerPhysicalPixel = 1 / window.devicePixelRatio;
  return (
    Math.ceil(virtualPixelPosition / virtualPixelsPerPhysicalPixel) *
    virtualPixelsPerPhysicalPixel
  );
}

================
File: src/text-editor.js
================
const _ = require('underscore-plus');
const path = require('path');
const fs = require('fs-plus');
const Grim = require('grim');
const dedent = require('dedent');
const { CompositeDisposable, Disposable, Emitter } = require('event-kit');
const TextBuffer = require('text-buffer');
const { Point, Range } = TextBuffer;
const DecorationManager = require('./decoration-manager');
const Cursor = require('./cursor');
const Selection = require('./selection');
const NullGrammar = require('./null-grammar');
const TextMateLanguageMode = require('./text-mate-language-mode');
const ScopeDescriptor = require('./scope-descriptor');

const TextMateScopeSelector = require('second-mate').ScopeSelector;
const GutterContainer = require('./gutter-container');
let TextEditorComponent = null;
let TextEditorElement = null;
const {
  isDoubleWidthCharacter,
  isHalfWidthCharacter,
  isKoreanCharacter,
  isWrapBoundary
} = require('./text-utils');

const SERIALIZATION_VERSION = 1;
const NON_WHITESPACE_REGEXP = /\S/;
const ZERO_WIDTH_NBSP = '\ufeff';
let nextId = 0;

const DEFAULT_NON_WORD_CHARACTERS = '/\\()"\':,.;<>~!@#$%^&*|+=[]{}`?-…';

// Essential: This class represents all essential editing state for a single
// {TextBuffer}, including cursor and selection positions, folds, and soft wraps.
// If you're manipulating the state of an editor, use this class.
//
// A single {TextBuffer} can belong to multiple editors. For example, if the
// same file is open in two different panes, Pulsar creates a separate editor for
// each pane. If the buffer is manipulated the changes are reflected in both
// editors, but each maintains its own cursor position, folded lines, etc.
//
// ## Accessing TextEditor Instances
//
// The easiest way to get hold of `TextEditor` objects is by registering a callback
// with `::observeTextEditors` on the `atom.workspace` global. Your callback will
// then be called with all current editor instances and also when any editor is
// created in the future.
//
// ```js
// atom.workspace.observeTextEditors(editor => {
//   editor.insertText('Hello World')
// })
// ```
//
// ## Buffer vs. Screen Coordinates
//
// Because editors support folds and soft-wrapping, the lines on screen don't
// always match the lines in the buffer. For example, a long line that soft wraps
// twice renders as three lines on screen, but only represents one line in the
// buffer. Similarly, if rows 5-10 are folded, then row 6 on screen corresponds
// to row 11 in the buffer.
//
// Your choice of coordinates systems will depend on what you're trying to
// achieve. For example, if you're writing a command that jumps the cursor up or
// down by 10 lines, you'll want to use screen coordinates because the user
// probably wants to skip lines *on screen*. However, if you're writing a package
// that jumps between method definitions, you'll want to work in buffer
// coordinates.
//
// **When in doubt, just default to buffer coordinates**, then experiment with
// soft wraps and folds to ensure your code interacts with them correctly.
module.exports = class TextEditor {
  static setClipboard(clipboard) {
    this.clipboard = clipboard;
  }

  static setScheduler(scheduler) {
    if (TextEditorComponent == null) {
      TextEditorComponent = require('./text-editor-component');
    }
    return TextEditorComponent.setScheduler(scheduler);
  }

  static didUpdateStyles() {
    if (TextEditorComponent == null) {
      TextEditorComponent = require('./text-editor-component');
    }
    return TextEditorComponent.didUpdateStyles();
  }

  static didUpdateScrollbarStyles() {
    if (TextEditorComponent == null) {
      TextEditorComponent = require('./text-editor-component');
    }
    return TextEditorComponent.didUpdateScrollbarStyles();
  }

  static viewForItem(item) {
    return item.element || item;
  }

  static deserialize(state, atomEnvironment) {
    if (state.version !== SERIALIZATION_VERSION) return null;

    let bufferId = state.tokenizedBuffer
      ? state.tokenizedBuffer.bufferId
      : state.bufferId;

    try {
      state.buffer = atomEnvironment.project.bufferForIdSync(bufferId);
      if (!state.buffer) return null;
    } catch (error) {
      if (error.syscall === 'read') {
        return; // Error reading the file, don't deserialize an editor for it
      } else {
        throw error;
      }
    }

    state.assert = atomEnvironment.assert.bind(atomEnvironment);

    // Semantics of the readOnly flag have changed since its introduction.
    // Only respect readOnly2, which has been set with the current readOnly semantics.
    delete state.readOnly;
    state.readOnly = state.readOnly2;
    delete state.readOnly2;

    const editor = new TextEditor(state);
    if (state.registered) {
      const disposable = atomEnvironment.textEditors.add(editor);
      editor.onDidDestroy(() => disposable.dispose());
    }
    return editor;
  }

  constructor(params = {}) {
    if (this.constructor.clipboard == null) {
      throw new Error(
        'Must call TextEditor.setClipboard at least once before creating TextEditor instances'
      );
    }

    this.id = params.id != null ? params.id : nextId++;
    if (this.id >= nextId) {
      // Ensure that new editors get unique ids:
      nextId = this.id + 1;
    }
    this.initialScrollTopRow = params.initialScrollTopRow;
    this.initialScrollLeftColumn = params.initialScrollLeftColumn;
    this.decorationManager = params.decorationManager;
    this.selectionsMarkerLayer = params.selectionsMarkerLayer;
    this.mini = params.mini != null ? params.mini : false;
    this.keyboardInputEnabled =
      params.keyboardInputEnabled != null ? params.keyboardInputEnabled : true;
    this.readOnly = params.readOnly != null ? params.readOnly : false;
    this.placeholderText = params.placeholderText;
    this.showLineNumbers = params.showLineNumbers;
    this.assert = params.assert || (condition => condition);
    this.showInvisibles =
      params.showInvisibles != null ? params.showInvisibles : true;
    this.autoHeight = params.autoHeight;
    this.autoWidth = params.autoWidth;
    this.scrollPastEnd =
      params.scrollPastEnd != null ? params.scrollPastEnd : false;
    this.scrollSensitivity =
      params.scrollSensitivity != null ? params.scrollSensitivity : 40;
    this.editorWidthInChars = params.editorWidthInChars;
    this.invisibles = params.invisibles;
    this.showIndentGuide = params.showIndentGuide;
    this.softWrapped = params.softWrapped;
    this.softWrapAtPreferredLineLength = params.softWrapAtPreferredLineLength;
    this.preferredLineLength = params.preferredLineLength;
    this.showCursorOnSelection =
      params.showCursorOnSelection != null
        ? params.showCursorOnSelection
        : true;
    this.maxScreenLineLength = params.maxScreenLineLength;
    this.softTabs = params.softTabs != null ? params.softTabs : true;
    this.autoIndent = params.autoIndent != null ? params.autoIndent : true;
    this.autoIndentOnPaste =
      params.autoIndentOnPaste != null ? params.autoIndentOnPaste : true;
    this.undoGroupingInterval =
      params.undoGroupingInterval != null ? params.undoGroupingInterval : 300;
    this.softWrapped = params.softWrapped != null ? params.softWrapped : false;
    this.softWrapAtPreferredLineLength =
      params.softWrapAtPreferredLineLength != null
        ? params.softWrapAtPreferredLineLength
        : false;
    this.preferredLineLength =
      params.preferredLineLength != null ? params.preferredLineLength : 80;
    this.maxScreenLineLength =
      params.maxScreenLineLength != null ? params.maxScreenLineLength : 500;
    this.showLineNumbers =
      params.showLineNumbers != null ? params.showLineNumbers : true;
    const { tabLength = 2 } = params;

    this.alive = true;
    this.doBackgroundWork = this.doBackgroundWork.bind(this);
    this.serializationVersion = 1;
    this.suppressSelectionMerging = false;
    this.selectionFlashDuration = 500;
    this.gutterContainer = null;
    this.verticalScrollMargin = 2;
    this.horizontalScrollMargin = 6;
    this.lineHeightInPixels = null;
    this.defaultCharWidth = null;
    this.height = null;
    this.width = null;
    this.registered = false;
    this.atomicSoftTabs = true;
    this.emitter = new Emitter();
    this.disposables = new CompositeDisposable();
    this.cursors = [];
    this.cursorsByMarkerId = new Map();
    this.selections = [];
    this.hasTerminatedPendingState = false;

    if (params.buffer) {
      this.buffer = params.buffer;
    } else {
      this.buffer = new TextBuffer({
        shouldDestroyOnFileDelete() {
          return atom.config.get('core.closeDeletedFileTabs');
        }
      });
      this.buffer.setLanguageMode(
        new TextMateLanguageMode({ buffer: this.buffer, config: atom.config })
      );
    }

    const languageMode = this.buffer.getLanguageMode();
    this.languageModeSubscription =
      languageMode.onDidTokenize &&
      languageMode.onDidTokenize(() => {
        this.emitter.emit('did-tokenize');
      });
    if (this.languageModeSubscription)
      this.disposables.add(this.languageModeSubscription);

    if (params.displayLayer) {
      this.displayLayer = params.displayLayer;
    } else {
      const displayLayerParams = {
        invisibles: this.getInvisibles(),
        softWrapColumn: this.getSoftWrapColumn(),
        showIndentGuides: this.doesShowIndentGuide(),
        atomicSoftTabs:
          params.atomicSoftTabs != null ? params.atomicSoftTabs : true,
        tabLength,
        ratioForCharacter: this.ratioForCharacter.bind(this),
        isWrapBoundary,
        foldCharacter: ZERO_WIDTH_NBSP,
        softWrapHangingIndent:
          params.softWrapHangingIndentLength != null
            ? params.softWrapHangingIndentLength
            : 0
      };

      this.displayLayer = this.buffer.getDisplayLayer(params.displayLayerId);
      if (this.displayLayer) {
        this.displayLayer.reset(displayLayerParams);
        this.selectionsMarkerLayer = this.displayLayer.getMarkerLayer(
          params.selectionsMarkerLayerId
        );
      } else {
        this.displayLayer = this.buffer.addDisplayLayer(displayLayerParams);
      }
    }

    this.backgroundWorkHandle = requestIdleCallback(this.doBackgroundWork);
    this.disposables.add(
      new Disposable(() => {
        if (this.backgroundWorkHandle != null)
          return cancelIdleCallback(this.backgroundWorkHandle);
      })
    );

    this.defaultMarkerLayer = this.displayLayer.addMarkerLayer();
    if (!this.selectionsMarkerLayer) {
      this.selectionsMarkerLayer = this.addMarkerLayer({
        maintainHistory: true,
        persistent: true,
        role: 'selections'
      });
    }

    this.decorationManager = new DecorationManager(this);
    this.decorateMarkerLayer(this.selectionsMarkerLayer, { type: 'cursor' });
    if (!this.isMini()) this.decorateCursorLine();

    this.decorateMarkerLayer(this.displayLayer.foldsMarkerLayer, {
      type: 'line-number',
      class: 'folded'
    });

    for (let marker of this.selectionsMarkerLayer.getMarkers()) {
      this.addSelection(marker);
    }

    this.subscribeToBuffer();
    this.subscribeToDisplayLayer();

    if (this.cursors.length === 0 && !params.suppressCursorCreation) {
      const initialLine = Math.max(parseInt(params.initialLine) || 0, 0);
      const initialColumn = Math.max(parseInt(params.initialColumn) || 0, 0);
      this.addCursorAtBufferPosition([initialLine, initialColumn]);
    }

    this.gutterContainer = new GutterContainer(this);
    this.lineNumberGutter = this.gutterContainer.addGutter({
      name: 'line-number',
      type: 'line-number',
      priority: 0,
      visible: params.lineNumberGutterVisible
    });
  }

  get element() {
    return this.getElement();
  }

  get editorElement() {
    Grim.deprecate(dedent`\
      \`TextEditor.prototype.editorElement\` has always been private, but now
      it is gone. Reading the \`editorElement\` property still returns a
      reference to the editor element but this field will be removed in a
      later version of Pulsar, so we recommend using the \`element\` property instead.\
    `);

    return this.getElement();
  }

  get displayBuffer() {
    Grim.deprecate(dedent`\
      \`TextEditor.prototype.displayBuffer\` has always been private, but now
      it is gone. Reading the \`displayBuffer\` property now returns a reference
      to the containing \`TextEditor\`, which now provides *some* of the API of
      the defunct \`DisplayBuffer\` class.\
    `);
    return this;
  }

  get languageMode() {
    return this.buffer.getLanguageMode();
  }

  get tokenizedBuffer() {
    return this.buffer.getLanguageMode();
  }

  get rowsPerPage() {
    return this.getRowsPerPage();
  }

  decorateCursorLine() {
    this.cursorLineDecorations = [
      this.decorateMarkerLayer(this.selectionsMarkerLayer, {
        type: 'line',
        class: 'cursor-line',
        onlyEmpty: true
      }),
      this.decorateMarkerLayer(this.selectionsMarkerLayer, {
        type: 'line-number',
        class: 'cursor-line'
      }),
      this.decorateMarkerLayer(this.selectionsMarkerLayer, {
        type: 'line-number',
        class: 'cursor-line-no-selection',
        onlyHead: true,
        onlyEmpty: true
      })
    ];
  }

  doBackgroundWork(deadline) {
    const previousLongestRow = this.getApproximateLongestScreenRow();
    if (this.displayLayer.doBackgroundWork(deadline)) {
      this.backgroundWorkHandle = requestIdleCallback(this.doBackgroundWork);
    } else {
      this.backgroundWorkHandle = null;
    }

    if (
      this.component &&
      this.getApproximateLongestScreenRow() !== previousLongestRow
    ) {
      this.component.scheduleUpdate();
    }
  }

  update(params) {
    const displayLayerParams = {};

    for (let param of Object.keys(params)) {
      const value = params[param];

      switch (param) {
        case 'autoIndent':
          this.updateAutoIndent(value, false);
          break;

        case 'autoIndentOnPaste':
          this.updateAutoIndentOnPaste(value, false);
          break;

        case 'undoGroupingInterval':
          this.updateUndoGroupingInterval(value, false);
          break;

        case 'scrollSensitivity':
          this.updateScrollSensitivity(value, false);
          break;

        case 'encoding':
          this.updateEncoding(value, false);
          break;

        case 'softTabs':
          this.updateSoftTabs(value, false);
          break;

        case 'atomicSoftTabs':
          this.updateAtomicSoftTabs(value, false, displayLayerParams);
          break;

        case 'tabLength':
          this.updateTabLength(value, false, displayLayerParams);
          break;

        case 'softWrapped':
          this.updateSoftWrapped(value, false, displayLayerParams);
          break;

        case 'softWrapHangingIndentLength':
          this.updateSoftWrapHangingIndentLength(
            value,
            false,
            displayLayerParams
          );
          break;

        case 'softWrapAtPreferredLineLength':
          this.updateSoftWrapAtPreferredLineLength(
            value,
            false,
            displayLayerParams
          );
          break;

        case 'preferredLineLength':
          this.updatePreferredLineLength(value, false, displayLayerParams);
          break;

        case 'maxScreenLineLength':
          this.updateMaxScreenLineLength(value, false, displayLayerParams);
          break;

        case 'mini':
          this.updateMini(value, false, displayLayerParams);
          break;

        case 'readOnly':
          this.updateReadOnly(value, false);
          break;

        case 'keyboardInputEnabled':
          this.updateKeyboardInputEnabled(value, false);
          break;

        case 'placeholderText':
          this.updatePlaceholderText(value, false);
          break;

        case 'lineNumberGutterVisible':
          this.updateLineNumberGutterVisible(value, false);
          break;

        case 'showIndentGuide':
          this.updateShowIndentGuide(value, false, displayLayerParams);
          break;

        case 'showLineNumbers':
          this.updateShowLineNumbers(value, false);
          break;

        case 'showInvisibles':
          this.updateShowInvisibles(value, false, displayLayerParams);
          break;

        case 'invisibles':
          this.updateInvisibles(value, false, displayLayerParams);
          break;

        case 'editorWidthInChars':
          this.updateEditorWidthInChars(value, false, displayLayerParams);
          break;

        case 'width':
          this.updateWidth(value, false, displayLayerParams);
          break;

        case 'scrollPastEnd':
          this.updateScrollPastEnd(value, false);
          break;

        case 'autoHeight':
          this.updateAutoHight(value, false);
          break;

        case 'autoWidth':
          this.updateAutoWidth(value, false);
          break;

        case 'showCursorOnSelection':
          this.updateShowCursorOnSelection(value, false);
          break;

        default:
          if (param !== 'ref' && param !== 'key') {
            throw new TypeError(`Invalid TextEditor parameter: '${param}'`);
          }
      }
    }

    return this.finishUpdate(displayLayerParams);
  }

  finishUpdate(displayLayerParams = {}) {
    this.displayLayer.reset(displayLayerParams);

    if (this.component) {
      return this.component.getNextUpdatePromise();
    } else {
      return Promise.resolve();
    }
  }

  updateAutoIndent(value, finish) {
    this.autoIndent = value;
    if (finish) this.finishUpdate();
  }

  updateAutoIndentOnPaste(value, finish) {
    this.autoIndentOnPaste = value;
    if (finish) this.finishUpdate();
  }

  updateUndoGroupingInterval(value, finish) {
    this.undoGroupingInterval = value;
    if (finish) this.finishUpdate();
  }

  updateScrollSensitivity(value, finish) {
    this.scrollSensitivity = value;
    if (finish) this.finishUpdate();
  }

  updateEncoding(value, finish) {
    this.buffer.setEncoding(value);
    if (finish) this.finishUpdate();
  }

  updateSoftTabs(value, finish) {
    if (value !== this.softTabs) {
      this.softTabs = value;
    }
    if (finish) this.finishUpdate();
  }

  updateAtomicSoftTabs(value, finish, displayLayerParams = {}) {
    if (value !== this.displayLayer.atomicSoftTabs) {
      displayLayerParams.atomicSoftTabs = value;
    }
    if (finish) this.finishUpdate(displayLayerParams);
  }

  updateTabLength(value, finish, displayLayerParams = {}) {
    if (value > 0 && value !== this.displayLayer.tabLength) {
      displayLayerParams.tabLength = value;
    }
    if (finish) this.finishUpdate(displayLayerParams);
  }

  updateSoftWrapped(value, finish, displayLayerParams = {}) {
    if (value !== this.softWrapped) {
      this.softWrapped = value;
      displayLayerParams.softWrapColumn = this.getSoftWrapColumn();
      this.emitter.emit('did-change-soft-wrapped', this.isSoftWrapped());
    }
    if (finish) this.finishUpdate(displayLayerParams);
  }

  updateSoftWrapHangingIndentLength(value, finish, displayLayerParams = {}) {
    if (value !== this.displayLayer.softWrapHangingIndent) {
      displayLayerParams.softWrapHangingIndent = value;
    }
    if (finish) this.finishUpdate(displayLayerParams);
  }

  updateSoftWrapAtPreferredLineLength(value, finish, displayLayerParams = {}) {
    if (value !== this.softWrapAtPreferredLineLength) {
      this.softWrapAtPreferredLineLength = value;
      displayLayerParams.softWrapColumn = this.getSoftWrapColumn();
    }
    if (finish) this.finishUpdate(displayLayerParams);
  }

  updatePreferredLineLength(value, finish, displayLayerParams = {}) {
    if (value !== this.preferredLineLength) {
      this.preferredLineLength = value;
      displayLayerParams.softWrapColumn = this.getSoftWrapColumn();
    }
    if (finish) this.finishUpdate(displayLayerParams);
  }

  updateMaxScreenLineLength(value, finish, displayLayerParams = {}) {
    if (value !== this.maxScreenLineLength) {
      this.maxScreenLineLength = value;
      displayLayerParams.softWrapColumn = this.getSoftWrapColumn();
    }
    if (finish) this.finishUpdate(displayLayerParams);
  }

  updateMini(value, finish, displayLayerParams = {}) {
    if (value !== this.mini) {
      this.mini = value;
      this.emitter.emit('did-change-mini', value);
      displayLayerParams.invisibles = this.getInvisibles();
      displayLayerParams.softWrapColumn = this.getSoftWrapColumn();
      displayLayerParams.showIndentGuides = this.doesShowIndentGuide();
      if (this.mini) {
        for (let decoration of this.cursorLineDecorations) {
          decoration.destroy();
        }
        this.cursorLineDecorations = null;
      } else {
        this.decorateCursorLine();
      }
      if (this.component != null) {
        this.component.scheduleUpdate();
      }
    }
    if (finish) this.finishUpdate(displayLayerParams);
  }

  updateReadOnly(value, finish) {
    if (value !== this.readOnly) {
      this.readOnly = value;
      if (this.component != null) {
        this.component.scheduleUpdate();
      }
    }
    if (finish) this.finishUpdate();
  }

  updateKeyboardInputEnabled(value, finish) {
    if (value !== this.keyboardInputEnabled) {
      this.keyboardInputEnabled = value;
      if (this.component != null) {
        this.component.scheduleUpdate();
      }
    }
    if (finish) this.finishUpdate();
  }

  updatePlaceholderText(value, finish) {
    if (value !== this.placeholderText) {
      this.placeholderText = value;
      this.emitter.emit('did-change-placeholder-text', value);
    }
    if (finish) this.finishUpdate();
  }

  updateLineNumberGutterVisible(value, finish) {
    if (value !== this.lineNumberGutterVisible) {
      if (value) {
        this.lineNumberGutter.show();
      } else {
        this.lineNumberGutter.hide();
      }
      this.emitter.emit(
        'did-change-line-number-gutter-visible',
        this.lineNumberGutter.isVisible()
      );
    }
    if (finish) this.finishUpdate();
  }

  updateShowIndentGuide(value, finish, displayLayerParams = {}) {
    if (value !== this.showIndentGuide) {
      this.showIndentGuide = value;
      displayLayerParams.showIndentGuides = this.doesShowIndentGuide();
    }
    if (finish) this.finishUpdate(displayLayerParams);
  }

  updateShowLineNumbers(value, finish) {
    if (value !== this.showLineNumbers) {
      this.showLineNumbers = value;
      if (this.component != null) {
        this.component.scheduleUpdate();
      }
    }
    if (finish) this.finishUpdate();
  }

  updateShowInvisibles(value, finish, displayLayerParams = {}) {
    if (value !== this.showInvisibles) {
      this.showInvisibles = value;
      displayLayerParams.invisibles = this.getInvisibles();
    }
    if (finish) this.finishUpdate(displayLayerParams);
  }

  updateInvisibles(value, finish, displayLayerParams = {}) {
    if (!_.isEqual(value, this.invisibles)) {
      this.invisibles = value;
      displayLayerParams.invisibles = this.getInvisibles();
    }
    if (finish) this.finishUpdate(displayLayerParams);
  }

  updateEditorWidthInChars(value, finish, displayLayerParams = {}) {
    if (value > 0 && value !== this.editorWidthInChars) {
      this.editorWidthInChars = value;
      displayLayerParams.softWrapColumn = this.getSoftWrapColumn();
    }
    if (finish) this.finishUpdate(displayLayerParams);
  }

  updateWidth(value, finish, displayLayerParams = {}) {
    if (value !== this.width) {
      this.width = value;
      displayLayerParams.softWrapColumn = this.getSoftWrapColumn();
    }
    if (finish) this.finishUpdate(displayLayerParams);
  }

  updateScrollPastEnd(value, finish) {
    if (value !== this.scrollPastEnd) {
      this.scrollPastEnd = value;
      if (this.component) this.component.scheduleUpdate();
    }
    if (finish) this.finishUpdate();
  }

  updateAutoHight(value, finish) {
    if (value !== this.autoHeight) {
      this.autoHeight = value;
    }
    if (finish) this.finishUpdate();
  }

  updateAutoWidth(value, finish) {
    if (value !== this.autoWidth) {
      this.autoWidth = value;
    }
    if (finish) this.finishUpdate();
  }

  updateShowCursorOnSelection(value, finish) {
    if (value !== this.showCursorOnSelection) {
      this.showCursorOnSelection = value;
      if (this.component) this.component.scheduleUpdate();
    }
    if (finish) this.finishUpdate();
  }

  scheduleComponentUpdate() {
    if (this.component) this.component.scheduleUpdate();
  }

  serialize() {
    return {
      deserializer: 'TextEditor',
      version: SERIALIZATION_VERSION,

      displayLayerId: this.displayLayer.id,
      selectionsMarkerLayerId: this.selectionsMarkerLayer.id,

      initialScrollTopRow: this.getScrollTopRow(),
      initialScrollLeftColumn: this.getScrollLeftColumn(),

      tabLength: this.displayLayer.tabLength,
      atomicSoftTabs: this.displayLayer.atomicSoftTabs,
      softWrapHangingIndentLength: this.displayLayer.softWrapHangingIndent,

      id: this.id,
      bufferId: this.buffer.id,
      softTabs: this.softTabs,
      softWrapped: this.softWrapped,
      softWrapAtPreferredLineLength: this.softWrapAtPreferredLineLength,
      preferredLineLength: this.preferredLineLength,
      mini: this.mini,
      readOnly2: this.readOnly, // readOnly encompassed both readOnly and keyboardInputEnabled
      keyboardInputEnabled: this.keyboardInputEnabled,
      editorWidthInChars: this.editorWidthInChars,
      width: this.width,
      maxScreenLineLength: this.maxScreenLineLength,
      registered: this.registered,
      invisibles: this.invisibles,
      showInvisibles: this.showInvisibles,
      showIndentGuide: this.showIndentGuide,
      autoHeight: this.autoHeight,
      autoWidth: this.autoWidth
    };
  }

  subscribeToBuffer() {
    this.buffer.retain();
    this.disposables.add(
      this.buffer.onDidChangeLanguageMode(
        this.handleLanguageModeChange.bind(this)
      )
    );
    this.disposables.add(
      this.buffer.onDidChangePath(() => {
        this.emitter.emit('did-change-title', this.getTitle());
        this.emitter.emit('did-change-path', this.getPath());
      })
    );
    this.disposables.add(
      this.buffer.onDidChangeEncoding(() => {
        this.emitter.emit('did-change-encoding', this.getEncoding());
      })
    );
    this.disposables.add(this.buffer.onDidDestroy(() => this.destroy()));
    this.disposables.add(
      this.buffer.onDidChangeModified(() => {
        if (!this.hasTerminatedPendingState && this.buffer.isModified())
          this.terminatePendingState();
      })
    );
  }

  terminatePendingState() {
    if (!this.hasTerminatedPendingState)
      this.emitter.emit('did-terminate-pending-state');
    this.hasTerminatedPendingState = true;
  }

  onDidTerminatePendingState(callback) {
    return this.emitter.on('did-terminate-pending-state', callback);
  }

  subscribeToDisplayLayer() {
    this.disposables.add(
      this.displayLayer.onDidChange(changes => {
        this.mergeIntersectingSelections();
        if (this.component) this.component.didChangeDisplayLayer(changes);
        this.emitter.emit(
          'did-change',
          changes.map(change => new ChangeEvent(change))
        );
      })
    );
    this.disposables.add(
      this.displayLayer.onDidReset(() => {
        this.mergeIntersectingSelections();
        if (this.component) this.component.didResetDisplayLayer();
        this.emitter.emit('did-change', {});
      })
    );
    this.disposables.add(
      this.selectionsMarkerLayer.onDidCreateMarker(this.addSelection.bind(this))
    );
    return this.disposables.add(
      this.selectionsMarkerLayer.onDidUpdate(() =>
        this.component != null
          ? this.component.didUpdateSelections()
          : undefined
      )
    );
  }

  destroy() {
    if (!this.alive) return;
    this.alive = false;
    this.disposables.dispose();
    this.displayLayer.destroy();
    for (let selection of this.selections.slice()) {
      selection.destroy();
    }
    this.buffer.release();
    this.gutterContainer.destroy();
    this.emitter.emit('did-destroy');
    this.emitter.clear();
    if (this.component) this.component.element.component = null;
    this.component = null;
    this.lineNumberGutter.element = null;
  }

  isAlive() {
    return this.alive;
  }

  isDestroyed() {
    return !this.alive;
  }

  /*
  Section: Event Subscription
  */

  // Essential: Calls your `callback` when the buffer's title has changed.
  //
  // * `callback` {Function}
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  onDidChangeTitle(callback) {
    return this.emitter.on('did-change-title', callback);
  }

  // Essential: Calls your `callback` when the buffer's path, and therefore title, has changed.
  //
  // * `callback` {Function}
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  onDidChangePath(callback) {
    return this.emitter.on('did-change-path', callback);
  }

  // Essential: Invoke the given callback synchronously when the content of the
  // buffer changes.
  //
  // Because observers are invoked synchronously, it's important not to perform
  // any expensive operations via this method. Consider {::onDidStopChanging} to
  // delay expensive operations until after changes stop occurring.
  //
  // * `callback` {Function}
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  onDidChange(callback) {
    return this.emitter.on('did-change', callback);
  }

  // Essential: Invoke `callback` when the buffer's contents change. It is
  // emit asynchronously 300ms after the last buffer change. This is a good place
  // to handle changes to the buffer without compromising typing performance.
  //
  // * `callback` {Function}
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  onDidStopChanging(callback) {
    return this.getBuffer().onDidStopChanging(callback);
  }

  // Essential: Calls your `callback` when a {Cursor} is moved. If there are
  // multiple cursors, your callback will be called for each cursor.
  //
  // * `callback` {Function}
  //   * `event` {Object}
  //     * `oldBufferPosition` {Point}
  //     * `oldScreenPosition` {Point}
  //     * `newBufferPosition` {Point}
  //     * `newScreenPosition` {Point}
  //     * `textChanged` {Boolean}
  //     * `cursor` {Cursor} that triggered the event
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  onDidChangeCursorPosition(callback) {
    return this.emitter.on('did-change-cursor-position', callback);
  }

  // Essential: Calls your `callback` when a selection's screen range changes.
  //
  // * `callback` {Function}
  //   * `event` {Object}
  //     * `oldBufferRange` {Range}
  //     * `oldScreenRange` {Range}
  //     * `newBufferRange` {Range}
  //     * `newScreenRange` {Range}
  //     * `selection` {Selection} that triggered the event
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  onDidChangeSelectionRange(callback) {
    return this.emitter.on('did-change-selection-range', callback);
  }

  // Extended: Calls your `callback` when soft wrap was enabled or disabled.
  //
  // * `callback` {Function}
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  onDidChangeSoftWrapped(callback) {
    return this.emitter.on('did-change-soft-wrapped', callback);
  }

  // Extended: Calls your `callback` when the buffer's encoding has changed.
  //
  // * `callback` {Function}
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  onDidChangeEncoding(callback) {
    return this.emitter.on('did-change-encoding', callback);
  }

  // Extended: Calls your `callback` when the grammar that interprets and
  // colorizes the text has been changed. Immediately calls your callback with
  // the current grammar.
  //
  // * `callback` {Function}
  //   * `grammar` {Grammar}
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  observeGrammar(callback) {
    callback(this.getGrammar());
    return this.onDidChangeGrammar(callback);
  }

  // Extended: Calls your `callback` when the grammar that interprets and
  // colorizes the text has been changed.
  //
  // * `callback` {Function}
  //   * `grammar` {Grammar}
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  onDidChangeGrammar(callback) {
    return this.buffer.onDidChangeLanguageMode(() => {
      callback(this.buffer.getLanguageMode().grammar);
    });
  }

  // Extended: Calls your `callback` when the result of {::isModified} changes.
  //
  // * `callback` {Function}
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  onDidChangeModified(callback) {
    return this.getBuffer().onDidChangeModified(callback);
  }

  // Extended: Calls your `callback` when the buffer's underlying file changes on
  // disk at a moment when the result of {::isModified} is true.
  //
  // * `callback` {Function}
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  onDidConflict(callback) {
    return this.getBuffer().onDidConflict(callback);
  }

  // Extended: Calls your `callback` before text has been inserted.
  //
  // * `callback` {Function}
  //   * `event` event {Object}
  //     * `text` {String} text to be inserted
  //     * `cancel` {Function} Call to prevent the text from being inserted
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  onWillInsertText(callback) {
    return this.emitter.on('will-insert-text', callback);
  }

  // Extended: Calls your `callback` after text has been inserted.
  //
  // * `callback` {Function}
  //   * `event` event {Object}
  //     * `text` {String} text to be inserted
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  onDidInsertText(callback) {
    return this.emitter.on('did-insert-text', callback);
  }

  // Essential: Invoke the given callback after the buffer is saved to disk.
  //
  // * `callback` {Function} to be called after the buffer is saved.
  //   * `event` {Object} with the following keys:
  //     * `path` The path to which the buffer was saved.
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  onDidSave(callback) {
    return this.getBuffer().onDidSave(callback);
  }

  // Essential: Invoke the given callback when the editor is destroyed.
  //
  // * `callback` {Function} to be called when the editor is destroyed.
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  onDidDestroy(callback) {
    return this.emitter.once('did-destroy', callback);
  }

  // Extended: Calls your `callback` when a {Cursor} is added to the editor.
  // Immediately calls your callback for each existing cursor.
  //
  // * `callback` {Function}
  //   * `cursor` {Cursor} that was added
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  observeCursors(callback) {
    this.getCursors().forEach(callback);
    return this.onDidAddCursor(callback);
  }

  // Extended: Calls your `callback` when a {Cursor} is added to the editor.
  //
  // * `callback` {Function}
  //   * `cursor` {Cursor} that was added
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  onDidAddCursor(callback) {
    return this.emitter.on('did-add-cursor', callback);
  }

  // Extended: Calls your `callback` when a {Cursor} is removed from the editor.
  //
  // * `callback` {Function}
  //   * `cursor` {Cursor} that was removed
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  onDidRemoveCursor(callback) {
    return this.emitter.on('did-remove-cursor', callback);
  }

  // Extended: Calls your `callback` when a {Selection} is added to the editor.
  // Immediately calls your callback for each existing selection.
  //
  // * `callback` {Function}
  //   * `selection` {Selection} that was added
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  observeSelections(callback) {
    this.getSelections().forEach(callback);
    return this.onDidAddSelection(callback);
  }

  // Extended: Calls your `callback` when a {Selection} is added to the editor.
  //
  // * `callback` {Function}
  //   * `selection` {Selection} that was added
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  onDidAddSelection(callback) {
    return this.emitter.on('did-add-selection', callback);
  }

  // Extended: Calls your `callback` when a {Selection} is removed from the editor.
  //
  // * `callback` {Function}
  //   * `selection` {Selection} that was removed
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  onDidRemoveSelection(callback) {
    return this.emitter.on('did-remove-selection', callback);
  }

  // Extended: Calls your `callback` with each {Decoration} added to the editor.
  // Calls your `callback` immediately for any existing decorations.
  //
  // * `callback` {Function}
  //   * `decoration` {Decoration}
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  observeDecorations(callback) {
    return this.decorationManager.observeDecorations(callback);
  }

  // Extended: Calls your `callback` when a {Decoration} is added to the editor.
  //
  // * `callback` {Function}
  //   * `decoration` {Decoration} that was added
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  onDidAddDecoration(callback) {
    return this.decorationManager.onDidAddDecoration(callback);
  }

  // Extended: Calls your `callback` when a {Decoration} is removed from the editor.
  //
  // * `callback` {Function}
  //   * `decoration` {Decoration} that was removed
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  onDidRemoveDecoration(callback) {
    return this.decorationManager.onDidRemoveDecoration(callback);
  }

  // Called by DecorationManager when a decoration is added.
  didAddDecoration(decoration) {
    if (this.component && decoration.isType('block')) {
      this.component.addBlockDecoration(decoration);
    }
  }

  // Extended: Calls your `callback` when the placeholder text is changed.
  //
  // * `callback` {Function}
  //   * `placeholderText` {String} new text
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  onDidChangePlaceholderText(callback) {
    return this.emitter.on('did-change-placeholder-text', callback);
  }

  onDidChangeScrollTop(callback) {
    Grim.deprecate(
      'This is now a view method. Call TextEditorElement::onDidChangeScrollTop instead.'
    );
    return this.getElement().onDidChangeScrollTop(callback);
  }

  onDidChangeScrollLeft(callback) {
    Grim.deprecate(
      'This is now a view method. Call TextEditorElement::onDidChangeScrollLeft instead.'
    );
    return this.getElement().onDidChangeScrollLeft(callback);
  }

  onDidRequestAutoscroll(callback) {
    return this.emitter.on('did-request-autoscroll', callback);
  }

  // TODO Remove once the tabs package no longer uses .on subscriptions
  onDidChangeIcon(callback) {
    return this.emitter.on('did-change-icon', callback);
  }

  onDidUpdateDecorations(callback) {
    return this.decorationManager.onDidUpdateDecorations(callback);
  }

  // Retrieves the current buffer's URI.
  getURI() {
    return this.buffer.getUri();
  }

  // Create an {TextEditor} with its initial state based on this object
  copy() {
    const displayLayer = this.displayLayer.copy();
    const selectionsMarkerLayer = displayLayer.getMarkerLayer(
      this.buffer.getMarkerLayer(this.selectionsMarkerLayer.id).copy().id
    );
    const softTabs = this.getSoftTabs();
    return new TextEditor({
      buffer: this.buffer,
      selectionsMarkerLayer,
      softTabs,
      suppressCursorCreation: true,
      tabLength: this.getTabLength(),
      initialScrollTopRow: this.getScrollTopRow(),
      initialScrollLeftColumn: this.getScrollLeftColumn(),
      assert: this.assert,
      displayLayer,
      grammar: this.getGrammar(),
      autoWidth: this.autoWidth,
      autoHeight: this.autoHeight,
      showCursorOnSelection: this.showCursorOnSelection
    });
  }

  // Controls visibility based on the given {Boolean}.
  setVisible(visible) {
    if (visible) {
      const languageMode = this.buffer.getLanguageMode();
      if (languageMode.startTokenizing) languageMode.startTokenizing();
    }
  }

  setMini(mini) {
    this.updateMini(mini, true);
  }

  isMini() {
    return this.mini;
  }

  setReadOnly(readOnly) {
    this.updateReadOnly(readOnly, true);
  }

  isReadOnly() {
    return this.readOnly;
  }

  enableKeyboardInput(enabled) {
    this.updateKeyboardInputEnabled(enabled, true);
  }

  isKeyboardInputEnabled() {
    return this.keyboardInputEnabled;
  }

  onDidChangeMini(callback) {
    return this.emitter.on('did-change-mini', callback);
  }

  setLineNumberGutterVisible(lineNumberGutterVisible) {
    this.updateLineNumberGutterVisible(lineNumberGutterVisible, true);
  }

  isLineNumberGutterVisible() {
    return this.lineNumberGutter.isVisible();
  }

  anyLineNumberGutterVisible() {
    return this.getGutters().some(
      gutter => gutter.type === 'line-number' && gutter.visible
    );
  }

  onDidChangeLineNumberGutterVisible(callback) {
    return this.emitter.on('did-change-line-number-gutter-visible', callback);
  }

  // Essential: Calls your `callback` when a {Gutter} is added to the editor.
  // Immediately calls your callback for each existing gutter.
  //
  // * `callback` {Function}
  //   * `gutter` {Gutter} that currently exists/was added.
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  observeGutters(callback) {
    return this.gutterContainer.observeGutters(callback);
  }

  // Essential: Calls your `callback` when a {Gutter} is added to the editor.
  //
  // * `callback` {Function}
  //   * `gutter` {Gutter} that was added.
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  onDidAddGutter(callback) {
    return this.gutterContainer.onDidAddGutter(callback);
  }

  // Essential: Calls your `callback` when a {Gutter} is removed from the editor.
  //
  // * `callback` {Function}
  //   * `name` The name of the {Gutter} that was removed.
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  onDidRemoveGutter(callback) {
    return this.gutterContainer.onDidRemoveGutter(callback);
  }

  // Set the number of characters that can be displayed horizontally in the
  // editor.
  //
  // * `editorWidthInChars` A {Number} representing the width of the
  // {TextEditorElement} in characters.
  setEditorWidthInChars(editorWidthInChars) {
    this.updateEditorWidthInChars(editorWidthInChars, true);
  }

  // Returns the editor width in characters.
  getEditorWidthInChars() {
    if (this.width != null && this.defaultCharWidth > 0) {
      return Math.max(0, Math.floor(this.width / this.defaultCharWidth));
    } else {
      return this.editorWidthInChars;
    }
  }

  /*
  Section: Buffer
  */

  // Essential: Retrieves the current {TextBuffer}.
  getBuffer() {
    return this.buffer;
  }

  /*
  Section: File Details
  */

  // Essential: Get the editor's title for display in other parts of the
  // UI such as the tabs.
  //
  // If the editor's buffer is saved, its title is the file name. If it is
  // unsaved, its title is "untitled".
  //
  // Returns a {String}.
  getTitle() {
    return this.getFileName() || 'untitled';
  }

  // Essential: Get unique title for display in other parts of the UI, such as
  // the window title.
  //
  // If the editor's buffer is unsaved, its title is "untitled"
  // If the editor's buffer is saved, its unique title is formatted as one
  // of the following,
  // * "<filename>" when it is the only editing buffer with this file name.
  // * "<filename> — <unique-dir-prefix>" when other buffers have this file name.
  //
  // Returns a {String}
  getLongTitle() {
    if (this.getPath()) {
      const fileName = this.getFileName();

      let myPathSegments;
      const openEditorPathSegmentsWithSameFilename = [];
      for (const textEditor of atom.workspace.getTextEditors()) {
        if (textEditor.getFileName() === fileName) {
          const pathSegments = fs
            .tildify(textEditor.getDirectoryPath())
            .split(path.sep);
          openEditorPathSegmentsWithSameFilename.push(pathSegments);
          if (textEditor === this) myPathSegments = pathSegments;
        }
      }

      if (
        !myPathSegments ||
        openEditorPathSegmentsWithSameFilename.length === 1
      )
        return fileName;

      let commonPathSegmentCount;
      for (let i = 0, { length } = myPathSegments; i < length; i++) {
        const myPathSegment = myPathSegments[i];
        if (
          openEditorPathSegmentsWithSameFilename.some(
            segments =>
              segments.length === i + 1 || segments[i] !== myPathSegment
          )
        ) {
          commonPathSegmentCount = i;
          break;
        }
      }

      return `${fileName} \u2014 ${path.join(
        ...myPathSegments.slice(commonPathSegmentCount)
      )}`;
    } else {
      return 'untitled';
    }
  }

  // Essential: Returns the {String} path of this editor's text buffer.
  getPath() {
    return this.buffer.getPath();
  }

  getFileName() {
    const fullPath = this.getPath();
    if (fullPath) return path.basename(fullPath);
  }

  getDirectoryPath() {
    const fullPath = this.getPath();
    if (fullPath) return path.dirname(fullPath);
  }

  // Extended: Returns the {String} character set encoding of this editor's text
  // buffer.
  getEncoding() {
    return this.buffer.getEncoding();
  }

  // Extended: Set the character set encoding to use in this editor's text
  // buffer.
  //
  // * `encoding` The {String} character set encoding name such as 'utf8'
  setEncoding(encoding) {
    this.buffer.setEncoding(encoding);
  }

  // Essential: Returns {Boolean} `true` if this editor has been modified.
  isModified() {
    return this.buffer.isModified();
  }

  // Essential: Returns {Boolean} `true` if this editor has no content.
  isEmpty() {
    return this.buffer.isEmpty();
  }

  /*
  Section: File Operations
  */

  // Essential: Saves the editor's text buffer.
  //
  // See {TextBuffer::save} for more details.
  save() {
    return this.buffer.save();
  }

  // Essential: Saves the editor's text buffer as the given path.
  //
  // See {TextBuffer::saveAs} for more details.
  //
  // * `filePath` A {String} path.
  saveAs(filePath) {
    return this.buffer.saveAs(filePath);
  }

  // Determine whether the user should be prompted to save before closing
  // this editor.
  shouldPromptToSave({ windowCloseRequested, projectHasPaths } = {}) {
    if (
      windowCloseRequested &&
      projectHasPaths &&
      atom.stateStore.isConnected()
    ) {
      return this.buffer.isInConflict();
    } else {
      return this.isModified() && !this.buffer.hasMultipleEditors();
    }
  }

  // Returns an {Object} to configure dialog shown when this editor is saved
  // via {Pane::saveItemAs}.
  getSaveDialogOptions() {
    return {};
  }

  /*
  Section: Reading Text
  */

  // Essential: Returns a {String} representing the entire contents of the editor.
  getText() {
    return this.buffer.getText();
  }

  // Essential: Get the text in the given {Range} in buffer coordinates.
  //
  // * `range` A {Range} or range-compatible {Array}.
  //
  // Returns a {String}.
  getTextInBufferRange(range) {
    return this.buffer.getTextInRange(range);
  }

  // Essential: Returns a {Number} representing the number of lines in the buffer.
  getLineCount() {
    return this.buffer.getLineCount();
  }

  // Essential: Returns a {Number} representing the number of screen lines in the
  // editor. This accounts for folds.
  getScreenLineCount() {
    return this.displayLayer.getScreenLineCount();
  }

  getApproximateScreenLineCount() {
    return this.displayLayer.getApproximateScreenLineCount();
  }

  // Essential: Returns a {Number} representing the last zero-indexed buffer row
  // number of the editor.
  getLastBufferRow() {
    return this.buffer.getLastRow();
  }

  // Essential: Returns a {Number} representing the last zero-indexed screen row
  // number of the editor.
  getLastScreenRow() {
    return this.getScreenLineCount() - 1;
  }

  // Essential: Returns a {String} representing the contents of the line at the
  // given buffer row.
  //
  // * `bufferRow` A {Number} representing a zero-indexed buffer row.
  lineTextForBufferRow(bufferRow) {
    return this.buffer.lineForRow(bufferRow);
  }

  // Essential: Returns a {String} representing the contents of the line at the
  // given screen row.
  //
  // * `screenRow` A {Number} representing a zero-indexed screen row.
  lineTextForScreenRow(screenRow) {
    const screenLine = this.screenLineForScreenRow(screenRow);
    if (screenLine) return screenLine.lineText;
  }

  logScreenLines(start = 0, end = this.getLastScreenRow()) {
    for (let row = start; row <= end; row++) {
      const line = this.lineTextForScreenRow(row);
      console.log(row, this.bufferRowForScreenRow(row), line, line.length);
    }
  }

  tokensForScreenRow(screenRow) {
    const tokens = [];
    let lineTextIndex = 0;
    const currentTokenScopes = [];
    const { lineText, tags } = this.screenLineForScreenRow(screenRow);
    for (const tag of tags) {
      if (this.displayLayer.isOpenTag(tag)) {
        currentTokenScopes.push(this.displayLayer.classNameForTag(tag));
      } else if (this.displayLayer.isCloseTag(tag)) {
        currentTokenScopes.pop();
      } else if (tag === 0) {
        // `tag` is not a tag, but rather a description of the number of
        // characters until the next boundary. In unusual circumstances, `0`
        // may be emitted here, but that's just an indication that we can
        // safely ignore this “tag,” because the next boundary will be at the
        // same position.
        continue;
      } else {
        tokens.push({
          text: lineText.substr(lineTextIndex, tag),
          scopes: currentTokenScopes.slice()
        });
        lineTextIndex += tag;
      }
    }
    return tokens;
  }

  screenLineForScreenRow(screenRow) {
    return this.displayLayer.getScreenLine(screenRow);
  }

  bufferRowForScreenRow(screenRow) {
    return this.displayLayer.translateScreenPosition(Point(screenRow, 0)).row;
  }

  bufferRowsForScreenRows(startScreenRow, endScreenRow) {
    return this.displayLayer.bufferRowsForScreenRows(
      startScreenRow,
      endScreenRow + 1
    );
  }

  screenRowForBufferRow(row) {
    return this.displayLayer.translateBufferPosition(Point(row, 0)).row;
  }

  getRightmostScreenPosition() {
    return this.displayLayer.getRightmostScreenPosition();
  }

  getApproximateRightmostScreenPosition() {
    return this.displayLayer.getApproximateRightmostScreenPosition();
  }

  getMaxScreenLineLength() {
    return this.getRightmostScreenPosition().column;
  }

  getLongestScreenRow() {
    return this.getRightmostScreenPosition().row;
  }

  getApproximateLongestScreenRow() {
    return this.getApproximateRightmostScreenPosition().row;
  }

  lineLengthForScreenRow(screenRow) {
    return this.displayLayer.lineLengthForScreenRow(screenRow);
  }

  // Returns the range for the given buffer row.
  //
  // * `row` A row {Number}.
  // * `options` (optional) An options hash with an `includeNewline` key.
  //
  // Returns a {Range}.
  bufferRangeForBufferRow(row, options) {
    return this.buffer.rangeForRow(row, options && options.includeNewline);
  }

  // Get the text in the given {Range}.
  //
  // Returns a {String}.
  getTextInRange(range) {
    return this.buffer.getTextInRange(range);
  }

  // {Delegates to: TextBuffer.isRowBlank}
  isBufferRowBlank(bufferRow) {
    return this.buffer.isRowBlank(bufferRow);
  }

  // {Delegates to: TextBuffer.nextNonBlankRow}
  nextNonBlankBufferRow(bufferRow) {
    return this.buffer.nextNonBlankRow(bufferRow);
  }

  // {Delegates to: TextBuffer.getEndPosition}
  getEofBufferPosition() {
    return this.buffer.getEndPosition();
  }

  // Essential: Get the {Range} of the paragraph surrounding the most recently added
  // cursor.
  //
  // Returns a {Range}.
  getCurrentParagraphBufferRange() {
    return this.getLastCursor().getCurrentParagraphBufferRange();
  }

  /*
  Section: Mutating Text
  */

  // Essential: Replaces the entire contents of the buffer with the given {String}.
  //
  // * `text` A {String} to replace with
  // * `options` (optional) {Object}
  //   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify a read-only editor.
  setText(text, options = {}) {
    if (!this.ensureWritable('setText', options)) return;
    return this.buffer.setText(text);
  }

  // Essential: Set the text in the given {Range} in buffer coordinates.
  //
  // * `range` A {Range} or range-compatible {Array}.
  // * `text` A {String}
  // * `options` (optional) {Object}
  //   * `normalizeLineEndings` (optional) {Boolean} (default: true)
  //   * `undo` (optional) *Deprecated* {String} 'skip' will skip the undo system. This property is deprecated. Call groupLastChanges() on the {TextBuffer} afterward instead.
  //   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify a read-only editor. (default: false)
  //
  // Returns the {Range} of the newly-inserted text.
  setTextInBufferRange(range, text, options = {}) {
    if (!this.ensureWritable('setTextInBufferRange', options)) return;
    return this.getBuffer().setTextInRange(range, text, options);
  }

  // Essential: For each selection, replace the selected text with the given text.
  //
  // * `text` A {String} representing the text to insert.
  // * `options` (optional) See {Selection::insertText}.
  //
  // Returns a {Range} when the text has been inserted. Returns a {Boolean} `false` when the text
  // has not been inserted.
  insertText(text, options = {}) {
    if (!this.ensureWritable('insertText', options)) return;
    if (!this.emitWillInsertTextEvent(text)) return false;

    let groupLastChanges = false;
    if (options.undo === 'skip') {
      options = Object.assign({}, options);
      delete options.undo;
      groupLastChanges = true;
    }

    const groupingInterval = options.groupUndo ? this.undoGroupingInterval : 0;
    if (options.autoIndentNewline == null)
      options.autoIndentNewline = this.shouldAutoIndent();
    if (options.autoDecreaseIndent == null)
      options.autoDecreaseIndent = this.shouldAutoIndent();
    const result = this.mutateSelectedText(selection => {
      const range = selection.insertText(text, options);
      const didInsertEvent = { text, range };
      this.emitter.emit('did-insert-text', didInsertEvent);
      return range;
    }, groupingInterval);
    if (groupLastChanges) this.buffer.groupLastChanges();

    if (options.autoIndent || options.autoIndentNewline || options.autoDecreaseIndent) {
      this.scheduleIndentAdjustment();
    }
    return result;
  }

  // Essential: For each selection, replace the selected text with a newline.
  //
  // * `options` (optional) {Object}
  //   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify a read-only editor. (default: false)
  insertNewline(options = {}) {
    return this.insertText('\n', options);
  }

  // Essential: For each selection, if the selection is empty, delete the character
  // following the cursor. Otherwise delete the selected text.
  //
  // * `options` (optional) {Object}
  //   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify a read-only editor. (default: false)
  delete(options = {}) {
    if (!this.ensureWritable('delete', options)) return;
    return this.mutateSelectedText(selection => selection.delete(options));
  }

  // Essential: For each selection, if the selection is empty, delete the character
  // preceding the cursor. Otherwise delete the selected text.
  //
  // * `options` (optional) {Object}
  //   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify a read-only editor. (default: false)
  backspace(options = {}) {
    if (!this.ensureWritable('backspace', options)) return;
    return this.mutateSelectedText(selection => selection.backspace(options));
  }

  // Extended: Mutate the text of all the selections in a single transaction.
  //
  // All the changes made inside the given {Function} can be reverted with a
  // single call to {::undo}.
  //
  // * `fn` A {Function} that will be called once for each {Selection}. The first
  //      argument will be a {Selection} and the second argument will be the
  //      {Number} index of that selection.
  mutateSelectedText(fn, groupingInterval = 0) {
    return this.mergeIntersectingSelections(() => {
      return this.transact(groupingInterval, () => {
        return this.getSelectionsOrderedByBufferPosition().map(
          (selection, index) => fn(selection, index)
        );
      });
    });
  }

  // Move lines intersecting the most recent selection or multiple selections
  // up by one row in screen coordinates.
  //
  // * `options` (optional) {Object}
  //   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify a read-only editor. (default: false)
  moveLineUp(options = {}) {
    if (!this.ensureWritable('moveLineUp', options)) return;

    const selections = this.getSelectedBufferRanges().sort((a, b) =>
      a.compare(b)
    );

    if (selections[0].start.row === 0) return;
    if (
      selections[selections.length - 1].start.row === this.getLastBufferRow() &&
      this.buffer.getLastLine() === ''
    )
      return;

    this.transact(() => {
      const newSelectionRanges = [];

      while (selections.length > 0) {
        // Find selections spanning a contiguous set of lines
        const selection = selections.shift();
        const selectionsToMove = [selection];

        while (
          selection.end.row ===
          (selections[0] != null ? selections[0].start.row : undefined)
        ) {
          selectionsToMove.push(selections[0]);
          selection.end.row = selections[0].end.row;
          selections.shift();
        }

        // Compute the buffer range spanned by all these selections, expanding it
        // so that it includes any folded region that intersects them.
        let startRow = selection.start.row;
        let endRow = selection.end.row;
        if (
          selection.end.row > selection.start.row &&
          selection.end.column === 0
        ) {
          // Don't move the last line of a multi-line selection if the selection ends at column 0
          endRow--;
        }

        startRow = this.displayLayer.findBoundaryPrecedingBufferRow(startRow);
        endRow = this.displayLayer.findBoundaryFollowingBufferRow(endRow + 1);
        const linesRange = new Range(Point(startRow, 0), Point(endRow, 0));

        // If selected line range is preceded by a fold, one line above on screen
        // could be multiple lines in the buffer.
        const precedingRow = this.displayLayer.findBoundaryPrecedingBufferRow(
          startRow - 1
        );
        const insertDelta = linesRange.start.row - precedingRow;

        // Any folds in the text that is moved will need to be re-created.
        // It includes the folds that were intersecting with the selection.
        const rangesToRefold = this.displayLayer
          .destroyFoldsIntersectingBufferRange(linesRange)
          .map(range => range.translate([-insertDelta, 0]));

        // Delete lines spanned by selection and insert them on the preceding buffer row
        let lines = this.buffer.getTextInRange(linesRange);
        if (lines[lines.length - 1] !== '\n') {
          lines += this.buffer.lineEndingForRow(linesRange.end.row - 2);
        }
        this.buffer.delete(linesRange);
        this.buffer.insert([precedingRow, 0], lines);

        // Restore folds that existed before the lines were moved
        for (let rangeToRefold of rangesToRefold) {
          this.displayLayer.foldBufferRange(rangeToRefold);
        }

        for (const selectionToMove of selectionsToMove) {
          newSelectionRanges.push(selectionToMove.translate([-insertDelta, 0]));
        }
      }

      this.setSelectedBufferRanges(newSelectionRanges, {
        autoscroll: false,
        preserveFolds: true
      });
      if (this.shouldAutoIndent()) this.autoIndentSelectedRows();
      this.scrollToBufferPosition([newSelectionRanges[0].start.row, 0]);
    });
  }

  // Move lines intersecting the most recent selection or multiple selections
  // down by one row in screen coordinates.
  //
  // * `options` (optional) {Object}
  //   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify a read-only editor. (default: false)
  moveLineDown(options = {}) {
    if (!this.ensureWritable('moveLineDown', options)) return;

    const selections = this.getSelectedBufferRanges();
    selections.sort((a, b) => b.compare(a));

    this.transact(() => {
      this.consolidateSelections();
      const newSelectionRanges = [];

      while (selections.length > 0) {
        // Find selections spanning a contiguous set of lines
        const selection = selections.shift();
        const selectionsToMove = [selection];

        // if the current selection start row matches the next selections' end row - make them one selection
        while (
          selection.start.row ===
          (selections[0] != null ? selections[0].end.row : undefined)
        ) {
          selectionsToMove.push(selections[0]);
          selection.start.row = selections[0].start.row;
          selections.shift();
        }

        // Compute the buffer range spanned by all these selections, expanding it
        // so that it includes any folded region that intersects them.
        let startRow = selection.start.row;
        let endRow = selection.end.row;
        if (
          selection.end.row > selection.start.row &&
          selection.end.column === 0
        ) {
          // Don't move the last line of a multi-line selection if the selection ends at column 0
          endRow--;
        }

        startRow = this.displayLayer.findBoundaryPrecedingBufferRow(startRow);
        endRow = this.displayLayer.findBoundaryFollowingBufferRow(endRow + 1);
        const linesRange = new Range(Point(startRow, 0), Point(endRow, 0));

        // If selected line range is followed by a fold, one line below on screen
        // could be multiple lines in the buffer. But at the same time, if the
        // next buffer row is wrapped, one line in the buffer can represent many
        // screen rows.
        const followingRow = Math.min(
          this.buffer.getLineCount(),
          this.displayLayer.findBoundaryFollowingBufferRow(endRow + 1)
        );
        const insertDelta = followingRow - linesRange.end.row;

        // Any folds in the text that is moved will need to be re-created.
        // It includes the folds that were intersecting with the selection.
        const rangesToRefold = this.displayLayer
          .destroyFoldsIntersectingBufferRange(linesRange)
          .map(range => range.translate([insertDelta, 0]));

        // Delete lines spanned by selection and insert them on the following correct buffer row
        let lines = this.buffer.getTextInRange(linesRange);
        if (followingRow - 1 === this.buffer.getLastRow()) {
          lines = `\n${lines}`;
        }

        this.buffer.insert([followingRow, 0], lines);
        this.buffer.delete(linesRange);

        // Restore folds that existed before the lines were moved
        for (let rangeToRefold of rangesToRefold) {
          this.displayLayer.foldBufferRange(rangeToRefold);
        }

        for (const selectionToMove of selectionsToMove) {
          newSelectionRanges.push(selectionToMove.translate([insertDelta, 0]));
        }
      }

      this.setSelectedBufferRanges(newSelectionRanges, {
        autoscroll: false,
        preserveFolds: true
      });
      if (this.shouldAutoIndent()) this.autoIndentSelectedRows();
      this.scrollToBufferPosition([newSelectionRanges[0].start.row - 1, 0]);
    });
  }

  // Move any active selections one column to the left.
  //
  // * `options` (optional) {Object}
  //   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify a read-only editor. (default: false)
  moveSelectionLeft(options = {}) {
    if (!this.ensureWritable('moveSelectionLeft', options)) return;
    const selections = this.getSelectedBufferRanges();
    const noSelectionAtStartOfLine = selections.every(
      selection => selection.start.column !== 0
    );

    const translationDelta = [0, -1];
    const translatedRanges = [];

    if (noSelectionAtStartOfLine) {
      this.transact(() => {
        for (let selection of selections) {
          const charToLeftOfSelection = new Range(
            selection.start.translate(translationDelta),
            selection.start
          );
          const charTextToLeftOfSelection = this.buffer.getTextInRange(
            charToLeftOfSelection
          );

          this.buffer.insert(selection.end, charTextToLeftOfSelection);
          this.buffer.delete(charToLeftOfSelection);
          translatedRanges.push(selection.translate(translationDelta));
        }

        this.setSelectedBufferRanges(translatedRanges);
      });
    }
  }

  // Move any active selections one column to the right.
  //
  // * `options` (optional) {Object}
  //   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify a read-only editor. (default: false)
  moveSelectionRight(options = {}) {
    if (!this.ensureWritable('moveSelectionRight', options)) return;
    const selections = this.getSelectedBufferRanges();
    const noSelectionAtEndOfLine = selections.every(selection => {
      return (
        selection.end.column !== this.buffer.lineLengthForRow(selection.end.row)
      );
    });

    const translationDelta = [0, 1];
    const translatedRanges = [];

    if (noSelectionAtEndOfLine) {
      this.transact(() => {
        for (let selection of selections) {
          const charToRightOfSelection = new Range(
            selection.end,
            selection.end.translate(translationDelta)
          );
          const charTextToRightOfSelection = this.buffer.getTextInRange(
            charToRightOfSelection
          );

          this.buffer.delete(charToRightOfSelection);
          this.buffer.insert(selection.start, charTextToRightOfSelection);
          translatedRanges.push(selection.translate(translationDelta));
        }

        this.setSelectedBufferRanges(translatedRanges);
      });
    }
  }

  // Duplicate all lines containing active selections.
  //
  // * `options` (optional) {Object}
  //   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify a read-only editor. (default: false)
  duplicateLines(options = {}) {
    if (!this.ensureWritable('duplicateLines', options)) return;
    this.transact(() => {
      const selections = this.getSelectionsOrderedByBufferPosition();
      const previousSelectionRanges = [];

      let i = selections.length - 1;
      while (i >= 0) {
        const j = i;
        previousSelectionRanges[i] = selections[i].getBufferRange();
        if (selections[i].isEmpty()) {
          const { start } = selections[i].getScreenRange();
          selections[i].setScreenRange([[start.row, 0], [start.row + 1, 0]], {
            preserveFolds: true
          });
        }
        let [startRow, endRow] = selections[i].getBufferRowRange();
        endRow++;
        while (i > 0) {
          const [
            previousSelectionStartRow,
            previousSelectionEndRow
          ] = selections[i - 1].getBufferRowRange();
          if (previousSelectionEndRow === startRow) {
            startRow = previousSelectionStartRow;
            previousSelectionRanges[i - 1] = selections[i - 1].getBufferRange();
            i--;
          } else {
            break;
          }
        }

        const intersectingFolds = this.displayLayer.foldsIntersectingBufferRange(
          [[startRow, 0], [endRow, 0]]
        );
        let textToDuplicate = this.getTextInBufferRange([
          [startRow, 0],
          [endRow, 0]
        ]);
        if (endRow > this.getLastBufferRow())
          textToDuplicate = `\n${textToDuplicate}`;
        this.buffer.insert([endRow, 0], textToDuplicate);

        const insertedRowCount = endRow - startRow;

        for (let k = i; k <= j; k++) {
          selections[k].setBufferRange(
            previousSelectionRanges[k].translate([insertedRowCount, 0])
          );
        }

        for (const fold of intersectingFolds) {
          const foldRange = this.displayLayer.bufferRangeForFold(fold);
          this.displayLayer.foldBufferRange(
            foldRange.translate([insertedRowCount, 0])
          );
        }

        i--;
      }
    });
  }

  replaceSelectedText(options, fn) {
    this.mutateSelectedText(selection => {
      selection.getBufferRange();
      if (options && options.selectWordIfEmpty && selection.isEmpty()) {
        selection.selectWord();
      }
      const text = selection.getText();
      selection.deleteSelectedText();
      const range = selection.insertText(fn(text));
      selection.setBufferRange(range);
    });
  }

  // Split multi-line selections into one selection per line.
  //
  // Operates on all selections. This method breaks apart all multi-line
  // selections to create multiple single-line selections that cumulatively cover
  // the same original area.
  splitSelectionsIntoLines() {
    this.mergeIntersectingSelections(() => {
      for (const selection of this.getSelections()) {
        const range = selection.getBufferRange();
        if (range.isSingleLine()) continue;

        const { start, end } = range;
        this.addSelectionForBufferRange([start, [start.row, Infinity]]);
        let { row } = start;
        while (++row < end.row) {
          this.addSelectionForBufferRange([[row, 0], [row, Infinity]]);
        }
        if (end.column !== 0)
          this.addSelectionForBufferRange([
            [end.row, 0],
            [end.row, end.column]
          ]);
        selection.destroy();
      }
    });
  }

  // Extended: For each selection, transpose the selected text.
  //
  // If the selection is empty, the characters preceding and following the cursor
  // are swapped. Otherwise, the selected characters are reversed.
  //
  // * `options` (optional) {Object}
  //   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify a read-only editor. (default: false)
  transpose(options = {}) {
    if (!this.ensureWritable('transpose', options)) return;
    this.mutateSelectedText(selection => {
      if (selection.isEmpty()) {
        selection.selectRight();
        const text = selection.getText();
        selection.delete();
        selection.cursor.moveLeft();
        selection.insertText(text);
      } else {
        selection.insertText(
          selection
            .getText()
            .split('')
            .reverse()
            .join('')
        );
      }
    });
  }

  // Extended: Convert the selected text to upper case.
  //
  // For each selection, if the selection is empty, converts the containing word
  // to upper case. Otherwise convert the selected text to upper case.
  //
  // * `options` (optional) {Object}
  //   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify a read-only editor. (default: false)
  upperCase(options = {}) {
    if (!this.ensureWritable('upperCase', options)) return;
    this.replaceSelectedText({ selectWordIfEmpty: true }, text =>
      text.toUpperCase(options)
    );
  }

  // Extended: Convert the selected text to lower case.
  //
  // For each selection, if the selection is empty, converts the containing word
  // to upper case. Otherwise convert the selected text to upper case.
  //
  // * `options` (optional) {Object}
  //   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify a read-only editor. (default: false)
  lowerCase(options = {}) {
    if (!this.ensureWritable('lowerCase', options)) return;
    this.replaceSelectedText({ selectWordIfEmpty: true }, text =>
      text.toLowerCase(options)
    );
  }

  // Extended: Toggle line comments for rows intersecting selections.
  //
  // If the current grammar doesn't support comments, does nothing.
  //
  // * `options` (optional) {Object}
  //   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify a read-only editor. (default: false)
  toggleLineCommentsInSelection(options = {}) {
    if (!this.ensureWritable('toggleLineCommentsInSelection', options)) return;
    this.mutateSelectedText(selection => selection.toggleLineComments(options));
  }

  // Convert multiple lines to a single line.
  //
  // Operates on all selections. If the selection is empty, joins the current
  // line with the next line. Otherwise it joins all lines that intersect the
  // selection.
  //
  // Joining a line means that multiple lines are converted to a single line with
  // the contents of each of the original non-empty lines separated by a space.
  //
  // * `options` (optional) {Object}
  //   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify a read-only editor. (default: false)
  joinLines(options = {}) {
    if (!this.ensureWritable('joinLines', options)) return;
    this.mutateSelectedText(selection => selection.joinLines());
  }

  // Extended: For each cursor, insert a newline at beginning the following line.
  //
  // * `options` (optional) {Object}
  //   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify a read-only editor. (default: false)
  insertNewlineBelow(options = {}) {
    if (!this.ensureWritable('insertNewlineBelow', options)) return;
    this.transact(() => {
      this.moveToEndOfLine();
      this.insertNewline(options);
    });
  }

  // Extended: For each cursor, insert a newline at the end of the preceding line.
  //
  // * `options` (optional) {Object}
  //   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify a read-only editor. (default: false)
  insertNewlineAbove(options = {}) {
    if (!this.ensureWritable('insertNewlineAbove', options)) return;
    this.transact(() => {
      const bufferRow = this.getCursorBufferPosition().row;
      const indentLevel = this.indentationForBufferRow(bufferRow);
      const onFirstLine = bufferRow === 0;

      this.moveToBeginningOfLine();
      this.moveLeft();
      this.insertNewline(options);

      if (
        this.shouldAutoIndent() &&
        this.indentationForBufferRow(bufferRow) < indentLevel
      ) {
        this.setIndentationForBufferRow(bufferRow, indentLevel);
      }

      if (onFirstLine) {
        this.moveUp();
        this.moveToEndOfLine();
      }
    });
  }

  // Extended: For each selection, if the selection is empty, delete all characters
  // of the containing word that precede the cursor. Otherwise delete the
  // selected text.
  //
  // * `options` (optional) {Object}
  //   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify a read-only editor. (default: false)
  deleteToBeginningOfWord(options = {}) {
    if (!this.ensureWritable('deleteToBeginningOfWord', options)) return;
    this.mutateSelectedText(selection =>
      selection.deleteToBeginningOfWord(options)
    );
  }

  // Extended: Similar to {::deleteToBeginningOfWord}, but deletes only back to the
  // previous word boundary.
  //
  // * `options` (optional) {Object}
  //   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify a read-only editor. (default: false)
  deleteToPreviousWordBoundary(options = {}) {
    if (!this.ensureWritable('deleteToPreviousWordBoundary', options)) return;
    this.mutateSelectedText(selection =>
      selection.deleteToPreviousWordBoundary(options)
    );
  }

  // Extended: Similar to {::deleteToEndOfWord}, but deletes only up to the
  // next word boundary.
  //
  // * `options` (optional) {Object}
  //   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify a read-only editor. (default: false)
  deleteToNextWordBoundary(options = {}) {
    if (!this.ensureWritable('deleteToNextWordBoundary', options)) return;
    this.mutateSelectedText(selection =>
      selection.deleteToNextWordBoundary(options)
    );
  }

  // Extended: For each selection, if the selection is empty, delete all characters
  // of the containing subword following the cursor. Otherwise delete the selected
  // text.
  //
  // * `options` (optional) {Object}
  //   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify a read-only editor. (default: false)
  deleteToBeginningOfSubword(options = {}) {
    if (!this.ensureWritable('deleteToBeginningOfSubword', options)) return;
    this.mutateSelectedText(selection =>
      selection.deleteToBeginningOfSubword(options)
    );
  }

  // Extended: For each selection, if the selection is empty, delete all characters
  // of the containing subword following the cursor. Otherwise delete the selected
  // text.
  //
  // * `options` (optional) {Object}
  //   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify a read-only editor. (default: false)
  deleteToEndOfSubword(options = {}) {
    if (!this.ensureWritable('deleteToEndOfSubword', options)) return;
    this.mutateSelectedText(selection =>
      selection.deleteToEndOfSubword(options)
    );
  }

  // Extended: For each selection, if the selection is empty, delete all characters
  // of the containing line that precede the cursor. Otherwise delete the
  // selected text.
  //
  // * `options` (optional) {Object}
  //   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify a read-only editor. (default: false)
  deleteToBeginningOfLine(options = {}) {
    if (!this.ensureWritable('deleteToBeginningOfLine', options)) return;
    this.mutateSelectedText(selection =>
      selection.deleteToBeginningOfLine(options)
    );
  }

  // Extended: For each selection, if the selection is not empty, deletes the
  // selection; otherwise, deletes all characters of the containing line
  // following the cursor. If the cursor is already at the end of the line,
  // deletes the following newline.
  //
  // * `options` (optional) {Object}
  //   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify a read-only editor. (default: false)
  deleteToEndOfLine(options = {}) {
    if (!this.ensureWritable('deleteToEndOfLine', options)) return;
    this.mutateSelectedText(selection => selection.deleteToEndOfLine(options));
  }

  // Extended: For each selection, if the selection is empty, delete all characters
  // of the containing word following the cursor. Otherwise delete the selected
  // text.
  //
  // * `options` (optional) {Object}
  //   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify a read-only editor. (default: false)
  deleteToEndOfWord(options = {}) {
    if (!this.ensureWritable('deleteToEndOfWord', options)) return;
    this.mutateSelectedText(selection => selection.deleteToEndOfWord(options));
  }

  // Extended: Delete all lines intersecting selections.
  //
  // * `options` (optional) {Object}
  //   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify a read-only editor. (default: false)
  deleteLine(options = {}) {
    if (!this.ensureWritable('deleteLine', options)) return;
    this.mergeSelectionsOnSameRows();
    this.mutateSelectedText(selection => selection.deleteLine(options));
  }

  // Private: Ensure that this editor is not marked read-only before allowing a buffer modification to occur. If
  // the editor is read-only, require an explicit opt-in option to proceed (`bypassReadOnly`) or throw an Error.
  ensureWritable(methodName, opts) {
    if (!opts.bypassReadOnly && this.isReadOnly()) {
      if (atom.inDevMode() || atom.inSpecMode()) {
        const e = new Error('Attempt to mutate a read-only TextEditor');
        e.detail =
          `Your package is attempting to call ${methodName} on an editor that has been marked read-only. ` +
          'Pass {bypassReadOnly: true} to modify it anyway, or test editors with .isReadOnly() before attempting ' +
          'modifications.';
        throw e;
      }

      return false;
    }

    return true;
  }

  /*
  Section: History
  */

  // Essential: Undo the last change.
  //
  // * `options` (optional) {Object}
  //   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify a read-only editor. (default: false)
  undo(options = {}) {
    if (!this.ensureWritable('undo', options)) return;
    this.avoidMergingSelections(() =>
      this.buffer.undo({ selectionsMarkerLayer: this.selectionsMarkerLayer })
    );
    this.getLastSelection().autoscroll();
  }

  // Essential: Redo the last change.
  //
  // * `options` (optional) {Object}
  //   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify a read-only editor. (default: false)
  redo(options = {}) {
    if (!this.ensureWritable('redo', options)) return;
    this.avoidMergingSelections(() =>
      this.buffer.redo({ selectionsMarkerLayer: this.selectionsMarkerLayer })
    );
    this.getLastSelection().autoscroll();
  }

  // Extended: Batch multiple operations as a single undo/redo step.
  //
  // Any group of operations that are logically grouped from the perspective of
  // undoing and redoing should be performed in a transaction. If you want to
  // abort the transaction, call {::abortTransaction} to terminate the function's
  // execution and revert any changes performed up to the abortion.
  //
  // * `groupingInterval` (optional) The {Number} of milliseconds for which this
  //   transaction should be considered 'groupable' after it begins. If a transaction
  //   with a positive `groupingInterval` is committed while the previous transaction is
  //   still 'groupable', the two transactions are merged with respect to undo and redo.
  // * `fn` A {Function} to call inside the transaction.
  transact(groupingInterval, fn) {
    const options = { selectionsMarkerLayer: this.selectionsMarkerLayer };
    if (typeof groupingInterval === 'function') {
      fn = groupingInterval;
    } else {
      options.groupingInterval = groupingInterval;
    }
    return this.buffer.transact(options, fn);
  }

  // Extended: Abort an open transaction, undoing any operations performed so far
  // within the transaction.
  abortTransaction() {
    return this.buffer.abortTransaction();
  }

  // Extended: Create a pointer to the current state of the buffer for use
  // with {::revertToCheckpoint} and {::groupChangesSinceCheckpoint}.
  //
  // Returns a checkpoint value.
  createCheckpoint() {
    return this.buffer.createCheckpoint({
      selectionsMarkerLayer: this.selectionsMarkerLayer
    });
  }

  // Extended: Revert the buffer to the state it was in when the given
  // checkpoint was created.
  //
  // The redo stack will be empty following this operation, so changes since the
  // checkpoint will be lost. If the given checkpoint is no longer present in the
  // undo history, no changes will be made to the buffer and this method will
  // return `false`.
  //
  // * `checkpoint` The checkpoint to revert to.
  //
  // Returns a {Boolean} indicating whether the operation succeeded.
  revertToCheckpoint(checkpoint) {
    return this.buffer.revertToCheckpoint(checkpoint);
  }

  // Extended: Group all changes since the given checkpoint into a single
  // transaction for purposes of undo/redo.
  //
  // If the given checkpoint is no longer present in the undo history, no
  // grouping will be performed and this method will return `false`.
  //
  // * `checkpoint` The checkpoint from which to group changes.
  //
  // Returns a {Boolean} indicating whether the operation succeeded.
  groupChangesSinceCheckpoint(checkpoint) {
    return this.buffer.groupChangesSinceCheckpoint(checkpoint, {
      selectionsMarkerLayer: this.selectionsMarkerLayer
    });
  }

  /*
  Section: TextEditor Coordinates
  */

  // Essential: Convert a position in buffer-coordinates to screen-coordinates.
  //
  // The position is clipped via {::clipBufferPosition} prior to the conversion.
  // The position is also clipped via {::clipScreenPosition} following the
  // conversion, which only makes a difference when `options` are supplied.
  //
  // * `bufferPosition` A {Point} or {Array} of [row, column].
  // * `options` (optional) An options hash for {::clipScreenPosition}.
  //
  // Returns a {Point}.
  screenPositionForBufferPosition(bufferPosition, options) {
    if (options && options.clip) {
      Grim.deprecate(
        'The `clip` parameter has been deprecated and will be removed soon. Please, use `clipDirection` instead.'
      );
      if (options.clipDirection) options.clipDirection = options.clip;
    }
    if (options && options.wrapAtSoftNewlines != null) {
      Grim.deprecate(
        "The `wrapAtSoftNewlines` parameter has been deprecated and will be removed soon. Please, use `clipDirection: 'forward'` instead."
      );
      if (options.clipDirection)
        options.clipDirection = options.wrapAtSoftNewlines
          ? 'forward'
          : 'backward';
    }
    if (options && options.wrapBeyondNewlines != null) {
      Grim.deprecate(
        "The `wrapBeyondNewlines` parameter has been deprecated and will be removed soon. Please, use `clipDirection: 'forward'` instead."
      );
      if (options.clipDirection)
        options.clipDirection = options.wrapBeyondNewlines
          ? 'forward'
          : 'backward';
    }

    return this.displayLayer.translateBufferPosition(bufferPosition, options);
  }

  // Essential: Convert a position in screen-coordinates to buffer-coordinates.
  //
  // The position is clipped via {::clipScreenPosition} prior to the conversion.
  //
  // * `bufferPosition` A {Point} or {Array} of [row, column].
  // * `options` (optional) An options hash for {::clipScreenPosition}.
  //
  // Returns a {Point}.
  bufferPositionForScreenPosition(screenPosition, options) {
    if (options && options.clip) {
      Grim.deprecate(
        'The `clip` parameter has been deprecated and will be removed soon. Please, use `clipDirection` instead.'
      );
      if (options.clipDirection) options.clipDirection = options.clip;
    }
    if (options && options.wrapAtSoftNewlines != null) {
      Grim.deprecate(
        "The `wrapAtSoftNewlines` parameter has been deprecated and will be removed soon. Please, use `clipDirection: 'forward'` instead."
      );
      if (options.clipDirection)
        options.clipDirection = options.wrapAtSoftNewlines
          ? 'forward'
          : 'backward';
    }
    if (options && options.wrapBeyondNewlines != null) {
      Grim.deprecate(
        "The `wrapBeyondNewlines` parameter has been deprecated and will be removed soon. Please, use `clipDirection: 'forward'` instead."
      );
      if (options.clipDirection)
        options.clipDirection = options.wrapBeyondNewlines
          ? 'forward'
          : 'backward';
    }

    return this.displayLayer.translateScreenPosition(screenPosition, options);
  }

  // Essential: Convert a range in buffer-coordinates to screen-coordinates.
  //
  // * `bufferRange` {Range} in buffer coordinates to translate into screen coordinates.
  //
  // Returns a {Range}.
  screenRangeForBufferRange(bufferRange, options) {
    bufferRange = Range.fromObject(bufferRange);
    const start = this.screenPositionForBufferPosition(
      bufferRange.start,
      options
    );
    const end = this.screenPositionForBufferPosition(bufferRange.end, options);
    return new Range(start, end);
  }

  // Essential: Convert a range in screen-coordinates to buffer-coordinates.
  //
  // * `screenRange` {Range} in screen coordinates to translate into buffer coordinates.
  //
  // Returns a {Range}.
  bufferRangeForScreenRange(screenRange) {
    screenRange = Range.fromObject(screenRange);
    const start = this.bufferPositionForScreenPosition(screenRange.start);
    const end = this.bufferPositionForScreenPosition(screenRange.end);
    return new Range(start, end);
  }

  // Extended: Clip the given {Point} to a valid position in the buffer.
  //
  // If the given {Point} describes a position that is actually reachable by the
  // cursor based on the current contents of the buffer, it is returned
  // unchanged. If the {Point} does not describe a valid position, the closest
  // valid position is returned instead.
  //
  // ## Examples
  //
  // ```js
  // editor.clipBufferPosition([-1, -1]) // -> `[0, 0]`
  //
  // // When the line at buffer row 2 is 10 characters long
  // editor.clipBufferPosition([2, Infinity]) // -> `[2, 10]`
  // ```
  //
  // * `bufferPosition` The {Point} representing the position to clip.
  //
  // Returns a {Point}.
  clipBufferPosition(bufferPosition) {
    return this.buffer.clipPosition(bufferPosition);
  }

  // Extended: Clip the start and end of the given range to valid positions in the
  // buffer. See {::clipBufferPosition} for more information.
  //
  // * `range` The {Range} to clip.
  //
  // Returns a {Range}.
  clipBufferRange(range) {
    return this.buffer.clipRange(range);
  }

  // Extended: Clip the given {Point} to a valid position on screen.
  //
  // If the given {Point} describes a position that is actually reachable by the
  // cursor based on the current contents of the screen, it is returned
  // unchanged. If the {Point} does not describe a valid position, the closest
  // valid position is returned instead.
  //
  // ## Examples
  //
  // ```js
  // editor.clipScreenPosition([-1, -1]) // -> `[0, 0]`
  //
  // // When the line at screen row 2 is 10 characters long
  // editor.clipScreenPosition([2, Infinity]) // -> `[2, 10]`
  // ```
  //
  // * `screenPosition` The {Point} representing the position to clip.
  // * `options` (optional) {Object}
  //   * `clipDirection` {String} If `'backward'`, returns the first valid
  //     position preceding an invalid position. If `'forward'`, returns the
  //     first valid position following an invalid position. If `'closest'`,
  //     returns the first valid position closest to an invalid position.
  //     Defaults to `'closest'`.
  //
  // Returns a {Point}.
  clipScreenPosition(screenPosition, options) {
    if (options && options.clip) {
      Grim.deprecate(
        'The `clip` parameter has been deprecated and will be removed soon. Please, use `clipDirection` instead.'
      );
      if (options.clipDirection) options.clipDirection = options.clip;
    }
    if (options && options.wrapAtSoftNewlines != null) {
      Grim.deprecate(
        "The `wrapAtSoftNewlines` parameter has been deprecated and will be removed soon. Please, use `clipDirection: 'forward'` instead."
      );
      if (options.clipDirection)
        options.clipDirection = options.wrapAtSoftNewlines
          ? 'forward'
          : 'backward';
    }
    if (options && options.wrapBeyondNewlines != null) {
      Grim.deprecate(
        "The `wrapBeyondNewlines` parameter has been deprecated and will be removed soon. Please, use `clipDirection: 'forward'` instead."
      );
      if (options.clipDirection)
        options.clipDirection = options.wrapBeyondNewlines
          ? 'forward'
          : 'backward';
    }

    return this.displayLayer.clipScreenPosition(screenPosition, options);
  }

  // Extended: Clip the start and end of the given range to valid positions on screen.
  // See {::clipScreenPosition} for more information.
  //
  // * `range` The {Range} to clip.
  // * `options` (optional) See {::clipScreenPosition} `options`.
  //
  // Returns a {Range}.
  clipScreenRange(screenRange, options) {
    screenRange = Range.fromObject(screenRange);
    const start = this.displayLayer.clipScreenPosition(
      screenRange.start,
      options
    );
    const end = this.displayLayer.clipScreenPosition(screenRange.end, options);
    return Range(start, end);
  }

  /*
  Section: Decorations
  */

  // Essential: Add a decoration that tracks a {DisplayMarker}. When the
  // marker moves, is invalidated, or is destroyed, the decoration will be
  // updated to reflect the marker's state.
  //
  // The following are the supported decorations types:
  //
  // * __line__: Adds the given CSS `class` to the lines overlapping the rows
  //     spanned by the marker.
  // * __line-number__: Adds the given CSS `class` to the line numbers overlapping
  //     the rows spanned by the marker
  // * __text__: Injects spans into all text overlapping the marked range, then adds
  //     the given `class` or `style` to these spans. Use this to manipulate the foreground
  //     color or styling of text in a range.
  // * __highlight__: Creates an absolutely-positioned `.highlight` div to the editor
  //     containing nested divs that cover the marked region. For example, when the user
  //     selects text, the selection is implemented with a highlight decoration. The structure
  //     of this highlight will be:
  //     ```html
  //     <div class="highlight <your-class>">
  //       <!-- Will be one region for each row in the range. Spans 2 lines? There will be 2 regions. -->
  //       <div class="region"></div>
  //     </div>
  //     ```
  // * __overlay__: Positions the view associated with the given item at the head
  //     or tail of the given `DisplayMarker`, depending on the `position` property.
  // * __gutter__: Tracks a {DisplayMarker} in a {Gutter}. Gutter decorations are created
  //     by calling {Gutter::decorateMarker} on the desired `Gutter` instance.
  // * __block__: Positions the view associated with the given item before or
  //     after the row of the given {DisplayMarker}, depending on the `position` property.
  //     Block decorations at the same screen row are ordered by their `order` property.
  // * __cursor__: Render a cursor at the head of the {DisplayMarker}. If multiple cursor decorations
  //     are created for the same marker, their class strings and style objects are combined
  //     into a single cursor. This decoration type may be used to style existing cursors
  //     by passing in their markers or to render artificial cursors that don't actually
  //     exist in the model by passing a marker that isn't associated with a real cursor.
  //
  // ## Arguments
  //
  // * `marker` A {DisplayMarker} you want this decoration to follow.
  // * `decorationParams` An {Object} representing the decoration e.g.
  //   `{type: 'line-number', class: 'linter-error'}`
  //   * `type` Determines the behavior and appearance of this {Decoration}. Supported decoration types
  //     and their uses are listed above.
  //   * `class` This CSS class will be applied to the decorated line number,
  //     line, text spans, highlight regions, cursors, or overlay.
  //   * `style` An {Object} containing CSS style properties to apply to the
  //     relevant DOM node. Currently this only works with a `type` of `cursor`
  //     or `text`.
  //   * `item` (optional) An {HTMLElement} or a model {Object} with a
  //     corresponding view registered. Only applicable to the `gutter`,
  //     `overlay` and `block` decoration types.
  //   * `onlyHead` (optional) If `true`, the decoration will only be applied to
  //     the head of the `DisplayMarker`. Only applicable to the `line` and
  //     `line-number` decoration types.
  //   * `onlyEmpty` (optional) If `true`, the decoration will only be applied if
  //     the associated `DisplayMarker` is empty. Only applicable to the `gutter`,
  //     `line`, and `line-number` decoration types.
  //   * `onlyNonEmpty` (optional) If `true`, the decoration will only be applied
  //     if the associated `DisplayMarker` is non-empty. Only applicable to the
  //     `gutter`, `line`, and `line-number` decoration types.
  //   * `omitEmptyLastRow` (optional) If `false`, the decoration will be applied
  //     to the last row of a non-empty range, even if it ends at column 0.
  //     Defaults to `true`. Only applicable to the `gutter`, `line`, and
  //     `line-number` decoration types.
  //   * `position` (optional) Only applicable to decorations of type `overlay` and `block`.
  //     Controls where the view is positioned relative to the `TextEditorMarker`.
  //     Values can be `'head'` (the default) or `'tail'` for overlay decorations, and
  //     `'before'` (the default) or `'after'` for block decorations.
  //   * `order` (optional) Only applicable to decorations of type `block`. Controls
  //      where the view is positioned relative to other block decorations at the
  //      same screen row. If unspecified, block decorations render oldest to newest.
  //   * `avoidOverflow` (optional) Only applicable to decorations of type
  //      `overlay`. Determines whether the decoration adjusts its horizontal or
  //      vertical position to remain fully visible when it would otherwise
  //      overflow the editor. Defaults to `true`.
  //
  // Returns the created {Decoration} object.
  decorateMarker(marker, decorationParams) {
    return this.decorationManager.decorateMarker(marker, decorationParams);
  }

  // Essential: Add a decoration to every marker in the given marker layer. Can
  // be used to decorate a large number of markers without having to create and
  // manage many individual decorations.
  //
  // * `markerLayer` A {DisplayMarkerLayer} or {MarkerLayer} to decorate.
  // * `decorationParams` The same parameters that are passed to
  //   {TextEditor::decorateMarker}, except the `type` cannot be `overlay` or `gutter`.
  //
  // Returns a {LayerDecoration}.
  decorateMarkerLayer(markerLayer, decorationParams) {
    return this.decorationManager.decorateMarkerLayer(
      markerLayer,
      decorationParams
    );
  }

  // Deprecated: Get all the decorations within a screen row range on the default
  // layer.
  //
  // * `startScreenRow` the {Number} beginning screen row
  // * `endScreenRow` the {Number} end screen row (inclusive)
  //
  // Returns an {Object} of decorations in the form
  //  `{1: [{id: 10, type: 'line-number', class: 'someclass'}], 2: ...}`
  //   where the keys are {DisplayMarker} IDs, and the values are an array of decoration
  //   params objects attached to the marker.
  // Returns an empty object when no decorations are found
  decorationsForScreenRowRange(startScreenRow, endScreenRow) {
    return this.decorationManager.decorationsForScreenRowRange(
      startScreenRow,
      endScreenRow
    );
  }

  decorationsStateForScreenRowRange(startScreenRow, endScreenRow) {
    return this.decorationManager.decorationsStateForScreenRowRange(
      startScreenRow,
      endScreenRow
    );
  }

  // Extended: Get all decorations.
  //
  // * `propertyFilter` (optional) An {Object} containing key value pairs that
  //   the returned decorations' properties must match.
  //
  // Returns an {Array} of {Decoration}s.
  getDecorations(propertyFilter) {
    return this.decorationManager.getDecorations(propertyFilter);
  }

  // Extended: Get all decorations of type 'line'.
  //
  // * `propertyFilter` (optional) An {Object} containing key value pairs that
  //   the returned decorations' properties must match.
  //
  // Returns an {Array} of {Decoration}s.
  getLineDecorations(propertyFilter) {
    return this.decorationManager.getLineDecorations(propertyFilter);
  }

  // Extended: Get all decorations of type 'line-number'.
  //
  // * `propertyFilter` (optional) An {Object} containing key value pairs that
  //   the returned decorations' properties must match.
  //
  // Returns an {Array} of {Decoration}s.
  getLineNumberDecorations(propertyFilter) {
    return this.decorationManager.getLineNumberDecorations(propertyFilter);
  }

  // Extended: Get all decorations of type 'highlight'.
  //
  // * `propertyFilter` (optional) An {Object} containing key value pairs that
  //   the returned decorations' properties must match.
  //
  // Returns an {Array} of {Decoration}s.
  getHighlightDecorations(propertyFilter) {
    return this.decorationManager.getHighlightDecorations(propertyFilter);
  }

  // Extended: Get all decorations of type 'overlay'.
  //
  // * `propertyFilter` (optional) An {Object} containing key value pairs that
  //   the returned decorations' properties must match.
  //
  // Returns an {Array} of {Decoration}s.
  getOverlayDecorations(propertyFilter) {
    return this.decorationManager.getOverlayDecorations(propertyFilter);
  }

  /*
  Section: Markers
  */

  // Essential: Create a marker on the default marker layer with the given range
  // in buffer coordinates. This marker will maintain its logical location as the
  // buffer is changed, so if you mark a particular word, the marker will remain
  // over that word even if the word's location in the buffer changes.
  //
  // * `range` A {Range} or range-compatible {Array}
  // * `properties` A hash of key-value pairs to associate with the marker. There
  //   are also reserved property names that have marker-specific meaning.
  //   * `maintainHistory` (optional) {Boolean} Whether to store this marker's
  //     range before and after each change in the undo history. This allows the
  //     marker's position to be restored more accurately for certain undo/redo
  //     operations, but uses more time and memory. (default: false)
  //   * `reversed` (optional) {Boolean} Creates the marker in a reversed
  //     orientation. (default: false)
  //   * `invalidate` (optional) {String} Determines the rules by which changes
  //     to the buffer *invalidate* the marker. (default: 'overlap') It can be
  //     any of the following strategies, in order of fragility:
  //     * __never__: The marker is never marked as invalid. This is a good choice for
  //       markers representing selections in an editor.
  //     * __surround__: The marker is invalidated by changes that completely surround it.
  //     * __overlap__: The marker is invalidated by changes that surround the
  //       start or end of the marker. This is the default.
  //     * __inside__: The marker is invalidated by changes that extend into the
  //       inside of the marker. Changes that end at the marker's start or
  //       start at the marker's end do not invalidate the marker.
  //     * __touch__: The marker is invalidated by a change that touches the marked
  //       region in any way, including changes that end at the marker's
  //       start or start at the marker's end. This is the most fragile strategy.
  //
  // Returns a {DisplayMarker}.
  markBufferRange(bufferRange, options) {
    return this.defaultMarkerLayer.markBufferRange(bufferRange, options);
  }

  // Essential: Create a marker on the default marker layer with the given range
  // in screen coordinates. This marker will maintain its logical location as the
  // buffer is changed, so if you mark a particular word, the marker will remain
  // over that word even if the word's location in the buffer changes.
  //
  // * `range` A {Range} or range-compatible {Array}
  // * `properties` A hash of key-value pairs to associate with the marker. There
  //   are also reserved property names that have marker-specific meaning.
  //   * `maintainHistory` (optional) {Boolean} Whether to store this marker's
  //     range before and after each change in the undo history. This allows the
  //     marker's position to be restored more accurately for certain undo/redo
  //     operations, but uses more time and memory. (default: false)
  //   * `reversed` (optional) {Boolean} Creates the marker in a reversed
  //     orientation. (default: false)
  //   * `invalidate` (optional) {String} Determines the rules by which changes
  //     to the buffer *invalidate* the marker. (default: 'overlap') It can be
  //     any of the following strategies, in order of fragility:
  //     * __never__: The marker is never marked as invalid. This is a good choice for
  //       markers representing selections in an editor.
  //     * __surround__: The marker is invalidated by changes that completely surround it.
  //     * __overlap__: The marker is invalidated by changes that surround the
  //       start or end of the marker. This is the default.
  //     * __inside__: The marker is invalidated by changes that extend into the
  //       inside of the marker. Changes that end at the marker's start or
  //       start at the marker's end do not invalidate the marker.
  //     * __touch__: The marker is invalidated by a change that touches the marked
  //       region in any way, including changes that end at the marker's
  //       start or start at the marker's end. This is the most fragile strategy.
  //
  // Returns a {DisplayMarker}.
  markScreenRange(screenRange, options) {
    return this.defaultMarkerLayer.markScreenRange(screenRange, options);
  }

  // Essential: Create a marker on the default marker layer with the given buffer
  // position and no tail. To group multiple markers together in their own
  // private layer, see {::addMarkerLayer}.
  //
  // * `bufferPosition` A {Point} or point-compatible {Array}
  // * `options` (optional) An {Object} with the following keys:
  //   * `invalidate` (optional) {String} Determines the rules by which changes
  //     to the buffer *invalidate* the marker. (default: 'overlap') It can be
  //     any of the following strategies, in order of fragility:
  //     * __never__: The marker is never marked as invalid. This is a good choice for
  //       markers representing selections in an editor.
  //     * __surround__: The marker is invalidated by changes that completely surround it.
  //     * __overlap__: The marker is invalidated by changes that surround the
  //       start or end of the marker. This is the default.
  //     * __inside__: The marker is invalidated by changes that extend into the
  //       inside of the marker. Changes that end at the marker's start or
  //       start at the marker's end do not invalidate the marker.
  //     * __touch__: The marker is invalidated by a change that touches the marked
  //       region in any way, including changes that end at the marker's
  //       start or start at the marker's end. This is the most fragile strategy.
  //
  // Returns a {DisplayMarker}.
  markBufferPosition(bufferPosition, options) {
    return this.defaultMarkerLayer.markBufferPosition(bufferPosition, options);
  }

  // Essential: Create a marker on the default marker layer with the given screen
  // position and no tail. To group multiple markers together in their own
  // private layer, see {::addMarkerLayer}.
  //
  // * `screenPosition` A {Point} or point-compatible {Array}
  // * `options` (optional) An {Object} with the following keys:
  //   * `invalidate` (optional) {String} Determines the rules by which changes
  //     to the buffer *invalidate* the marker. (default: 'overlap') It can be
  //     any of the following strategies, in order of fragility:
  //     * __never__: The marker is never marked as invalid. This is a good choice for
  //       markers representing selections in an editor.
  //     * __surround__: The marker is invalidated by changes that completely surround it.
  //     * __overlap__: The marker is invalidated by changes that surround the
  //       start or end of the marker. This is the default.
  //     * __inside__: The marker is invalidated by changes that extend into the
  //       inside of the marker. Changes that end at the marker's start or
  //       start at the marker's end do not invalidate the marker.
  //     * __touch__: The marker is invalidated by a change that touches the marked
  //       region in any way, including changes that end at the marker's
  //       start or start at the marker's end. This is the most fragile strategy.
  //   * `clipDirection` {String} If `'backward'`, returns the first valid
  //     position preceding an invalid position. If `'forward'`, returns the
  //     first valid position following an invalid position. If `'closest'`,
  //     returns the first valid position closest to an invalid position.
  //     Defaults to `'closest'`.
  //
  // Returns a {DisplayMarker}.
  markScreenPosition(screenPosition, options) {
    return this.defaultMarkerLayer.markScreenPosition(screenPosition, options);
  }

  // Essential: Find all {DisplayMarker}s on the default marker layer that
  // match the given properties.
  //
  // This method finds markers based on the given properties. Markers can be
  // associated with custom properties that will be compared with basic equality.
  // In addition, there are several special properties that will be compared
  // with the range of the markers rather than their properties.
  //
  // * `properties` An {Object} containing properties that each returned marker
  //   must satisfy. Markers can be associated with custom properties, which are
  //   compared with basic equality. In addition, several reserved properties
  //   can be used to filter markers based on their current range:
  //   * `startBufferRow` Only include markers starting at this row in buffer
  //       coordinates.
  //   * `endBufferRow` Only include markers ending at this row in buffer
  //       coordinates.
  //   * `containsBufferRange` Only include markers containing this {Range} or
  //       in range-compatible {Array} in buffer coordinates.
  //   * `containsBufferPosition` Only include markers containing this {Point}
  //       or {Array} of `[row, column]` in buffer coordinates.
  //
  // Returns an {Array} of {DisplayMarker}s
  findMarkers(params) {
    return this.defaultMarkerLayer.findMarkers(params);
  }

  // Extended: Get the {DisplayMarker} on the default layer for the given
  // marker id.
  //
  // * `id` {Number} id of the marker
  getMarker(id) {
    return this.defaultMarkerLayer.getMarker(id);
  }

  // Extended: Get all {DisplayMarker}s on the default marker layer. Consider
  // using {::findMarkers}
  getMarkers() {
    return this.defaultMarkerLayer.getMarkers();
  }

  // Extended: Get the number of markers in the default marker layer.
  //
  // Returns a {Number}.
  getMarkerCount() {
    return this.defaultMarkerLayer.getMarkerCount();
  }

  destroyMarker(id) {
    const marker = this.getMarker(id);
    if (marker) marker.destroy();
  }

  // Essential: Create a marker layer to group related markers.
  //
  // * `options` An {Object} containing the following keys:
  //   * `maintainHistory` A {Boolean} indicating whether marker state should be
  //     restored on undo/redo. Defaults to `false`.
  //   * `persistent` A {Boolean} indicating whether or not this marker layer
  //     should be serialized and deserialized along with the rest of the
  //     buffer. Defaults to `false`. If `true`, the marker layer's id will be
  //     maintained across the serialization boundary, allowing you to retrieve
  //     it via {::getMarkerLayer}.
  //
  // Returns a {DisplayMarkerLayer}.
  addMarkerLayer(options) {
    return this.displayLayer.addMarkerLayer(options);
  }

  // Essential: Get a {DisplayMarkerLayer} by id.
  //
  // * `id` The id of the marker layer to retrieve.
  //
  // Returns a {DisplayMarkerLayer} or `undefined` if no layer exists with the
  // given id.
  getMarkerLayer(id) {
    return this.displayLayer.getMarkerLayer(id);
  }

  // Essential: Get the default {DisplayMarkerLayer}.
  //
  // All marker APIs not tied to an explicit layer interact with this default
  // layer.
  //
  // Returns a {DisplayMarkerLayer}.
  getDefaultMarkerLayer() {
    return this.defaultMarkerLayer;
  }

  /*
  Section: Cursors
  */

  // Essential: Get the position of the most recently added cursor in buffer
  // coordinates.
  //
  // Returns a {Point}
  getCursorBufferPosition() {
    return this.getLastCursor().getBufferPosition();
  }

  // Essential: Get the position of all the cursor positions in buffer coordinates.
  //
  // Returns {Array} of {Point}s in the order they were added
  getCursorBufferPositions() {
    return this.getCursors().map(cursor => cursor.getBufferPosition());
  }

  // Essential: Move the cursor to the given position in buffer coordinates.
  //
  // If there are multiple cursors, they will be consolidated to a single cursor.
  //
  // * `position` A {Point} or {Array} of `[row, column]`
  // * `options` (optional) An {Object} containing the following keys:
  //   * `autoscroll` Determines whether the editor scrolls to the new cursor's
  //     position. Defaults to true.
  setCursorBufferPosition(position, options) {
    return this.moveCursors(cursor =>
      cursor.setBufferPosition(position, options)
    );
  }

  // Essential: Get a {Cursor} at given screen coordinates {Point}
  //
  // * `position` A {Point} or {Array} of `[row, column]`
  //
  // Returns the first matched {Cursor} or undefined
  getCursorAtScreenPosition(position) {
    const selection = this.getSelectionAtScreenPosition(position);
    if (selection && selection.getHeadScreenPosition().isEqual(position)) {
      return selection.cursor;
    }
  }

  // Essential: Get the position of the most recently added cursor in screen
  // coordinates.
  //
  // Returns a {Point}.
  getCursorScreenPosition() {
    return this.getLastCursor().getScreenPosition();
  }

  // Essential: Get the position of all the cursor positions in screen coordinates.
  //
  // Returns {Array} of {Point}s in the order the cursors were added
  getCursorScreenPositions() {
    return this.getCursors().map(cursor => cursor.getScreenPosition());
  }

  // Essential: Move the cursor to the given position in screen coordinates.
  //
  // If there are multiple cursors, they will be consolidated to a single cursor.
  //
  // * `position` A {Point} or {Array} of `[row, column]`
  // * `options` (optional) An {Object} combining options for {::clipScreenPosition} with:
  //   * `autoscroll` Determines whether the editor scrolls to the new cursor's
  //     position. Defaults to true.
  setCursorScreenPosition(position, options) {
    if (options && options.clip) {
      Grim.deprecate(
        'The `clip` parameter has been deprecated and will be removed soon. Please, use `clipDirection` instead.'
      );
      if (options.clipDirection) options.clipDirection = options.clip;
    }
    if (options && options.wrapAtSoftNewlines != null) {
      Grim.deprecate(
        "The `wrapAtSoftNewlines` parameter has been deprecated and will be removed soon. Please, use `clipDirection: 'forward'` instead."
      );
      if (options.clipDirection)
        options.clipDirection = options.wrapAtSoftNewlines
          ? 'forward'
          : 'backward';
    }
    if (options && options.wrapBeyondNewlines != null) {
      Grim.deprecate(
        "The `wrapBeyondNewlines` parameter has been deprecated and will be removed soon. Please, use `clipDirection: 'forward'` instead."
      );
      if (options.clipDirection)
        options.clipDirection = options.wrapBeyondNewlines
          ? 'forward'
          : 'backward';
    }

    return this.moveCursors(cursor =>
      cursor.setScreenPosition(position, options)
    );
  }

  // Essential: Add a cursor at the given position in buffer coordinates.
  //
  // * `bufferPosition` A {Point} or {Array} of `[row, column]`
  //
  // Returns a {Cursor}.
  addCursorAtBufferPosition(bufferPosition, options) {
    this.selectionsMarkerLayer.markBufferPosition(bufferPosition, {
      invalidate: 'never'
    });
    if (!options || options.autoscroll !== false)
      this.getLastSelection().cursor.autoscroll();
    return this.getLastSelection().cursor;
  }

  // Essential: Add a cursor at the position in screen coordinates.
  //
  // * `screenPosition` A {Point} or {Array} of `[row, column]`
  //
  // Returns a {Cursor}.
  addCursorAtScreenPosition(screenPosition, options) {
    this.selectionsMarkerLayer.markScreenPosition(screenPosition, {
      invalidate: 'never'
    });
    if (!options || options.autoscroll !== false)
      this.getLastSelection().cursor.autoscroll();
    return this.getLastSelection().cursor;
  }

  // Essential: Returns {Boolean} indicating whether or not there are multiple cursors.
  hasMultipleCursors() {
    return this.getCursors().length > 1;
  }

  // Essential: Move every cursor up one row in screen coordinates.
  //
  // * `lineCount` (optional) {Number} number of lines to move
  moveUp(lineCount) {
    return this.moveCursors(cursor =>
      cursor.moveUp(lineCount, { moveToEndOfSelection: true })
    );
  }

  // Essential: Move every cursor down one row in screen coordinates.
  //
  // * `lineCount` (optional) {Number} number of lines to move
  moveDown(lineCount) {
    return this.moveCursors(cursor =>
      cursor.moveDown(lineCount, { moveToEndOfSelection: true })
    );
  }

  // Essential: Move every cursor left one column.
  //
  // * `columnCount` (optional) {Number} number of columns to move (default: 1)
  moveLeft(columnCount) {
    return this.moveCursors(cursor =>
      cursor.moveLeft(columnCount, { moveToEndOfSelection: true })
    );
  }

  // Essential: Move every cursor right one column.
  //
  // * `columnCount` (optional) {Number} number of columns to move (default: 1)
  moveRight(columnCount) {
    return this.moveCursors(cursor =>
      cursor.moveRight(columnCount, { moveToEndOfSelection: true })
    );
  }

  // Essential: Move every cursor to the beginning of its line in buffer coordinates.
  moveToBeginningOfLine() {
    return this.moveCursors(cursor => cursor.moveToBeginningOfLine());
  }

  // Essential: Move every cursor to the beginning of its line in screen coordinates.
  moveToBeginningOfScreenLine() {
    return this.moveCursors(cursor => cursor.moveToBeginningOfScreenLine());
  }

  // Essential: Move every cursor to the first non-whitespace character of its line.
  moveToFirstCharacterOfLine() {
    return this.moveCursors(cursor => cursor.moveToFirstCharacterOfLine());
  }

  // Essential: Move every cursor to the end of its line in buffer coordinates.
  moveToEndOfLine() {
    return this.moveCursors(cursor => cursor.moveToEndOfLine());
  }

  // Essential: Move every cursor to the end of its line in screen coordinates.
  moveToEndOfScreenLine() {
    return this.moveCursors(cursor => cursor.moveToEndOfScreenLine());
  }

  // Essential: Move every cursor to the beginning of its surrounding word.
  moveToBeginningOfWord() {
    return this.moveCursors(cursor => cursor.moveToBeginningOfWord());
  }

  // Essential: Move every cursor to the end of its surrounding word.
  moveToEndOfWord() {
    return this.moveCursors(cursor => cursor.moveToEndOfWord());
  }

  // Cursor Extended

  // Extended: Move every cursor to the top of the buffer.
  //
  // If there are multiple cursors, they will be merged into a single cursor.
  moveToTop() {
    return this.moveCursors(cursor => cursor.moveToTop());
  }

  // Extended: Move every cursor to the bottom of the buffer.
  //
  // If there are multiple cursors, they will be merged into a single cursor.
  moveToBottom() {
    return this.moveCursors(cursor => cursor.moveToBottom());
  }

  // Extended: Move every cursor to the beginning of the next word.
  moveToBeginningOfNextWord() {
    return this.moveCursors(cursor => cursor.moveToBeginningOfNextWord());
  }

  // Extended: Move every cursor to the previous word boundary.
  moveToPreviousWordBoundary() {
    return this.moveCursors(cursor => cursor.moveToPreviousWordBoundary());
  }

  // Extended: Move every cursor to the next word boundary.
  moveToNextWordBoundary() {
    return this.moveCursors(cursor => cursor.moveToNextWordBoundary());
  }

  // Extended: Move every cursor to the previous subword boundary.
  moveToPreviousSubwordBoundary() {
    return this.moveCursors(cursor => cursor.moveToPreviousSubwordBoundary());
  }

  // Extended: Move every cursor to the next subword boundary.
  moveToNextSubwordBoundary() {
    return this.moveCursors(cursor => cursor.moveToNextSubwordBoundary());
  }

  // Extended: Move every cursor to the beginning of the next paragraph.
  moveToBeginningOfNextParagraph() {
    return this.moveCursors(cursor => cursor.moveToBeginningOfNextParagraph());
  }

  // Extended: Move every cursor to the beginning of the previous paragraph.
  moveToBeginningOfPreviousParagraph() {
    return this.moveCursors(cursor =>
      cursor.moveToBeginningOfPreviousParagraph()
    );
  }

  // Extended: Returns the most recently added {Cursor}
  getLastCursor() {
    this.createLastSelectionIfNeeded();
    return _.last(this.cursors);
  }

  // Extended: Returns the word surrounding the most recently added cursor.
  //
  // * `options` (optional) See {Cursor::getBeginningOfCurrentWordBufferPosition}.
  getWordUnderCursor(options) {
    return this.getTextInBufferRange(
      this.getLastCursor().getCurrentWordBufferRange(options)
    );
  }

  // Extended: Get an Array of all {Cursor}s.
  getCursors() {
    this.createLastSelectionIfNeeded();
    return this.cursors.slice();
  }

  // Extended: Get all {Cursor}s, ordered by their position in the buffer
  // instead of the order in which they were added.
  //
  // Returns an {Array} of {Selection}s.
  getCursorsOrderedByBufferPosition() {
    return this.getCursors().sort((a, b) => a.compare(b));
  }

  cursorsForScreenRowRange(startScreenRow, endScreenRow) {
    const cursors = [];
    for (let marker of this.selectionsMarkerLayer.findMarkers({
      intersectsScreenRowRange: [startScreenRow, endScreenRow]
    })) {
      const cursor = this.cursorsByMarkerId.get(marker.id);
      if (cursor) cursors.push(cursor);
    }
    return cursors;
  }

  // Add a cursor based on the given {DisplayMarker}.
  addCursor(marker) {
    const cursor = new Cursor({
      editor: this,
      marker,
      showCursorOnSelection: this.showCursorOnSelection
    });
    this.cursors.push(cursor);
    this.cursorsByMarkerId.set(marker.id, cursor);
    return cursor;
  }

  moveCursors(fn) {
    return this.transact(() => {
      this.getCursors().forEach(fn);
      return this.mergeCursors();
    });
  }

  cursorMoved(event) {
    return this.emitter.emit('did-change-cursor-position', event);
  }

  // Merge cursors that have the same screen position
  mergeCursors() {
    const positions = {};
    for (let cursor of this.getCursors()) {
      const position = cursor.getBufferPosition().toString();
      if (positions.hasOwnProperty(position)) {
        cursor.destroy();
      } else {
        positions[position] = true;
      }
    }
  }

  /*
  Section: Selections
  */

  // Essential: Get the selected text of the most recently added selection.
  //
  // Returns a {String}.
  getSelectedText() {
    return this.getLastSelection().getText();
  }

  // Essential: Get the {Range} of the most recently added selection in buffer
  // coordinates.
  //
  // Returns a {Range}.
  getSelectedBufferRange() {
    return this.getLastSelection().getBufferRange();
  }

  // Essential: Get the {Range}s of all selections in buffer coordinates.
  //
  // The ranges are sorted by when the selections were added. Most recent at the end.
  //
  // Returns an {Array} of {Range}s.
  getSelectedBufferRanges() {
    return this.getSelections().map(selection => selection.getBufferRange());
  }

  // Essential: Set the selected range in buffer coordinates. If there are multiple
  // selections, they are reduced to a single selection with the given range.
  //
  // * `bufferRange` A {Range} or range-compatible {Array}.
  // * `options` (optional) An options {Object}:
  //   * `reversed` A {Boolean} indicating whether to create the selection in a
  //     reversed orientation.
  //   * `preserveFolds` A {Boolean}, which if `true` preserves the fold settings after the
  //     selection is set.
  setSelectedBufferRange(bufferRange, options) {
    return this.setSelectedBufferRanges([bufferRange], options);
  }

  // Essential: Set the selected ranges in buffer coordinates. If there are multiple
  // selections, they are replaced by new selections with the given ranges.
  //
  // * `bufferRanges` An {Array} of {Range}s or range-compatible {Array}s.
  // * `options` (optional) An options {Object}:
  //   * `reversed` A {Boolean} indicating whether to create the selection in a
  //     reversed orientation.
  //   * `preserveFolds` A {Boolean}, which if `true` preserves the fold settings after the
  //     selection is set.
  setSelectedBufferRanges(bufferRanges, options = {}) {
    if (!bufferRanges.length)
      throw new Error('Passed an empty array to setSelectedBufferRanges');

    const selections = this.getSelections();
    for (let selection of selections.slice(bufferRanges.length)) {
      selection.destroy();
    }

    this.mergeIntersectingSelections(options, () => {
      for (let i = 0; i < bufferRanges.length; i++) {
        let bufferRange = bufferRanges[i];
        bufferRange = Range.fromObject(bufferRange);
        if (selections[i]) {
          selections[i].setBufferRange(bufferRange, options);
        } else {
          this.addSelectionForBufferRange(bufferRange, options);
        }
      }
    });
  }

  // Essential: Get the {Range} of the most recently added selection in screen
  // coordinates.
  //
  // Returns a {Range}.
  getSelectedScreenRange() {
    return this.getLastSelection().getScreenRange();
  }

  // Essential: Get the {Range}s of all selections in screen coordinates.
  //
  // The ranges are sorted by when the selections were added. Most recent at the end.
  //
  // Returns an {Array} of {Range}s.
  getSelectedScreenRanges() {
    return this.getSelections().map(selection => selection.getScreenRange());
  }

  // Essential: Set the selected range in screen coordinates. If there are multiple
  // selections, they are reduced to a single selection with the given range.
  //
  // * `screenRange` A {Range} or range-compatible {Array}.
  // * `options` (optional) An options {Object}:
  //   * `reversed` A {Boolean} indicating whether to create the selection in a
  //     reversed orientation.
  setSelectedScreenRange(screenRange, options) {
    return this.setSelectedBufferRange(
      this.bufferRangeForScreenRange(screenRange, options),
      options
    );
  }

  // Essential: Set the selected ranges in screen coordinates. If there are multiple
  // selections, they are replaced by new selections with the given ranges.
  //
  // * `screenRanges` An {Array} of {Range}s or range-compatible {Array}s.
  // * `options` (optional) An options {Object}:
  //   * `reversed` A {Boolean} indicating whether to create the selection in a
  //     reversed orientation.
  setSelectedScreenRanges(screenRanges, options = {}) {
    if (!screenRanges.length)
      throw new Error('Passed an empty array to setSelectedScreenRanges');

    const selections = this.getSelections();
    for (let selection of selections.slice(screenRanges.length)) {
      selection.destroy();
    }

    this.mergeIntersectingSelections(options, () => {
      for (let i = 0; i < screenRanges.length; i++) {
        let screenRange = screenRanges[i];
        screenRange = Range.fromObject(screenRange);
        if (selections[i]) {
          selections[i].setScreenRange(screenRange, options);
        } else {
          this.addSelectionForScreenRange(screenRange, options);
        }
      }
    });
  }

  // Essential: Add a selection for the given range in buffer coordinates.
  //
  // * `bufferRange` A {Range}
  // * `options` (optional) An options {Object}:
  //   * `reversed` A {Boolean} indicating whether to create the selection in a
  //     reversed orientation.
  //   * `preserveFolds` A {Boolean}, which if `true` preserves the fold settings after the
  //     selection is set.
  //
  // Returns the added {Selection}.
  addSelectionForBufferRange(bufferRange, options = {}) {
    bufferRange = Range.fromObject(bufferRange);
    if (!options.preserveFolds) {
      this.displayLayer.destroyFoldsContainingBufferPositions(
        [bufferRange.start, bufferRange.end],
        true
      );
    }
    this.selectionsMarkerLayer.markBufferRange(bufferRange, {
      invalidate: 'never',
      reversed: options.reversed != null ? options.reversed : false
    });
    if (options.autoscroll !== false) this.getLastSelection().autoscroll();
    return this.getLastSelection();
  }

  // Essential: Add a selection for the given range in screen coordinates.
  //
  // * `screenRange` A {Range}
  // * `options` (optional) An options {Object}:
  //   * `reversed` A {Boolean} indicating whether to create the selection in a
  //     reversed orientation.
  //   * `preserveFolds` A {Boolean}, which if `true` preserves the fold settings after the
  //     selection is set.
  // Returns the added {Selection}.
  addSelectionForScreenRange(screenRange, options = {}) {
    return this.addSelectionForBufferRange(
      this.bufferRangeForScreenRange(screenRange),
      options
    );
  }

  // Essential: Select from the current cursor position to the given position in
  // buffer coordinates.
  //
  // This method may merge selections that end up intersecting.
  //
  // * `position` An instance of {Point}, with a given `row` and `column`.
  selectToBufferPosition(position) {
    const lastSelection = this.getLastSelection();
    lastSelection.selectToBufferPosition(position);
    return this.mergeIntersectingSelections({
      reversed: lastSelection.isReversed()
    });
  }

  // Essential: Select from the current cursor position to the given position in
  // screen coordinates.
  //
  // This method may merge selections that end up intersecting.
  //
  // * `position` An instance of {Point}, with a given `row` and `column`.
  selectToScreenPosition(position, options) {
    const lastSelection = this.getLastSelection();
    lastSelection.selectToScreenPosition(position, options);
    if (!options || !options.suppressSelectionMerge) {
      return this.mergeIntersectingSelections({
        reversed: lastSelection.isReversed()
      });
    }
  }

  // Essential: Move the cursor of each selection one character upward while
  // preserving the selection's tail position.
  //
  // * `rowCount` (optional) {Number} number of rows to select (default: 1)
  //
  // This method may merge selections that end up intersecting.
  selectUp(rowCount) {
    return this.expandSelectionsBackward(selection =>
      selection.selectUp(rowCount)
    );
  }

  // Essential: Move the cursor of each selection one character downward while
  // preserving the selection's tail position.
  //
  // * `rowCount` (optional) {Number} number of rows to select (default: 1)
  //
  // This method may merge selections that end up intersecting.
  selectDown(rowCount) {
    return this.expandSelectionsForward(selection =>
      selection.selectDown(rowCount)
    );
  }

  // Essential: Move the cursor of each selection one character leftward while
  // preserving the selection's tail position.
  //
  // * `columnCount` (optional) {Number} number of columns to select (default: 1)
  //
  // This method may merge selections that end up intersecting.
  selectLeft(columnCount) {
    return this.expandSelectionsBackward(selection =>
      selection.selectLeft(columnCount)
    );
  }

  // Essential: Move the cursor of each selection one character rightward while
  // preserving the selection's tail position.
  //
  // * `columnCount` (optional) {Number} number of columns to select (default: 1)
  //
  // This method may merge selections that end up intersecting.
  selectRight(columnCount) {
    return this.expandSelectionsForward(selection =>
      selection.selectRight(columnCount)
    );
  }

  // Essential: Select from the top of the buffer to the end of the last selection
  // in the buffer.
  //
  // This method merges multiple selections into a single selection.
  selectToTop() {
    return this.expandSelectionsBackward(selection => selection.selectToTop());
  }

  // Essential: Selects from the top of the first selection in the buffer to the end
  // of the buffer.
  //
  // This method merges multiple selections into a single selection.
  selectToBottom() {
    return this.expandSelectionsForward(selection =>
      selection.selectToBottom()
    );
  }

  // Essential: Select all text in the buffer.
  //
  // This method merges multiple selections into a single selection.
  selectAll() {
    return this.expandSelectionsForward(selection => selection.selectAll());
  }

  // Essential: Move the cursor of each selection to the beginning of its line
  // while preserving the selection's tail position.
  //
  // This method may merge selections that end up intersecting.
  selectToBeginningOfLine() {
    return this.expandSelectionsBackward(selection =>
      selection.selectToBeginningOfLine()
    );
  }

  // Essential: Move the cursor of each selection to the first non-whitespace
  // character of its line while preserving the selection's tail position. If the
  // cursor is already on the first character of the line, move it to the
  // beginning of the line.
  //
  // This method may merge selections that end up intersecting.
  selectToFirstCharacterOfLine() {
    return this.expandSelectionsBackward(selection =>
      selection.selectToFirstCharacterOfLine()
    );
  }

  // Essential: Move the cursor of each selection to the end of its line while
  // preserving the selection's tail position.
  //
  // This method may merge selections that end up intersecting.
  selectToEndOfLine() {
    return this.expandSelectionsForward(selection =>
      selection.selectToEndOfLine()
    );
  }

  // Essential: Expand selections to the beginning of their containing word.
  //
  // Operates on all selections. Moves the cursor to the beginning of the
  // containing word while preserving the selection's tail position.
  selectToBeginningOfWord() {
    return this.expandSelectionsBackward(selection =>
      selection.selectToBeginningOfWord()
    );
  }

  // Essential: Expand selections to the end of their containing word.
  //
  // Operates on all selections. Moves the cursor to the end of the containing
  // word while preserving the selection's tail position.
  selectToEndOfWord() {
    return this.expandSelectionsForward(selection =>
      selection.selectToEndOfWord()
    );
  }

  // Extended: For each selection, move its cursor to the preceding subword
  // boundary while maintaining the selection's tail position.
  //
  // This method may merge selections that end up intersecting.
  selectToPreviousSubwordBoundary() {
    return this.expandSelectionsBackward(selection =>
      selection.selectToPreviousSubwordBoundary()
    );
  }

  // Extended: For each selection, move its cursor to the next subword boundary
  // while maintaining the selection's tail position.
  //
  // This method may merge selections that end up intersecting.
  selectToNextSubwordBoundary() {
    return this.expandSelectionsForward(selection =>
      selection.selectToNextSubwordBoundary()
    );
  }

  // Essential: For each cursor, select the containing line.
  //
  // This method merges selections on successive lines.
  selectLinesContainingCursors() {
    return this.expandSelectionsForward(selection => selection.selectLine());
  }

  // Essential: Select the word surrounding each cursor.
  selectWordsContainingCursors() {
    return this.expandSelectionsForward(selection => selection.selectWord());
  }

  // Selection Extended

  // Extended: For each selection, move its cursor to the preceding word boundary
  // while maintaining the selection's tail position.
  //
  // This method may merge selections that end up intersecting.
  selectToPreviousWordBoundary() {
    return this.expandSelectionsBackward(selection =>
      selection.selectToPreviousWordBoundary()
    );
  }

  // Extended: For each selection, move its cursor to the next word boundary while
  // maintaining the selection's tail position.
  //
  // This method may merge selections that end up intersecting.
  selectToNextWordBoundary() {
    return this.expandSelectionsForward(selection =>
      selection.selectToNextWordBoundary()
    );
  }

  // Extended: Expand selections to the beginning of the next word.
  //
  // Operates on all selections. Moves the cursor to the beginning of the next
  // word while preserving the selection's tail position.
  selectToBeginningOfNextWord() {
    return this.expandSelectionsForward(selection =>
      selection.selectToBeginningOfNextWord()
    );
  }

  // Extended: Expand selections to the beginning of the next paragraph.
  //
  // Operates on all selections. Moves the cursor to the beginning of the next
  // paragraph while preserving the selection's tail position.
  selectToBeginningOfNextParagraph() {
    return this.expandSelectionsForward(selection =>
      selection.selectToBeginningOfNextParagraph()
    );
  }

  // Extended: Expand selections to the beginning of the next paragraph.
  //
  // Operates on all selections. Moves the cursor to the beginning of the next
  // paragraph while preserving the selection's tail position.
  selectToBeginningOfPreviousParagraph() {
    return this.expandSelectionsBackward(selection =>
      selection.selectToBeginningOfPreviousParagraph()
    );
  }

  // Extended: For each selection, select the syntax node that contains
  // that selection.
  selectLargerSyntaxNode() {
    const languageMode = this.buffer.getLanguageMode();
    if (!languageMode.getRangeForSyntaxNodeContainingRange) return;

    this.expandSelectionsForward(selection => {
      const currentRange = selection.getBufferRange();
      const newRange = languageMode.getRangeForSyntaxNodeContainingRange(
        currentRange
      );
      if (newRange) {
        if (!selection._rangeStack) selection._rangeStack = [];
        selection._rangeStack.push(currentRange);
        selection.setBufferRange(newRange);
      }
    });
  }

  // Extended: Undo the effect of a preceding call to {::selectLargerSyntaxNode}.
  selectSmallerSyntaxNode() {
    this.expandSelectionsForward(selection => {
      if (selection._rangeStack) {
        const lastRange =
          selection._rangeStack[selection._rangeStack.length - 1];
        if (lastRange && selection.getBufferRange().containsRange(lastRange)) {
          selection._rangeStack.length--;
          selection.setBufferRange(lastRange);
        }
      }
    });
  }

  // Extended: Select the range of the given marker if it is valid.
  //
  // * `marker` A {DisplayMarker}
  //
  // Returns the selected {Range} or `undefined` if the marker is invalid.
  selectMarker(marker) {
    if (marker.isValid()) {
      const range = marker.getBufferRange();
      this.setSelectedBufferRange(range);
      return range;
    }
  }

  // Extended: Get the most recently added {Selection}.
  //
  // Returns a {Selection}.
  getLastSelection() {
    this.createLastSelectionIfNeeded();
    return _.last(this.selections);
  }

  getSelectionAtScreenPosition(position) {
    const markers = this.selectionsMarkerLayer.findMarkers({
      containsScreenPosition: position
    });
    if (markers.length > 0)
      return this.cursorsByMarkerId.get(markers[0].id).selection;
  }

  // Extended: Get current {Selection}s.
  //
  // Returns: An {Array} of {Selection}s.
  getSelections() {
    this.createLastSelectionIfNeeded();
    return this.selections.slice();
  }

  // Extended: Get all {Selection}s, ordered by their position in the buffer
  // instead of the order in which they were added.
  //
  // Returns an {Array} of {Selection}s.
  getSelectionsOrderedByBufferPosition() {
    return this.getSelections().sort((a, b) => a.compare(b));
  }

  // Extended: Determine if a given range in buffer coordinates intersects a
  // selection.
  //
  // * `bufferRange` A {Range} or range-compatible {Array}.
  //
  // Returns a {Boolean}.
  selectionIntersectsBufferRange(bufferRange) {
    return this.getSelections().some(selection =>
      selection.intersectsBufferRange(bufferRange)
    );
  }

  // Selections Private

  // Add a similarly-shaped selection to the next eligible line below
  // each selection.
  //
  // Operates on all selections. If the selection is empty, adds an empty
  // selection to the next following non-empty line as close to the current
  // selection's column as possible. If the selection is non-empty, adds a
  // selection to the next line that is long enough for a non-empty selection
  // starting at the same column as the current selection to be added to it.
  addSelectionBelow() {
    return this.expandSelectionsForward(selection =>
      selection.addSelectionBelow()
    );
  }

  // Add a similarly-shaped selection to the next eligible line above
  // each selection.
  //
  // Operates on all selections. If the selection is empty, adds an empty
  // selection to the next preceding non-empty line as close to the current
  // selection's column as possible. If the selection is non-empty, adds a
  // selection to the next line that is long enough for a non-empty selection
  // starting at the same column as the current selection to be added to it.
  addSelectionAbove() {
    return this.expandSelectionsBackward(selection =>
      selection.addSelectionAbove()
    );
  }

  // Calls the given function with each selection, then merges selections
  expandSelectionsForward(fn) {
    this.mergeIntersectingSelections(() => this.getSelections().forEach(fn));
  }

  // Calls the given function with each selection, then merges selections in the
  // reversed orientation
  expandSelectionsBackward(fn) {
    this.mergeIntersectingSelections({ reversed: true }, () =>
      this.getSelections().forEach(fn)
    );
  }

  finalizeSelections() {
    for (let selection of this.getSelections()) {
      selection.finalize();
    }
  }

  selectionsForScreenRows(startRow, endRow) {
    return this.getSelections().filter(selection =>
      selection.intersectsScreenRowRange(startRow, endRow)
    );
  }

  // Merges intersecting selections. If passed a function, it executes
  // the function with merging suppressed, then merges intersecting selections
  // afterward.
  mergeIntersectingSelections(...args) {
    return this.mergeSelections(
      ...args,
      (previousSelection, currentSelection) => {
        const exclusive =
          !currentSelection.isEmpty() && !previousSelection.isEmpty();
        return previousSelection.intersectsWith(currentSelection, exclusive);
      }
    );
  }

  mergeSelectionsOnSameRows(...args) {
    return this.mergeSelections(
      ...args,
      (previousSelection, currentSelection) => {
        const screenRange = currentSelection.getScreenRange();
        return previousSelection.intersectsScreenRowRange(
          screenRange.start.row,
          screenRange.end.row
        );
      }
    );
  }

  avoidMergingSelections(...args) {
    return this.mergeSelections(...args, () => false);
  }

  mergeSelections(...args) {
    const mergePredicate = args.pop();
    let fn = args.pop();
    let options = args.pop();
    if (typeof fn !== 'function') {
      options = fn;
      fn = () => {};
    }

    if (this.suppressSelectionMerging) return fn();

    this.suppressSelectionMerging = true;
    const result = fn();
    this.suppressSelectionMerging = false;

    const selections = this.getSelectionsOrderedByBufferPosition();
    let lastSelection = selections.shift();
    for (const selection of selections) {
      if (mergePredicate(lastSelection, selection)) {
        lastSelection.merge(selection, options);
      } else {
        lastSelection = selection;
      }
    }

    return result;
  }

  // Add a {Selection} based on the given {DisplayMarker}.
  //
  // * `marker` The {DisplayMarker} to highlight
  // * `options` (optional) An {Object} that pertains to the {Selection} constructor.
  //
  // Returns the new {Selection}.
  addSelection(marker, options = {}) {
    const cursor = this.addCursor(marker);
    let selection = new Selection(
      Object.assign({ editor: this, marker, cursor }, options)
    );
    this.selections.push(selection);
    const selectionBufferRange = selection.getBufferRange();
    this.mergeIntersectingSelections({ preserveFolds: options.preserveFolds });

    if (selection.destroyed) {
      for (selection of this.getSelections()) {
        if (selection.intersectsBufferRange(selectionBufferRange))
          return selection;
      }
    } else {
      this.emitter.emit('did-add-cursor', cursor);
      this.emitter.emit('did-add-selection', selection);
      return selection;
    }
  }

  // Remove the given selection.
  removeSelection(selection) {
    _.remove(this.cursors, selection.cursor);
    _.remove(this.selections, selection);
    this.cursorsByMarkerId.delete(selection.cursor.marker.id);
    this.emitter.emit('did-remove-cursor', selection.cursor);
    return this.emitter.emit('did-remove-selection', selection);
  }

  // Reduce one or more selections to a single empty selection based on the most
  // recently added cursor.
  clearSelections(options) {
    this.consolidateSelections();
    this.getLastSelection().clear(options);
  }

  // Reduce multiple selections to the least recently added selection.
  consolidateSelections() {
    const selections = this.getSelections();
    if (selections.length > 1) {
      for (let selection of selections.slice(1, selections.length)) {
        selection.destroy();
      }
      selections[0].autoscroll({ center: true });
      return true;
    } else {
      return false;
    }
  }

  // Called by the selection
  selectionRangeChanged(event) {
    if (this.component) this.component.didChangeSelectionRange();
    this.emitter.emit('did-change-selection-range', event);
  }

  createLastSelectionIfNeeded() {
    if (this.selections.length === 0) {
      this.addSelectionForBufferRange([[0, 0], [0, 0]], {
        autoscroll: false,
        preserveFolds: true
      });
    }
  }

  /*
  Section: Searching and Replacing
  */

  // Essential: Scan regular expression matches in the entire buffer, calling the
  // given iterator function on each match.
  //
  // `::scan` functions as the replace method as well via the `replace`
  //
  // If you're programmatically modifying the results, you may want to try
  // {::backwardsScanInBufferRange} to avoid tripping over your own changes.
  //
  // * `regex` A {RegExp} to search for.
  // * `options` (optional) {Object}
  //   * `leadingContextLineCount` {Number} default `0`; The number of lines
  //      before the matched line to include in the results object.
  //   * `trailingContextLineCount` {Number} default `0`; The number of lines
  //      after the matched line to include in the results object.
  // * `iterator` A {Function} that's called on each match
  //   * `object` {Object}
  //     * `match` The current regular expression match.
  //     * `matchText` A {String} with the text of the match.
  //     * `range` The {Range} of the match.
  //     * `stop` Call this {Function} to terminate the scan.
  //     * `replace` Call this {Function} with a {String} to replace the match.
  scan(regex, options = {}, iterator) {
    if (_.isFunction(options)) {
      iterator = options;
      options = {};
    }

    return this.buffer.scan(regex, options, iterator);
  }

  // Essential: Scan regular expression matches in a given range, calling the given
  // iterator function on each match.
  //
  // * `regex` A {RegExp} to search for.
  // * `range` A {Range} in which to search.
  // * `iterator` A {Function} that's called on each match with an {Object}
  //   containing the following keys:
  //   * `match` The current regular expression match.
  //   * `matchText` A {String} with the text of the match.
  //   * `range` The {Range} of the match.
  //   * `stop` Call this {Function} to terminate the scan.
  //   * `replace` Call this {Function} with a {String} to replace the match.
  scanInBufferRange(regex, range, iterator) {
    return this.buffer.scanInRange(regex, range, iterator);
  }

  // Essential: Scan regular expression matches in a given range in reverse order,
  // calling the given iterator function on each match.
  //
  // * `regex` A {RegExp} to search for.
  // * `range` A {Range} in which to search.
  // * `iterator` A {Function} that's called on each match with an {Object}
  //   containing the following keys:
  //   * `match` The current regular expression match.
  //   * `matchText` A {String} with the text of the match.
  //   * `range` The {Range} of the match.
  //   * `stop` Call this {Function} to terminate the scan.
  //   * `replace` Call this {Function} with a {String} to replace the match.
  backwardsScanInBufferRange(regex, range, iterator) {
    return this.buffer.backwardsScanInRange(regex, range, iterator);
  }

  /*
  Section: Tab Behavior
  */

  // Essential: Returns a {Boolean} indicating whether softTabs are enabled for this
  // editor.
  getSoftTabs() {
    return this.softTabs;
  }

  // Essential: Enable or disable soft tabs for this editor.
  //
  // * `softTabs` A {Boolean}
  setSoftTabs(softTabs) {
    this.softTabs = softTabs;
    this.updateSoftTabs(this.softTabs, true);
  }

  // Returns a {Boolean} indicating whether atomic soft tabs are enabled for this editor.
  hasAtomicSoftTabs() {
    return this.displayLayer.atomicSoftTabs;
  }

  // Essential: Toggle soft tabs for this editor
  toggleSoftTabs() {
    this.setSoftTabs(!this.getSoftTabs());
  }

  // Essential: Get the on-screen length of tab characters.
  //
  // Returns a {Number}.
  getTabLength() {
    return this.displayLayer.tabLength;
  }

  // Essential: Set the on-screen length of tab characters. Setting this to a
  // {Number} This will override the `editor.tabLength` setting.
  //
  // * `tabLength` {Number} length of a single tab. Setting to `null` will
  //   fallback to using the `editor.tabLength` config setting
  setTabLength(tabLength) {
    this.updateTabLength(tabLength, true);
  }

  // Returns an {Object} representing the current invisible character
  // substitutions for this editor, whose keys are names of invisible characters
  // and whose values are 1-character {Strings}s that are displayed in place of
  // those invisible characters
  getInvisibles() {
    if (!this.mini && this.showInvisibles && this.invisibles != null) {
      return this.invisibles;
    } else {
      return {};
    }
  }

  doesShowIndentGuide() {
    return this.showIndentGuide && !this.mini;
  }

  getSoftWrapHangingIndentLength() {
    return this.displayLayer.softWrapHangingIndent;
  }

  // Extended: Determine if the buffer uses hard or soft tabs.
  //
  // Returns `true` if the first non-comment line with leading whitespace starts
  // with a space character. Returns `false` if it starts with a hard tab (`\t`).
  //
  // Returns a {Boolean} or undefined if no non-comment lines had leading
  // whitespace.
  usesSoftTabs() {
    const languageMode = this.buffer.getLanguageMode();
    const hasIsRowCommented = languageMode.isRowCommented;
    for (
      let bufferRow = 0, end = Math.min(1000, this.buffer.getLastRow());
      bufferRow <= end;
      bufferRow++
    ) {
      if (hasIsRowCommented && languageMode.isRowCommented(bufferRow)) continue;
      const line = this.buffer.lineForRow(bufferRow);
      if (line[0] === ' ') return true;
      if (line[0] === '\t') return false;
    }
  }

  // Extended: Get the text representing a single level of indent.
  //
  // If soft tabs are enabled, the text is composed of N spaces, where N is the
  // tab length. Otherwise the text is a tab character (`\t`).
  //
  // Returns a {String}.
  getTabText() {
    return this.buildIndentString(1);
  }

  // If soft tabs are enabled, convert all hard tabs to soft tabs in the given
  // {Range}.
  normalizeTabsInBufferRange(bufferRange) {
    if (!this.getSoftTabs()) {
      return;
    }
    return this.scanInBufferRange(/\t/g, bufferRange, ({ replace }) =>
      replace(this.getTabText())
    );
  }

  /*
  Section: Soft Wrap Behavior
  */

  // Essential: Determine whether lines in this editor are soft-wrapped.
  //
  // Returns a {Boolean}.
  isSoftWrapped() {
    return this.softWrapped;
  }

  // Essential: Enable or disable soft wrapping for this editor.
  //
  // * `softWrapped` A {Boolean}
  //
  // Returns a {Boolean}.
  setSoftWrapped(softWrapped) {
    this.updateSoftWrapped(softWrapped, true);
    return this.isSoftWrapped();
  }

  getPreferredLineLength() {
    return this.preferredLineLength;
  }

  // Essential: Toggle soft wrapping for this editor
  //
  // Returns a {Boolean}.
  toggleSoftWrapped() {
    return this.setSoftWrapped(!this.isSoftWrapped());
  }

  // Essential: Gets the column at which column will soft wrap
  getSoftWrapColumn() {
    if (this.isSoftWrapped() && !this.mini) {
      if (this.softWrapAtPreferredLineLength) {
        return Math.min(this.getEditorWidthInChars(), this.preferredLineLength);
      } else {
        return this.getEditorWidthInChars();
      }
    } else {
      return this.maxScreenLineLength;
    }
  }

  /*
  Section: Indentation
  */

  // Essential: Get the indentation level of the given buffer row.
  //
  // Determines how deeply the given row is indented based on the soft tabs and
  // tab length settings of this editor. Note that if soft tabs are enabled and
  // the tab length is 2, a row with 4 leading spaces would have an indentation
  // level of 2.
  //
  // * `bufferRow` A {Number} indicating the buffer row.
  //
  // Returns a {Number}.
  indentationForBufferRow(bufferRow) {
    return this.indentLevelForLine(this.lineTextForBufferRow(bufferRow));
  }

  // Essential: Set the indentation level for the given buffer row.
  //
  // Inserts or removes hard tabs or spaces based on the soft tabs and tab length
  // settings of this editor in order to bring it to the given indentation level.
  // Note that if soft tabs are enabled and the tab length is 2, a row with 4
  // leading spaces would have an indentation level of 2.
  //
  // * `bufferRow` A {Number} indicating the buffer row.
  // * `newLevel` A {Number} indicating the new indentation level.
  // * `options` (optional) An {Object} with the following keys:
  //   * `preserveLeadingWhitespace` `true` to preserve any whitespace already at
  //      the beginning of the line (default: false).
  setIndentationForBufferRow(
    bufferRow,
    newLevel,
    { preserveLeadingWhitespace } = {}
  ) {
    let endColumn;
    if (preserveLeadingWhitespace) {
      endColumn = 0;
    } else {
      endColumn = this.lineTextForBufferRow(bufferRow).match(/^\s*/)[0].length;
    }
    const newIndentString = this.buildIndentString(newLevel);
    return this.buffer.setTextInRange(
      [[bufferRow, 0], [bufferRow, endColumn]],
      newIndentString
    );
  }

  // Extended: Indent rows intersecting selections by one level.
  //
  // * `options` (optional) {Object}
  //   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify a read-only editor.
  indentSelectedRows(options = {}) {
    if (!this.ensureWritable('indentSelectedRows', options)) return;
    return this.mutateSelectedText(selection =>
      selection.indentSelectedRows(options)
    );
  }

  // Extended: Outdent rows intersecting selections by one level.
  //
  // * `options` (optional) {Object}
  //   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify a read-only editor.
  outdentSelectedRows(options = {}) {
    if (!this.ensureWritable('outdentSelectedRows', options)) return;
    return this.mutateSelectedText(selection =>
      selection.outdentSelectedRows(options)
    );
  }

  // Extended: Get the indentation level of the given line of text.
  //
  // Determines how deeply the given line is indented based on the soft tabs and
  // tab length settings of this editor. Note that if soft tabs are enabled and
  // the tab length is 2, a row with 4 leading spaces would have an indentation
  // level of 2.
  //
  // * `line` A {String} representing a line of text.
  //
  // Returns a {Number}.
  indentLevelForLine(line) {
    const tabLength = this.getTabLength();
    let indentLength = 0;
    for (let i = 0, { length } = line; i < length; i++) {
      const char = line[i];
      if (char === '\t') {
        indentLength += tabLength - (indentLength % tabLength);
      } else if (char === ' ') {
        indentLength++;
      } else {
        break;
      }
    }
    return indentLength / tabLength;
  }

  // Extended: Indent rows intersecting selections based on the grammar's suggested
  // indent level.
  //
  // * `options` (optional) {Object}
  //   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify a read-only editor.
  autoIndentSelectedRows(options = {}) {
    if (!this.ensureWritable('autoIndentSelectedRows', options)) return;
    return this.mutateSelectedText(selection =>
      selection.autoIndentSelectedRows(options)
    );
  }

  // Indent all lines intersecting selections. See {Selection::indent} for more
  // information.
  //
  // * `options` (optional) {Object}
  //   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify a read-only editor.
  indent(options = {}) {
    if (!this.ensureWritable('indent', options)) return;
    if (options.autoIndent == null)
      options.autoIndent = this.shouldAutoIndent();
    this.mutateSelectedText(selection => selection.indent(options));
  }

  // Constructs the string used for indents.
  buildIndentString(level, column = 0) {
    if (this.getSoftTabs()) {
      const tabStopViolation = column % this.getTabLength();
      return _.multiplyString(
        ' ',
        Math.floor(level * this.getTabLength()) - tabStopViolation
      );
    } else {
      const excessWhitespace = _.multiplyString(
        ' ',
        Math.round((level - Math.floor(level)) * this.getTabLength())
      );
      return _.multiplyString('\t', Math.floor(level)) + excessWhitespace;
    }
  }

  /*
  Section: Grammars
  */

  // Essential: Get the current {Grammar} of this editor.
  getGrammar() {
    const languageMode = this.buffer.getLanguageMode();
    return (
      (languageMode.getGrammar && languageMode.getGrammar()) || NullGrammar
    );
  }

  // Deprecated: Set the current {Grammar} of this editor.
  //
  // Assigning a grammar will cause the editor to re-tokenize based on the new
  // grammar.
  //
  // * `grammar` {Grammar}
  setGrammar(grammar) {
    const buffer = this.getBuffer();
    buffer.setLanguageMode(
      atom.grammars.languageModeForGrammarAndBuffer(grammar, buffer)
    );
  }

  // Experimental: Get a notification when async tokenization is completed.
  onDidTokenize(callback) {
    return this.emitter.on('did-tokenize', callback);
  }

  /*
  Section: Managing Syntax Scopes
  */

  // Essential: Returns a {ScopeDescriptor} that includes this editor's language.
  // e.g. `['.source.ruby']`, or `['.source.coffee']`. You can use this with
  // {Config::get} to get language specific config values.
  getRootScopeDescriptor() {
    return this.buffer.getLanguageMode().rootScopeDescriptor;
  }

  // Essential: Get the syntactic {ScopeDescriptor} for the given position in buffer
  // coordinates. Useful with {Config::get}.
  //
  // For example, if called with a position inside the parameter list of an
  // anonymous CoffeeScript function, this method returns a {ScopeDescriptor} with
  // the following scopes array:
  // `["source.coffee", "meta.function.inline.coffee", "meta.parameters.coffee", "variable.parameter.function.coffee"]`
  //
  // * `bufferPosition` A {Point} or {Array} of `[row, column]`.
  //
  // Returns a {ScopeDescriptor}.
  scopeDescriptorForBufferPosition(bufferPosition) {
    const languageMode = this.buffer.getLanguageMode();
    return languageMode.scopeDescriptorForPosition
      ? languageMode.scopeDescriptorForPosition(bufferPosition)
      : new ScopeDescriptor({ scopes: ['text'] });
  }

  // Essential: Get the syntactic tree {ScopeDescriptor} for the given position in buffer
  // coordinates or the syntactic {ScopeDescriptor} for TextMate language mode
  //
  // For example, if called with a position inside the parameter list of a
  // JavaScript class function, this method returns a {ScopeDescriptor} with
  // the following syntax nodes array:
  // `["source.js", "program", "expression_statement", "assignment_expression", "class", "class_body", "method_definition", "formal_parameters", "identifier"]`
  // if tree-sitter is used
  // and the following scopes array:
  // `["source.js"]`
  // if textmate is used
  //
  // * `bufferPosition` A {Point} or {Array} of `[row, column]`.
  //
  // Returns a {ScopeDescriptor}.
  syntaxTreeScopeDescriptorForBufferPosition(bufferPosition) {
    const languageMode = this.buffer.getLanguageMode();
    return languageMode.syntaxTreeScopeDescriptorForPosition
      ? languageMode.syntaxTreeScopeDescriptorForPosition(bufferPosition)
      : this.scopeDescriptorForBufferPosition(bufferPosition);
  }

  // Extended: Get the range in buffer coordinates of all tokens surrounding the
  // cursor that match the given scope selector.
  //
  // For example, if you wanted to find the string surrounding the cursor, you
  // could call `editor.bufferRangeForScopeAtCursor(".string.quoted")`.
  //
  // * `scopeSelector` {String} selector. e.g. `'.source.ruby'`
  //
  // Returns a {Range}.
  bufferRangeForScopeAtCursor(scopeSelector) {
    return this.bufferRangeForScopeAtPosition(
      scopeSelector,
      this.getCursorBufferPosition()
    );
  }

  // Extended: Get the range in buffer coordinates of all tokens surrounding the
  // given position in buffer coordinates that match the given scope selector.
  //
  // For example, if you wanted to find the string surrounding the cursor, you
  // could call `editor.bufferRangeForScopeAtPosition(".string.quoted", this.getCursorBufferPosition())`.
  //
  // * `scopeSelector` {String} selector. e.g. `'.source.ruby'`
  // * `bufferPosition` A {Point} or {Array} of [row, column]
  //
  // Returns a {Range}.
  bufferRangeForScopeAtPosition(scopeSelector, bufferPosition) {
    return this.buffer
      .getLanguageMode()
      .bufferRangeForScopeAtPosition(scopeSelector, bufferPosition);
  }

  // Extended: Determine if the given row is entirely a comment
  isBufferRowCommented(bufferRow) {
    const match = this.lineTextForBufferRow(bufferRow).match(/\S/);
    if (match) {
      if (!this.commentScopeSelector)
        this.commentScopeSelector = new TextMateScopeSelector('comment.*');
      return this.commentScopeSelector.matches(
        this.scopeDescriptorForBufferPosition([bufferRow, match.index]).scopes
      );
    }
  }

  // Get the scope descriptor at the cursor.
  getCursorScope() {
    return this.getLastCursor().getScopeDescriptor();
  }

  // Get the syntax nodes at the cursor.
  getCursorSyntaxTreeScope() {
    return this.getLastCursor().getSyntaxTreeScopeDescriptor();
  }

  tokenForBufferPosition(bufferPosition) {
    return this.buffer.getLanguageMode().tokenForPosition(bufferPosition);
  }

  /*
  Section: Clipboard Operations
  */

  // Essential: For each selection, copy the selected text.
  copySelectedText() {
    let maintainClipboard = false;
    for (let selection of this.getSelectionsOrderedByBufferPosition()) {
      if (selection.isEmpty()) {
        const previousRange = selection.getBufferRange();
        selection.selectLine();
        selection.copy(maintainClipboard, true);
        selection.setBufferRange(previousRange);
      } else {
        selection.copy(maintainClipboard, false);
      }
      maintainClipboard = true;
    }
  }

  // Private: For each selection, only copy highlighted text.
  copyOnlySelectedText() {
    let maintainClipboard = false;
    for (let selection of this.getSelectionsOrderedByBufferPosition()) {
      if (!selection.isEmpty()) {
        selection.copy(maintainClipboard, false);
        maintainClipboard = true;
      }
    }
  }

  // Essential: For each selection, cut the selected text.
  //
  // * `options` (optional) {Object}
  //   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify a read-only editor.
  cutSelectedText(options = {}) {
    if (!this.ensureWritable('cutSelectedText', options)) return;
    let maintainClipboard = false;
    this.mutateSelectedText(selection => {
      if (selection.isEmpty()) {
        selection.selectLine();
        selection.cut(maintainClipboard, true, options.bypassReadOnly);
      } else {
        selection.cut(maintainClipboard, false, options.bypassReadOnly);
      }
      maintainClipboard = true;
    });
  }

  // Essential: For each selection, replace the selected text with the contents of
  // the clipboard.
  //
  // If the clipboard contains the same number of selections as the current
  // editor, each selection will be replaced with the content of the
  // corresponding clipboard selection text.
  //
  // * `options` (optional) See {Selection::insertText}.
  pasteText(options = {}) {
    if (!this.ensureWritable('parseText', options)) return;
    options = Object.assign({}, options);
    let {
      text: clipboardText,
      metadata
    } = this.constructor.clipboard.readWithMetadata();
    if (!this.emitWillInsertTextEvent(clipboardText)) return false;
    let languageMode = this.buffer.getLanguageMode();

    if (!metadata) metadata = {};
    if (options.autoIndent == null)
      options.autoIndent = this.shouldAutoIndentOnPaste();

    this.mutateSelectedText((selection, index) => {
      let fullLine, indentBasis, text;
      if (
        metadata.selections &&
        metadata.selections.length === this.getSelections().length
      ) {
        ({ text, indentBasis, fullLine } = metadata.selections[index]);
      } else {
        ({ indentBasis, fullLine } = metadata);
        text = clipboardText;
      }

      if (
        indentBasis != null &&
        (text.includes('\n') ||
          !selection.cursor.hasPrecedingCharactersOnLine())
      ) {
        options.indentBasis = indentBasis;
      } else {
        options.indentBasis = null;
      }

      let range;
      if (fullLine && selection.isEmpty()) {
        const oldPosition = selection.getBufferRange().start;
        selection.setBufferRange([[oldPosition.row, 0], [oldPosition.row, 0]]);
        range = selection.insertText(text, options);
        const newPosition = oldPosition.translate([1, 0]);
        selection.setBufferRange([newPosition, newPosition]);
      } else {
        range = selection.insertText(text, options);
      }

      if (languageMode.atTransactionEnd && options.autoIndent && text.includes('\n')) {
        // The `autoIndent` option as passed to `Selection#insertText` has no
        // effect in `WASMTreeSitterLanguageMode` because it asks what the
        // right indent level would be for the given text _before_ inserting
        // it, and that question can't be answered because the text isn't part
        // of the buffer yet and can't be parsed.
        //
        // The good news is that we can wait until the transaction's done;
        // we'll know the extent of the buffer involved in the paste, so we can
        // auto-indent those rows once they're in the buffer and reflected in
        // the parse tree. This also lets us defer the `did-insert-text` event
        // until the auto-indent happens, so that the event metadata is more
        // accurate.
        //
        // We can also use this technique to format text as required by the
        // `editor:paste-without-reformatting` command. Instead of
        // getting the suggested indent level for each row of the pasted text,
        // we get the suggested indent level of the first row, then alter each
        // succeeding row's level by the same amount.
        //
        languageMode.atTransactionEnd().then(({ range }) => {
          let marker = this.markBufferRange(range);
          let endRow = range.end.row;
          // A range that ends on column 0 of a given row doesn't actually
          // touch that row.
          if (range.end.column === 0) endRow--;
          let checkpoint = this.buffer.createCheckpoint();
          this.autoIndentBufferRows(
            range.start.row,
            endRow,
            { ...options, isPastedText: true }
          );
          // Detect whether the buffer actually changed. If it did, fold that
          // change into the previous history entry.
          if (this.buffer.getChangesSinceCheckpoint(checkpoint).length > 0) {
            this.buffer.groupLastChanges();
          }

          range = marker.getBufferRange();
          text = this.buffer.getTextInRange(range);
          this.emitter.emit('did-insert-text', { text, range });
        });
      } else {
        this.emitter.emit('did-insert-text', { text, range });
      }
    });
  }

  // Essential: For each selection, if the selection is empty, cut all characters
  // of the containing screen line following the cursor. Otherwise cut the selected
  // text.
  //
  // * `options` (optional) {Object}
  //   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify a read-only editor.
  cutToEndOfLine(options = {}) {
    if (!this.ensureWritable('cutToEndOfLine', options)) return;
    let maintainClipboard = false;
    this.mutateSelectedText(selection => {
      selection.cutToEndOfLine(maintainClipboard, options);
      maintainClipboard = true;
    });
  }

  // Essential: For each selection, if the selection is empty, cut all characters
  // of the containing buffer line following the cursor. Otherwise cut the
  // selected text.
  //
  // * `options` (optional) {Object}
  //   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify a read-only editor.
  cutToEndOfBufferLine(options = {}) {
    if (!this.ensureWritable('cutToEndOfBufferLine', options)) return;
    let maintainClipboard = false;
    this.mutateSelectedText(selection => {
      selection.cutToEndOfBufferLine(maintainClipboard, options);
      maintainClipboard = true;
    });
  }

  /*
  Section: Folds
  */

  // Essential: Fold the most recent cursor's row based on its indentation level.
  //
  // The fold will extend from the nearest preceding line with a lower
  // indentation level up to the nearest following row with a lower indentation
  // level.
  foldCurrentRow() {
    const { row } = this.getCursorBufferPosition();
    const languageMode = this.buffer.getLanguageMode();
    const range =
      languageMode.getFoldableRangeContainingPoint &&
      languageMode.getFoldableRangeContainingPoint(
        Point(row, Infinity),
        this.getTabLength()
      );
    if (range) return this.displayLayer.foldBufferRange(range);
  }

  // Essential: Unfold the most recent cursor's row by one level.
  unfoldCurrentRow() {
    const { row } = this.getCursorBufferPosition();
    return this.displayLayer.destroyFoldsContainingBufferPositions(
      [Point(row, Infinity)],
      false
    );
  }

  // Essential: Fold the given row in buffer coordinates based on its indentation
  // level.
  //
  // If the given row is foldable, the fold will begin there. Otherwise, it will
  // begin at the first foldable row preceding the given row.
  //
  // * `bufferRow` A {Number}.
  foldBufferRow(bufferRow) {
    let position = Point(bufferRow, Infinity);
    const languageMode = this.buffer.getLanguageMode();
    while (true) {
      const foldableRange =
        languageMode.getFoldableRangeContainingPoint &&
        languageMode.getFoldableRangeContainingPoint(
          position,
          this.getTabLength()
        );
      if (foldableRange) {
        const existingFolds = this.displayLayer.foldsIntersectingBufferRange(
          Range(foldableRange.start, foldableRange.start)
        );
        if (existingFolds.length === 0) {
          this.displayLayer.foldBufferRange(foldableRange);
        } else {
          const firstExistingFoldRange = this.displayLayer.bufferRangeForFold(
            existingFolds[0]
          );
          if (firstExistingFoldRange.start.isLessThan(position)) {
            position = Point(firstExistingFoldRange.start.row, 0);
            continue;
          }
        }
      }
      break;
    }
  }

  // Essential: Unfold all folds containing the given row in buffer coordinates.
  //
  // * `bufferRow` A {Number}
  unfoldBufferRow(bufferRow) {
    const position = Point(bufferRow, Infinity);
    return this.displayLayer.destroyFoldsContainingBufferPositions([position]);
  }

  // Extended: For each selection, fold the rows it intersects.
  foldSelectedLines() {
    for (let selection of this.selections) {
      selection.fold();
    }
  }

  // Extended: Fold all foldable lines.
  foldAll() {
    const languageMode = this.buffer.getLanguageMode();
    const foldableRanges =
      languageMode.getFoldableRanges &&
      languageMode.getFoldableRanges(this.getTabLength());
    this.displayLayer.destroyAllFolds();
    for (let range of foldableRanges || []) {
      this.displayLayer.foldBufferRange(range);
    }
  }

  // Extended: Unfold all existing folds.
  unfoldAll() {
    const result = this.displayLayer.destroyAllFolds();
    if (result.length > 0) this.scrollToCursorPosition();
    return result;
  }

  // Extended: Fold all foldable lines at the given indent level.
  //
  // * `level` A {Number} starting at 0.
  foldAllAtIndentLevel(level) {
    const languageMode = this.buffer.getLanguageMode();
    const foldableRanges =
      languageMode.getFoldableRangesAtIndentLevel &&
      languageMode.getFoldableRangesAtIndentLevel(level, this.getTabLength());
    this.displayLayer.destroyAllFolds();
    for (let range of foldableRanges || []) {
      this.displayLayer.foldBufferRange(range);
    }
  }

  // Extended: Determine whether the given row in buffer coordinates is foldable.
  //
  // A *foldable* row is a row that *starts* a row range that can be folded.
  //
  // * `bufferRow` A {Number}
  //
  // Returns a {Boolean}.
  isFoldableAtBufferRow(bufferRow) {
    const languageMode = this.buffer.getLanguageMode();
    return (
      languageMode.isFoldableAtRow && languageMode.isFoldableAtRow(bufferRow)
    );
  }

  // Extended: Determine whether the given row in screen coordinates is foldable.
  //
  // A *foldable* row is a row that *starts* a row range that can be folded.
  //
  // * `bufferRow` A {Number}
  //
  // Returns a {Boolean}.
  isFoldableAtScreenRow(screenRow) {
    return this.isFoldableAtBufferRow(this.bufferRowForScreenRow(screenRow));
  }

  // Extended: Fold the given buffer row if it isn't currently folded, and unfold
  // it otherwise.
  toggleFoldAtBufferRow(bufferRow) {
    if (this.isFoldedAtBufferRow(bufferRow)) {
      return this.unfoldBufferRow(bufferRow);
    } else {
      return this.foldBufferRow(bufferRow);
    }
  }

  // Extended: Determine whether the most recently added cursor's row is folded.
  //
  // Returns a {Boolean}.
  isFoldedAtCursorRow() {
    return this.isFoldedAtBufferRow(this.getCursorBufferPosition().row);
  }

  // Extended: Determine whether the given row in buffer coordinates is folded.
  //
  // * `bufferRow` A {Number}
  //
  // Returns a {Boolean}.
  isFoldedAtBufferRow(bufferRow) {
    const range = Range(
      Point(bufferRow, 0),
      Point(bufferRow, this.buffer.lineLengthForRow(bufferRow))
    );
    return this.displayLayer.foldsIntersectingBufferRange(range).length > 0;
  }

  // Extended: Determine whether the given row in screen coordinates is folded.
  //
  // * `screenRow` A {Number}
  //
  // Returns a {Boolean}.
  isFoldedAtScreenRow(screenRow) {
    return this.isFoldedAtBufferRow(this.bufferRowForScreenRow(screenRow));
  }

  // Creates a new fold between two row numbers.
  //
  // startRow - The row {Number} to start folding at
  // endRow - The row {Number} to end the fold
  //
  // Returns the new {Fold}.
  foldBufferRowRange(startRow, endRow) {
    return this.foldBufferRange(
      Range(Point(startRow, Infinity), Point(endRow, Infinity))
    );
  }

  foldBufferRange(range) {
    return this.displayLayer.foldBufferRange(range);
  }

  // Remove any {Fold}s found that intersect the given buffer range.
  destroyFoldsIntersectingBufferRange(bufferRange) {
    return this.displayLayer.destroyFoldsIntersectingBufferRange(bufferRange);
  }

  // Remove any {Fold}s found that contain the given array of buffer positions.
  destroyFoldsContainingBufferPositions(bufferPositions, excludeEndpoints) {
    return this.displayLayer.destroyFoldsContainingBufferPositions(
      bufferPositions,
      excludeEndpoints
    );
  }

  /*
  Section: Gutters
  */

  // Essential: Add a custom {Gutter}.
  //
  // * `options` An {Object} with the following fields:
  //   * `name` (required) A unique {String} to identify this gutter.
  //   * `priority` (optional) A {Number} that determines stacking order between
  //       gutters. Lower priority items are forced closer to the edges of the
  //       window. (default: -100)
  //   * `visible` (optional) {Boolean} specifying whether the gutter is visible
  //       initially after being created. (default: true)
  //   * `type` (optional) {String} specifying the type of gutter to create. `'decorated'`
  //       gutters are useful as a destination for decorations created with {Gutter::decorateMarker}.
  //       `'line-number'` gutters.
  //   * `class` (optional) {String} added to the CSS classnames of the gutter's root DOM element.
  //   * `labelFn` (optional) {Function} called by a `'line-number'` gutter to generate the label for each line number
  //       element. Should return a {String} that will be used to label the corresponding line.
  //     * `lineData` an {Object} containing information about each line to label.
  //       * `bufferRow` {Number} indicating the zero-indexed buffer index of this line.
  //       * `screenRow` {Number} indicating the zero-indexed screen index.
  //       * `foldable` {Boolean} that is `true` if a fold may be created here.
  //       * `softWrapped` {Boolean} if this screen row is the soft-wrapped continuation of the same buffer row.
  //       * `maxDigits` {Number} the maximum number of digits necessary to represent any known screen row.
  //   * `onMouseDown` (optional) {Function} to be called when a mousedown event is received by a line-number
  //        element within this `type: 'line-number'` {Gutter}. If unspecified, the default behavior is to select the
  //        clicked buffer row.
  //     * `lineData` an {Object} containing information about the line that's being clicked.
  //       * `bufferRow` {Number} of the originating line element
  //       * `screenRow` {Number}
  //   * `onMouseMove` (optional) {Function} to be called when a mousemove event occurs on a line-number element within
  //        within this `type: 'line-number'` {Gutter}.
  //     * `lineData` an {Object} containing information about the line that's being clicked.
  //       * `bufferRow` {Number} of the originating line element
  //       * `screenRow` {Number}
  //
  // Returns the newly-created {Gutter}.
  addGutter(options) {
    return this.gutterContainer.addGutter(options);
  }

  // Essential: Get this editor's gutters.
  //
  // Returns an {Array} of {Gutter}s.
  getGutters() {
    return this.gutterContainer.getGutters();
  }

  getLineNumberGutter() {
    return this.lineNumberGutter;
  }

  // Essential: Get the gutter with the given name.
  //
  // Returns a {Gutter}, or `null` if no gutter exists for the given name.
  gutterWithName(name) {
    return this.gutterContainer.gutterWithName(name);
  }

  /*
  Section: Scrolling the TextEditor
  */

  // Essential: Scroll the editor to reveal the most recently added cursor if it is
  // off-screen.
  //
  // * `options` (optional) {Object}
  //   * `center` Center the editor around the cursor if possible. (default: true)
  scrollToCursorPosition(options) {
    this.getLastCursor().autoscroll({
      center: options && options.center !== false
    });
  }

  // Essential: Scrolls the editor to the given buffer position.
  //
  // * `bufferPosition` An object that represents a buffer position. It can be either
  //   an {Object} (`{row, column}`), {Array} (`[row, column]`), or {Point}
  // * `options` (optional) {Object}
  //   * `center` Center the editor around the position if possible. (default: false)
  scrollToBufferPosition(bufferPosition, options) {
    return this.scrollToScreenPosition(
      this.screenPositionForBufferPosition(bufferPosition),
      options
    );
  }

  // Essential: Scrolls the editor to the given screen position.
  //
  // * `screenPosition` An object that represents a screen position. It can be either
  //    an {Object} (`{row, column}`), {Array} (`[row, column]`), or {Point}
  // * `options` (optional) {Object}
  //   * `center` Center the editor around the position if possible. (default: false)
  scrollToScreenPosition(screenPosition, options) {
    this.scrollToScreenRange(
      new Range(screenPosition, screenPosition),
      options
    );
  }

  scrollToTop() {
    Grim.deprecate(
      'This is now a view method. Call TextEditorElement::scrollToTop instead.'
    );
    this.getElement().scrollToTop();
  }

  scrollToBottom() {
    Grim.deprecate(
      'This is now a view method. Call TextEditorElement::scrollToTop instead.'
    );
    this.getElement().scrollToBottom();
  }

  scrollToScreenRange(screenRange, options = {}) {
    if (options.clip !== false) screenRange = this.clipScreenRange(screenRange);
    const scrollEvent = { screenRange, options };
    if (this.component) this.component.didRequestAutoscroll(scrollEvent);
    this.emitter.emit('did-request-autoscroll', scrollEvent);
  }

  getHorizontalScrollbarHeight() {
    Grim.deprecate(
      'This is now a view method. Call TextEditorElement::getHorizontalScrollbarHeight instead.'
    );
    return this.getElement().getHorizontalScrollbarHeight();
  }

  getVerticalScrollbarWidth() {
    Grim.deprecate(
      'This is now a view method. Call TextEditorElement::getVerticalScrollbarWidth instead.'
    );
    return this.getElement().getVerticalScrollbarWidth();
  }

  pageUp() {
    this.moveUp(this.getRowsPerPage());
  }

  pageDown() {
    this.moveDown(this.getRowsPerPage());
  }

  selectPageUp() {
    this.selectUp(this.getRowsPerPage());
  }

  selectPageDown() {
    this.selectDown(this.getRowsPerPage());
  }

  // Returns the number of rows per page
  getRowsPerPage() {
    if (this.component) {
      const clientHeight = this.component.getScrollContainerClientHeight();
      const lineHeight = this.component.getLineHeight();
      return Math.max(1, Math.ceil(clientHeight / lineHeight));
    } else {
      return 1;
    }
  }

  /*
  Section: Config
  */

  // Experimental: Is auto-indentation enabled for this editor?
  //
  // Returns a {Boolean}.
  shouldAutoIndent() {
    return this.autoIndent;
  }

  // Experimental: Is auto-indentation on paste enabled for this editor?
  //
  // Returns a {Boolean}.
  shouldAutoIndentOnPaste() {
    return this.autoIndentOnPaste;
  }

  // Experimental: Does this editor allow scrolling past the last line?
  //
  // Returns a {Boolean}.
  getScrollPastEnd() {
    if (this.getAutoHeight()) {
      return false;
    } else {
      return this.scrollPastEnd;
    }
  }

  // Experimental: How fast does the editor scroll in response to mouse wheel
  // movements?
  //
  // Returns a positive {Number}.
  getScrollSensitivity() {
    return this.scrollSensitivity;
  }

  // Experimental: Does this editor show cursors while there is a selection?
  //
  // Returns a positive {Boolean}.
  getShowCursorOnSelection() {
    return this.showCursorOnSelection;
  }

  // Experimental: Are line numbers enabled for this editor?
  //
  // Returns a {Boolean}
  doesShowLineNumbers() {
    return this.showLineNumbers;
  }

  // Experimental: Get the time interval within which text editing operations
  // are grouped together in the editor's undo history.
  //
  // Returns the time interval {Number} in milliseconds.
  getUndoGroupingInterval() {
    return this.undoGroupingInterval;
  }

  // Experimental: Get the characters that are *not* considered part of words,
  // for the purpose of word-based cursor movements.
  //
  // Returns a {String} containing the non-word characters.
  getNonWordCharacters(position) {
    const languageMode = this.buffer.getLanguageMode();
    return (
      (languageMode.getNonWordCharacters &&
        languageMode.getNonWordCharacters(position || Point(0, 0))) ||
      DEFAULT_NON_WORD_CHARACTERS
    );
  }

  /*
  Section: Event Handlers
  */

  handleLanguageModeChange() {
    this.unfoldAll();
    if (this.languageModeSubscription) {
      this.languageModeSubscription.dispose();
      this.disposables.remove(this.languageModeSubscription);
    }
    const languageMode = this.buffer.getLanguageMode();

    if (
      this.component &&
      this.component.visible &&
      languageMode.startTokenizing
    ) {
      languageMode.startTokenizing();
    }
    this.languageModeSubscription =
      languageMode.onDidTokenize &&
      languageMode.onDidTokenize(() => {
        this.emitter.emit('did-tokenize');
      });
    if (this.languageModeSubscription)
      this.disposables.add(this.languageModeSubscription);
    this.emitter.emit('did-change-grammar', languageMode.grammar);
  }

  /*
  Section: TextEditor Rendering
  */

  // Get the Element for the editor.
  getElement() {
    if (!this.component) {
      if (!TextEditorComponent)
        TextEditorComponent = require('./text-editor-component');
      if (!TextEditorElement)
        TextEditorElement = require('./text-editor-element');
      this.component = new TextEditorComponent({
        model: this,
        updatedSynchronously: TextEditorElement.prototype.updatedSynchronously,
        initialScrollTopRow: this.initialScrollTopRow,
        initialScrollLeftColumn: this.initialScrollLeftColumn
      });
    }
    return this.component.element;
  }

  getAllowedLocations() {
    return ['center'];
  }

  // Essential: Retrieves the greyed out placeholder of a mini editor.
  //
  // Returns a {String}.
  getPlaceholderText() {
    return this.placeholderText;
  }

  // Essential: Set the greyed out placeholder of a mini editor. Placeholder text
  // will be displayed when the editor has no content.
  //
  // * `placeholderText` {String} text that is displayed when the editor has no content.
  setPlaceholderText(placeholderText) {
    this.updatePlaceholderText(placeholderText, true);
  }

  pixelPositionForBufferPosition(bufferPosition) {
    Grim.deprecate(
      'This method is deprecated on the model layer. Use `TextEditorElement::pixelPositionForBufferPosition` instead'
    );
    return this.getElement().pixelPositionForBufferPosition(bufferPosition);
  }

  pixelPositionForScreenPosition(screenPosition) {
    Grim.deprecate(
      'This method is deprecated on the model layer. Use `TextEditorElement::pixelPositionForScreenPosition` instead'
    );
    return this.getElement().pixelPositionForScreenPosition(screenPosition);
  }

  getVerticalScrollMargin() {
    const maxScrollMargin = Math.floor(
      (this.height / this.getLineHeightInPixels() - 1) / 2
    );
    return Math.min(this.verticalScrollMargin, maxScrollMargin);
  }

  setVerticalScrollMargin(verticalScrollMargin) {
    this.verticalScrollMargin = verticalScrollMargin;
    return this.verticalScrollMargin;
  }

  getHorizontalScrollMargin() {
    return Math.min(
      this.horizontalScrollMargin,
      Math.floor((this.width / this.getDefaultCharWidth() - 1) / 2)
    );
  }
  setHorizontalScrollMargin(horizontalScrollMargin) {
    this.horizontalScrollMargin = horizontalScrollMargin;
    return this.horizontalScrollMargin;
  }

  getLineHeightInPixels() {
    return this.lineHeightInPixels;
  }
  setLineHeightInPixels(lineHeightInPixels) {
    this.lineHeightInPixels = lineHeightInPixels;
    return this.lineHeightInPixels;
  }

  getKoreanCharWidth() {
    return this.koreanCharWidth;
  }
  getHalfWidthCharWidth() {
    return this.halfWidthCharWidth;
  }
  getDoubleWidthCharWidth() {
    return this.doubleWidthCharWidth;
  }
  getDefaultCharWidth() {
    return this.defaultCharWidth;
  }

  ratioForCharacter(character) {
    if (isKoreanCharacter(character)) {
      return this.getKoreanCharWidth() / this.getDefaultCharWidth();
    } else if (isHalfWidthCharacter(character)) {
      return this.getHalfWidthCharWidth() / this.getDefaultCharWidth();
    } else if (isDoubleWidthCharacter(character)) {
      return this.getDoubleWidthCharWidth() / this.getDefaultCharWidth();
    } else {
      return 1;
    }
  }

  setDefaultCharWidth(
    defaultCharWidth,
    doubleWidthCharWidth,
    halfWidthCharWidth,
    koreanCharWidth
  ) {
    if (doubleWidthCharWidth == null) {
      doubleWidthCharWidth = defaultCharWidth;
    }
    if (halfWidthCharWidth == null) {
      halfWidthCharWidth = defaultCharWidth;
    }
    if (koreanCharWidth == null) {
      koreanCharWidth = defaultCharWidth;
    }
    if (
      defaultCharWidth !== this.defaultCharWidth ||
      (doubleWidthCharWidth !== this.doubleWidthCharWidth &&
        halfWidthCharWidth !== this.halfWidthCharWidth &&
        koreanCharWidth !== this.koreanCharWidth)
    ) {
      this.defaultCharWidth = defaultCharWidth;
      this.doubleWidthCharWidth = doubleWidthCharWidth;
      this.halfWidthCharWidth = halfWidthCharWidth;
      this.koreanCharWidth = koreanCharWidth;
      if (this.isSoftWrapped()) {
        this.displayLayer.reset({
          softWrapColumn: this.getSoftWrapColumn()
        });
      }
    }
    return defaultCharWidth;
  }

  setHeight(height) {
    Grim.deprecate(
      'This is now a view method. Call TextEditorElement::setHeight instead.'
    );
    this.getElement().setHeight(height);
  }

  getHeight() {
    Grim.deprecate(
      'This is now a view method. Call TextEditorElement::getHeight instead.'
    );
    return this.getElement().getHeight();
  }

  getAutoHeight() {
    return this.autoHeight != null ? this.autoHeight : true;
  }

  getAutoWidth() {
    return this.autoWidth != null ? this.autoWidth : false;
  }

  setWidth(width) {
    Grim.deprecate(
      'This is now a view method. Call TextEditorElement::setWidth instead.'
    );
    this.getElement().setWidth(width);
  }

  getWidth() {
    Grim.deprecate(
      'This is now a view method. Call TextEditorElement::getWidth instead.'
    );
    return this.getElement().getWidth();
  }

  // Use setScrollTopRow instead of this method
  setFirstVisibleScreenRow(screenRow) {
    this.setScrollTopRow(screenRow);
  }

  getFirstVisibleScreenRow() {
    return this.getElement().component.getFirstVisibleRow();
  }

  getLastVisibleScreenRow() {
    return this.getElement().component.getLastVisibleRow();
  }

  getVisibleRowRange() {
    return [this.getFirstVisibleScreenRow(), this.getLastVisibleScreenRow()];
  }

  // Use setScrollLeftColumn instead of this method
  setFirstVisibleScreenColumn(column) {
    return this.setScrollLeftColumn(column);
  }

  getFirstVisibleScreenColumn() {
    return this.getElement().component.getFirstVisibleColumn();
  }

  getScrollTop() {
    Grim.deprecate(
      'This is now a view method. Call TextEditorElement::getScrollTop instead.'
    );
    return this.getElement().getScrollTop();
  }

  setScrollTop(scrollTop) {
    Grim.deprecate(
      'This is now a view method. Call TextEditorElement::setScrollTop instead.'
    );
    this.getElement().setScrollTop(scrollTop);
  }

  getScrollBottom() {
    Grim.deprecate(
      'This is now a view method. Call TextEditorElement::getScrollBottom instead.'
    );
    return this.getElement().getScrollBottom();
  }

  setScrollBottom(scrollBottom) {
    Grim.deprecate(
      'This is now a view method. Call TextEditorElement::setScrollBottom instead.'
    );
    this.getElement().setScrollBottom(scrollBottom);
  }

  getScrollLeft() {
    Grim.deprecate(
      'This is now a view method. Call TextEditorElement::getScrollLeft instead.'
    );
    return this.getElement().getScrollLeft();
  }

  setScrollLeft(scrollLeft) {
    Grim.deprecate(
      'This is now a view method. Call TextEditorElement::setScrollLeft instead.'
    );
    this.getElement().setScrollLeft(scrollLeft);
  }

  getScrollRight() {
    Grim.deprecate(
      'This is now a view method. Call TextEditorElement::getScrollRight instead.'
    );
    return this.getElement().getScrollRight();
  }

  setScrollRight(scrollRight) {
    Grim.deprecate(
      'This is now a view method. Call TextEditorElement::setScrollRight instead.'
    );
    this.getElement().setScrollRight(scrollRight);
  }

  getScrollHeight() {
    Grim.deprecate(
      'This is now a view method. Call TextEditorElement::getScrollHeight instead.'
    );
    return this.getElement().getScrollHeight();
  }

  getScrollWidth() {
    Grim.deprecate(
      'This is now a view method. Call TextEditorElement::getScrollWidth instead.'
    );
    return this.getElement().getScrollWidth();
  }

  getMaxScrollTop() {
    Grim.deprecate(
      'This is now a view method. Call TextEditorElement::getMaxScrollTop instead.'
    );
    return this.getElement().getMaxScrollTop();
  }

  getScrollTopRow() {
    return this.getElement().component.getScrollTopRow();
  }

  setScrollTopRow(scrollTopRow) {
    this.getElement().component.setScrollTopRow(scrollTopRow);
  }

  getScrollLeftColumn() {
    return this.getElement().component.getScrollLeftColumn();
  }

  setScrollLeftColumn(scrollLeftColumn) {
    this.getElement().component.setScrollLeftColumn(scrollLeftColumn);
  }

  intersectsVisibleRowRange(startRow, endRow) {
    Grim.deprecate(
      'This is now a view method. Call TextEditorElement::intersectsVisibleRowRange instead.'
    );
    return this.getElement().intersectsVisibleRowRange(startRow, endRow);
  }

  selectionIntersectsVisibleRowRange(selection) {
    Grim.deprecate(
      'This is now a view method. Call TextEditorElement::selectionIntersectsVisibleRowRange instead.'
    );
    return this.getElement().selectionIntersectsVisibleRowRange(selection);
  }

  screenPositionForPixelPosition(pixelPosition) {
    Grim.deprecate(
      'This is now a view method. Call TextEditorElement::screenPositionForPixelPosition instead.'
    );
    return this.getElement().screenPositionForPixelPosition(pixelPosition);
  }

  pixelRectForScreenRange(screenRange) {
    Grim.deprecate(
      'This is now a view method. Call TextEditorElement::pixelRectForScreenRange instead.'
    );
    return this.getElement().pixelRectForScreenRange(screenRange);
  }

  /*
  Section: Utility
  */

  inspect() {
    return `<TextEditor ${this.id}>`;
  }

  emitWillInsertTextEvent(text) {
    let result = true;
    const cancel = () => {
      result = false;
    };
    this.emitter.emit('will-insert-text', { cancel, text });
    return result;
  }

  /*
  Section: Language Mode Delegated Methods
  */

  suggestedIndentForBufferRow(bufferRow, options) {
    const languageMode = this.buffer.getLanguageMode();
    return (
      languageMode.suggestedIndentForBufferRow &&
      languageMode.suggestedIndentForBufferRow(
        bufferRow,
        this.getTabLength(),
        options
      )
    );
  }

  // Given a buffer row, indent it.
  //
  // * bufferRow - The row {Number}.
  // * options - An options {Object} to pass through to {TextEditor::setIndentationForBufferRow}.
  autoIndentBufferRow(bufferRow, options) {
    const indentLevel = this.suggestedIndentForBufferRow(bufferRow, options);
    if (indentLevel?.then) {
      // The language mode may go async if it can't answer our question
      // immediately. If it fulfills with a number, that's our indent level. If
      // it fulfills with `undefined`, it means it couldn't give us an answer
      // because of further changes in the same transaction, meaning we should
      // schedule an auto-indent for the entire range affected by the
      // transaction.
      indentLevel.then(indentLevel => {
        if (typeof indentLevel === 'number') {
          this.setIndentationForBufferRow(bufferRow, indentLevel, options);
          this.buffer.groupLastChanges();
        } else if (indentLevel === undefined) {
          this.scheduleIndentAdjustment(true);
        }
      });
    } else if (typeof indentLevel === 'number') {
      return this.setIndentationForBufferRow(bufferRow, indentLevel, options);
    }
  }

  // Indents all the rows between two buffer row numbers.
  //
  // * startRow - The row {Number} to start at
  // * endRow - The row {Number} to end at
  autoIndentBufferRows(startRow, endRow, options = {}) {
    const languageMode = this.buffer.getLanguageMode();
    let lastRowIndented = startRow - 1;
    if (languageMode.suggestedIndentForBufferRows) {
      // In tree-sitter mode, we are fortunate that this command will only ever
      // be called at the ends of transactions, when the parse tree is clean.
      // But that's also why we should try to auto-indent this whole range
      // atomically. Compared to the naive version below, on a hypothetical
      // ten-line range, this will result in only one tree re-parse (after
      // we're done) rather than ten.
      let indents = languageMode.suggestedIndentForBufferRows(
        startRow, endRow, this.getTabLength(), options);

      // The language mode may not be able to indent the whole block
      // atomically. If not, we'll indent as much as we're able, then fall back
      // to the costlier approach.
      if (indents !== null) {
        this.transact(() => {
          for (let [row, indent] of indents) {
            this.setIndentationForBufferRow(row, indent);
            lastRowIndented = row;
          }
        });
        if (lastRowIndented === endRow) { return; }
      }

      if (options.isPastedText) {
        // With this option enabled, if we reach this point, it means that
        // `indents` is `null`, or somehow gave us an incomplete set of indent
        // levels. In either case, we don't want to fall back to a row-by-row
        // auto-indent, because we were just using this mode to batch-adjust
        // the rows to preserve relative indentation.
        return;
      }
    }
    let row = lastRowIndented + 1;
    while (row <= endRow) {
      this.autoIndentBufferRow(row);
      row++;
    }
  }

  autoDecreaseIndentForBufferRow(bufferRow) {
    const languageMode = this.buffer.getLanguageMode();
    if (!languageMode.suggestedIndentForEditedBufferRow) { return; }
    let indentLevel = languageMode.suggestedIndentForEditedBufferRow(
      bufferRow,
      this.getTabLength()
    );
    if (indentLevel?.then) {
      indentLevel.then(indentLevel => {
        // We have a stricter contract than `autoIndentBufferRow`: if
        // `suggestedIndentForEditedBufferRow` doesn't return a number, we
        // should ignore it. Otherwise we run the risk of dedenting something
        // that the user doesn't want dedented.
        if (typeof indentLevel === 'number') {
          this.setIndentationForBufferRow(bufferRow, indentLevel);
          this.buffer.groupLastChanges();
        }
      });
    } else {
      if (indentLevel != null)
        this.setIndentationForBufferRow(bufferRow, indentLevel);
    }
  }

  // Called at the end of a multi-change transaction when an auto-indent action
  // was supposed to happen during that transaction. May be called multiple
  // times, but will result in a maximum of one post-transaction adjustment.
  scheduleIndentAdjustment(force = false) {
    // Ensure that we schedule only one indent adjustment per
    // between-transaction interval. It might have already been done, in which
    // case we don't even need to try to schedule it.
    if (this.didAdjustIndent) return;

    // If we're forcing this to run, replace the existing promise, because
    // there's no guarantee that the existing promise won't bail early.
    if (this.autoIndentAtTransactionEndPromise && !force) return;

    let languageMode = this.buffer.getLanguageMode();
    if (!languageMode.atTransactionEnd) return;
    if (!languageMode.useAsyncParsing || !languageMode.useAsyncIndent) return;

    let promise = languageMode.atTransactionEnd().then(
      ({ range, autoIndentRequests }) => {
        if (!range || this.didAdjustIndent) return;
        // When `force` is not `true`, will only try to auto-indent this
        // transaction's range if the language mode reports that one of its
        // suggested-indent methods was called during the transaction.
        if (autoIndentRequests === 0 && !force) return;

        this.transact(() => (
          this.autoIndentBufferRows(range.start.row, range.end.row)
        ));
        this.buffer.groupLastChanges();
        this.didAdjustIndent = true;
      }
    );

    this.autoIndentAtTransactionEndPromise = promise.finally(() => {
      this.autoIndentAtTransactionEndPromise = null;
      this.didAdjustIndent = false;
    });
  }

  toggleLineCommentForBufferRow(row) {
    this.toggleLineCommentsForBufferRows(row, row);
  }

  toggleLineCommentsForBufferRows(start, end, options = {}) {
    const languageMode = this.buffer.getLanguageMode();
    let { commentStartString, commentEndString } =
      (languageMode.commentStringsForPosition &&
        languageMode.commentStringsForPosition(new Point(start, 0))) ||
      {};
    if (!commentStartString) return;
    commentStartString = commentStartString.trim();

    if (commentEndString) {
      commentEndString = commentEndString.trim();
      const startDelimiterColumnRange = columnRangeForStartDelimiter(
        this.buffer.lineForRow(start),
        commentStartString
      );
      if (startDelimiterColumnRange) {
        const endDelimiterColumnRange = columnRangeForEndDelimiter(
          this.buffer.lineForRow(end),
          commentEndString
        );
        if (endDelimiterColumnRange) {
          this.buffer.transact(() => {
            this.buffer.delete([
              [end, endDelimiterColumnRange[0]],
              [end, endDelimiterColumnRange[1]]
            ]);
            this.buffer.delete([
              [start, startDelimiterColumnRange[0]],
              [start, startDelimiterColumnRange[1]]
            ]);
          });
        }
      } else {
        this.buffer.transact(() => {
          const indentLength = this.buffer.lineForRow(start).match(/^\s*/)[0]
            .length;
          this.buffer.insert([start, indentLength], commentStartString + ' ');
          this.buffer.insert(
            [end, this.buffer.lineLengthForRow(end)],
            ' ' + commentEndString
          );

          // Prevent the cursor from selecting / passing the delimiters
          // See https://github.com/atom/atom/pull/17519
          if (options.correctSelection && options.selection) {
            const endLineLength = this.buffer.lineLengthForRow(end);
            const oldRange = options.selection.getBufferRange();
            if (oldRange.isEmpty()) {
              if (oldRange.start.column === endLineLength) {
                const endCol = endLineLength - commentEndString.length - 1;
                options.selection.setBufferRange(
                  [[end, endCol], [end, endCol]],
                  { autoscroll: false }
                );
              }
            } else {
              const startDelta =
                oldRange.start.column === indentLength
                  ? [0, commentStartString.length + 1]
                  : [0, 0];
              const endDelta =
                oldRange.end.column === endLineLength
                  ? [0, -commentEndString.length - 1]
                  : [0, 0];
              options.selection.setBufferRange(
                oldRange.translate(startDelta, endDelta),
                { autoscroll: false }
              );
            }
          }
        });
      }
    } else {
      let hasCommentedLines = false;
      let hasUncommentedLines = false;
      for (let row = start; row <= end; row++) {
        const line = this.buffer.lineForRow(row);
        if (NON_WHITESPACE_REGEXP.test(line)) {
          if (columnRangeForStartDelimiter(line, commentStartString)) {
            hasCommentedLines = true;
          } else {
            hasUncommentedLines = true;
          }
        }
      }

      const shouldUncomment = hasCommentedLines && !hasUncommentedLines;

      if (shouldUncomment) {
        for (let row = start; row <= end; row++) {
          const columnRange = columnRangeForStartDelimiter(
            this.buffer.lineForRow(row),
            commentStartString
          );
          if (columnRange)
            this.buffer.delete([[row, columnRange[0]], [row, columnRange[1]]]);
        }
      } else {
        let minIndentLevel = Infinity;
        let minBlankIndentLevel = Infinity;
        for (let row = start; row <= end; row++) {
          const line = this.buffer.lineForRow(row);
          const indentLevel = this.indentLevelForLine(line);
          if (NON_WHITESPACE_REGEXP.test(line)) {
            if (indentLevel < minIndentLevel) minIndentLevel = indentLevel;
          } else {
            if (indentLevel < minBlankIndentLevel)
              minBlankIndentLevel = indentLevel;
          }
        }
        minIndentLevel = Number.isFinite(minIndentLevel)
          ? minIndentLevel
          : Number.isFinite(minBlankIndentLevel)
          ? minBlankIndentLevel
          : 0;

        const indentString = this.buildIndentString(minIndentLevel);
        for (let row = start; row <= end; row++) {
          const line = this.buffer.lineForRow(row);
          if (NON_WHITESPACE_REGEXP.test(line)) {
            const indentColumn = columnForIndentLevel(
              line,
              minIndentLevel,
              this.getTabLength()
            );
            this.buffer.insert(
              Point(row, indentColumn),
              commentStartString + ' '
            );
          } else {
            this.buffer.setTextInRange(
              new Range(new Point(row, 0), new Point(row, Infinity)),
              indentString + commentStartString + ' '
            );
          }
        }
      }
    }
  }

  // Public: Return information about the appropriate comment delimiters to use
  // at a given point in the buffer.
  //
  // Pulsar allows language bundles to define comment delimiters in several
  // places. For instance, a grammar author can place delimiter metadata in the
  // grammar definition file, or as scope-specific settings in the ordinary
  // config system — or a combination of the two.
  //
  // In some languages, comment delimiters vary based on position in the
  // buffer. (For instance, line comments can't always be used in JavaScript
  // JSX blocks, so block comments are much safer.) This method will look for
  // any such overrides and return what it thinks are the best delimiters to
  // use at a given point.
  //
  // Some languages don't specify all their delimiters in their configuration,
  // but this method will return all the information that it can discern.
  //
  // * point - A {Point} or point-compatible {Array}.
  //
  // Returns an {Object} with the following properties:
  //
  // * `line`: If present, a {String} representing a line comment delimiter.
  //   (If `undefined`, there is no known line comment delimiter for the given
  //   buffer position.)
  // * `block`: If present, a two-item {Array} containing {String}s
  //   representing the starting and ending block comment delimiters. (If
  //   `undefined`, there are no known block comment delimiters for the given
  //   buffer position.)
  //
  getCommentDelimitersForBufferPosition(point) {
    point = Point.fromObject(point);
    const languageMode = this.buffer.getLanguageMode();
    let {
      commentStartString,
      commentEndString,
      commentDelimiters
    } = languageMode.commentStringsForPosition(point);
    if (commentDelimiters) {
      return commentDelimiters;
    } else {
      // Build a delimiters object out of the other data we received. The
      // `commentStartString` and `commentEndString` settings aren't meant to
      // be comprehensive — they just tell you which delimiter(s) to use to
      // comment out a given selection — but they're better than nothing.
      if (commentStartString && commentEndString) {
        return { block: [commentStartString.trim(), commentEndString.trim()] };
      } else if (commentStartString && !commentEndString) {
        return { line: commentStartString.trim() };
      } else {
        return null;
      }
    }
  }

  rowRangeForParagraphAtBufferRow(bufferRow) {
    if (!NON_WHITESPACE_REGEXP.test(this.lineTextForBufferRow(bufferRow)))
      return;

    const languageMode = this.buffer.getLanguageMode();
    const isCommented = languageMode.isRowCommented(bufferRow);

    let startRow = bufferRow;
    while (startRow > 0) {
      if (!NON_WHITESPACE_REGEXP.test(this.lineTextForBufferRow(startRow - 1)))
        break;
      if (languageMode.isRowCommented(startRow - 1) !== isCommented) break;
      startRow--;
    }

    let endRow = bufferRow;
    const rowCount = this.getLineCount();
    while (endRow + 1 < rowCount) {
      if (!NON_WHITESPACE_REGEXP.test(this.lineTextForBufferRow(endRow + 1)))
        break;
      if (languageMode.isRowCommented(endRow + 1) !== isCommented) break;
      endRow++;
    }

    return new Range(
      new Point(startRow, 0),
      new Point(endRow, this.buffer.lineLengthForRow(endRow))
    );
  }
};

function columnForIndentLevel(line, indentLevel, tabLength) {
  let column = 0;
  let indentLength = 0;
  const goalIndentLength = indentLevel * tabLength;
  while (indentLength < goalIndentLength) {
    const char = line[column];
    if (char === '\t') {
      indentLength += tabLength - (indentLength % tabLength);
    } else if (char === ' ') {
      indentLength++;
    } else {
      break;
    }
    column++;
  }
  return column;
}

function columnRangeForStartDelimiter(line, delimiter) {
  const startColumn = line.search(NON_WHITESPACE_REGEXP);
  if (startColumn === -1) return null;
  if (!line.startsWith(delimiter, startColumn)) return null;

  let endColumn = startColumn + delimiter.length;
  if (line[endColumn] === ' ') endColumn++;
  return [startColumn, endColumn];
}

function columnRangeForEndDelimiter(line, delimiter) {
  let startColumn = line.lastIndexOf(delimiter);
  if (startColumn === -1) return null;

  const endColumn = startColumn + delimiter.length;
  if (NON_WHITESPACE_REGEXP.test(line.slice(endColumn))) return null;
  if (line[startColumn - 1] === ' ') startColumn--;
  return [startColumn, endColumn];
}

class ChangeEvent {
  constructor({ oldRange, newRange }) {
    this.oldRange = oldRange;
    this.newRange = newRange;
  }

  get start() {
    return this.newRange.start;
  }

  get oldExtent() {
    return this.oldRange.getExtent();
  }

  get newExtent() {
    return this.newRange.getExtent();
  }
}

================
File: src/workspace-element.js
================
'use strict';

const { ipcRenderer } = require('electron');
const path = require('path');
const fs = require('fs-plus');
const { CompositeDisposable, Disposable } = require('event-kit');
const scrollbarStyle = require('scrollbar-style');
const _ = require('underscore-plus');

class WorkspaceElement extends HTMLElement {
  connectedCallback() {
    this.focus();
    this.htmlElement = document.querySelector('html');
    this.htmlElement.addEventListener('mouseleave', this.handleCenterLeave);
  }

  disconnectedCallback() {
    this.subscriptions.dispose();
    this.htmlElement.removeEventListener('mouseleave', this.handleCenterLeave);
  }

  initializeContent() {
    this.classList.add('workspace');
    this.setAttribute('tabindex', -1);

    this.verticalAxis = document.createElement('atom-workspace-axis');
    this.verticalAxis.classList.add('vertical');

    this.horizontalAxis = document.createElement('atom-workspace-axis');
    this.horizontalAxis.classList.add('horizontal');
    this.horizontalAxis.appendChild(this.verticalAxis);

    this.appendChild(this.horizontalAxis);
  }

  observeScrollbarStyle() {
    this.subscriptions.add(
      scrollbarStyle.observePreferredScrollbarStyle(style => {
        switch (style) {
          case 'legacy':
            this.classList.remove('scrollbars-visible-when-scrolling');
            this.classList.add('scrollbars-visible-always');
            break;
          case 'overlay':
            this.classList.remove('scrollbars-visible-always');
            this.classList.add('scrollbars-visible-when-scrolling');
            break;
        }
      })
    );
  }

  observeTextEditorFontConfig() {
    this.updateGlobalTextEditorStyleSheet();
    this.subscriptions.add(
      this.config.onDidChange(
        'editor.fontSize',
        this.updateGlobalTextEditorStyleSheet.bind(this)
      )
    );
    this.subscriptions.add(
      this.config.onDidChange(
        'editor.fontFamily',
        this.updateGlobalTextEditorStyleSheet.bind(this)
      )
    );
    this.subscriptions.add(
      this.config.onDidChange(
        'editor.lineHeight',
        this.updateGlobalTextEditorStyleSheet.bind(this)
      )
    );
  }

  updateGlobalTextEditorStyleSheet() {
    const styleSheetSource = `atom-workspace {
  --editor-font-size: ${this.config.get('editor.fontSize')}px;
  --editor-font-family: ${this.config.get('editor.fontFamily')};
  --editor-line-height: ${this.config.get('editor.lineHeight')};
}`;
    this.styleManager.addStyleSheet(styleSheetSource, {
      sourcePath: 'global-text-editor-styles',
      priority: -1
    });
  }

  initialize(model, { config, project, styleManager, viewRegistry }) {
    this.handleCenterEnter = this.handleCenterEnter.bind(this);
    this.handleCenterLeave = this.handleCenterLeave.bind(this);
    this.handleEdgesMouseMove = _.throttle(
      this.handleEdgesMouseMove.bind(this),
      100
    );
    this.handleDockDragEnd = this.handleDockDragEnd.bind(this);
    this.handleDragStart = this.handleDragStart.bind(this);
    this.handleDragEnd = this.handleDragEnd.bind(this);
    this.handleDrop = this.handleDrop.bind(this);

    this.model = model;
    this.viewRegistry = viewRegistry;
    this.project = project;
    this.config = config;
    this.styleManager = styleManager;
    if (this.viewRegistry == null) {
      throw new Error(
        'Must pass a viewRegistry parameter when initializing WorkspaceElements'
      );
    }
    if (this.project == null) {
      throw new Error(
        'Must pass a project parameter when initializing WorkspaceElements'
      );
    }
    if (this.config == null) {
      throw new Error(
        'Must pass a config parameter when initializing WorkspaceElements'
      );
    }
    if (this.styleManager == null) {
      throw new Error(
        'Must pass a styleManager parameter when initializing WorkspaceElements'
      );
    }

    this.subscriptions = new CompositeDisposable(
      new Disposable(() => {
        this.paneContainer.removeEventListener(
          'mouseenter',
          this.handleCenterEnter
        );
        this.paneContainer.removeEventListener(
          'mouseleave',
          this.handleCenterLeave
        );
        window.removeEventListener('mousemove', this.handleEdgesMouseMove);
        window.removeEventListener('dragend', this.handleDockDragEnd);
        window.removeEventListener('dragstart', this.handleDragStart);
        window.removeEventListener('dragend', this.handleDragEnd, true);
        window.removeEventListener('drop', this.handleDrop, true);
      }),
      ...[
        this.model.getLeftDock(),
        this.model.getRightDock(),
        this.model.getBottomDock()
      ].map(dock =>
        dock.onDidChangeHovered(hovered => {
          if (hovered) this.hoveredDock = dock;
          else if (dock === this.hoveredDock) this.hoveredDock = null;
          this.checkCleanupDockHoverEvents();
        })
      )
    );
    this.initializeContent();
    this.observeScrollbarStyle();
    this.observeTextEditorFontConfig();

    this.paneContainer = this.model.getCenter().paneContainer.getElement();
    this.verticalAxis.appendChild(this.paneContainer);
    this.addEventListener('focus', this.handleFocus.bind(this));

    this.addEventListener('mousewheel', this.handleMousewheel.bind(this), {
      capture: true
    });
    window.addEventListener('dragstart', this.handleDragStart);
    window.addEventListener('mousemove', this.handleEdgesMouseMove);

    this.panelContainers = {
      top: this.model.panelContainers.top.getElement(),
      left: this.model.panelContainers.left.getElement(),
      right: this.model.panelContainers.right.getElement(),
      bottom: this.model.panelContainers.bottom.getElement(),
      header: this.model.panelContainers.header.getElement(),
      footer: this.model.panelContainers.footer.getElement(),
      modal: this.model.panelContainers.modal.getElement()
    };

    this.horizontalAxis.insertBefore(
      this.panelContainers.left,
      this.verticalAxis
    );
    this.horizontalAxis.appendChild(this.panelContainers.right);

    this.verticalAxis.insertBefore(
      this.panelContainers.top,
      this.paneContainer
    );
    this.verticalAxis.appendChild(this.panelContainers.bottom);

    this.insertBefore(this.panelContainers.header, this.horizontalAxis);
    this.appendChild(this.panelContainers.footer);

    this.appendChild(this.panelContainers.modal);

    this.paneContainer.addEventListener('mouseenter', this.handleCenterEnter);
    this.paneContainer.addEventListener('mouseleave', this.handleCenterLeave);

    return this;
  }

  destroy() {
    this.subscriptions.dispose();
  }

  getModel() {
    return this.model;
  }

  handleDragStart(event) {
    if (!isTab(event.target)) return;
    const { item } = event.target;
    if (!item) return;
    this.model.setDraggingItem(item);
    window.addEventListener('dragend', this.handleDragEnd, { capture: true });
    window.addEventListener('drop', this.handleDrop, { capture: true });
  }

  handleDragEnd(event) {
    this.dragEnded();
  }

  handleDrop(event) {
    this.dragEnded();
  }

  dragEnded() {
    this.model.setDraggingItem(null);
    window.removeEventListener('dragend', this.handleDragEnd, true);
    window.removeEventListener('drop', this.handleDrop, true);
  }

  handleCenterEnter(event) {
    // Just re-entering the center isn't enough to hide the dock toggle buttons, since they poke
    // into the center and we want to give an affordance.
    this.cursorInCenter = true;
    this.checkCleanupDockHoverEvents();
  }

  handleCenterLeave(event) {
    // If the cursor leaves the center, we start listening to determine whether one of the docs is
    // being hovered.
    this.cursorInCenter = false;
    this.updateHoveredDock({ x: event.pageX, y: event.pageY });
    window.addEventListener('dragend', this.handleDockDragEnd);
  }

  handleEdgesMouseMove(event) {
    this.updateHoveredDock({ x: event.pageX, y: event.pageY });
  }

  handleDockDragEnd(event) {
    this.updateHoveredDock({ x: event.pageX, y: event.pageY });
  }

  updateHoveredDock(mousePosition) {
    // If we haven't left the currently hovered dock, don't change anything.
    if (
      this.hoveredDock &&
      this.hoveredDock.pointWithinHoverArea(mousePosition, true)
    )
      return;

    const docks = [
      this.model.getLeftDock(),
      this.model.getRightDock(),
      this.model.getBottomDock()
    ];
    const nextHoveredDock = docks.find(
      dock =>
        dock !== this.hoveredDock && dock.pointWithinHoverArea(mousePosition)
    );
    docks.forEach(dock => {
      dock.setHovered(dock === nextHoveredDock);
    });
  }

  checkCleanupDockHoverEvents() {
    if (this.cursorInCenter && !this.hoveredDock) {
      window.removeEventListener('dragend', this.handleDockDragEnd);
    }
  }

  handleMousewheel(event) {
    if (
      event.ctrlKey &&
      this.config.get('editor.zoomFontWhenCtrlScrolling') &&
      event.target.closest('atom-text-editor') != null
    ) {
      if (event.wheelDeltaY > 0) {
        this.model.increaseFontSize();
      } else if (event.wheelDeltaY < 0) {
        this.model.decreaseFontSize();
      }
      event.preventDefault();
      event.stopPropagation();
    }
  }

  handleFocus(event) {
    this.model.getActivePane().activate();
  }

  focusPaneViewAbove() {
    this.focusPaneViewInDirection('above');
  }

  focusPaneViewBelow() {
    this.focusPaneViewInDirection('below');
  }

  focusPaneViewOnLeft() {
    this.focusPaneViewInDirection('left');
  }

  focusPaneViewOnRight() {
    this.focusPaneViewInDirection('right');
  }

  focusPaneViewInDirection(direction, pane) {
    const activePane = this.model.getActivePane();
    const paneToFocus = this.nearestVisiblePaneInDirection(
      direction,
      activePane
    );
    paneToFocus && paneToFocus.focus();
  }

  moveActiveItemToPaneAbove(params) {
    this.moveActiveItemToNearestPaneInDirection('above', params);
  }

  moveActiveItemToPaneBelow(params) {
    this.moveActiveItemToNearestPaneInDirection('below', params);
  }

  moveActiveItemToPaneOnLeft(params) {
    this.moveActiveItemToNearestPaneInDirection('left', params);
  }

  moveActiveItemToPaneOnRight(params) {
    this.moveActiveItemToNearestPaneInDirection('right', params);
  }

  moveActiveItemToNearestPaneInDirection(direction, params) {
    const activePane = this.model.getActivePane();
    const nearestPaneView = this.nearestVisiblePaneInDirection(
      direction,
      activePane
    );
    if (nearestPaneView == null) {
      return;
    }
    if (params && params.keepOriginal) {
      activePane
        .getContainer()
        .copyActiveItemToPane(nearestPaneView.getModel());
    } else {
      activePane
        .getContainer()
        .moveActiveItemToPane(nearestPaneView.getModel());
    }
    nearestPaneView.focus();
  }

  nearestVisiblePaneInDirection(direction, pane) {
    const distance = function(pointA, pointB) {
      const x = pointB.x - pointA.x;
      const y = pointB.y - pointA.y;
      return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
    };

    const paneView = pane.getElement();
    const box = this.boundingBoxForPaneView(paneView);

    const paneViews = atom.workspace
      .getVisiblePanes()
      .map(otherPane => otherPane.getElement())
      .filter(otherPaneView => {
        const otherBox = this.boundingBoxForPaneView(otherPaneView);
        switch (direction) {
          case 'left':
            return otherBox.right.x <= box.left.x;
          case 'right':
            return otherBox.left.x >= box.right.x;
          case 'above':
            return otherBox.bottom.y <= box.top.y;
          case 'below':
            return otherBox.top.y >= box.bottom.y;
        }
      })
      .sort((paneViewA, paneViewB) => {
        const boxA = this.boundingBoxForPaneView(paneViewA);
        const boxB = this.boundingBoxForPaneView(paneViewB);
        switch (direction) {
          case 'left':
            return (
              distance(box.left, boxA.right) - distance(box.left, boxB.right)
            );
          case 'right':
            return (
              distance(box.right, boxA.left) - distance(box.right, boxB.left)
            );
          case 'above':
            return (
              distance(box.top, boxA.bottom) - distance(box.top, boxB.bottom)
            );
          case 'below':
            return (
              distance(box.bottom, boxA.top) - distance(box.bottom, boxB.top)
            );
        }
      });

    return paneViews[0];
  }

  boundingBoxForPaneView(paneView) {
    const boundingBox = paneView.getBoundingClientRect();

    return {
      left: { x: boundingBox.left, y: boundingBox.top },
      right: { x: boundingBox.right, y: boundingBox.top },
      top: { x: boundingBox.left, y: boundingBox.top },
      bottom: { x: boundingBox.left, y: boundingBox.bottom }
    };
  }

  runPackageSpecs(options = {}) {
    const activePaneItem = this.model.getActivePaneItem();
    const activePath =
      activePaneItem && typeof activePaneItem.getPath === 'function'
        ? activePaneItem.getPath()
        : null;
    let projectPath;
    if (activePath != null) {
      [projectPath] = this.project.relativizePath(activePath);
    } else {
      [projectPath] = this.project.getPaths();
    }
    if (projectPath) {
      let specPath = path.join(projectPath, 'spec');
      const testPath = path.join(projectPath, 'test');
      if (!fs.existsSync(specPath) && fs.existsSync(testPath)) {
        specPath = testPath;
      }

      ipcRenderer.send('run-package-specs', specPath, options);
    }
  }
}

function isTab(element) {
  let el = element;
  while (el != null) {
    if (el.getAttribute && el.getAttribute('is') === 'tabs-tab') return true;
    el = el.parentElement;
  }
  return false;
}

window.customElements.define('atom-workspace', WorkspaceElement);

function createWorkspaceElement() {
  return document.createElement('atom-workspace');
}

module.exports = {
  createWorkspaceElement
};

================
File: src/workspace.js
================
const _ = require('underscore-plus');
const url = require('url');
const path = require('path');
const { Emitter, Disposable, CompositeDisposable } = require('event-kit');
const fs = require('fs-plus');
const { Directory } = require('pathwatcher');
const Grim = require('grim');
const DefaultDirectorySearcher = require('./default-directory-searcher');
const RipgrepDirectorySearcher = require('./ripgrep-directory-searcher');
const Dock = require('./dock');
const Model = require('./model');
const StateStore = require('./state-store');
const TextEditor = require('./text-editor');
const Panel = require('./panel');
const PanelContainer = require('./panel-container');
const Task = require('./task');
const WorkspaceCenter = require('./workspace-center');
const { createWorkspaceElement } = require('./workspace-element');

const STOPPED_CHANGING_ACTIVE_PANE_ITEM_DELAY = 100;
const ALL_LOCATIONS = ['center', 'left', 'right', 'bottom'];

// Essential: Represents the state of the user interface for the entire window.
// An instance of this class is available via the `atom.workspace` global.
//
// Interact with this object to open files, be notified of current and future
// editors, and manipulate panes. To add panels, use {Workspace::addTopPanel}
// and friends.
//
// ## Workspace Items
//
// The term "item" refers to anything that can be displayed
// in a pane within the workspace, either in the {WorkspaceCenter} or in one
// of the three {Dock}s. The workspace expects items to conform to the
// following interface:
//
// ### Required Methods
//
// #### `getTitle()`
//
// Returns a {String} containing the title of the item to display on its
// associated tab.
//
// ### Optional Methods
//
// #### `getElement()`
//
// If your item already *is* a DOM element, you do not need to implement this
// method. Otherwise it should return the element you want to display to
// represent this item.
//
// #### `destroy()`
//
// Destroys the item. This will be called when the item is removed from its
// parent pane.
//
// #### `onDidDestroy(callback)`
//
// Called by the workspace so it can be notified when the item is destroyed.
// Must return a {Disposable}.
//
// #### `serialize()`
//
// Serialize the state of the item. Must return an object that can be passed to
// `JSON.stringify`. The state should include a field called `deserializer`,
// which names a deserializer declared in your `package.json`. This method is
// invoked on items when serializing the workspace so they can be restored to
// the same location later.
//
// #### `getURI()`
//
// Returns the URI associated with the item.
//
// #### `getLongTitle()`
//
// Returns a {String} containing a longer version of the title to display in
// places like the window title or on tabs their short titles are ambiguous.
//
// #### `onDidChangeTitle(callback)`
//
// Called by the workspace so it can be notified when the item's title changes.
// Must return a {Disposable}.
//
// #### `getIconName()`
//
// Return a {String} with the name of an icon. If this method is defined and
// returns a string, the item's tab element will be rendered with the `icon` and
// `icon-${iconName}` CSS classes.
//
// ### `onDidChangeIcon(callback)`
//
// Called by the workspace so it can be notified when the item's icon changes.
// Must return a {Disposable}.
//
// #### `getDefaultLocation()`
//
// Tells the workspace where your item should be opened in absence of a user
// override. Items can appear in the center or in a dock on the left, right, or
// bottom of the workspace.
//
// Returns a {String} with one of the following values: `'center'`, `'left'`,
// `'right'`, `'bottom'`. If this method is not defined, `'center'` is the
// default.
//
// #### `getAllowedLocations()`
//
// Tells the workspace where this item can be moved. Returns an {Array} of one
// or more of the following values: `'center'`, `'left'`, `'right'`, or
// `'bottom'`.
//
// #### `isPermanentDockItem()`
//
// Tells the workspace whether or not this item can be closed by the user by
// clicking an `x` on its tab. Use of this feature is discouraged unless there's
// a very good reason not to allow users to close your item. Items can be made
// permanent *only* when they are contained in docks. Center pane items can
// always be removed. Note that it is currently still possible to close dock
// items via the `Close Pane` option in the context menu and via Pulsar APIs, so
// you should still be prepared to handle your dock items being destroyed by the
// user even if you implement this method.
//
// #### `save()`
//
// Saves the item.
//
// #### `saveAs(path)`
//
// Saves the item to the specified path.
//
// #### `getPath()`
//
// Returns the local path associated with this item. This is only used to set
// the initial location of the "save as" dialog.
//
// #### `isModified()`
//
// Returns whether or not the item is modified to reflect modification in the
// UI.
//
// #### `onDidChangeModified()`
//
// Called by the workspace so it can be notified when item's modified status
// changes. Must return a {Disposable}.
//
// #### `copy()`
//
// Create a copy of the item. If defined, the workspace will call this method to
// duplicate the item when splitting panes via certain split commands.
//
// #### `getPreferredHeight()`
//
// If this item is displayed in the bottom {Dock}, called by the workspace when
// initially displaying the dock to set its height. Once the dock has been
// resized by the user, their height will override this value.
//
// Returns a {Number}.
//
// #### `getPreferredWidth()`
//
// If this item is displayed in the left or right {Dock}, called by the
// workspace when initially displaying the dock to set its width. Once the dock
// has been resized by the user, their width will override this value.
//
// Returns a {Number}.
//
// #### `onDidTerminatePendingState(callback)`
//
// If the workspace is configured to use *pending pane items*, the workspace
// will subscribe to this method to terminate the pending state of the item.
// Must return a {Disposable}.
//
// #### `shouldPromptToSave()`
//
// This method indicates whether Pulsar should prompt the user to save this item
// when the user closes or reloads the window. Returns a boolean.
module.exports = class Workspace extends Model {
  constructor(params) {
    super(...arguments);

    this.disposables = new CompositeDisposable();
    this.updateWindowTitle = this.updateWindowTitle.bind(this);
    this.updateDocumentEdited = this.updateDocumentEdited.bind(this);
    this.didDestroyPaneItem = this.didDestroyPaneItem.bind(this);
    this.didChangeActivePaneOnPaneContainer = this.didChangeActivePaneOnPaneContainer.bind(
      this
    );
    this.didChangeActivePaneItemOnPaneContainer = this.didChangeActivePaneItemOnPaneContainer.bind(
      this
    );
    this.didActivatePaneContainer = this.didActivatePaneContainer.bind(this);

    this.enablePersistence = params.enablePersistence;
    this.packageManager = params.packageManager;
    this.config = params.config;
    this.project = params.project;
    this.notificationManager = params.notificationManager;
    this.viewRegistry = params.viewRegistry;
    this.grammarRegistry = params.grammarRegistry;
    this.applicationDelegate = params.applicationDelegate;
    this.assert = params.assert;
    this.deserializerManager = params.deserializerManager;
    this.textEditorRegistry = params.textEditorRegistry;
    this.styleManager = params.styleManager;
    this.draggingItem = false;
    this.itemLocationStore = new StateStore('AtomPreviousItemLocations', 1);

    this.emitter = new Emitter();
    this.openers = [];
    this.destroyedItemURIs = [];
    this.stoppedChangingActivePaneItemTimeout = null;

    this.scandalDirectorySearcher = new DefaultDirectorySearcher();
    this.ripgrepDirectorySearcher = new RipgrepDirectorySearcher();
    this.consumeServices(this.packageManager);

    this.paneContainers = {
      center: this.createCenter(),
      left: this.createDock('left'),
      right: this.createDock('right'),
      bottom: this.createDock('bottom')
    };
    this.activePaneContainer = this.paneContainers.center;
    this.hasActiveTextEditor = false;

    this.panelContainers = {
      top: new PanelContainer({
        viewRegistry: this.viewRegistry,
        location: 'top'
      }),
      left: new PanelContainer({
        viewRegistry: this.viewRegistry,
        location: 'left',
        dock: this.paneContainers.left
      }),
      right: new PanelContainer({
        viewRegistry: this.viewRegistry,
        location: 'right',
        dock: this.paneContainers.right
      }),
      bottom: new PanelContainer({
        viewRegistry: this.viewRegistry,
        location: 'bottom',
        dock: this.paneContainers.bottom
      }),
      header: new PanelContainer({
        viewRegistry: this.viewRegistry,
        location: 'header'
      }),
      footer: new PanelContainer({
        viewRegistry: this.viewRegistry,
        location: 'footer'
      }),
      modal: new PanelContainer({
        viewRegistry: this.viewRegistry,
        location: 'modal'
      })
    };

    this.incoming = new Map();
  }

  get paneContainer() {
    Grim.deprecate(
      '`atom.workspace.paneContainer` has always been private, but it is now gone. Please use `atom.workspace.getCenter()` instead and consult the workspace API docs for public methods.'
    );
    return this.paneContainers.center.paneContainer;
  }

  getElement() {
    if (!this.element) {
      this.element = createWorkspaceElement().initialize(this, {
        config: this.config,
        project: this.project,
        viewRegistry: this.viewRegistry,
        styleManager: this.styleManager
      });
    }
    return this.element;
  }

  createCenter() {
    return new WorkspaceCenter({
      config: this.config,
      applicationDelegate: this.applicationDelegate,
      notificationManager: this.notificationManager,
      deserializerManager: this.deserializerManager,
      viewRegistry: this.viewRegistry,
      didActivate: this.didActivatePaneContainer,
      didChangeActivePane: this.didChangeActivePaneOnPaneContainer,
      didChangeActivePaneItem: this.didChangeActivePaneItemOnPaneContainer,
      didDestroyPaneItem: this.didDestroyPaneItem
    });
  }

  createDock(location) {
    return new Dock({
      location,
      config: this.config,
      applicationDelegate: this.applicationDelegate,
      deserializerManager: this.deserializerManager,
      notificationManager: this.notificationManager,
      viewRegistry: this.viewRegistry,
      didActivate: this.didActivatePaneContainer,
      didChangeActivePane: this.didChangeActivePaneOnPaneContainer,
      didChangeActivePaneItem: this.didChangeActivePaneItemOnPaneContainer,
      didDestroyPaneItem: this.didDestroyPaneItem
    });
  }

  reset(packageManager) {
    this.packageManager = packageManager;
    this.emitter.dispose();
    this.emitter = new Emitter();

    this.paneContainers.center.destroy();
    this.paneContainers.left.destroy();
    this.paneContainers.right.destroy();
    this.paneContainers.bottom.destroy();

    _.values(this.panelContainers).forEach(panelContainer => {
      panelContainer.destroy();
    });

    this.paneContainers = {
      center: this.createCenter(),
      left: this.createDock('left'),
      right: this.createDock('right'),
      bottom: this.createDock('bottom')
    };
    this.activePaneContainer = this.paneContainers.center;
    this.hasActiveTextEditor = false;

    this.panelContainers = {
      top: new PanelContainer({
        viewRegistry: this.viewRegistry,
        location: 'top'
      }),
      left: new PanelContainer({
        viewRegistry: this.viewRegistry,
        location: 'left',
        dock: this.paneContainers.left
      }),
      right: new PanelContainer({
        viewRegistry: this.viewRegistry,
        location: 'right',
        dock: this.paneContainers.right
      }),
      bottom: new PanelContainer({
        viewRegistry: this.viewRegistry,
        location: 'bottom',
        dock: this.paneContainers.bottom
      }),
      header: new PanelContainer({
        viewRegistry: this.viewRegistry,
        location: 'header'
      }),
      footer: new PanelContainer({
        viewRegistry: this.viewRegistry,
        location: 'footer'
      }),
      modal: new PanelContainer({
        viewRegistry: this.viewRegistry,
        location: 'modal'
      })
    };

    this.openers = [];
    this.destroyedItemURIs = [];
    if (this.element) {
      this.element.destroy();
      this.element = null;
    }
    this.consumeServices(this.packageManager);
  }

  initialize() {
    // we set originalFontSize to avoid breaking packages that might have relied on it
    this.originalFontSize = this.config.get('defaultFontSize');

    this.project.onDidChangePaths(this.updateWindowTitle);
    this.subscribeToAddedItems();
    this.subscribeToMovedItems();
    this.subscribeToDockToggling();

    this.disposables.add(
      this.config.onDidChange('core.addCurrentTabToWindowTitle', () => {
        this.updateWindowTitle();
      })
    );
  }

  consumeServices({ serviceHub }) {
    this.directorySearchers = [];
    serviceHub.consume('atom.directory-searcher', '^0.1.0', provider =>
      this.directorySearchers.unshift(provider)
    );
  }

  // Called by the Serializable mixin during serialization.
  serialize() {
    return {
      deserializer: 'Workspace',
      packagesWithActiveGrammars: this.getPackageNamesWithActiveGrammars(),
      destroyedItemURIs: this.destroyedItemURIs.slice(),
      // Ensure deserializing 1.17 state with pre 1.17 Pulsar does not error
      // TODO: Remove after 1.17 has been on stable for a while
      paneContainer: { version: 2 },
      paneContainers: {
        center: this.paneContainers.center.serialize(),
        left: this.paneContainers.left.serialize(),
        right: this.paneContainers.right.serialize(),
        bottom: this.paneContainers.bottom.serialize()
      }
    };
  }

  deserialize(state, deserializerManager) {
    const packagesWithActiveGrammars =
      state.packagesWithActiveGrammars != null
        ? state.packagesWithActiveGrammars
        : [];
    for (let packageName of packagesWithActiveGrammars) {
      const pkg = this.packageManager.getLoadedPackage(packageName);
      if (pkg != null) {
        pkg.loadGrammarsSync();
      }
    }
    if (state.destroyedItemURIs != null) {
      this.destroyedItemURIs = state.destroyedItemURIs;
    }

    if (state.paneContainers) {
      this.paneContainers.center.deserialize(
        state.paneContainers.center,
        deserializerManager
      );
      this.paneContainers.left.deserialize(
        state.paneContainers.left,
        deserializerManager
      );
      this.paneContainers.right.deserialize(
        state.paneContainers.right,
        deserializerManager
      );
      this.paneContainers.bottom.deserialize(
        state.paneContainers.bottom,
        deserializerManager
      );
    } else if (state.paneContainer) {
      // TODO: Remove this fallback once a lot of time has passed since 1.17 was released
      this.paneContainers.center.deserialize(
        state.paneContainer,
        deserializerManager
      );
    }

    this.hasActiveTextEditor = this.getActiveTextEditor() != null;

    this.updateWindowTitle();
  }

  getPackageNamesWithActiveGrammars() {
    const packageNames = [];
    const addGrammar = ({ includedGrammarScopes, packageName } = {}) => {
      if (!packageName) {
        return;
      }
      // Prevent cycles
      if (packageNames.indexOf(packageName) !== -1) {
        return;
      }

      packageNames.push(packageName);
      for (let scopeName of includedGrammarScopes != null
        ? includedGrammarScopes
        : []) {
        addGrammar(this.grammarRegistry.grammarForScopeName(scopeName));
      }
    };

    const editors = this.getTextEditors();
    for (let editor of editors) {
      addGrammar(editor.getGrammar());
    }

    if (editors.length > 0) {
      for (let grammar of this.grammarRegistry.getGrammars()) {
        if (grammar.injectionSelector) {
          addGrammar(grammar);
        }
      }
    }

    return _.uniq(packageNames);
  }

  didActivatePaneContainer(paneContainer) {
    if (paneContainer !== this.getActivePaneContainer()) {
      this.activePaneContainer = paneContainer;
      this.didChangeActivePaneItem(
        this.activePaneContainer.getActivePaneItem()
      );
      this.emitter.emit(
        'did-change-active-pane-container',
        this.activePaneContainer
      );
      this.emitter.emit(
        'did-change-active-pane',
        this.activePaneContainer.getActivePane()
      );
      this.emitter.emit(
        'did-change-active-pane-item',
        this.activePaneContainer.getActivePaneItem()
      );
    }
  }

  didChangeActivePaneOnPaneContainer(paneContainer, pane) {
    if (paneContainer === this.getActivePaneContainer()) {
      this.emitter.emit('did-change-active-pane', pane);
    }
  }

  didChangeActivePaneItemOnPaneContainer(paneContainer, item) {
    if (paneContainer === this.getActivePaneContainer()) {
      this.didChangeActivePaneItem(item);
      this.emitter.emit('did-change-active-pane-item', item);
    }

    if (paneContainer === this.getCenter()) {
      const hadActiveTextEditor = this.hasActiveTextEditor;
      this.hasActiveTextEditor = item instanceof TextEditor;

      if (this.hasActiveTextEditor || hadActiveTextEditor) {
        const itemValue = this.hasActiveTextEditor ? item : undefined;
        this.emitter.emit('did-change-active-text-editor', itemValue);
      }
    }
  }

  didChangeActivePaneItem(item) {
    this.updateWindowTitle();
    this.updateDocumentEdited();
    if (this.activeItemSubscriptions) this.activeItemSubscriptions.dispose();
    this.activeItemSubscriptions = new CompositeDisposable();

    let modifiedSubscription, titleSubscription;

    if (item != null && typeof item.onDidChangeTitle === 'function') {
      titleSubscription = item.onDidChangeTitle(this.updateWindowTitle);
    } else if (item != null && typeof item.on === 'function') {
      titleSubscription = item.on('title-changed', this.updateWindowTitle);
      if (
        titleSubscription == null ||
        typeof titleSubscription.dispose !== 'function'
      ) {
        titleSubscription = new Disposable(() => {
          item.off('title-changed', this.updateWindowTitle);
        });
      }
    }

    if (item != null && typeof item.onDidChangeModified === 'function') {
      modifiedSubscription = item.onDidChangeModified(
        this.updateDocumentEdited
      );
    } else if (item != null && typeof item.on === 'function') {
      modifiedSubscription = item.on(
        'modified-status-changed',
        this.updateDocumentEdited
      );
      if (
        modifiedSubscription == null ||
        typeof modifiedSubscription.dispose !== 'function'
      ) {
        modifiedSubscription = new Disposable(() => {
          item.off('modified-status-changed', this.updateDocumentEdited);
        });
      }
    }

    if (titleSubscription != null) {
      this.activeItemSubscriptions.add(titleSubscription);
    }
    if (modifiedSubscription != null) {
      this.activeItemSubscriptions.add(modifiedSubscription);
    }

    this.cancelStoppedChangingActivePaneItemTimeout();
    this.stoppedChangingActivePaneItemTimeout = setTimeout(() => {
      this.stoppedChangingActivePaneItemTimeout = null;
      this.emitter.emit('did-stop-changing-active-pane-item', item);
    }, STOPPED_CHANGING_ACTIVE_PANE_ITEM_DELAY);
  }

  cancelStoppedChangingActivePaneItemTimeout() {
    if (this.stoppedChangingActivePaneItemTimeout != null) {
      clearTimeout(this.stoppedChangingActivePaneItemTimeout);
    }
  }

  setDraggingItem(draggingItem) {
    _.values(this.paneContainers).forEach(dock => {
      dock.setDraggingItem(draggingItem);
    });
  }

  subscribeToAddedItems() {
    this.onDidAddPaneItem(({ item, pane, index }) => {
      if (item instanceof TextEditor) {
        const subscriptions = new CompositeDisposable(
          this.textEditorRegistry.add(item),
          this.textEditorRegistry.maintainConfig(item)
        );
        if (!this.project.findBufferForId(item.buffer.id)) {
          this.project.addBuffer(item.buffer);
        }
        item.onDidDestroy(() => {
          subscriptions.dispose();
        });
        this.emitter.emit('did-add-text-editor', {
          textEditor: item,
          pane,
          index
        });
        // It's important to call handleGrammarUsed after emitting the did-add event:
        // if we activate a package between adding the editor to the registry and emitting
        // the package may receive the editor twice from `observeTextEditors`.
        // (Note that the item can be destroyed by an `observeTextEditors` handler.)
        if (!item.isDestroyed()) {
          subscriptions.add(
            item.observeGrammar(this.handleGrammarUsed.bind(this))
          );
        }
      }
    });
  }

  subscribeToDockToggling() {
    const docks = [
      this.getLeftDock(),
      this.getRightDock(),
      this.getBottomDock()
    ];
    docks.forEach(dock => {
      dock.onDidChangeVisible(visible => {
        if (visible) return;
        const { activeElement } = document;
        const dockElement = dock.getElement();
        if (
          dockElement === activeElement ||
          dockElement.contains(activeElement)
        ) {
          this.getCenter().activate();
        }
      });
    });
  }

  subscribeToMovedItems() {
    for (const paneContainer of this.getPaneContainers()) {
      paneContainer.observePanes(pane => {
        pane.onDidAddItem(({ item }) => {
          if (typeof item.getURI === 'function' && this.enablePersistence) {
            const uri = item.getURI();
            if (uri) {
              const location = paneContainer.getLocation();
              let defaultLocation;
              if (typeof item.getDefaultLocation === 'function') {
                defaultLocation = item.getDefaultLocation();
              }
              defaultLocation = defaultLocation || 'center';
              if (location === defaultLocation) {
                this.itemLocationStore.delete(item.getURI());
              } else {
                this.itemLocationStore.save(item.getURI(), location);
              }
            }
          }
        });
      });
    }
  }

  // Updates the application's title and proxy icon based on whichever file is
  // open.
  updateWindowTitle() {
    let itemPath, itemTitle, projectPath, representedPath;
    const appName = atom.getAppName();
    const left = this.project.getPaths();
    const projectPaths = left != null ? left : [];
    const item = this.getActivePaneItem();
    if (item) {
      itemPath =
        typeof item.getPath === 'function' ? item.getPath() : undefined;
      const longTitle =
        typeof item.getLongTitle === 'function'
          ? item.getLongTitle()
          : undefined;
      itemTitle =
        longTitle == null
          ? typeof item.getTitle === 'function'
            ? item.getTitle()
            : undefined
          : longTitle;
      projectPath = _.find(
        projectPaths,
        projectPath =>
          itemPath === projectPath ||
          (itemPath != null
            ? itemPath.startsWith(projectPath + path.sep)
            : undefined)
      );
    }
    if (itemTitle == null) {
      itemTitle = 'untitled';
    }
    if (projectPath == null) {
      projectPath = itemPath ? path.dirname(itemPath) : projectPaths[0];
    }
    if (projectPath != null) {
      projectPath = fs.tildify(projectPath);
    }

    const titleParts = [];
    if (item != null && projectPath != null && this.config.get('core.addCurrentTabToWindowTitle')) {
      titleParts.push(itemTitle, projectPath);
      representedPath = itemPath != null ? itemPath : projectPath;
    } else if (item != null && projectPath != null && !this.config.get('core.addCurrentTabToWindowTitle')) {
      titleParts.push(projectPath);
      representedPath = itemPath != null ? itemPath : projectPath;
    } else if (projectPath != null) {
      titleParts.push(projectPath);
      representedPath = projectPath;
    } else {
      titleParts.push(itemTitle);
      representedPath = '';
    }

    if (process.platform !== 'darwin') {
      titleParts.push(appName);
    }

    document.title = titleParts.join(' \u2014 ');
    this.applicationDelegate.setRepresentedFilename(representedPath);
    this.emitter.emit('did-change-window-title');
  }

  // On macOS, fades the application window's proxy icon when the current file
  // has been modified.
  updateDocumentEdited() {
    const activePaneItem = this.getActivePaneItem();
    const modified =
      activePaneItem != null && typeof activePaneItem.isModified === 'function'
        ? activePaneItem.isModified() || false
        : false;
    this.applicationDelegate.setWindowDocumentEdited(modified);
  }

  /*
  Section: Event Subscription
  */

  onDidChangeActivePaneContainer(callback) {
    return this.emitter.on('did-change-active-pane-container', callback);
  }

  // Essential: Invoke the given callback with all current and future text
  // editors in the workspace.
  //
  // * `callback` {Function} to be called with current and future text editors.
  //   * `editor` A {TextEditor} that is present in {::getTextEditors} at the time
  //     of subscription or that is added at some later time.
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  observeTextEditors(callback) {
    for (let textEditor of this.getTextEditors()) {
      callback(textEditor);
    }
    return this.onDidAddTextEditor(({ textEditor }) => callback(textEditor));
  }

  // Essential: Invoke the given callback with all current and future panes items
  // in the workspace.
  //
  // * `callback` {Function} to be called with current and future pane items.
  //   * `item` An item that is present in {::getPaneItems} at the time of
  //      subscription or that is added at some later time.
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  observePaneItems(callback) {
    return new CompositeDisposable(
      ...this.getPaneContainers().map(container =>
        container.observePaneItems(callback)
      )
    );
  }

  // Essential: Invoke the given callback when the active pane item changes.
  //
  // Because observers are invoked synchronously, it's important not to perform
  // any expensive operations via this method. Consider
  // {::onDidStopChangingActivePaneItem} to delay operations until after changes
  // stop occurring.
  //
  // * `callback` {Function} to be called when the active pane item changes.
  //   * `item` The active pane item.
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  onDidChangeActivePaneItem(callback) {
    return this.emitter.on('did-change-active-pane-item', callback);
  }

  // Essential: Invoke the given callback when the active pane item stops
  // changing.
  //
  // Observers are called asynchronously 100ms after the last active pane item
  // change. Handling changes here rather than in the synchronous
  // {::onDidChangeActivePaneItem} prevents unneeded work if the user is quickly
  // changing or closing tabs and ensures critical UI feedback, like changing the
  // highlighted tab, gets priority over work that can be done asynchronously.
  //
  // * `callback` {Function} to be called when the active pane item stops
  //   changing.
  //   * `item` The active pane item.
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  onDidStopChangingActivePaneItem(callback) {
    return this.emitter.on('did-stop-changing-active-pane-item', callback);
  }

  // Essential: Invoke the given callback when a text editor becomes the active
  // text editor and when there is no longer an active text editor.
  //
  // * `callback` {Function} to be called when the active text editor changes.
  //   * `editor` The active {TextEditor} or undefined if there is no longer an
  //      active text editor.
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  onDidChangeActiveTextEditor(callback) {
    return this.emitter.on('did-change-active-text-editor', callback);
  }

  // Essential: Invoke the given callback with the current active pane item and
  // with all future active pane items in the workspace.
  //
  // * `callback` {Function} to be called when the active pane item changes.
  //   * `item` The current active pane item.
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  observeActivePaneItem(callback) {
    callback(this.getActivePaneItem());
    return this.onDidChangeActivePaneItem(callback);
  }

  // Essential: Invoke the given callback with the current active text editor
  // (if any), with all future active text editors, and when there is no longer
  // an active text editor.
  //
  // * `callback` {Function} to be called when the active text editor changes.
  //   * `editor` The active {TextEditor} or undefined if there is not an
  //      active text editor.
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  observeActiveTextEditor(callback) {
    callback(this.getActiveTextEditor());

    return this.onDidChangeActiveTextEditor(callback);
  }

  // Essential: Invoke the given callback whenever an item is opened. Unlike
  // {::onDidAddPaneItem}, observers will be notified for items that are already
  // present in the workspace when they are reopened.
  //
  // * `callback` {Function} to be called whenever an item is opened.
  //   * `event` {Object} with the following keys:
  //     * `uri` {String} representing the opened URI. Could be `undefined`.
  //     * `item` The opened item.
  //     * `pane` The pane in which the item was opened.
  //     * `index` The index of the opened item on its pane.
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  onDidOpen(callback) {
    return this.emitter.on('did-open', callback);
  }

  // Extended: Invoke the given callback when a pane is added to the workspace.
  //
  // * `callback` {Function} to be called panes are added.
  //   * `event` {Object} with the following keys:
  //     * `pane` The added pane.
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  onDidAddPane(callback) {
    return new CompositeDisposable(
      ...this.getPaneContainers().map(container =>
        container.onDidAddPane(callback)
      )
    );
  }

  // Extended: Invoke the given callback before a pane is destroyed in the
  // workspace.
  //
  // * `callback` {Function} to be called before panes are destroyed.
  //   * `event` {Object} with the following keys:
  //     * `pane` The pane to be destroyed.
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  onWillDestroyPane(callback) {
    return new CompositeDisposable(
      ...this.getPaneContainers().map(container =>
        container.onWillDestroyPane(callback)
      )
    );
  }

  // Extended: Invoke the given callback when a pane is destroyed in the
  // workspace.
  //
  // * `callback` {Function} to be called panes are destroyed.
  //   * `event` {Object} with the following keys:
  //     * `pane` The destroyed pane.
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  onDidDestroyPane(callback) {
    return new CompositeDisposable(
      ...this.getPaneContainers().map(container =>
        container.onDidDestroyPane(callback)
      )
    );
  }

  // Extended: Invoke the given callback with all current and future panes in the
  // workspace.
  //
  // * `callback` {Function} to be called with current and future panes.
  //   * `pane` A {Pane} that is present in {::getPanes} at the time of
  //      subscription or that is added at some later time.
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  observePanes(callback) {
    return new CompositeDisposable(
      ...this.getPaneContainers().map(container =>
        container.observePanes(callback)
      )
    );
  }

  // Extended: Invoke the given callback when the active pane changes.
  //
  // * `callback` {Function} to be called when the active pane changes.
  //   * `pane` A {Pane} that is the current return value of {::getActivePane}.
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  onDidChangeActivePane(callback) {
    return this.emitter.on('did-change-active-pane', callback);
  }

  // Extended: Invoke the given callback with the current active pane and when
  // the active pane changes.
  //
  // * `callback` {Function} to be called with the current and future active#
  //   panes.
  //   * `pane` A {Pane} that is the current return value of {::getActivePane}.
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  observeActivePane(callback) {
    callback(this.getActivePane());
    return this.onDidChangeActivePane(callback);
  }

  // Extended: Invoke the given callback when a pane item is added to the
  // workspace.
  //
  // * `callback` {Function} to be called when pane items are added.
  //   * `event` {Object} with the following keys:
  //     * `item` The added pane item.
  //     * `pane` {Pane} containing the added item.
  //     * `index` {Number} indicating the index of the added item in its pane.
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  onDidAddPaneItem(callback) {
    return new CompositeDisposable(
      ...this.getPaneContainers().map(container =>
        container.onDidAddPaneItem(callback)
      )
    );
  }

  // Extended: Invoke the given callback when a pane item is about to be
  // destroyed, before the user is prompted to save it.
  //
  // * `callback` {Function} to be called before pane items are destroyed. If this function returns
  //   a {Promise}, then the item will not be destroyed until the promise resolves.
  //   * `event` {Object} with the following keys:
  //     * `item` The item to be destroyed.
  //     * `pane` {Pane} containing the item to be destroyed.
  //     * `index` {Number} indicating the index of the item to be destroyed in
  //       its pane.
  //
  // Returns a {Disposable} on which `.dispose` can be called to unsubscribe.
  onWillDestroyPaneItem(callback) {
    return new CompositeDisposable(
      ...this.getPaneContainers().map(container =>
        container.onWillDestroyPaneItem(callback)
      )
    );
  }

  // Extended: Invoke the given callback when a pane item is destroyed.
  //
  // * `callback` {Function} to be called when pane items are destroyed.
  //   * `event` {Object} with the following keys:
  //     * `item` The destroyed item.
  //     * `pane` {Pane} containing the destroyed item.
  //     * `index` {Number} indicating the index of the destroyed item in its
  //       pane.
  //
  // Returns a {Disposable} on which `.dispose` can be called to unsubscribe.
  onDidDestroyPaneItem(callback) {
    return new CompositeDisposable(
      ...this.getPaneContainers().map(container =>
        container.onDidDestroyPaneItem(callback)
      )
    );
  }

  // Extended: Invoke the given callback when a text editor is added to the
  // workspace.
  //
  // * `callback` {Function} to be called panes are added.
  //   * `event` {Object} with the following keys:
  //     * `textEditor` {TextEditor} that was added.
  //     * `pane` {Pane} containing the added text editor.
  //     * `index` {Number} indicating the index of the added text editor in its
  //        pane.
  //
  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
  onDidAddTextEditor(callback) {
    return this.emitter.on('did-add-text-editor', callback);
  }

  onDidChangeWindowTitle(callback) {
    return this.emitter.on('did-change-window-title', callback);
  }

  /*
  Section: Opening
  */

  // Essential: Opens the given URI in Pulsar asynchronously.
  // If the URI is already open, the existing item for that URI will be
  // activated. If no URI is given, or no registered opener can open
  // the URI, a new empty {TextEditor} will be created.
  //
  // * `uri` (optional) A {String} containing a URI.
  // * `options` (optional) {Object}
  //   * `initialLine` A {Number} indicating which row to move the cursor to
  //     initially. Defaults to `0`.
  //   * `initialColumn` A {Number} indicating which column to move the cursor to
  //     initially. Defaults to `0`.
  //   * `split` Either 'left', 'right', 'up' or 'down'.
  //     If 'left', the item will be opened in leftmost pane of the current active pane's row.
  //     If 'right', the item will be opened in the rightmost pane of the current active pane's row. If only one pane exists in the row, a new pane will be created.
  //     If 'up', the item will be opened in topmost pane of the current active pane's column.
  //     If 'down', the item will be opened in the bottommost pane of the current active pane's column. If only one pane exists in the column, a new pane will be created.
  //   * `activatePane` A {Boolean} indicating whether to call {Pane::activate} on
  //     containing pane. Defaults to `true`.
  //   * `activateItem` A {Boolean} indicating whether to call {Pane::activateItem}
  //     on containing pane. Defaults to `true`.
  //   * `pending` A {Boolean} indicating whether or not the item should be opened
  //     in a pending state. Existing pending items in a pane are replaced with
  //     new pending items when they are opened.
  //   * `searchAllPanes` A {Boolean}. If `true`, the workspace will attempt to
  //     activate an existing item for the given URI on any pane.
  //     If `false`, only the active pane will be searched for
  //     an existing item for the same URI. Defaults to `false`.
  //   * `location` (optional) A {String} containing the name of the location
  //     in which this item should be opened (one of "left", "right", "bottom",
  //     or "center"). If omitted, Pulsar will fall back to the last location in
  //     which a user has placed an item with the same URI or, if this is a new
  //     URI, the default location specified by the item. NOTE: This option
  //     should almost always be omitted to honor user preference.
  //
  // Returns a {Promise} that resolves to the {TextEditor} for the file URI.
  async open(itemOrURI, options = {}) {
    let uri, item;
    if (typeof itemOrURI === 'string') {
      uri = this.project.resolvePath(itemOrURI);
    } else if (itemOrURI) {
      item = itemOrURI;
      if (typeof item.getURI === 'function') uri = item.getURI();
    }

    let resolveItem = () => {};
    if (uri) {
      const incomingItem = this.incoming.get(uri);
      if (!incomingItem) {
        this.incoming.set(
          uri,
          new Promise(resolve => {
            resolveItem = resolve;
          })
        );
      } else {
        await incomingItem;
      }
    }

    try {
      if (!atom.config.get('core.allowPendingPaneItems')) {
        options.pending = false;
      }

      // Avoid adding URLs as recent documents to work-around this Spotlight crash:
      // https://github.com/atom/atom/issues/10071
      if (uri && (!url.parse(uri).protocol || process.platform === 'win32')) {
        this.applicationDelegate.addRecentDocument(uri);
      }

      let pane, itemExistsInWorkspace;

      // Try to find an existing item in the workspace.
      if (item || uri) {
        if (options.pane) {
          pane = options.pane;
        } else if (options.searchAllPanes) {
          pane = item ? this.paneForItem(item) : this.paneForURI(uri);
        } else {
          // If an item with the given URI is already in the workspace, assume
          // that item's pane container is the preferred location for that URI.
          let container;
          if (uri) container = this.paneContainerForURI(uri);
          if (!container) container = this.getActivePaneContainer();

          // The `split` option affects where we search for the item.
          pane = container.getActivePane();
          switch (options.split) {
            case 'left':
              pane = pane.findLeftmostSibling();
              break;
            case 'right':
              pane = pane.findRightmostSibling();
              break;
            case 'up':
              pane = pane.findTopmostSibling();
              break;
            case 'down':
              pane = pane.findBottommostSibling();
              break;
          }
        }

        if (pane) {
          if (item) {
            itemExistsInWorkspace = pane.getItems().includes(item);
          } else {
            item = pane.itemForURI(uri);
            itemExistsInWorkspace = item != null;
          }
        }
      }

      // If we already have an item at this stage, we won't need to do an async
      // lookup of the URI, so we yield the event loop to ensure this method
      // is consistently asynchronous.
      if (item) await Promise.resolve();

      if (!itemExistsInWorkspace) {
        item = item || (await this.createItemForURI(uri, options));
        if (!item) return;

        if (options.pane) {
          pane = options.pane;
        } else {
          let location = options.location;
          if (!location && !options.split && uri && this.enablePersistence) {
            location = await this.itemLocationStore.load(uri);
          }
          if (!location && typeof item.getDefaultLocation === 'function') {
            location = item.getDefaultLocation();
          }

          const allowedLocations =
            typeof item.getAllowedLocations === 'function'
              ? item.getAllowedLocations()
              : ALL_LOCATIONS;
          location = allowedLocations.includes(location)
            ? location
            : allowedLocations[0];

          const container = this.paneContainers[location] || this.getCenter();
          pane = container.getActivePane();
          switch (options.split) {
            case 'left':
              pane = pane.findLeftmostSibling();
              break;
            case 'right':
              pane = pane.findOrCreateRightmostSibling();
              break;
            case 'up':
              pane = pane.findTopmostSibling();
              break;
            case 'down':
              pane = pane.findOrCreateBottommostSibling();
              break;
          }
        }
      }

      if (!options.pending && pane.getPendingItem() === item) {
        pane.clearPendingItem();
      }

      this.itemOpened(item);

      if (options.activateItem === false) {
        pane.addItem(item, { pending: options.pending });
      } else {
        pane.activateItem(item, { pending: options.pending });
      }

      if (options.activatePane !== false) {
        pane.activate();
      }

      let initialColumn = 0;
      let initialLine = 0;
      if (!Number.isNaN(options.initialLine)) {
        initialLine = options.initialLine;
      }
      if (!Number.isNaN(options.initialColumn)) {
        initialColumn = options.initialColumn;
      }
      if (initialLine >= 0 || initialColumn >= 0) {
        if (typeof item.setCursorBufferPosition === 'function') {
          item.setCursorBufferPosition([initialLine, initialColumn]);
        }
        if (typeof item.unfoldBufferRow === 'function') {
          item.unfoldBufferRow(initialLine);
        }
        if (typeof item.scrollToBufferPosition === 'function') {
          item.scrollToBufferPosition([initialLine, initialColumn], {
            center: true
          });
        }
      }

      const index = pane.getActiveItemIndex();
      this.emitter.emit('did-open', { uri, pane, item, index });
      if (uri) {
        this.incoming.delete(uri);
      }

      // After emitting the open event, lets trigger any packages activation commands
      let activationHookItem;
      let activationHookText;

      if (item instanceof TextEditor) {
        // This is a TextEditor opening, meaning a file
        activationHookItem = item.getTitle();
        activationHookText = "file-name-opened";
      } else {
        activationHookText = "uri-opened";
        if (typeof item.getURI === "function") {
          activationHookItem = item.getURI();
        } else if (typeof item.getUri === "function") {
          activationHookItem = item.getUri();
        } else {
          activationHookItem = "";
          activationHookText = "";
          // We are purposefully redeclaring the text here, to fail gracefully
        }
      }

      if (activationHookText?.length > 1 && activationHookItem?.length > 1) {
        this.packageManager.triggerActivationHook(
          `${activationHookItem}:${activationHookText}`
        );
      }

    } finally {
      resolveItem();
    }
    return item;
  }

  // Essential: Search the workspace for items matching the given URI and hide them.
  //
  // * `itemOrURI` The item to hide or a {String} containing the URI
  //   of the item to hide.
  //
  // Returns a {Boolean} indicating whether any items were found (and hidden).
  hide(itemOrURI) {
    let foundItems = false;

    // If any visible item has the given URI, hide it
    for (const container of this.getPaneContainers()) {
      const isCenter = container === this.getCenter();
      if (isCenter || container.isVisible()) {
        for (const pane of container.getPanes()) {
          const activeItem = pane.getActiveItem();
          const foundItem =
            activeItem != null &&
            (activeItem === itemOrURI ||
              (typeof activeItem.getURI === 'function' &&
                activeItem.getURI() === itemOrURI));
          if (foundItem) {
            foundItems = true;
            // We can't really hide the center so we just destroy the item.
            if (isCenter) {
              pane.destroyItem(activeItem);
            } else {
              container.hide();
            }
          }
        }
      }
    }

    return foundItems;
  }

  // Essential: Search the workspace for items matching the given URI. If any are found, hide them.
  // Otherwise, open the URL.
  //
  // * `itemOrURI` (optional) The item to toggle or a {String} containing the URI
  //   of the item to toggle.
  //
  // Returns a Promise that resolves when the item is shown or hidden.
  toggle(itemOrURI) {
    if (this.hide(itemOrURI)) {
      return Promise.resolve();
    } else {
      return this.open(itemOrURI, { searchAllPanes: true });
    }
  }

  // Open Pulsar's license in the active pane.
  openLicense() {
    const resPath = path.join(process.resourcesPath, 'LICENSE.md')
    if(fs.existsSync(resPath)) {
      return this.open(resPath);
    } else {
      return this.open(path.join(__dirname, '..', 'LICENSE.md'))
    }
  }

  // Synchronously open the given URI in the active pane. **Only use this method
  // in specs. Calling this in production code will block the UI thread and
  // everyone will be mad at you.**
  //
  // * `uri` A {String} containing a URI.
  // * `options` An optional options {Object}
  //   * `initialLine` A {Number} indicating which row to move the cursor to
  //     initially. Defaults to `0`.
  //   * `initialColumn` A {Number} indicating which column to move the cursor to
  //     initially. Defaults to `0`.
  //   * `activatePane` A {Boolean} indicating whether to call {Pane::activate} on
  //     the containing pane. Defaults to `true`.
  //   * `activateItem` A {Boolean} indicating whether to call {Pane::activateItem}
  //     on containing pane. Defaults to `true`.
  openSync(uri_ = '', options = {}) {
    const { initialLine, initialColumn } = options;
    const activatePane =
      options.activatePane != null ? options.activatePane : true;
    const activateItem =
      options.activateItem != null ? options.activateItem : true;

    const uri = this.project.resolvePath(uri_);
    let item = this.getActivePane().itemForURI(uri);
    if (uri && item == null) {
      for (const opener of this.getOpeners()) {
        item = opener(uri, options);
        if (item) break;
      }
    }
    if (item == null) {
      item = this.project.openSync(uri, { initialLine, initialColumn });
    }

    if (activateItem) {
      this.getActivePane().activateItem(item);
    }
    this.itemOpened(item);
    if (activatePane) {
      this.getActivePane().activate();
    }
    return item;
  }

  openURIInPane(uri, pane) {
    return this.open(uri, { pane });
  }

  // Public: Creates a new item that corresponds to the provided URI.
  //
  // If no URI is given, or no registered opener can open the URI, a new empty
  // {TextEditor} will be created.
  //
  // * `uri` A {String} containing a URI.
  //
  // Returns a {Promise} that resolves to the {TextEditor} (or other item) for the given URI.
  async createItemForURI(uri, options) {
    if (uri != null) {
      for (const opener of this.getOpeners()) {
        const item = opener(uri, options);
        if (item != null) return item;
      }
    }

    try {
      const item = await this.openTextFile(uri, options);
      return item;
    } catch (error) {
      switch (error.code) {
        case 'CANCELLED':
          return Promise.resolve();
        case 'EACCES':
          this.notificationManager.addWarning(
            `Permission denied '${error.path}'`
          );
          return Promise.resolve();
        case 'EPERM':
        case 'EBUSY':
        case 'ENXIO':
        case 'EIO':
        case 'ENOTCONN':
        case 'UNKNOWN':
        case 'ECONNRESET':
        case 'EINVAL':
        case 'EMFILE':
        case 'ENOTDIR':
        case 'EAGAIN':
          this.notificationManager.addWarning(
            `Unable to open '${error.path != null ? error.path : uri}'`,
            { detail: error.message }
          );
          return Promise.resolve();
        default:
          throw error;
      }
    }
  }

  async openTextFile(uri, options) {
    const filePath = this.project.resolvePath(uri);

    if (filePath != null) {
      try {
        fs.closeSync(fs.openSync(filePath, 'r'));
      } catch (error) {
        // allow ENOENT errors to create an editor for paths that dont exist
        if (error.code !== 'ENOENT') {
          throw error;
        }
      }
    }

    const fileSize = fs.getSizeSync(filePath);

    if (fileSize >= this.config.get('core.warnOnLargeFileLimit') * 1048576) {
      // 40MB by default
      await new Promise((resolve, reject) => {
        this.applicationDelegate.confirm(
          {
            message:
              'Pulsar will be unresponsive during the loading of very large files.',
            detail: 'Do you still want to load this file?',
            buttons: ['Proceed', 'Cancel']
          },
          response => {
            if (response === 1) {
              const error = new Error();
              error.code = 'CANCELLED';
              reject(error);
            } else {
              resolve();
            }
          }
        );
      });
    }

    const buffer = await this.project.bufferForPath(filePath, options);
    return this.textEditorRegistry.build(
      Object.assign({ buffer, autoHeight: false }, options)
    );
  }

  handleGrammarUsed(grammar) {
    if (grammar == null) {
      return;
    }
    this.packageManager.triggerActivationHook(
      `${grammar.scopeName}:root-scope-used`
    );
    this.packageManager.triggerActivationHook(
      `${grammar.packageName}:grammar-used`
    );
  }

  // Public: Returns a {Boolean} that is `true` if `object` is a `TextEditor`.
  //
  // * `object` An {Object} you want to perform the check against.
  isTextEditor(object) {
    return object instanceof TextEditor;
  }

  // Extended: Create a new text editor.
  //
  // Returns a {TextEditor}.
  buildTextEditor(params) {
    const editor = this.textEditorRegistry.build(params);
    const subscription = this.textEditorRegistry.maintainConfig(editor);
    editor.onDidDestroy(() => subscription.dispose());
    return editor;
  }

  // Public: Asynchronously reopens the last-closed item's URI if it hasn't already been
  // reopened.
  //
  // Returns a {Promise} that is resolved when the item is opened
  reopenItem() {
    const uri = this.destroyedItemURIs.pop();
    if (uri) {
      return this.open(uri);
    } else {
      return Promise.resolve();
    }
  }

  // Public: Register an opener for a uri.
  //
  // When a URI is opened via {Workspace::open}, Pulsar loops through its registered
  // opener functions until one returns a value for the given uri.
  // Openers are expected to return an object that inherits from HTMLElement or
  // a model which has an associated view in the {ViewRegistry}.
  // A {TextEditor} will be used if no opener returns a value.
  //
  // ## Examples
  //
  // ```coffee
  // atom.workspace.addOpener (uri) ->
  //   if path.extname(uri) is '.toml'
  //     return new TomlEditor(uri)
  // ```
  //
  // * `opener` A {Function} to be called when a path is being opened.
  //
  // Returns a {Disposable} on which `.dispose()` can be called to remove the
  // opener.
  //
  // Note that the opener will be called if and only if the URI is not already open
  // in the current pane. The searchAllPanes flag expands the search from the
  // current pane to all panes. If you wish to open a view of a different type for
  // a file that is already open, consider changing the protocol of the URI. For
  // example, perhaps you wish to preview a rendered version of the file `/foo/bar/baz.quux`
  // that is already open in a text editor view. You could signal this by calling
  // {Workspace::open} on the URI `quux-preview://foo/bar/baz.quux`. Then your opener
  // can check the protocol for quux-preview and only handle those URIs that match.
  //
  // To defer your package's activation until a specific URL is opened, add a
  // `workspaceOpeners` field to your `package.json` containing an array of URL
  // strings.
  addOpener(opener) {
    this.openers.push(opener);
    return new Disposable(() => {
      _.remove(this.openers, opener);
    });
  }

  getOpeners() {
    return this.openers;
  }

  /*
  Section: Pane Items
  */

  // Essential: Get all pane items in the workspace.
  //
  // Returns an {Array} of items.
  getPaneItems() {
    return _.flatten(
      this.getPaneContainers().map(container => container.getPaneItems())
    );
  }

  // Essential: Get the active {Pane}'s active item.
  //
  // Returns a pane item {Object}.
  getActivePaneItem() {
    return this.getActivePaneContainer().getActivePaneItem();
  }

  // Essential: Get all text editors in the workspace, if they are pane items.
  //
  // Returns an {Array} of {TextEditor}s.
  getTextEditors() {
    return this.getPaneItems().filter(item => item instanceof TextEditor);
  }

  // Essential: Get the workspace center's active item if it is a {TextEditor}.
  //
  // Returns a {TextEditor} or `undefined` if the workspace center's current
  // active item is not a {TextEditor}.
  getActiveTextEditor() {
    const activeItem = this.getCenter().getActivePaneItem();
    if (activeItem instanceof TextEditor) {
      return activeItem;
    }
  }

  // Save all pane items.
  saveAll() {
    this.getPaneContainers().forEach(container => {
      container.saveAll();
    });
  }

  confirmClose(options) {
    return Promise.all(
      this.getPaneContainers().map(container => container.confirmClose(options))
    ).then(results => !results.includes(false));
  }

  // Save the active pane item.
  //
  // If the active pane item currently has a URI according to the item's
  // `.getURI` method, calls `.save` on the item. Otherwise
  // {::saveActivePaneItemAs} # will be called instead. This method does nothing
  // if the active item does not implement a `.save` method.
  saveActivePaneItem() {
    return this.getCenter()
      .getActivePane()
      .saveActiveItem();
  }

  // Prompt the user for a path and save the active pane item to it.
  //
  // Opens a native dialog where the user selects a path on disk, then calls
  // `.saveAs` on the item with the selected path. This method does nothing if
  // the active item does not implement a `.saveAs` method.
  saveActivePaneItemAs() {
    this.getCenter()
      .getActivePane()
      .saveActiveItemAs();
  }

  // Destroy (close) the active pane item.
  //
  // Removes the active pane item and calls the `.destroy` method on it if one is
  // defined.
  destroyActivePaneItem() {
    return this.getActivePane().destroyActiveItem();
  }

  /*
  Section: Panes
  */

  // Extended: Get the most recently focused pane container.
  //
  // Returns a {Dock} or the {WorkspaceCenter}.
  getActivePaneContainer() {
    return this.activePaneContainer;
  }

  // Extended: Get all panes in the workspace.
  //
  // Returns an {Array} of {Pane}s.
  getPanes() {
    return _.flatten(
      this.getPaneContainers().map(container => container.getPanes())
    );
  }

  getVisiblePanes() {
    return _.flatten(
      this.getVisiblePaneContainers().map(container => container.getPanes())
    );
  }

  // Extended: Get the active {Pane}.
  //
  // Returns a {Pane}.
  getActivePane() {
    return this.getActivePaneContainer().getActivePane();
  }

  // Extended: Make the next pane active.
  activateNextPane() {
    return this.getActivePaneContainer().activateNextPane();
  }

  // Extended: Make the previous pane active.
  activatePreviousPane() {
    return this.getActivePaneContainer().activatePreviousPane();
  }

  // Extended: Get the first pane container that contains an item with the given
  // URI.
  //
  // * `uri` {String} uri
  //
  // Returns a {Dock}, the {WorkspaceCenter}, or `undefined` if no item exists
  // with the given URI.
  paneContainerForURI(uri) {
    return this.getPaneContainers().find(container =>
      container.paneForURI(uri)
    );
  }

  // Extended: Get the first pane container that contains the given item.
  //
  // * `item` the Item that the returned pane container must contain.
  //
  // Returns a {Dock}, the {WorkspaceCenter}, or `undefined` if no item exists
  // with the given URI.
  paneContainerForItem(uri) {
    return this.getPaneContainers().find(container =>
      container.paneForItem(uri)
    );
  }

  // Extended: Get the first {Pane} that contains an item with the given URI.
  //
  // * `uri` {String} uri
  //
  // Returns a {Pane} or `undefined` if no item exists with the given URI.
  paneForURI(uri) {
    for (let location of this.getPaneContainers()) {
      const pane = location.paneForURI(uri);
      if (pane != null) {
        return pane;
      }
    }
  }

  // Extended: Get the {Pane} containing the given item.
  //
  // * `item` the Item that the returned pane must contain.
  //
  // Returns a {Pane} or `undefined` if no pane exists for the given item.
  paneForItem(item) {
    for (let location of this.getPaneContainers()) {
      const pane = location.paneForItem(item);
      if (pane != null) {
        return pane;
      }
    }
  }

  // Destroy (close) the active pane.
  destroyActivePane() {
    const activePane = this.getActivePane();
    if (activePane != null) {
      activePane.destroy();
    }
  }

  // Close the active center pane item, or the active center pane if it is
  // empty, or the current window if there is only the empty root pane.
  closeActivePaneItemOrEmptyPaneOrWindow() {
    if (this.getCenter().getActivePaneItem() != null) {
      this.getCenter()
        .getActivePane()
        .destroyActiveItem();
    } else if (this.getCenter().getPanes().length > 1) {
      this.getCenter().destroyActivePane();
    } else if (this.config.get('core.closeEmptyWindows')) {
      atom.close();
    }
  }

  // Increase the editor font size by 1px.
  increaseFontSize() {
    this.config.set('editor.fontSize', this.config.get('editor.fontSize') + 1);
  }

  // Decrease the editor font size by 1px.
  decreaseFontSize() {
    const fontSize = this.config.get('editor.fontSize');
    if (fontSize > 1) {
      this.config.set('editor.fontSize', fontSize - 1);
    }
  }

  // Restore to the window's default editor font size.
  resetFontSize() {
    this.config.set(
      'editor.fontSize',
      this.config.get('editor.defaultFontSize')
    );
  }

  // Removes the item's uri from the list of potential items to reopen.
  itemOpened(item) {
    let uri;
    if (typeof item.getURI === 'function') {
      uri = item.getURI();
    } else if (typeof item.getUri === 'function') {
      uri = item.getUri();
    }

    if (uri != null) {
      _.remove(this.destroyedItemURIs, uri);
    }
  }

  // Adds the destroyed item's uri to the list of items to reopen.
  didDestroyPaneItem({ item }) {
    let uri;
    if (typeof item.getURI === 'function') {
      uri = item.getURI();
    } else if (typeof item.getUri === 'function') {
      uri = item.getUri();
    }

    if (uri != null) {
      this.destroyedItemURIs.push(uri);
    }
  }

  // Called by Model superclass when destroyed
  destroyed() {
    this.paneContainers.center.destroy();
    this.paneContainers.left.destroy();
    this.paneContainers.right.destroy();
    this.paneContainers.bottom.destroy();
    this.cancelStoppedChangingActivePaneItemTimeout();
    if (this.activeItemSubscriptions != null) {
      this.activeItemSubscriptions.dispose();
    }
    if (this.element) this.element.destroy();
  }

  /*
  Section: Pane Locations
  */

  // Essential: Get the {WorkspaceCenter} at the center of the editor window.
  getCenter() {
    return this.paneContainers.center;
  }

  // Essential: Get the {Dock} to the left of the editor window.
  getLeftDock() {
    return this.paneContainers.left;
  }

  // Essential: Get the {Dock} to the right of the editor window.
  getRightDock() {
    return this.paneContainers.right;
  }

  // Essential: Get the {Dock} below the editor window.
  getBottomDock() {
    return this.paneContainers.bottom;
  }

  getPaneContainers() {
    return [
      this.paneContainers.center,
      this.paneContainers.left,
      this.paneContainers.right,
      this.paneContainers.bottom
    ];
  }

  getVisiblePaneContainers() {
    const center = this.getCenter();
    return atom.workspace
      .getPaneContainers()
      .filter(container => container === center || container.isVisible());
  }

  /*
  Section: Panels

  Panels are used to display UI related to an editor window. They are placed at one of the four
  edges of the window: left, right, top or bottom. If there are multiple panels on the same window
  edge they are stacked in order of priority: higher priority is closer to the center, lower
  priority towards the edge.

  *Note:* If your panel changes its size throughout its lifetime, consider giving it a higher
  priority, allowing fixed size panels to be closer to the edge. This allows control targets to
  remain more static for easier targeting by users that employ mice or trackpads. (See
  [atom/atom#4834](https://github.com/atom/atom/issues/4834) for discussion.)
  */

  // Essential: Get an {Array} of all the panel items at the bottom of the editor window.
  getBottomPanels() {
    return this.getPanels('bottom');
  }

  // Essential: Adds a panel item to the bottom of the editor window.
  //
  // * `options` {Object}
  //   * `item` Your panel content. It can be DOM element, a jQuery element, or
  //     a model with a view registered via {ViewRegistry::addViewProvider}. We recommend the
  //     latter. See {ViewRegistry::addViewProvider} for more information.
  //   * `visible` (optional) {Boolean} false if you want the panel to initially be hidden
  //     (default: true)
  //   * `priority` (optional) {Number} Determines stacking order. Lower priority items are
  //     forced closer to the edges of the window. (default: 100)
  //
  // Returns a {Panel}
  addBottomPanel(options) {
    return this.addPanel('bottom', options);
  }

  // Essential: Get an {Array} of all the panel items to the left of the editor window.
  getLeftPanels() {
    return this.getPanels('left');
  }

  // Essential: Adds a panel item to the left of the editor window.
  //
  // * `options` {Object}
  //   * `item` Your panel content. It can be DOM element, a jQuery element, or
  //     a model with a view registered via {ViewRegistry::addViewProvider}. We recommend the
  //     latter. See {ViewRegistry::addViewProvider} for more information.
  //   * `visible` (optional) {Boolean} false if you want the panel to initially be hidden
  //     (default: true)
  //   * `priority` (optional) {Number} Determines stacking order. Lower priority items are
  //     forced closer to the edges of the window. (default: 100)
  //
  // Returns a {Panel}
  addLeftPanel(options) {
    return this.addPanel('left', options);
  }

  // Essential: Get an {Array} of all the panel items to the right of the editor window.
  getRightPanels() {
    return this.getPanels('right');
  }

  // Essential: Adds a panel item to the right of the editor window.
  //
  // * `options` {Object}
  //   * `item` Your panel content. It can be DOM element, a jQuery element, or
  //     a model with a view registered via {ViewRegistry::addViewProvider}. We recommend the
  //     latter. See {ViewRegistry::addViewProvider} for more information.
  //   * `visible` (optional) {Boolean} false if you want the panel to initially be hidden
  //     (default: true)
  //   * `priority` (optional) {Number} Determines stacking order. Lower priority items are
  //     forced closer to the edges of the window. (default: 100)
  //
  // Returns a {Panel}
  addRightPanel(options) {
    return this.addPanel('right', options);
  }

  // Essential: Get an {Array} of all the panel items at the top of the editor window.
  getTopPanels() {
    return this.getPanels('top');
  }

  // Essential: Adds a panel item to the top of the editor window above the tabs.
  //
  // * `options` {Object}
  //   * `item` Your panel content. It can be DOM element, a jQuery element, or
  //     a model with a view registered via {ViewRegistry::addViewProvider}. We recommend the
  //     latter. See {ViewRegistry::addViewProvider} for more information.
  //   * `visible` (optional) {Boolean} false if you want the panel to initially be hidden
  //     (default: true)
  //   * `priority` (optional) {Number} Determines stacking order. Lower priority items are
  //     forced closer to the edges of the window. (default: 100)
  //
  // Returns a {Panel}
  addTopPanel(options) {
    return this.addPanel('top', options);
  }

  // Essential: Get an {Array} of all the panel items in the header.
  getHeaderPanels() {
    return this.getPanels('header');
  }

  // Essential: Adds a panel item to the header.
  //
  // * `options` {Object}
  //   * `item` Your panel content. It can be DOM element, a jQuery element, or
  //     a model with a view registered via {ViewRegistry::addViewProvider}. We recommend the
  //     latter. See {ViewRegistry::addViewProvider} for more information.
  //   * `visible` (optional) {Boolean} false if you want the panel to initially be hidden
  //     (default: true)
  //   * `priority` (optional) {Number} Determines stacking order. Lower priority items are
  //     forced closer to the edges of the window. (default: 100)
  //
  // Returns a {Panel}
  addHeaderPanel(options) {
    return this.addPanel('header', options);
  }

  // Essential: Get an {Array} of all the panel items in the footer.
  getFooterPanels() {
    return this.getPanels('footer');
  }

  // Essential: Adds a panel item to the footer.
  //
  // * `options` {Object}
  //   * `item` Your panel content. It can be DOM element, a jQuery element, or
  //     a model with a view registered via {ViewRegistry::addViewProvider}. We recommend the
  //     latter. See {ViewRegistry::addViewProvider} for more information.
  //   * `visible` (optional) {Boolean} false if you want the panel to initially be hidden
  //     (default: true)
  //   * `priority` (optional) {Number} Determines stacking order. Lower priority items are
  //     forced closer to the edges of the window. (default: 100)
  //
  // Returns a {Panel}
  addFooterPanel(options) {
    return this.addPanel('footer', options);
  }

  // Essential: Get an {Array} of all the modal panel items
  getModalPanels() {
    return this.getPanels('modal');
  }

  // Essential: Adds a panel item as a modal dialog.
  //
  // * `options` {Object}
  //   * `item` Your panel content. It can be a DOM element, a jQuery element, or
  //     a model with a view registered via {ViewRegistry::addViewProvider}. We recommend the
  //     model option. See {ViewRegistry::addViewProvider} for more information.
  //   * `visible` (optional) {Boolean} false if you want the panel to initially be hidden
  //     (default: true)
  //   * `priority` (optional) {Number} Determines stacking order. Lower priority items are
  //     forced closer to the edges of the window. (default: 100)
  //   * `autoFocus` (optional) {Boolean|Element} true if you want modal focus managed for you by Pulsar.
  //     Pulsar will automatically focus on this element or your modal panel's first tabbable element when the modal
  //     opens and will restore the previously selected element when the modal closes. Pulsar will
  //     also automatically restrict user tab focus within your modal while it is open.
  //     (default: false)
  //
  // Returns a {Panel}
  addModalPanel(options = {}) {
    return this.addPanel('modal', options);
  }

  // Essential: Returns the {Panel} associated with the given item. Returns
  // `null` when the item has no panel.
  //
  // * `item` Item the panel contains
  panelForItem(item) {
    for (let location in this.panelContainers) {
      const container = this.panelContainers[location];
      const panel = container.panelForItem(item);
      if (panel != null) {
        return panel;
      }
    }
    return null;
  }

  getPanels(location) {
    return this.panelContainers[location].getPanels();
  }

  addPanel(location, options) {
    if (options == null) {
      options = {};
    }
    return this.panelContainers[location].addPanel(
      new Panel(options, this.viewRegistry)
    );
  }

  /*
  Section: Searching and Replacing
  */

  // Public: Performs a search across all files in the workspace.
  //
  // * `regex` {RegExp} to search with.
  // * `options` (optional) {Object}
  //   * `paths` An {Array} of glob patterns to search within.
  //   * `onPathsSearched` (optional) {Function} to be periodically called
  //     with number of paths searched.
  //   * `leadingContextLineCount` {Number} default `0`; The number of lines
  //      before the matched line to include in the results object.
  //   * `trailingContextLineCount` {Number} default `0`; The number of lines
  //      after the matched line to include in the results object.
  // * `iterator` {Function} callback on each file found.
  //
  // Returns a {Promise} with a `cancel()` method that will cancel all
  // of the underlying searches that were started as part of this scan.
  scan(regex, options = {}, iterator) {
    if (_.isFunction(options)) {
      iterator = options;
      options = {};
    }

    // Find a searcher for every Directory in the project. Each searcher that is matched
    // will be associated with an Array of Directory objects in the Map.
    const directoriesForSearcher = new Map();
    for (const directory of this.project.getDirectories()) {
      let searcher = options.ripgrep
        ? this.ripgrepDirectorySearcher
        : this.scandalDirectorySearcher;
      for (const directorySearcher of this.directorySearchers) {
        if (directorySearcher.canSearchDirectory(directory)) {
          searcher = directorySearcher;
          break;
        }
      }
      let directories = directoriesForSearcher.get(searcher);
      if (!directories) {
        directories = [];
        directoriesForSearcher.set(searcher, directories);
      }
      directories.push(directory);
    }

    // Define the onPathsSearched callback.
    let onPathsSearched;
    if (_.isFunction(options.onPathsSearched)) {
      // Maintain a map of directories to the number of search results. When notified of a new count,
      // replace the entry in the map and update the total.
      const onPathsSearchedOption = options.onPathsSearched;
      let totalNumberOfPathsSearched = 0;
      const numberOfPathsSearchedForSearcher = new Map();
      onPathsSearched = function(searcher, numberOfPathsSearched) {
        const oldValue = numberOfPathsSearchedForSearcher.get(searcher);
        if (oldValue) {
          totalNumberOfPathsSearched -= oldValue;
        }
        numberOfPathsSearchedForSearcher.set(searcher, numberOfPathsSearched);
        totalNumberOfPathsSearched += numberOfPathsSearched;
        return onPathsSearchedOption(totalNumberOfPathsSearched);
      };
    } else {
      onPathsSearched = function() {};
    }

    // Kick off all of the searches and unify them into one Promise.
    const allSearches = [];
    directoriesForSearcher.forEach((directories, searcher) => {
      const searchOptions = {
        inclusions: options.paths || [],
        includeHidden: true,
        excludeVcsIgnores: this.config.get('core.excludeVcsIgnoredPaths'),
        exclusions: this.config.get('core.ignoredNames'),
        follow: this.config.get('core.followSymlinks'),
        leadingContextLineCount: options.leadingContextLineCount || 0,
        trailingContextLineCount: options.trailingContextLineCount || 0,
        PCRE2: options.PCRE2,
        didMatch: result => {
          if (!this.project.isPathModified(result.filePath)) {
            return iterator(result);
          }
        },
        didError(error) {
          return iterator(null, error);
        },
        didSearchPaths(count) {
          return onPathsSearched(searcher, count);
        }
      };
      const directorySearcher = searcher.search(
        directories,
        regex,
        searchOptions
      );
      allSearches.push(directorySearcher);
    });
    const searchPromise = Promise.all(allSearches);

    for (let buffer of this.project.getBuffers()) {
      if (buffer.isModified()) {
        const filePath = buffer.getPath();
        if (!this.project.contains(filePath)) {
          continue;
        }
        var matches = [];
        buffer.scan(regex, match => matches.push(match));
        if (matches.length > 0) {
          iterator({ filePath, matches });
        }
      }
    }

    // Make sure the Promise that is returned to the client is cancelable. To be consistent
    // with the existing behavior, instead of cancel() rejecting the promise, it should
    // resolve it with the special value 'cancelled'. At least the built-in find-and-replace
    // package relies on this behavior.
    let isCancelled = false;
    const cancellablePromise = new Promise((resolve, reject) => {
      const onSuccess = function() {
        if (isCancelled) {
          resolve('cancelled');
        } else {
          resolve(null);
        }
      };

      const onFailure = function(error) {
        for (let promise of allSearches) {
          promise.cancel();
        }
        reject(error);
      };

      searchPromise.then(onSuccess, onFailure);
    });
    cancellablePromise.cancel = () => {
      isCancelled = true;
      // Note that cancelling all of the members of allSearches will cause all of the searches
      // to resolve, which causes searchPromise to resolve, which is ultimately what causes
      // cancellablePromise to resolve.
      allSearches.map(promise => promise.cancel());
    };

    return cancellablePromise;
  }

  // Public: Performs a replace across all the specified files in the project.
  //
  // * `regex` A {RegExp} to search with.
  // * `replacementText` {String} to replace all matches of regex with.
  // * `filePaths` An {Array} of file path strings to run the replace on.
  // * `iterator` A {Function} callback on each file with replacements:
  //   * `options` {Object} with keys `filePath` and `replacements`.
  //
  // Returns a {Promise}.
  replace(regex, replacementText, filePaths, iterator) {
    return new Promise((resolve, reject) => {
      let buffer;
      const openPaths = this.project
        .getBuffers()
        .map(buffer => buffer.getPath());
      const outOfProcessPaths = _.difference(filePaths, openPaths);

      let inProcessFinished = !openPaths.length;
      let outOfProcessFinished = !outOfProcessPaths.length;
      const checkFinished = () => {
        if (outOfProcessFinished && inProcessFinished) {
          resolve();
        }
      };

      if (!outOfProcessFinished.length) {
        let flags = 'g';
        if (regex.multiline) {
          flags += 'm';
        }
        if (regex.ignoreCase) {
          flags += 'i';
        }

        const task = Task.once(
          require.resolve('./replace-handler'),
          outOfProcessPaths,
          regex.source,
          flags,
          replacementText,
          () => {
            outOfProcessFinished = true;
            checkFinished();
          }
        );

        task.on('replace:path-replaced', iterator);
        task.on('replace:file-error', error => {
          iterator(null, error);
        });
      }

      for (buffer of this.project.getBuffers()) {
        if (!filePaths.includes(buffer.getPath())) {
          continue;
        }
        const replacements = buffer.replace(regex, replacementText, iterator);
        if (replacements) {
          iterator({ filePath: buffer.getPath(), replacements });
        }
      }

      inProcessFinished = true;
      checkFinished();
    });
  }

  checkoutHeadRevision(editor) {
    if (editor.getPath()) {
      const checkoutHead = async () => {
        const repository = await this.project.repositoryForDirectory(
          new Directory(editor.getDirectoryPath())
        );
        if (repository) repository.checkoutHeadForEditor(editor);
      };

      if (this.config.get('editor.confirmCheckoutHeadRevision')) {
        this.applicationDelegate.confirm(
          {
            message: 'Confirm Checkout HEAD Revision',
            detail: `Are you sure you want to discard all changes to "${editor.getFileName()}" since the last Git commit?`,
            buttons: ['OK', 'Cancel']
          },
          response => {
            if (response === 0) checkoutHead();
          }
        );
      } else {
        checkoutHead();
      }
    }
  }
};

================
File: static/index.html
================
<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Security-Policy" content="default-src * atom://*; img-src blob: data: * atom://*; script-src 'self' 'unsafe-eval'; style-src 'self' 'unsafe-inline'; media-src blob: data: mediastream: * atom://*;">
  <script src="index.js"></script>
</head>
<body tabindex="-1">
</body>
</html>

================
File: static/index.js
================
(function() {
  // Define the window start time before the requires so we get a more accurate
  // window:start marker.
  const startWindowTime = Date.now();

  const electron = require('electron');
  const path = require('path');
  const Module = require('module');
  const getWindowLoadSettings = require('../src/get-window-load-settings');
  const { getReleaseChannel } = require('../src/get-app-details.js');
  const StartupTime = require('../src/startup-time');
  const entryPointDirPath = __dirname;
  let blobStore = null;

  const startupMarkers = electron.remote.getCurrentWindow().startupMarkers;

  if (startupMarkers) {
    StartupTime.importData(startupMarkers);
  }
  StartupTime.addMarker('window:start', startWindowTime);

  window.onload = async function() {
    try {
      StartupTime.addMarker('window:onload:start');
      const startTime = Date.now();
      await require('second-mate').ready

      process.on('unhandledRejection', function(error, promise) {
        console.error(
          'Unhandled promise rejection %o with error: %o',
          promise,
          error
        );
      });

      // Normalize to make sure drive letter case is consistent on Windows
      process.resourcesPath = path.normalize(process.resourcesPath);

      setupAtomHome();
      const devMode =
        getWindowLoadSettings().devMode ||
        !getWindowLoadSettings().resourcePath.startsWith(
          process.resourcesPath + path.sep
        );

      const FileSystemBlobStore = require('../src/file-system-blob-store');
      blobStore = FileSystemBlobStore.load(
        path.join(process.env.ATOM_HOME, 'blob-store')
      );

      const NativeCompileCache = require('../src/native-compile-cache');
      NativeCompileCache.setCacheStore(blobStore);
      NativeCompileCache.setV8Version(process.versions.v8);
      NativeCompileCache.install();

      if (getWindowLoadSettings().profileStartup) {
        profileStartup(Date.now() - startTime);
      } else {
        StartupTime.addMarker('window:setup-window:start');
        setupWindow().then(() => {
          StartupTime.addMarker('window:setup-window:end');
        });
        setLoadTime(Date.now() - startTime);
      }
    } catch (error) {
      handleSetupError(error);
    }
    StartupTime.addMarker('window:onload:end');
  };

  function setLoadTime(loadTime) {
    if (global.atom) {
      global.atom.loadTime = loadTime;
    }
  }

  function handleSetupError(error) {
    const currentWindow = electron.remote.getCurrentWindow();
    currentWindow.setSize(800, 600);
    currentWindow.center();
    currentWindow.show();
    currentWindow.openDevTools();
    console.error(error.stack || error);
  }

  function setupWindow() {
    const CompileCache = require('../src/compile-cache');
    CompileCache.setAtomHomeDirectory(process.env.ATOM_HOME);
    CompileCache.install(process.resourcesPath, require);

    const ModuleCache = require('../src/module-cache');
    ModuleCache.register(getWindowLoadSettings());

    require('document-register-element');

    const Grim = require('grim');
    const documentRegisterElement = document.registerElement;

    document.registerElement = (type, options) => {
      Grim.deprecate(
        'Use `customElements.define` instead of `document.registerElement` see https://javascript.info/custom-elements'
      );

      return documentRegisterElement(type, options);
    };

    const { userSettings, appVersion } = getWindowLoadSettings();

    const CSON = require('season');
    CSON.setCacheDir(path.join(CompileCache.getCacheDirectory(), 'cson'));

    const initScriptPath = path.relative(
      entryPointDirPath,
      getWindowLoadSettings().windowInitializationScript
    );
    const initialize = require(initScriptPath);

    StartupTime.addMarker('window:initialize:start');

    return initialize({ blobStore: blobStore }).then(function() {
      StartupTime.addMarker('window:initialize:end');
      electron.ipcRenderer.send('window-command', 'window:loaded');
    });
  }

  function profileStartup(initialTime) {
    function profile() {
      console.profile('startup');
      const startTime = Date.now();
      setupWindow().then(function() {
        setLoadTime(Date.now() - startTime + initialTime);
        console.profileEnd('startup');
        console.log(
          'Switch to the Profiles tab to view the created startup profile'
        );
      });
    }

    const webContents = electron.remote.getCurrentWindow().webContents;
    if (webContents.devToolsWebContents) {
      profile();
    } else {
      webContents.once('devtools-opened', () => {
        setTimeout(profile, 1000);
      });
      webContents.openDevTools();
    }
  }

  function setupAtomHome() {
    if (process.env.ATOM_HOME) {
      return;
    }

    // Ensure ATOM_HOME is always set before anything else is required
    // This is because of a difference in Linux not inherited between browser and render processes
    // https://github.com/atom/atom/issues/5412
    if (getWindowLoadSettings() && getWindowLoadSettings().atomHome) {
      process.env.ATOM_HOME = getWindowLoadSettings().atomHome;
    }
  }
})();

================
File: package.json
================
{
  "name": "pulsar",
  "author": "Pulsar-Edit <admin@pulsar-edit.dev>",
  "productName": "Pulsar",
  "version": "1.121.0-dev",
  "description": "A Community-led Hyper-Hackable Text Editor",
  "branding": {
    "id": "pulsar",
    "name": "Pulsar",
    "urlWeb": "https://pulsar-edit.dev/",
    "urlGH": "https://github.com/pulsar-edit",
    "urlForum": "https://github.com/orgs/pulsar-edit/discussions"
  },
  "main": "./src/main-process/main.js",
  "repository": {
    "type": "git",
    "url": "https://github.com/pulsar-edit/pulsar"
  },
  "bugs": {
    "url": "https://github.com/pulsar-edit/pulsar/issues"
  },
  "engines": {
    "node": ">=14"
  },
  "license": "MIT",
  "electronVersion": "12.2.3",
  "resolutions": {
    "es5-ext": "https://github.com/pulsar-edit/es5-ext#169f6ae9b2675675269a0ba265f83c29c7b56244",
    "superstring": "github:pulsar-edit/superstring#de97b496663fce40050bf2d66e1466ccfbd00943",
    "text-buffer/superstring": "github:pulsar-edit/superstring#de97b496663fce40050bf2d66e1466ccfbd00943"
  },
  "dependencies": {
    "@atom/source-map-support": "^0.3.4",
    "@babel/core": "7.18.6",
    "@pulsar-edit/fuzzy-native": "https://github.com/pulsar-edit/fuzzy-native.git#c6ddd2e0ace7b3cfe8082fcbe5985c49f76da5b8",
    "about": "file:packages/about",
    "archive-view": "file:packages/archive-view",
    "async": "3.2.4",
    "atom-dark-syntax": "file:packages/atom-dark-syntax",
    "atom-dark-ui": "file:packages/atom-dark-ui",
    "atom-keymap": "8.2.15",
    "atom-light-syntax": "file:packages/atom-light-syntax",
    "atom-light-ui": "file:packages/atom-light-ui",
    "atom-select-list": "^0.8.1",
    "autocomplete-atom-api": "file:packages/autocomplete-atom-api",
    "autocomplete-css": "file:packages/autocomplete-css",
    "autocomplete-html": "file:packages/autocomplete-html",
    "autocomplete-plus": "file:./packages/autocomplete-plus",
    "autocomplete-snippets": "file:packages/autocomplete-snippets",
    "autoflow": "file:packages/autoflow",
    "autosave": "file:./packages/autosave",
    "babel-preset-atomic": "^5.0.0",
    "background-tips": "file:packages/background-tips",
    "base16-tomorrow-dark-theme": "file:packages/base16-tomorrow-dark-theme",
    "base16-tomorrow-light-theme": "file:packages/base16-tomorrow-light-theme",
    "bookmarks": "file:packages/bookmarks",
    "bracket-matcher": "file:packages/bracket-matcher",
    "chai": "4.3.4",
    "clear-cut": "^2.0.2",
    "coffeescript": "1.12.7",
    "color": "3.1.3",
    "command-palette": "file:packages/command-palette",
    "dalek": "file:packages/dalek",
    "dedent": "^0.7.0",
    "deprecation-cop": "file:packages/deprecation-cop",
    "dev-live-reload": "file:packages/dev-live-reload",
    "document-register-element": "https://github.com/pulsar-edit/document-register-element.git#1f5868f",
    "dompurify": "^3.0.6",
    "encoding-selector": "file:packages/encoding-selector",
    "etch": "0.14.1",
    "event-kit": "^2.5.3",
    "exception-reporting": "file:packages/exception-reporting",
    "find-and-replace": "file:packages/find-and-replace",
    "find-parent-dir": "^0.3.0",
    "focus-trap": "6.3.0",
    "fs-admin": "0.19.0",
    "fs-plus": "^3.1.1",
    "fstream": "1.0.12",
    "fuzzy-finder": "file:packages/fuzzy-finder",
    "git-diff": "file:packages/git-diff",
    "git-utils": "^5.7.3",
    "github": "https://github.com/pulsar-edit/github/archive/refs/tags/v0.36.20-pretranspiled.tar.gz",
    "go-to-line": "file:packages/go-to-line",
    "grammar-selector": "file:packages/grammar-selector",
    "grim": "2.0.3",
    "image-view": "file:packages/image-view",
    "incompatible-packages": "file:packages/incompatible-packages",
    "jasmine-json": "~0.0",
    "jasmine-reporters": "1.1.0",
    "jasmine-tagged": "^1.1.4",
    "key-path-helpers": "^0.4.0",
    "keybinding-resolver": "file:./packages/keybinding-resolver",
    "language-c": "file:packages/language-c",
    "language-clojure": "file:packages/language-clojure",
    "language-coffee-script": "file:packages/language-coffee-script",
    "language-csharp": "file:packages/language-csharp",
    "language-css": "file:packages/language-css",
    "language-gfm": "file:packages/language-gfm",
    "language-git": "file:packages/language-git",
    "language-go": "file:packages/language-go",
    "language-html": "file:packages/language-html",
    "language-hyperlink": "file:packages/language-hyperlink",
    "language-java": "file:packages/language-java",
    "language-javascript": "file:packages/language-javascript",
    "language-json": "file:packages/language-json",
    "language-less": "file:packages/language-less",
    "language-make": "file:packages/language-make",
    "language-mustache": "file:packages/language-mustache",
    "language-objective-c": "file:packages/language-objective-c",
    "language-perl": "file:packages/language-perl",
    "language-php": "file:packages/language-php",
    "language-property-list": "file:packages/language-property-list",
    "language-python": "file:packages/language-python",
    "language-ruby": "file:packages/language-ruby",
    "language-ruby-on-rails": "file:packages/language-ruby-on-rails",
    "language-rust-bundled": "file:packages/language-rust-bundled",
    "language-sass": "file:packages/language-sass",
    "language-shellscript": "file:packages/language-shellscript",
    "language-source": "file:packages/language-source",
    "language-sql": "file:packages/language-sql",
    "language-text": "file:packages/language-text",
    "language-todo": "file:packages/language-todo",
    "language-toml": "file:packages/language-toml",
    "language-typescript": "file:packages/language-typescript",
    "language-xml": "file:packages/language-xml",
    "language-yaml": "file:packages/language-yaml",
    "less-cache": "pulsar-edit/less-cache#v2.0.1",
    "line-ending-selector": "file:packages/line-ending-selector",
    "line-top-index": "0.3.1",
    "link": "file:packages/link",
    "markdown-it": "^13.0.2",
    "markdown-it-emoji": "^2.0.2",
    "markdown-it-github-headings": "^2.0.1",
    "markdown-it-task-checkbox": "^1.0.6",
    "markdown-preview": "file:./packages/markdown-preview",
    "minimatch": "^3.0.3",
    "mocha": "6.2.3",
    "mocha-junit-reporter": "2.0.0",
    "mocha-multi-reporters": "^1.1.4",
    "mock-spawn": "^0.2.6",
    "normalize-package-data": "3.0.2",
    "notifications": "file:./packages/notifications",
    "nsfw": "2.2.2",
    "one-dark-syntax": "file:packages/one-dark-syntax",
    "one-dark-ui": "file:packages/one-dark-ui",
    "one-light-syntax": "file:packages/one-light-syntax",
    "one-light-ui": "file:packages/one-light-ui",
    "open-on-github": "file:packages/open-on-github",
    "package-generator": "file:packages/package-generator",
    "pathwatcher": "^8.1.2",
    "postcss": "8.4.31",
    "postcss-selector-parser": "6.0.4",
    "pulsar-updater": "file:packages/pulsar-updater",
    "resolve": "1.18.1",
    "scandal": "^3.2.0",
    "scoped-property-store": "^0.17.0",
    "scrollbar-style": "^4.0.1",
    "season": "^6.0.2",
    "second-mate": "https://github.com/pulsar-edit/second-mate.git#9686771",
    "semver": "7.5.2",
    "service-hub": "^0.7.4",
    "settings-view": "file:packages/settings-view",
    "sinon": "9.2.1",
    "snippets": "file:./packages/snippets",
    "solarized-dark-syntax": "file:packages/solarized-dark-syntax",
    "solarized-light-syntax": "file:packages/solarized-light-syntax",
    "spell-check": "file:packages/spell-check",
    "status-bar": "file:packages/status-bar",
    "styleguide": "file:./packages/styleguide",
    "superstring": "github:pulsar-edit/superstring#de97b496663fce40050bf2d66e1466ccfbd00943",
    "symbol-provider-ctags": "file:./packages/symbol-provider-ctags",
    "symbol-provider-tree-sitter": "file:./packages/symbol-provider-tree-sitter",
    "symbols-view": "file:./packages/symbols-view",
    "tabs": "file:packages/tabs",
    "temp": "0.9.4",
    "text-buffer": "^13.18.6",
    "timecop": "file:./packages/timecop",
    "tree-sitter": "0.20.0",
    "tree-view": "file:packages/tree-view",
    "typescript-simple": "github:pulsar-edit/typescript-simple#ccb03e558217030e8f261339281f1d69147934f7",
    "underscore-plus": "^1.7.0",
    "update-package-dependencies": "file:./packages/update-package-dependencies",
    "vscode-ripgrep": "1.9.0",
    "web-tree-sitter": "^0.20.7",
    "welcome": "file:packages/welcome",
    "whitespace": "file:./packages/whitespace",
    "winreg": "^1.2.1",
    "wrap-guide": "file:./packages/wrap-guide",
    "yaml-front-matter": "^4.1.1",
    "yargs": "17.6.2"
  },
  "packageDependencies": {
    "atom-dark-syntax": "file:./packages/atom-dark-syntax",
    "atom-dark-ui": "file:./packages/atom-dark-ui",
    "atom-light-syntax": "file:./packages/atom-light-syntax",
    "atom-light-ui": "file:./packages/atom-light-ui",
    "base16-tomorrow-dark-theme": "file:./packages/base16-tomorrow-dark-theme",
    "base16-tomorrow-light-theme": "file:./packages/base16-tomorrow-light-theme",
    "one-dark-ui": "file:./packages/one-dark-ui",
    "one-light-ui": "file:./packages/one-light-ui",
    "one-dark-syntax": "file:./packages/one-dark-syntax",
    "one-light-syntax": "file:./packages/one-light-syntax",
    "solarized-dark-syntax": "file:./packages/solarized-dark-syntax",
    "solarized-light-syntax": "file:./packages/solarized-light-syntax",
    "about": "file:./packages/about",
    "archive-view": "file:./packages/archive-view",
    "autocomplete-atom-api": "file:packages/autocomplete-atom-api",
    "autocomplete-css": "file:./packages/autocomplete-css",
    "autocomplete-html": "file:./packages/autocomplete-html",
    "autocomplete-plus": "file:./packages/autocomplete-plus",
    "autocomplete-snippets": "file:./packages/autocomplete-snippets",
    "autoflow": "file:./packages/autoflow",
    "autosave": "file:./packages/autosave",
    "background-tips": "file:./packages/background-tips",
    "bookmarks": "file:./packages/bookmarks",
    "bracket-matcher": "file:./packages/bracket-matcher",
    "command-palette": "file:./packages/command-palette",
    "dalek": "file:./packages/dalek",
    "deprecation-cop": "file:./packages/deprecation-cop",
    "dev-live-reload": "file:./packages/dev-live-reload",
    "encoding-selector": "file:./packages/encoding-selector",
    "exception-reporting": "file:./packages/exception-reporting",
    "find-and-replace": "file:./packages/find-and-replace",
    "fuzzy-finder": "file:packages/fuzzy-finder",
    "github": "0.36.20",
    "git-diff": "file:./packages/git-diff",
    "go-to-line": "file:./packages/go-to-line",
    "grammar-selector": "file:./packages/grammar-selector",
    "image-view": "file:./packages/image-view",
    "incompatible-packages": "file:./packages/incompatible-packages",
    "keybinding-resolver": "file:./packages/keybinding-resolver",
    "line-ending-selector": "file:./packages/line-ending-selector",
    "link": "file:./packages/link",
    "markdown-preview": "file:./packages/markdown-preview",
    "notifications": "file:./packages/notifications",
    "open-on-github": "file:./packages/open-on-github",
    "package-generator": "file:./packages/package-generator",
    "pulsar-updater": "file:./packages/pulsar-updater",
    "settings-view": "file:./packages/settings-view",
    "snippets": "file:./packages/snippets",
    "spell-check": "file:./packages/spell-check",
    "status-bar": "file:./packages/status-bar",
    "styleguide": "file:./packages/styleguide",
    "symbol-provider-ctags": "file:./packages/symbol-provider-ctags",
    "symbol-provider-tree-sitter": "file:./packages/symbol-provider-tree-sitter",
    "symbols-view": "file:./packages/symbols-view",
    "tabs": "file:./packages/tabs",
    "timecop": "file:./packages/timecop",
    "tree-view": "file:./packages/tree-view",
    "update-package-dependencies": "file:./packages/update-package-dependencies",
    "welcome": "file:./packages/welcome",
    "whitespace": "file:./packages/whitespace",
    "wrap-guide": "file:./packages/wrap-guide",
    "language-c": "file:./packages/language-c",
    "language-clojure": "file:./packages/language-clojure",
    "language-coffee-script": "file:./packages/language-coffee-script",
    "language-csharp": "file:./packages/language-csharp",
    "language-css": "file:./packages/language-css",
    "language-gfm": "file:./packages/language-gfm",
    "language-git": "file:./packages/language-git",
    "language-go": "file:./packages/language-go",
    "language-html": "file:./packages/language-html",
    "language-hyperlink": "file:./packages/language-hyperlink",
    "language-java": "file:./packages/language-java",
    "language-javascript": "file:./packages/language-javascript",
    "language-json": "file:./packages/language-json",
    "language-less": "file:./packages/language-less",
    "language-make": "file:./packages/language-make",
    "language-mustache": "file:./packages/language-mustache",
    "language-objective-c": "file:./packages/language-objective-c",
    "language-perl": "file:./packages/language-perl",
    "language-php": "file:./packages/language-php",
    "language-property-list": "file:./packages/language-property-list",
    "language-python": "file:./packages/language-python",
    "language-ruby": "file:./packages/language-ruby",
    "language-ruby-on-rails": "file:./packages/language-ruby-on-rails",
    "language-rust-bundled": "file:./packages/language-rust-bundled",
    "language-sass": "file:./packages/language-sass",
    "language-shellscript": "file:./packages/language-shellscript",
    "language-source": "file:./packages/language-source",
    "language-sql": "file:./packages/language-sql",
    "language-text": "file:./packages/language-text",
    "language-todo": "file:./packages/language-todo",
    "language-toml": "file:./packages/language-toml",
    "language-typescript": "file:./packages/language-typescript",
    "language-xml": "file:./packages/language-xml",
    "language-yaml": "file:./packages/language-yaml"
  },
  "private": true,
  "scripts": {
    "build": "electron-rebuild",
    "build:apm": "cd ppm && yarn install",
    "start": "electron --no-sandbox --enable-logging . -f",
    "dist": "node script/electron-builder.js",
    "js-docs": "jsdoc2md --files src --configure docs/.jsdoc.json > ./docs/Pulsar-API-Documentation.md",
    "private-js-docs": "jsdoc2md --private --files src --configure docs/.jsdoc.json > ./docs/Source-Code-Documentation.md"
  },
  "devDependencies": {
    "@electron/notarize": "^1.2.3",
    "@playwright/test": "1.22.2",
    "electron": "12.2.3",
    "electron-builder": "23.3.1",
    "electron-rebuild": "3.2.7",
    "eslint": "^8.33.0",
    "eslint-plugin-jsdoc": "^39.7.4",
    "eslint-plugin-node": "^11.1.0",
    "jsdoc-to-markdown": "^8.0.0",
    "playwright": "1.22.2",
    "playwright-core": "1.22.2",
    "random-seed": "0.3.0",
    "webdriverio": "7.20.9"
  }
}
